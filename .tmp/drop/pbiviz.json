{"visual":{"name":"powerbiOl3Viz","displayName":"PowerbiOl3Viz","guid":"powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG","visualClassName":"Visual","version":"1.0.0","description":"","supportUrl":"","gitHubUrl":""},"apiVersion":"1.11.0","author":{"name":"","email":""},"assets":{"icon":"assets/icon.png"},"externalJS":["node_modules/powerbi-visuals-utils-dataviewutils/lib/index.js","./assets/js/ol-debug.js"],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Longitude","name":"lng","kind":"Grouping"},{"displayName":"Latitude","name":"lat","kind":"Grouping"},{"displayName":"Jobs","name":"jobs","kind":"Grouping"}],"dataViewMappings":[{"categorical":{"categories":{"for":{"in":"lng"}},"values":{"select":[{"bind":{"to":"lat"}},{"bind":{"to":"jobs"}}]}}}],"advancedEditModeSupport":2},"stringResources":{},"content":{"js":"/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n                var DataViewTransform;\r\n                (function (DataViewTransform) {\r\n                    // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\r\n                    function createValueColumns(values, valueIdentityFields, source) {\r\n                        if (values === void 0) { values = []; }\r\n                        var result = values;\r\n                        setGrouped(result);\r\n                        if (valueIdentityFields) {\r\n                            result.identityFields = valueIdentityFields;\r\n                        }\r\n                        if (source) {\r\n                            result.source = source;\r\n                        }\r\n                        return result;\r\n                    }\r\n                    DataViewTransform.createValueColumns = createValueColumns;\r\n                    function setGrouped(values, groupedResult) {\r\n                        values.grouped = groupedResult\r\n                            ? function () { return groupedResult; }\r\n                            : function () { return groupValues(values); };\r\n                    }\r\n                    DataViewTransform.setGrouped = setGrouped;\r\n                    /** Group together the values with a common identity. */\r\n                    function groupValues(values) {\r\n                        var groups = [], currentGroup;\r\n                        for (var i = 0, len = values.length; i < len; i++) {\r\n                            var value = values[i];\r\n                            if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                                currentGroup = {\r\n                                    values: []\r\n                                };\r\n                                if (value.identity) {\r\n                                    currentGroup.identity = value.identity;\r\n                                    var source = value.source;\r\n                                    // allow null, which will be formatted as (Blank).\r\n                                    if (source.groupName !== undefined) {\r\n                                        currentGroup.name = source.groupName;\r\n                                    }\r\n                                    else if (source.displayName) {\r\n                                        currentGroup.name = source.displayName;\r\n                                    }\r\n                                }\r\n                                groups.push(currentGroup);\r\n                            }\r\n                            currentGroup.values.push(value);\r\n                        }\r\n                        return groups;\r\n                    }\r\n                    DataViewTransform.groupValues = groupValues;\r\n                })(DataViewTransform = dataview.DataViewTransform || (dataview.DataViewTransform = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataRoleHelper;\r\n                (function (DataRoleHelper) {\r\n                    function getMeasureIndexOfRole(grouped, roleName) {\r\n                        if (!grouped || !grouped.length) {\r\n                            return -1;\r\n                        }\r\n                        var firstGroup = grouped[0];\r\n                        if (firstGroup.values && firstGroup.values.length > 0) {\r\n                            for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                                var value = firstGroup.values[i];\r\n                                if (value && value.source) {\r\n                                    if (hasRole(value.source, roleName)) {\r\n                                        return i;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        return -1;\r\n                    }\r\n                    DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\r\n                    function getCategoryIndexOfRole(categories, roleName) {\r\n                        if (categories && categories.length) {\r\n                            for (var i = 0, ilen = categories.length; i < ilen; i++) {\r\n                                if (hasRole(categories[i].source, roleName)) {\r\n                                    return i;\r\n                                }\r\n                            }\r\n                        }\r\n                        return -1;\r\n                    }\r\n                    DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\r\n                    function hasRole(column, name) {\r\n                        var roles = column.roles;\r\n                        return roles && roles[name];\r\n                    }\r\n                    DataRoleHelper.hasRole = hasRole;\r\n                    function hasRoleInDataView(dataView, name) {\r\n                        return dataView != null\r\n                            && dataView.metadata != null\r\n                            && dataView.metadata.columns\r\n                            && dataView.metadata.columns.some(function (c) { return c.roles && c.roles[name] !== undefined; }); // any is an alias of some\r\n                    }\r\n                    DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\r\n                    function hasRoleInValueColumn(valueColumn, name) {\r\n                        return valueColumn\r\n                            && valueColumn.source\r\n                            && valueColumn.source.roles\r\n                            && (valueColumn.source.roles[name] === true);\r\n                    }\r\n                    DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;\r\n                })(DataRoleHelper = dataview.DataRoleHelper || (dataview.DataRoleHelper = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObject;\r\n                (function (DataViewObject) {\r\n                    function getValue(object, propertyName, defaultValue) {\r\n                        if (!object) {\r\n                            return defaultValue;\r\n                        }\r\n                        var propertyValue = object[propertyName];\r\n                        if (propertyValue === undefined) {\r\n                            return defaultValue;\r\n                        }\r\n                        return propertyValue;\r\n                    }\r\n                    DataViewObject.getValue = getValue;\r\n                    /** Gets the solid color from a fill property using only a propertyName */\r\n                    function getFillColorByPropertyName(object, propertyName, defaultColor) {\r\n                        var value = getValue(object, propertyName);\r\n                        if (!value || !value.solid) {\r\n                            return defaultColor;\r\n                        }\r\n                        return value.solid.color;\r\n                    }\r\n                    DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\r\n                })(DataViewObject = dataview.DataViewObject || (dataview.DataViewObject = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObjects;\r\n                (function (DataViewObjects) {\r\n                    /** Gets the value of the given object/property pair. */\r\n                    function getValue(objects, propertyId, defaultValue) {\r\n                        if (!objects) {\r\n                            return defaultValue;\r\n                        }\r\n                        return dataview.DataViewObject.getValue(objects[propertyId.objectName], propertyId.propertyName, defaultValue);\r\n                    }\r\n                    DataViewObjects.getValue = getValue;\r\n                    /** Gets an object from objects. */\r\n                    function getObject(objects, objectName, defaultValue) {\r\n                        if (objects && objects[objectName]) {\r\n                            return objects[objectName];\r\n                        }\r\n                        return defaultValue;\r\n                    }\r\n                    DataViewObjects.getObject = getObject;\r\n                    /** Gets the solid color from a fill property. */\r\n                    function getFillColor(objects, propertyId, defaultColor) {\r\n                        var value = getValue(objects, propertyId);\r\n                        if (!value || !value.solid) {\r\n                            return defaultColor;\r\n                        }\r\n                        return value.solid.color;\r\n                    }\r\n                    DataViewObjects.getFillColor = getFillColor;\r\n                    function getCommonValue(objects, propertyId, defaultValue) {\r\n                        var value = getValue(objects, propertyId, defaultValue);\r\n                        if (value && value.solid) {\r\n                            return value.solid.color;\r\n                        }\r\n                        if (value === undefined\r\n                            || value === null\r\n                            || (typeof value === \"object\" && !value.solid)) {\r\n                            return defaultValue;\r\n                        }\r\n                        return value;\r\n                    }\r\n                    DataViewObjects.getCommonValue = getCommonValue;\r\n                })(DataViewObjects = dataview.DataViewObjects || (dataview.DataViewObjects = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                // powerbi.extensibility.utils.dataview\r\n                var DataRoleHelper = powerbi.extensibility.utils.dataview.DataRoleHelper;\r\n                var converterHelper;\r\n                (function (converterHelper) {\r\n                    function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {\r\n                        if (dataView.categories && dataView.categories.length > 0) {\r\n                            // Need to pivot data if our category soure is a series role\r\n                            var category = dataView.categories[0];\r\n                            return category.source &&\r\n                                DataRoleHelper.hasRole(category.source, seriesRoleName) &&\r\n                                DataRoleHelper.hasRole(category.source, categoryRoleName);\r\n                        }\r\n                        return false;\r\n                    }\r\n                    converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;\r\n                    function getSeriesName(source) {\r\n                        return (source.groupName !== undefined)\r\n                            ? source.groupName\r\n                            : source.queryName;\r\n                    }\r\n                    converterHelper.getSeriesName = getSeriesName;\r\n                    function isImageUrlColumn(column) {\r\n                        var misc = getMiscellaneousTypeDescriptor(column);\r\n                        return misc != null && misc.imageUrl === true;\r\n                    }\r\n                    converterHelper.isImageUrlColumn = isImageUrlColumn;\r\n                    function isWebUrlColumn(column) {\r\n                        var misc = getMiscellaneousTypeDescriptor(column);\r\n                        return misc != null && misc.webUrl === true;\r\n                    }\r\n                    converterHelper.isWebUrlColumn = isWebUrlColumn;\r\n                    function getMiscellaneousTypeDescriptor(column) {\r\n                        return column\r\n                            && column.type\r\n                            && column.type.misc;\r\n                    }\r\n                    converterHelper.getMiscellaneousTypeDescriptor = getMiscellaneousTypeDescriptor;\r\n                    function hasImageUrlColumn(dataView) {\r\n                        if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.columns.length) {\r\n                            return false;\r\n                        }\r\n                        return dataView.metadata.columns.some(function (column) { return isImageUrlColumn(column) === true; });\r\n                    }\r\n                    converterHelper.hasImageUrlColumn = hasImageUrlColumn;\r\n                })(converterHelper = dataview.converterHelper || (dataview.converterHelper = {}));\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var utils;\r\n        (function (utils) {\r\n            var dataview;\r\n            (function (dataview) {\r\n                var DataViewObjectsParser = (function () {\r\n                    function DataViewObjectsParser() {\r\n                    }\r\n                    DataViewObjectsParser.getDefault = function () {\r\n                        return new this();\r\n                    };\r\n                    DataViewObjectsParser.createPropertyIdentifier = function (objectName, propertyName) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName\r\n                        };\r\n                    };\r\n                    DataViewObjectsParser.parse = function (dataView) {\r\n                        var dataViewObjectParser = this.getDefault(), properties;\r\n                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) {\r\n                            return dataViewObjectParser;\r\n                        }\r\n                        properties = dataViewObjectParser.getProperties();\r\n                        for (var objectName in properties) {\r\n                            for (var propertyName in properties[objectName]) {\r\n                                var defaultValue = dataViewObjectParser[objectName][propertyName];\r\n                                dataViewObjectParser[objectName][propertyName] = dataview.DataViewObjects.getCommonValue(dataView.metadata.objects, properties[objectName][propertyName], defaultValue);\r\n                            }\r\n                        }\r\n                        return dataViewObjectParser;\r\n                    };\r\n                    DataViewObjectsParser.isPropertyEnumerable = function (propertyName) {\r\n                        return !DataViewObjectsParser.InnumerablePropertyPrefix.test(propertyName);\r\n                    };\r\n                    DataViewObjectsParser.enumerateObjectInstances = function (dataViewObjectParser, options) {\r\n                        var dataViewProperties = dataViewObjectParser && dataViewObjectParser[options.objectName];\r\n                        if (!dataViewProperties) {\r\n                            return [];\r\n                        }\r\n                        var instance = {\r\n                            objectName: options.objectName,\r\n                            selector: null,\r\n                            properties: {}\r\n                        };\r\n                        for (var key in dataViewProperties) {\r\n                            if (dataViewProperties.hasOwnProperty(key)) {\r\n                                instance.properties[key] = dataViewProperties[key];\r\n                            }\r\n                        }\r\n                        return {\r\n                            instances: [instance]\r\n                        };\r\n                    };\r\n                    DataViewObjectsParser.prototype.getProperties = function () {\r\n                        var _this = this;\r\n                        var properties = {}, objectNames = Object.keys(this);\r\n                        objectNames.forEach(function (objectName) {\r\n                            if (DataViewObjectsParser.isPropertyEnumerable(objectName)) {\r\n                                var propertyNames = Object.keys(_this[objectName]);\r\n                                properties[objectName] = {};\r\n                                propertyNames.forEach(function (propertyName) {\r\n                                    if (DataViewObjectsParser.isPropertyEnumerable(objectName)) {\r\n                                        properties[objectName][propertyName] =\r\n                                            DataViewObjectsParser.createPropertyIdentifier(objectName, propertyName);\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                        return properties;\r\n                    };\r\n                    return DataViewObjectsParser;\r\n                }());\r\n                DataViewObjectsParser.InnumerablePropertyPrefix = /^_/;\r\n                dataview.DataViewObjectsParser = DataViewObjectsParser;\r\n            })(dataview = utils.dataview || (utils.dataview = {}));\r\n        })(utils = extensibility.utils || (extensibility.utils = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\n\n// OpenLayers. See https://openlayers.org/\n// License: https://raw.githubusercontent.com/openlayers/openlayers/master/LICENSE.md\n// Version: v4.6.5\n;(function (root, factory) {\n    if (typeof exports === \"object\") {\n      module.exports = factory();\n    } else if (typeof define === \"function\" && define.amd) {\n      define([], factory);\n    } else {\n      root.ol = factory();\n    }\n  }(this, function () {\n    var OPENLAYERS = {};\n    var goog = this.goog = {};\n  this.CLOSURE_NO_DEPS = true;\n  // Copyright 2006 The Closure Library Authors. All Rights Reserved.\n  //\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  //      http://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS-IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n  \n  /**\n   * @fileoverview Bootstrap for the Google JS Library (Closure).\n   *\n   * In uncompiled mode base.js will attempt to load Closure's deps file, unless\n   * the global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects\n   * to include their own deps file(s) from different locations.\n   *\n   * Avoid including base.js more than once. This is strictly discouraged and not\n   * supported. goog.require(...) won't work properly in that case.\n   *\n   * @provideGoog\n   */\n  \n  \n  /**\n   * @define {boolean} Overridden to true by the compiler.\n   */\n  var COMPILED = false;\n  \n  \n  /**\n   * Base namespace for the Closure library.  Checks to see goog is already\n   * defined in the current scope before assigning to prevent clobbering if\n   * base.js is loaded more than once.\n   *\n   * @const\n   */\n  var goog = goog || {};\n  \n  \n  /**\n   * Reference to the global context.  In most cases this will be 'window'.\n   */\n  goog.global = this;\n  \n  \n  /**\n   * A hook for overriding the define values in uncompiled mode.\n   *\n   * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before\n   * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},\n   * {@code goog.define} will use the value instead of the default value.  This\n   * allows flags to be overwritten without compilation (this is normally\n   * accomplished with the compiler's \"define\" flag).\n   *\n   * Example:\n   * <pre>\n   *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};\n   * </pre>\n   *\n   * @type {Object<string, (string|number|boolean)>|undefined}\n   */\n  goog.global.CLOSURE_UNCOMPILED_DEFINES;\n  \n  \n  /**\n   * A hook for overriding the define values in uncompiled or compiled mode,\n   * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In\n   * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.\n   *\n   * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or\n   * string literals or the compiler will emit an error.\n   *\n   * While any @define value may be set, only those set with goog.define will be\n   * effective for uncompiled code.\n   *\n   * Example:\n   * <pre>\n   *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;\n   * </pre>\n   *\n   * @type {Object<string, (string|number|boolean)>|undefined}\n   */\n  goog.global.CLOSURE_DEFINES;\n  \n  \n  /**\n   * Returns true if the specified value is not undefined.\n   *\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is defined.\n   */\n  goog.isDef = function(val) {\n    // void 0 always evaluates to undefined and hence we do not need to depend on\n    // the definition of the global variable named 'undefined'.\n    return val !== void 0;\n  };\n  \n  /**\n   * Returns true if the specified value is a string.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is a string.\n   */\n  goog.isString = function(val) {\n    return typeof val == 'string';\n  };\n  \n  \n  /**\n   * Returns true if the specified value is a boolean.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is boolean.\n   */\n  goog.isBoolean = function(val) {\n    return typeof val == 'boolean';\n  };\n  \n  \n  /**\n   * Returns true if the specified value is a number.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is a number.\n   */\n  goog.isNumber = function(val) {\n    return typeof val == 'number';\n  };\n  \n  \n  /**\n   * Builds an object structure for the provided namespace path, ensuring that\n   * names that already exist are not overwritten. For example:\n   * \"a.b.c\" -> a = {};a.b={};a.b.c={};\n   * Used by goog.provide and goog.exportSymbol.\n   * @param {string} name name of the object that this file defines.\n   * @param {*=} opt_object the object to expose at the end of the path.\n   * @param {Object=} opt_objectToExportTo The object to add the path to; default\n   *     is `goog.global`.\n   * @private\n   */\n  goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {\n    var parts = name.split('.');\n    var cur = opt_objectToExportTo || goog.global;\n  \n    // Internet Explorer exhibits strange behavior when throwing errors from\n    // methods externed in this manner.  See the testExportSymbolExceptions in\n    // base_test.html for an example.\n    if (!(parts[0] in cur) && cur.execScript) {\n      cur.execScript('var ' + parts[0]);\n    }\n  \n    for (var part; parts.length && (part = parts.shift());) {\n      if (!parts.length && goog.isDef(opt_object)) {\n        // last part and we have an object; use it\n        cur[part] = opt_object;\n      } else if (cur[part] && cur[part] !== Object.prototype[part]) {\n        cur = cur[part];\n      } else {\n        cur = cur[part] = {};\n      }\n    }\n  };\n  \n  \n  /**\n   * Defines a named value. In uncompiled mode, the value is retrieved from\n   * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and\n   * has the property specified, and otherwise used the defined defaultValue.\n   * When compiled the default can be overridden using the compiler\n   * options or the value set in the CLOSURE_DEFINES object.\n   *\n   * @param {string} name The distinguished name to provide.\n   * @param {string|number|boolean} defaultValue\n   */\n  goog.define = function(name, defaultValue) {\n    var value = defaultValue;\n    if (!COMPILED) {\n      if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&\n          // Anti DOM-clobbering runtime check (b/37736576).\n          /** @type {?} */ (goog.global.CLOSURE_UNCOMPILED_DEFINES).nodeType ===\n              undefined &&\n          Object.prototype.hasOwnProperty.call(\n              goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {\n        value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];\n      } else if (\n          goog.global.CLOSURE_DEFINES &&\n          // Anti DOM-clobbering runtime check (b/37736576).\n          /** @type {?} */ (goog.global.CLOSURE_DEFINES).nodeType === undefined &&\n          Object.prototype.hasOwnProperty.call(\n              goog.global.CLOSURE_DEFINES, name)) {\n        value = goog.global.CLOSURE_DEFINES[name];\n      }\n    }\n    goog.exportPath_(name, value);\n  };\n  \n  \n  /**\n   * @define {boolean} DEBUG is provided as a convenience so that debugging code\n   * that should not be included in a production. It can be easily stripped\n   * by specifying --define goog.DEBUG=false to the Closure Compiler aka\n   * JSCompiler. For example, most toString() methods should be declared inside an\n   * \"if (goog.DEBUG)\" conditional because they are generally used for debugging\n   * purposes and it is difficult for the JSCompiler to statically determine\n   * whether they are used.\n   */\n  goog.define('goog.DEBUG', true);\n  \n  \n  /**\n   * @define {string} LOCALE defines the locale being used for compilation. It is\n   * used to select locale specific data to be compiled in js binary. BUILD rule\n   * can specify this value by \"--define goog.LOCALE=<locale_name>\" as a compiler\n   * option.\n   *\n   * Take into account that the locale code format is important. You should use\n   * the canonical Unicode format with hyphen as a delimiter. Language must be\n   * lowercase, Language Script - Capitalized, Region - UPPERCASE.\n   * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\n   *\n   * See more info about locale codes here:\n   * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\n   *\n   * For language codes you should use values defined by ISO 693-1. See it here\n   * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\n   * this rule: the Hebrew language. For legacy reasons the old code (iw) should\n   * be used instead of the new code (he).\n   *\n   */\n  goog.define('goog.LOCALE', 'en');  // default to en\n  \n  \n  /**\n   * @define {boolean} Whether this code is running on trusted sites.\n   *\n   * On untrusted sites, several native functions can be defined or overridden by\n   * external libraries like Prototype, Datejs, and JQuery and setting this flag\n   * to false forces closure to use its own implementations when possible.\n   *\n   * If your JavaScript can be loaded by a third party site and you are wary about\n   * relying on non-standard implementations, specify\n   * \"--define goog.TRUSTED_SITE=false\" to the compiler.\n   */\n  goog.define('goog.TRUSTED_SITE', true);\n  \n  \n  /**\n   * @define {boolean} Whether a project is expected to be running in strict mode.\n   *\n   * This define can be used to trigger alternate implementations compatible with\n   * running in EcmaScript Strict mode or warn about unavailable functionality.\n   * @see https://goo.gl/PudQ4y\n   *\n   */\n  goog.define('goog.STRICT_MODE_COMPATIBLE', false);\n  \n  \n  /**\n   * @define {boolean} Whether code that calls {@link goog.setTestOnly} should\n   *     be disallowed in the compilation unit.\n   */\n  goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);\n  \n  \n  /**\n   * @define {boolean} Whether to use a Chrome app CSP-compliant method for\n   *     loading scripts via goog.require. @see appendScriptSrcNode_.\n   */\n  goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);\n  \n  \n  /**\n   * Defines a namespace in Closure.\n   *\n   * A namespace may only be defined once in a codebase. It may be defined using\n   * goog.provide() or goog.module().\n   *\n   * The presence of one or more goog.provide() calls in a file indicates\n   * that the file defines the given objects/namespaces.\n   * Provided symbols must not be null or undefined.\n   *\n   * In addition, goog.provide() creates the object stubs for a namespace\n   * (for example, goog.provide(\"goog.foo.bar\") will create the object\n   * goog.foo.bar if it does not already exist).\n   *\n   * Build tools also scan for provide/require/module statements\n   * to discern dependencies, build dependency files (see deps.js), etc.\n   *\n   * @see goog.require\n   * @see goog.module\n   * @param {string} name Namespace provided by this file in the form\n   *     \"goog.package.part\".\n   */\n  goog.provide = function(name) {\n    if (goog.isInModuleLoader_()) {\n      throw new Error('goog.provide can not be used within a goog.module.');\n    }\n    if (!COMPILED) {\n      // Ensure that the same namespace isn't provided twice.\n      // A goog.module/goog.provide maps a goog.require to a specific file\n      if (goog.isProvided_(name)) {\n        throw new Error('Namespace \"' + name + '\" already declared.');\n      }\n    }\n  \n    goog.constructNamespace_(name);\n  };\n  \n  \n  /**\n   * @param {string} name Namespace provided by this file in the form\n   *     \"goog.package.part\".\n   * @param {Object=} opt_obj The object to embed in the namespace.\n   * @private\n   */\n  goog.constructNamespace_ = function(name, opt_obj) {\n    if (!COMPILED) {\n      delete goog.implicitNamespaces_[name];\n  \n      var namespace = name;\n      while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\n        if (goog.getObjectByName(namespace)) {\n          break;\n        }\n        goog.implicitNamespaces_[namespace] = true;\n      }\n    }\n  \n    goog.exportPath_(name, opt_obj);\n  };\n  \n  \n  /**\n   * Module identifier validation regexp.\n   * Note: This is a conservative check, it is very possible to be more lenient,\n   *   the primary exclusion here is \"/\" and \"\\\" and a leading \".\", these\n   *   restrictions are intended to leave the door open for using goog.require\n   *   with relative file paths rather than module identifiers.\n   * @private\n   */\n  goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;\n  \n  \n  /**\n   * Defines a module in Closure.\n   *\n   * Marks that this file must be loaded as a module and claims the namespace.\n   *\n   * A namespace may only be defined once in a codebase. It may be defined using\n   * goog.provide() or goog.module().\n   *\n   * goog.module() has three requirements:\n   * - goog.module may not be used in the same file as goog.provide.\n   * - goog.module must be the first statement in the file.\n   * - only one goog.module is allowed per file.\n   *\n   * When a goog.module annotated file is loaded, it is enclosed in\n   * a strict function closure. This means that:\n   * - any variables declared in a goog.module file are private to the file\n   * (not global), though the compiler is expected to inline the module.\n   * - The code must obey all the rules of \"strict\" JavaScript.\n   * - the file will be marked as \"use strict\"\n   *\n   * NOTE: unlike goog.provide, goog.module does not declare any symbols by\n   * itself. If declared symbols are desired, use\n   * goog.module.declareLegacyNamespace().\n   *\n   *\n   * See the public goog.module proposal: http://goo.gl/Va1hin\n   *\n   * @param {string} name Namespace provided by this file in the form\n   *     \"goog.package.part\", is expected but not required.\n   * @return {void}\n   */\n  goog.module = function(name) {\n    if (!goog.isString(name) || !name ||\n        name.search(goog.VALID_MODULE_RE_) == -1) {\n      throw new Error('Invalid module identifier');\n    }\n    if (!goog.isInModuleLoader_()) {\n      throw new Error(\n          'Module ' + name + ' has been loaded incorrectly. Note, ' +\n          'modules cannot be loaded as normal scripts. They require some kind of ' +\n          'pre-processing step. You\\'re likely trying to load a module via a ' +\n          'script tag or as a part of a concatenated bundle without rewriting the ' +\n          'module. For more info see: ' +\n          'https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.');\n    }\n    if (goog.moduleLoaderState_.moduleName) {\n      throw new Error('goog.module may only be called once per module.');\n    }\n  \n    // Store the module name for the loader.\n    goog.moduleLoaderState_.moduleName = name;\n    if (!COMPILED) {\n      // Ensure that the same namespace isn't provided twice.\n      // A goog.module/goog.provide maps a goog.require to a specific file\n      if (goog.isProvided_(name)) {\n        throw new Error('Namespace \"' + name + '\" already declared.');\n      }\n      delete goog.implicitNamespaces_[name];\n    }\n  };\n  \n  \n  /**\n   * @param {string} name The module identifier.\n   * @return {?} The module exports for an already loaded module or null.\n   *\n   * Note: This is not an alternative to goog.require, it does not\n   * indicate a hard dependency, instead it is used to indicate\n   * an optional dependency or to access the exports of a module\n   * that has already been loaded.\n   * @suppress {missingProvide}\n   */\n  goog.module.get = function(name) {\n    return goog.module.getInternal_(name);\n  };\n  \n  \n  /**\n   * @param {string} name The module identifier.\n   * @return {?} The module exports for an already loaded module or null.\n   * @private\n   */\n  goog.module.getInternal_ = function(name) {\n    if (!COMPILED) {\n      if (name in goog.loadedModules_) {\n        return goog.loadedModules_[name];\n      } else if (!goog.implicitNamespaces_[name]) {\n        var ns = goog.getObjectByName(name);\n        return ns != null ? ns : null;\n      }\n    }\n    return null;\n  };\n  \n  \n  /**\n   * @private {?{moduleName: (string|undefined), declareLegacyNamespace:boolean}}\n   */\n  goog.moduleLoaderState_ = null;\n  \n  \n  /**\n   * @private\n   * @return {boolean} Whether a goog.module is currently being initialized.\n   */\n  goog.isInModuleLoader_ = function() {\n    return goog.moduleLoaderState_ != null;\n  };\n  \n  \n  /**\n   * Provide the module's exports as a globally accessible object under the\n   * module's declared name.  This is intended to ease migration to goog.module\n   * for files that have existing usages.\n   * @suppress {missingProvide}\n   */\n  goog.module.declareLegacyNamespace = function() {\n    if (!COMPILED && !goog.isInModuleLoader_()) {\n      throw new Error(\n          'goog.module.declareLegacyNamespace must be called from ' +\n          'within a goog.module');\n    }\n    if (!COMPILED && !goog.moduleLoaderState_.moduleName) {\n      throw new Error(\n          'goog.module must be called prior to ' +\n          'goog.module.declareLegacyNamespace.');\n    }\n    goog.moduleLoaderState_.declareLegacyNamespace = true;\n  };\n  \n  \n  /**\n   * Marks that the current file should only be used for testing, and never for\n   * live code in production.\n   *\n   * In the case of unit tests, the message may optionally be an exact namespace\n   * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra\n   * provide (if not explicitly defined in the code).\n   *\n   * @param {string=} opt_message Optional message to add to the error that's\n   *     raised when used in production code.\n   */\n  goog.setTestOnly = function(opt_message) {\n    if (goog.DISALLOW_TEST_ONLY_CODE) {\n      opt_message = opt_message || '';\n      throw new Error(\n          'Importing test-only code into non-debug environment' +\n          (opt_message ? ': ' + opt_message : '.'));\n    }\n  };\n  \n  \n  /**\n   * Forward declares a symbol. This is an indication to the compiler that the\n   * symbol may be used in the source yet is not required and may not be provided\n   * in compilation.\n   *\n   * The most common usage of forward declaration is code that takes a type as a\n   * function parameter but does not need to require it. By forward declaring\n   * instead of requiring, no hard dependency is made, and (if not required\n   * elsewhere) the namespace may never be required and thus, not be pulled\n   * into the JavaScript binary. If it is required elsewhere, it will be type\n   * checked as normal.\n   *\n   * Before using goog.forwardDeclare, please read the documentation at\n   * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to\n   * understand the options and tradeoffs when working with forward declarations.\n   *\n   * @param {string} name The namespace to forward declare in the form of\n   *     \"goog.package.part\".\n   */\n  goog.forwardDeclare = function(name) {};\n  \n  \n  /**\n   * Forward declare type information. Used to assign types to goog.global\n   * referenced object that would otherwise result in unknown type references\n   * and thus block property disambiguation.\n   */\n  goog.forwardDeclare('Document');\n  goog.forwardDeclare('HTMLScriptElement');\n  goog.forwardDeclare('XMLHttpRequest');\n  \n  \n  if (!COMPILED) {\n    /**\n     * Check if the given name has been goog.provided. This will return false for\n     * names that are available only as implicit namespaces.\n     * @param {string} name name of the object to look for.\n     * @return {boolean} Whether the name has been provided.\n     * @private\n     */\n    goog.isProvided_ = function(name) {\n      return (name in goog.loadedModules_) ||\n          (!goog.implicitNamespaces_[name] &&\n           goog.isDefAndNotNull(goog.getObjectByName(name)));\n    };\n  \n    /**\n     * Namespaces implicitly defined by goog.provide. For example,\n     * goog.provide('goog.events.Event') implicitly declares that 'goog' and\n     * 'goog.events' must be namespaces.\n     *\n     * @type {!Object<string, (boolean|undefined)>}\n     * @private\n     */\n    goog.implicitNamespaces_ = {'goog.module': true};\n  \n    // NOTE: We add goog.module as an implicit namespace as goog.module is defined\n    // here and because the existing module package has not been moved yet out of\n    // the goog.module namespace. This satisifies both the debug loader and\n    // ahead-of-time dependency management.\n  }\n  \n  \n  /**\n   * Returns an object based on its fully qualified external name.  The object\n   * is not found if null or undefined.  If you are using a compilation pass that\n   * renames property names beware that using this function will not find renamed\n   * properties.\n   *\n   * @param {string} name The fully qualified name.\n   * @param {Object=} opt_obj The object within which to look; default is\n   *     |goog.global|.\n   * @return {?} The value (object or primitive) or, if not found, null.\n   */\n  goog.getObjectByName = function(name, opt_obj) {\n    var parts = name.split('.');\n    var cur = opt_obj || goog.global;\n    for (var i = 0; i < parts.length; i++) {\n      cur = cur[parts[i]];\n      if (!goog.isDefAndNotNull(cur)) {\n        return null;\n      }\n    }\n    return cur;\n  };\n  \n  \n  /**\n   * Globalizes a whole namespace, such as goog or goog.lang.\n   *\n   * @param {!Object} obj The namespace to globalize.\n   * @param {Object=} opt_global The object to add the properties to.\n   * @deprecated Properties may be explicitly exported to the global scope, but\n   *     this should no longer be done in bulk.\n   */\n  goog.globalize = function(obj, opt_global) {\n    var global = opt_global || goog.global;\n    for (var x in obj) {\n      global[x] = obj[x];\n    }\n  };\n  \n  \n  /**\n   * Adds a dependency from a file to the files it requires.\n   * @param {string} relPath The path to the js file.\n   * @param {!Array<string>} provides An array of strings with\n   *     the names of the objects this file provides.\n   * @param {!Array<string>} requires An array of strings with\n   *     the names of the objects this file requires.\n   * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating\n   *     how the file must be loaded.  The boolean 'true' is equivalent\n   *     to {'module': 'goog'} for backwards-compatibility.  Valid properties\n   *     and values include {'module': 'goog'} and {'lang': 'es6'}.\n   */\n  goog.addDependency = function(relPath, provides, requires, opt_loadFlags) {\n    if (goog.DEPENDENCIES_ENABLED) {\n      var provide, require;\n      var path = relPath.replace(/\\\\/g, '/');\n      var deps = goog.dependencies_;\n      if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {\n        opt_loadFlags = opt_loadFlags ? {'module': 'goog'} : {};\n      }\n      for (var i = 0; provide = provides[i]; i++) {\n        deps.nameToPath[provide] = path;\n        deps.loadFlags[path] = opt_loadFlags;\n      }\n      for (var j = 0; require = requires[j]; j++) {\n        if (!(path in deps.requires)) {\n          deps.requires[path] = {};\n        }\n        deps.requires[path][require] = true;\n      }\n    }\n  };\n  \n  \n  \n  \n  // NOTE(nnaze): The debug DOM loader was included in base.js as an original way\n  // to do \"debug-mode\" development.  The dependency system can sometimes be\n  // confusing, as can the debug DOM loader's asynchronous nature.\n  //\n  // With the DOM loader, a call to goog.require() is not blocking -- the script\n  // will not load until some point after the current script.  If a namespace is\n  // needed at runtime, it needs to be defined in a previous script, or loaded via\n  // require() with its registered dependencies.\n  //\n  // User-defined namespaces may need their own deps file. For a reference on\n  // creating a deps file, see:\n  // Externally: https://developers.google.com/closure/library/docs/depswriter\n  //\n  // Because of legacy clients, the DOM loader can't be easily removed from\n  // base.js.  Work was done to make it disableable or replaceable for\n  // different environments (DOM-less JavaScript interpreters like Rhino or V8,\n  // for example). See bootstrap/ for more information.\n  \n  \n  /**\n   * @define {boolean} Whether to enable the debug loader.\n   *\n   * If enabled, a call to goog.require() will attempt to load the namespace by\n   * appending a script tag to the DOM (if the namespace has been registered).\n   *\n   * If disabled, goog.require() will simply assert that the namespace has been\n   * provided (and depend on the fact that some outside tool correctly ordered\n   * the script).\n   */\n  goog.define('goog.ENABLE_DEBUG_LOADER', true);\n  \n  \n  /**\n   * @param {string} msg\n   * @private\n   */\n  goog.logToConsole_ = function(msg) {\n    if (goog.global.console) {\n      goog.global.console['error'](msg);\n    }\n  };\n  \n  \n  /**\n   * Implements a system for the dynamic resolution of dependencies that works in\n   * parallel with the BUILD system. Note that all calls to goog.require will be\n   * stripped by the compiler.\n   * @see goog.provide\n   * @param {string} name Namespace to include (as was given in goog.provide()) in\n   *     the form \"goog.package.part\".\n   * @return {?} If called within a goog.module file, the associated namespace or\n   *     module otherwise null.\n   */\n  goog.require = function(name) {\n    // If the object already exists we do not need to do anything.\n    if (!COMPILED) {\n      if (goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_) {\n        goog.maybeProcessDeferredDep_(name);\n      }\n  \n      if (goog.isProvided_(name)) {\n        if (goog.isInModuleLoader_()) {\n          return goog.module.getInternal_(name);\n        }\n      } else if (goog.ENABLE_DEBUG_LOADER) {\n        var path = goog.getPathFromDeps_(name);\n        if (path) {\n          goog.writeScripts_(path);\n        } else {\n          var errorMessage = 'goog.require could not find: ' + name;\n          goog.logToConsole_(errorMessage);\n  \n          throw new Error(errorMessage);\n        }\n      }\n  \n      return null;\n    }\n  };\n  \n  \n  /**\n   * Path for included scripts.\n   * @type {string}\n   */\n  goog.basePath = '';\n  \n  \n  /**\n   * A hook for overriding the base path.\n   * @type {string|undefined}\n   */\n  goog.global.CLOSURE_BASE_PATH;\n  \n  \n  /**\n   * Whether to attempt to load Closure's deps file. By default, when uncompiled,\n   * deps files will attempt to be loaded.\n   * @type {boolean|undefined}\n   */\n  goog.global.CLOSURE_NO_DEPS;\n  \n  \n  /**\n   * A function to import a single script. This is meant to be overridden when\n   * Closure is being run in non-HTML contexts, such as web workers. It's defined\n   * in the global scope so that it can be set before base.js is loaded, which\n   * allows deps.js to be imported properly.\n   *\n   * The function is passed the script source, which is a relative URI. It should\n   * return true if the script was imported, false otherwise.\n   * @type {(function(string): boolean)|undefined}\n   */\n  goog.global.CLOSURE_IMPORT_SCRIPT;\n  \n  \n  /**\n   * Null function used for default values of callbacks, etc.\n   * @return {void} Nothing.\n   */\n  goog.nullFunction = function() {};\n  \n  \n  /**\n   * When defining a class Foo with an abstract method bar(), you can do:\n   * Foo.prototype.bar = goog.abstractMethod\n   *\n   * Now if a subclass of Foo fails to override bar(), an error will be thrown\n   * when bar() is invoked.\n   *\n   * @type {!Function}\n   * @throws {Error} when invoked to indicate the method should be overridden.\n   */\n  goog.abstractMethod = function() {\n    throw new Error('unimplemented abstract method');\n  };\n  \n  \n  /**\n   * Adds a {@code getInstance} static method that always returns the same\n   * instance object.\n   * @param {!Function} ctor The constructor for the class to add the static\n   *     method to.\n   */\n  goog.addSingletonGetter = function(ctor) {\n    // instance_ is immediately set to prevent issues with sealed constructors\n    // such as are encountered when a constructor is returned as the export object\n    // of a goog.module in unoptimized code.\n    ctor.instance_ = undefined;\n    ctor.getInstance = function() {\n      if (ctor.instance_) {\n        return ctor.instance_;\n      }\n      if (goog.DEBUG) {\n        // NOTE: JSCompiler can't optimize away Array#push.\n        goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;\n      }\n      return ctor.instance_ = new ctor;\n    };\n  };\n  \n  \n  /**\n   * All singleton classes that have been instantiated, for testing. Don't read\n   * it directly, use the {@code goog.testing.singleton} module. The compiler\n   * removes this variable if unused.\n   * @type {!Array<!Function>}\n   * @private\n   */\n  goog.instantiatedSingletons_ = [];\n  \n  \n  /**\n   * @define {boolean} Whether to load goog.modules using {@code eval} when using\n   * the debug loader.  This provides a better debugging experience as the\n   * source is unmodified and can be edited using Chrome Workspaces or similar.\n   * However in some environments the use of {@code eval} is banned\n   * so we provide an alternative.\n   */\n  goog.define('goog.LOAD_MODULE_USING_EVAL', true);\n  \n  \n  /**\n   * @define {boolean} Whether the exports of goog.modules should be sealed when\n   * possible.\n   */\n  goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);\n  \n  \n  /**\n   * The registry of initialized modules:\n   * the module identifier to module exports map.\n   * @private @const {!Object<string, ?>}\n   */\n  goog.loadedModules_ = {};\n  \n  \n  /**\n   * True if goog.dependencies_ is available.\n   * @const {boolean}\n   */\n  goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;\n  \n  \n  /**\n   * @define {string} How to decide whether to transpile.  Valid values\n   * are 'always', 'never', and 'detect'.  The default ('detect') is to\n   * use feature detection to determine which language levels need\n   * transpilation.\n   */\n  // NOTE(user): we could expand this to accept a language level to bypass\n  // detection: e.g. goog.TRANSPILE == 'es5' would transpile ES6 files but\n  // would leave ES3 and ES5 files alone.\n  goog.define('goog.TRANSPILE', 'detect');\n  \n  \n  /**\n   * @define {string} Path to the transpiler.  Executing the script at this\n   * path (relative to base.js) should define a function $jscomp.transpile.\n   */\n  goog.define('goog.TRANSPILER', 'transpile.js');\n  \n  \n  if (goog.DEPENDENCIES_ENABLED) {\n    /**\n     * This object is used to keep track of dependencies and other data that is\n     * used for loading scripts.\n     * @private\n     * @type {{\n     *   loadFlags: !Object<string, !Object<string, string>>,\n     *   nameToPath: !Object<string, string>,\n     *   requires: !Object<string, !Object<string, boolean>>,\n     *   visited: !Object<string, boolean>,\n     *   written: !Object<string, boolean>,\n     *   deferred: !Object<string, string>\n     * }}\n     */\n    goog.dependencies_ = {\n      loadFlags: {},  // 1 to 1\n  \n      nameToPath: {},  // 1 to 1\n  \n      requires: {},  // 1 to many\n  \n      // Used when resolving dependencies to prevent us from visiting file twice.\n      visited: {},\n  \n      written: {},  // Used to keep track of script files we have written.\n  \n      deferred: {}  // Used to track deferred module evaluations in old IEs\n    };\n  \n  \n    /**\n     * Tries to detect whether is in the context of an HTML document.\n     * @return {boolean} True if it looks like HTML document.\n     * @private\n     */\n    goog.inHtmlDocument_ = function() {\n      /** @type {Document} */\n      var doc = goog.global.document;\n      return doc != null && 'write' in doc;  // XULDocument misses write.\n    };\n  \n  \n    /**\n     * Tries to detect the base path of base.js script that bootstraps Closure.\n     * @private\n     */\n    goog.findBasePath_ = function() {\n      if (goog.isDef(goog.global.CLOSURE_BASE_PATH) &&\n          // Anti DOM-clobbering runtime check (b/37736576).\n          goog.isString(goog.global.CLOSURE_BASE_PATH)) {\n        goog.basePath = goog.global.CLOSURE_BASE_PATH;\n        return;\n      } else if (!goog.inHtmlDocument_()) {\n        return;\n      }\n      /** @type {Document} */\n      var doc = goog.global.document;\n      // If we have a currentScript available, use it exclusively.\n      var currentScript = doc.currentScript;\n      if (currentScript) {\n        var scripts = [currentScript];\n      } else {\n        var scripts = doc.getElementsByTagName('SCRIPT');\n      }\n      // Search backwards since the current script is in almost all cases the one\n      // that has base.js.\n      for (var i = scripts.length - 1; i >= 0; --i) {\n        var script = /** @type {!HTMLScriptElement} */ (scripts[i]);\n        var src = script.src;\n        var qmark = src.lastIndexOf('?');\n        var l = qmark == -1 ? src.length : qmark;\n        if (src.substr(l - 7, 7) == 'base.js') {\n          goog.basePath = src.substr(0, l - 7);\n          return;\n        }\n      }\n    };\n  \n  \n    /**\n     * Imports a script if, and only if, that script hasn't already been imported.\n     * (Must be called at execution time)\n     * @param {string} src Script source.\n     * @param {string=} opt_sourceText The optionally source text to evaluate\n     * @private\n     */\n    goog.importScript_ = function(src, opt_sourceText) {\n      var importScript =\n          goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;\n      if (importScript(src, opt_sourceText)) {\n        goog.dependencies_.written[src] = true;\n      }\n    };\n  \n  \n    /**\n     * Whether the browser is IE9 or earlier, which needs special handling\n     * for deferred modules.\n     * @const @private {boolean}\n     */\n    goog.IS_OLD_IE_ =\n        !!(!goog.global.atob && goog.global.document && goog.global.document.all);\n  \n  \n    /**\n     * Whether IE9 or earlier is waiting on a dependency.  This ensures that\n     * deferred modules that have no non-deferred dependencies actually get\n     * loaded, since if we defer them and then never pull in a non-deferred\n     * script, then `goog.loadQueuedModules_` will never be called.  Instead,\n     * if not waiting on anything we simply don't defer in the first place.\n     * @private {boolean}\n     */\n    goog.oldIeWaiting_ = false;\n  \n  \n    /**\n     * Given a URL initiate retrieval and execution of a script that needs\n     * pre-processing.\n     * @param {string} src Script source URL.\n     * @param {boolean} isModule Whether this is a goog.module.\n     * @param {boolean} needsTranspile Whether this source needs transpilation.\n     * @private\n     */\n    goog.importProcessedScript_ = function(src, isModule, needsTranspile) {\n      // In an attempt to keep browsers from timing out loading scripts using\n      // synchronous XHRs, put each load in its own script block.\n      var bootstrap = 'goog.retrieveAndExec_(\"' + src + '\", ' + isModule + ', ' +\n          needsTranspile + ');';\n  \n      goog.importScript_('', bootstrap);\n    };\n  \n  \n    /** @private {!Array<string>} */\n    goog.queuedModules_ = [];\n  \n  \n    /**\n     * Return an appropriate module text. Suitable to insert into\n     * a script tag (that is unescaped).\n     * @param {string} srcUrl\n     * @param {string} scriptText\n     * @return {string}\n     * @private\n     */\n    goog.wrapModule_ = function(srcUrl, scriptText) {\n      if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {\n        return '' +\n            'goog.loadModule(function(exports) {' +\n            '\"use strict\";' + scriptText +\n            '\\n' +  // terminate any trailing single line comment.\n            ';return exports' +\n            '});' +\n            '\\n//# sourceURL=' + srcUrl + '\\n';\n      } else {\n        return '' +\n            'goog.loadModule(' +\n            goog.global.JSON.stringify(\n                scriptText + '\\n//# sourceURL=' + srcUrl + '\\n') +\n            ');';\n      }\n    };\n  \n    // On IE9 and earlier, it is necessary to handle\n    // deferred module loads. In later browsers, the\n    // code to be evaluated is simply inserted as a script\n    // block in the correct order. To eval deferred\n    // code at the right time, we piggy back on goog.require to call\n    // goog.maybeProcessDeferredDep_.\n    //\n    // The goog.requires are used both to bootstrap\n    // the loading process (when no deps are available) and\n    // declare that they should be available.\n    //\n    // Here we eval the sources, if all the deps are available\n    // either already eval'd or goog.require'd.  This will\n    // be the case when all the dependencies have already\n    // been loaded, and the dependent module is loaded.\n    //\n    // But this alone isn't sufficient because it is also\n    // necessary to handle the case where there is no root\n    // that is not deferred.  For that there we register for an event\n    // and trigger goog.loadQueuedModules_ handle any remaining deferred\n    // evaluations.\n  \n    /**\n     * Handle any remaining deferred goog.module evals.\n     * @private\n     */\n    goog.loadQueuedModules_ = function() {\n      var count = goog.queuedModules_.length;\n      if (count > 0) {\n        var queue = goog.queuedModules_;\n        goog.queuedModules_ = [];\n        for (var i = 0; i < count; i++) {\n          var path = queue[i];\n          goog.maybeProcessDeferredPath_(path);\n        }\n      }\n      goog.oldIeWaiting_ = false;\n    };\n  \n  \n    /**\n     * Eval the named module if its dependencies are\n     * available.\n     * @param {string} name The module to load.\n     * @private\n     */\n    goog.maybeProcessDeferredDep_ = function(name) {\n      if (goog.isDeferredModule_(name) && goog.allDepsAreAvailable_(name)) {\n        var path = goog.getPathFromDeps_(name);\n        goog.maybeProcessDeferredPath_(goog.basePath + path);\n      }\n    };\n  \n    /**\n     * @param {string} name The module to check.\n     * @return {boolean} Whether the name represents a\n     *     module whose evaluation has been deferred.\n     * @private\n     */\n    goog.isDeferredModule_ = function(name) {\n      var path = goog.getPathFromDeps_(name);\n      var loadFlags = path && goog.dependencies_.loadFlags[path] || {};\n      var languageLevel = loadFlags['lang'] || 'es3';\n      if (path && (loadFlags['module'] == 'goog' ||\n                   goog.needsTranspile_(languageLevel))) {\n        var abspath = goog.basePath + path;\n        return (abspath) in goog.dependencies_.deferred;\n      }\n      return false;\n    };\n  \n    /**\n     * @param {string} name The module to check.\n     * @return {boolean} Whether the name represents a\n     *     module whose declared dependencies have all been loaded\n     *     (eval'd or a deferred module load)\n     * @private\n     */\n    goog.allDepsAreAvailable_ = function(name) {\n      var path = goog.getPathFromDeps_(name);\n      if (path && (path in goog.dependencies_.requires)) {\n        for (var requireName in goog.dependencies_.requires[path]) {\n          if (!goog.isProvided_(requireName) &&\n              !goog.isDeferredModule_(requireName)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n  \n  \n    /**\n     * @param {string} abspath\n     * @private\n     */\n    goog.maybeProcessDeferredPath_ = function(abspath) {\n      if (abspath in goog.dependencies_.deferred) {\n        var src = goog.dependencies_.deferred[abspath];\n        delete goog.dependencies_.deferred[abspath];\n        goog.globalEval(src);\n      }\n    };\n  \n  \n    /**\n     * Load a goog.module from the provided URL.  This is not a general purpose\n     * code loader and does not support late loading code, that is it should only\n     * be used during page load. This method exists to support unit tests and\n     * \"debug\" loaders that would otherwise have inserted script tags. Under the\n     * hood this needs to use a synchronous XHR and is not recommeneded for\n     * production code.\n     *\n     * The module's goog.requires must have already been satisified; an exception\n     * will be thrown if this is not the case. This assumption is that no\n     * \"deps.js\" file exists, so there is no way to discover and locate the\n     * module-to-be-loaded's dependencies and no attempt is made to do so.\n     *\n     * There should only be one attempt to load a module.  If\n     * \"goog.loadModuleFromUrl\" is called for an already loaded module, an\n     * exception will be throw.\n     *\n     * @param {string} url The URL from which to attempt to load the goog.module.\n     */\n    goog.loadModuleFromUrl = function(url) {\n      // Because this executes synchronously, we don't need to do any additional\n      // bookkeeping. When \"goog.loadModule\" the namespace will be marked as\n      // having been provided which is sufficient.\n      goog.retrieveAndExec_(url, true, false);\n    };\n  \n  \n    /**\n     * Writes a new script pointing to {@code src} directly into the DOM.\n     *\n     * NOTE: This method is not CSP-compliant. @see goog.appendScriptSrcNode_ for\n     * the fallback mechanism.\n     *\n     * @param {string} src The script URL.\n     * @private\n     */\n    goog.writeScriptSrcNode_ = function(src) {\n      goog.global.document.write(\n          '<script type=\"text/javascript\" src=\"' + src + '\"></' +\n          'script>');\n    };\n  \n  \n    /**\n     * Appends a new script node to the DOM using a CSP-compliant mechanism. This\n     * method exists as a fallback for document.write (which is not allowed in a\n     * strict CSP context, e.g., Chrome apps).\n     *\n     * NOTE: This method is not analogous to using document.write to insert a\n     * <script> tag; specifically, the user agent will execute a script added by\n     * document.write immediately after the current script block finishes\n     * executing, whereas the DOM-appended script node will not be executed until\n     * the entire document is parsed and executed. That is to say, this script is\n     * added to the end of the script execution queue.\n     *\n     * The page must not attempt to call goog.required entities until after the\n     * document has loaded, e.g., in or after the window.onload callback.\n     *\n     * @param {string} src The script URL.\n     * @private\n     */\n    goog.appendScriptSrcNode_ = function(src) {\n      /** @type {Document} */\n      var doc = goog.global.document;\n      var scriptEl =\n          /** @type {HTMLScriptElement} */ (doc.createElement('script'));\n      scriptEl.type = 'text/javascript';\n      scriptEl.src = src;\n      scriptEl.defer = false;\n      scriptEl.async = false;\n      doc.head.appendChild(scriptEl);\n    };\n  \n  \n    /**\n     * The default implementation of the import function. Writes a script tag to\n     * import the script.\n     *\n     * @param {string} src The script url.\n     * @param {string=} opt_sourceText The optionally source text to evaluate\n     * @return {boolean} True if the script was imported, false otherwise.\n     * @private\n     */\n    goog.writeScriptTag_ = function(src, opt_sourceText) {\n      if (goog.inHtmlDocument_()) {\n        /** @type {!HTMLDocument} */\n        var doc = goog.global.document;\n  \n        // If the user tries to require a new symbol after document load,\n        // something has gone terribly wrong. Doing a document.write would\n        // wipe out the page. This does not apply to the CSP-compliant method\n        // of writing script tags.\n        if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&\n            doc.readyState == 'complete') {\n          // Certain test frameworks load base.js multiple times, which tries\n          // to write deps.js each time. If that happens, just fail silently.\n          // These frameworks wipe the page between each load of base.js, so this\n          // is OK.\n          var isDeps = /\\bdeps.js$/.test(src);\n          if (isDeps) {\n            return false;\n          } else {\n            throw new Error('Cannot write \"' + src + '\" after document load');\n          }\n        }\n  \n        if (opt_sourceText === undefined) {\n          if (!goog.IS_OLD_IE_) {\n            if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {\n              goog.appendScriptSrcNode_(src);\n            } else {\n              goog.writeScriptSrcNode_(src);\n            }\n          } else {\n            goog.oldIeWaiting_ = true;\n            var state = ' onreadystatechange=\\'goog.onScriptLoad_(this, ' +\n                ++goog.lastNonModuleScriptIndex_ + ')\\' ';\n            doc.write(\n                '<script type=\"text/javascript\" src=\"' + src + '\"' + state +\n                '></' +\n                'script>');\n          }\n        } else {\n          doc.write(\n              '<script type=\"text/javascript\">' +\n              goog.protectScriptTag_(opt_sourceText) + '</' +\n              'script>');\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n  \n    /**\n     * Rewrites closing script tags in input to avoid ending an enclosing script\n     * tag.\n     *\n     * @param {string} str\n     * @return {string}\n     * @private\n     */\n    goog.protectScriptTag_ = function(str) {\n      return str.replace(/<\\/(SCRIPT)/ig, '\\\\x3c/$1');\n    };\n  \n    /**\n     * Determines whether the given language needs to be transpiled.\n     * @param {string} lang\n     * @return {boolean}\n     * @private\n     */\n    goog.needsTranspile_ = function(lang) {\n      if (goog.TRANSPILE == 'always') {\n        return true;\n      } else if (goog.TRANSPILE == 'never') {\n        return false;\n      } else if (!goog.requiresTranspilation_) {\n        goog.requiresTranspilation_ = goog.createRequiresTranspilation_();\n      }\n      if (lang in goog.requiresTranspilation_) {\n        return goog.requiresTranspilation_[lang];\n      } else {\n        throw new Error('Unknown language mode: ' + lang);\n      }\n    };\n  \n    /** @private {?Object<string, boolean>} */\n    goog.requiresTranspilation_ = null;\n  \n  \n    /** @private {number} */\n    goog.lastNonModuleScriptIndex_ = 0;\n  \n  \n    /**\n     * A readystatechange handler for legacy IE\n     * @param {?} script\n     * @param {number} scriptIndex\n     * @return {boolean}\n     * @private\n     */\n    goog.onScriptLoad_ = function(script, scriptIndex) {\n      // for now load the modules when we reach the last script,\n      // later allow more inter-mingling.\n      if (script.readyState == 'complete' &&\n          goog.lastNonModuleScriptIndex_ == scriptIndex) {\n        goog.loadQueuedModules_();\n      }\n      return true;\n    };\n  \n    /**\n     * Resolves dependencies based on the dependencies added using addDependency\n     * and calls importScript_ in the correct order.\n     * @param {string} pathToLoad The path from which to start discovering\n     *     dependencies.\n     * @private\n     */\n    goog.writeScripts_ = function(pathToLoad) {\n      /** @type {!Array<string>} The scripts we need to write this time. */\n      var scripts = [];\n      var seenScript = {};\n      var deps = goog.dependencies_;\n  \n      /** @param {string} path */\n      function visitNode(path) {\n        if (path in deps.written) {\n          return;\n        }\n  \n        // We have already visited this one. We can get here if we have cyclic\n        // dependencies.\n        if (path in deps.visited) {\n          return;\n        }\n  \n        deps.visited[path] = true;\n  \n        if (path in deps.requires) {\n          for (var requireName in deps.requires[path]) {\n            // If the required name is defined, we assume that it was already\n            // bootstrapped by other means.\n            if (!goog.isProvided_(requireName)) {\n              if (requireName in deps.nameToPath) {\n                visitNode(deps.nameToPath[requireName]);\n              } else {\n                throw new Error('Undefined nameToPath for ' + requireName);\n              }\n            }\n          }\n        }\n  \n        if (!(path in seenScript)) {\n          seenScript[path] = true;\n          scripts.push(path);\n        }\n      }\n  \n      visitNode(pathToLoad);\n  \n      // record that we are going to load all these scripts.\n      for (var i = 0; i < scripts.length; i++) {\n        var path = scripts[i];\n        goog.dependencies_.written[path] = true;\n      }\n  \n      // If a module is loaded synchronously then we need to\n      // clear the current inModuleLoader value, and restore it when we are\n      // done loading the current \"requires\".\n      var moduleState = goog.moduleLoaderState_;\n      goog.moduleLoaderState_ = null;\n  \n      for (var i = 0; i < scripts.length; i++) {\n        var path = scripts[i];\n        if (path) {\n          var loadFlags = deps.loadFlags[path] || {};\n          var languageLevel = loadFlags['lang'] || 'es3';\n          var needsTranspile = goog.needsTranspile_(languageLevel);\n          if (loadFlags['module'] == 'goog' || needsTranspile) {\n            goog.importProcessedScript_(\n                goog.basePath + path, loadFlags['module'] == 'goog',\n                needsTranspile);\n          } else {\n            goog.importScript_(goog.basePath + path);\n          }\n        } else {\n          goog.moduleLoaderState_ = moduleState;\n          throw new Error('Undefined script input');\n        }\n      }\n  \n      // restore the current \"module loading state\"\n      goog.moduleLoaderState_ = moduleState;\n    };\n  \n  \n    /**\n     * Looks at the dependency rules and tries to determine the script file that\n     * fulfills a particular rule.\n     * @param {string} rule In the form goog.namespace.Class or project.script.\n     * @return {?string} Url corresponding to the rule, or null.\n     * @private\n     */\n    goog.getPathFromDeps_ = function(rule) {\n      if (rule in goog.dependencies_.nameToPath) {\n        return goog.dependencies_.nameToPath[rule];\n      } else {\n        return null;\n      }\n    };\n  \n    goog.findBasePath_();\n  \n    // Allow projects to manage the deps files themselves.\n    if (!goog.global.CLOSURE_NO_DEPS) {\n      goog.importScript_(goog.basePath + 'deps.js');\n    }\n  }\n  \n  \n  /**\n   * @package {?boolean}\n   * Visible for testing.\n   */\n  goog.hasBadLetScoping = null;\n  \n  \n  /**\n   * @return {boolean}\n   * @package Visible for testing.\n   */\n  goog.useSafari10Workaround = function() {\n    if (goog.hasBadLetScoping == null) {\n      var hasBadLetScoping;\n      try {\n        hasBadLetScoping = !eval(\n            '\"use strict\";' +\n            'let x = 1; function f() { return typeof x; };' +\n            'f() == \"number\";');\n      } catch (e) {\n        // Assume that ES6 syntax isn't supported.\n        hasBadLetScoping = false;\n      }\n      goog.hasBadLetScoping = hasBadLetScoping;\n    }\n    return goog.hasBadLetScoping;\n  };\n  \n  \n  /**\n   * @param {string} moduleDef\n   * @return {string}\n   * @package Visible for testing.\n   */\n  goog.workaroundSafari10EvalBug = function(moduleDef) {\n    return '(function(){' + moduleDef +\n        '\\n' +  // Terminate any trailing single line comment.\n        ';' +   // Terminate any trailing expression.\n        '})();\\n';\n  };\n  \n  \n  /**\n   * @param {function(?):?|string} moduleDef The module definition.\n   */\n  goog.loadModule = function(moduleDef) {\n    // NOTE: we allow function definitions to be either in the from\n    // of a string to eval (which keeps the original source intact) or\n    // in a eval forbidden environment (CSP) we allow a function definition\n    // which in its body must call {@code goog.module}, and return the exports\n    // of the module.\n    var previousState = goog.moduleLoaderState_;\n    try {\n      goog.moduleLoaderState_ = {\n        moduleName: undefined,\n        declareLegacyNamespace: false\n      };\n      var exports;\n      if (goog.isFunction(moduleDef)) {\n        exports = moduleDef.call(undefined, {});\n      } else if (goog.isString(moduleDef)) {\n        if (goog.useSafari10Workaround()) {\n          moduleDef = goog.workaroundSafari10EvalBug(moduleDef);\n        }\n  \n        exports = goog.loadModuleFromSource_.call(undefined, moduleDef);\n      } else {\n        throw new Error('Invalid module definition');\n      }\n  \n      var moduleName = goog.moduleLoaderState_.moduleName;\n      if (!goog.isString(moduleName) || !moduleName) {\n        throw new Error('Invalid module name \\\"' + moduleName + '\\\"');\n      }\n  \n      // Don't seal legacy namespaces as they may be uses as a parent of\n      // another namespace\n      if (goog.moduleLoaderState_.declareLegacyNamespace) {\n        goog.constructNamespace_(moduleName, exports);\n      } else if (\n          goog.SEAL_MODULE_EXPORTS && Object.seal && typeof exports == 'object' &&\n          exports != null) {\n        Object.seal(exports);\n      }\n  \n      goog.loadedModules_[moduleName] = exports;\n    } finally {\n      goog.moduleLoaderState_ = previousState;\n    }\n  };\n  \n  \n  /**\n   * @private @const\n   */\n  goog.loadModuleFromSource_ = /** @type {function(string):?} */ (function() {\n    // NOTE: we avoid declaring parameters or local variables here to avoid\n    // masking globals or leaking values into the module definition.\n    'use strict';\n    var exports = {};\n    eval(arguments[0]);\n    return exports;\n  });\n  \n  \n  /**\n   * Normalize a file path by removing redundant \"..\" and extraneous \".\" file\n   * path components.\n   * @param {string} path\n   * @return {string}\n   * @private\n   */\n  goog.normalizePath_ = function(path) {\n    var components = path.split('/');\n    var i = 0;\n    while (i < components.length) {\n      if (components[i] == '.') {\n        components.splice(i, 1);\n      } else if (\n          i && components[i] == '..' && components[i - 1] &&\n          components[i - 1] != '..') {\n        components.splice(--i, 2);\n      } else {\n        i++;\n      }\n    }\n    return components.join('/');\n  };\n  \n  \n  /**\n   * Provides a hook for loading a file when using Closure's goog.require() API\n   * with goog.modules.  In particular this hook is provided to support Node.js.\n   *\n   * @type {(function(string):string)|undefined}\n   */\n  goog.global.CLOSURE_LOAD_FILE_SYNC;\n  \n  \n  /**\n   * Loads file by synchronous XHR. Should not be used in production environments.\n   * @param {string} src Source URL.\n   * @return {?string} File contents, or null if load failed.\n   * @private\n   */\n  goog.loadFileSync_ = function(src) {\n    if (goog.global.CLOSURE_LOAD_FILE_SYNC) {\n      return goog.global.CLOSURE_LOAD_FILE_SYNC(src);\n    } else {\n      try {\n        /** @type {XMLHttpRequest} */\n        var xhr = new goog.global['XMLHttpRequest']();\n        xhr.open('get', src, false);\n        xhr.send();\n        // NOTE: Successful http: requests have a status of 200, but successful\n        // file: requests may have a status of zero.  Any other status, or a\n        // thrown exception (particularly in case of file: requests) indicates\n        // some sort of error, which we treat as a missing or unavailable file.\n        return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;\n      } catch (err) {\n        // No need to rethrow or log, since errors should show up on their own.\n        return null;\n      }\n    }\n  };\n  \n  \n  /**\n   * Retrieve and execute a script that needs some sort of wrapping.\n   * @param {string} src Script source URL.\n   * @param {boolean} isModule Whether to load as a module.\n   * @param {boolean} needsTranspile Whether to transpile down to ES3.\n   * @private\n   */\n  goog.retrieveAndExec_ = function(src, isModule, needsTranspile) {\n    if (!COMPILED) {\n      // The full but non-canonicalized URL for later use.\n      var originalPath = src;\n      // Canonicalize the path, removing any /./ or /../ since Chrome's debugging\n      // console doesn't auto-canonicalize XHR loads as it does <script> srcs.\n      src = goog.normalizePath_(src);\n  \n      var importScript =\n          goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;\n  \n      var scriptText = goog.loadFileSync_(src);\n      if (scriptText == null) {\n        throw new Error('Load of \"' + src + '\" failed');\n      }\n  \n      if (needsTranspile) {\n        scriptText = goog.transpile_.call(goog.global, scriptText, src);\n      }\n  \n      if (isModule) {\n        scriptText = goog.wrapModule_(src, scriptText);\n      } else {\n        scriptText += '\\n//# sourceURL=' + src;\n      }\n      var isOldIE = goog.IS_OLD_IE_;\n      if (isOldIE && goog.oldIeWaiting_) {\n        goog.dependencies_.deferred[originalPath] = scriptText;\n        goog.queuedModules_.push(originalPath);\n      } else {\n        importScript(src, scriptText);\n      }\n    }\n  };\n  \n  \n  /**\n   * Lazily retrieves the transpiler and applies it to the source.\n   * @param {string} code JS code.\n   * @param {string} path Path to the code.\n   * @return {string} The transpiled code.\n   * @private\n   */\n  goog.transpile_ = function(code, path) {\n    var jscomp = goog.global['$jscomp'];\n    if (!jscomp) {\n      goog.global['$jscomp'] = jscomp = {};\n    }\n    var transpile = jscomp.transpile;\n    if (!transpile) {\n      var transpilerPath = goog.basePath + goog.TRANSPILER;\n      var transpilerCode = goog.loadFileSync_(transpilerPath);\n      if (transpilerCode) {\n        // This must be executed synchronously, since by the time we know we\n        // need it, we're about to load and write the ES6 code synchronously,\n        // so a normal script-tag load will be too slow.\n        eval(transpilerCode + '\\n//# sourceURL=' + transpilerPath);\n        // Even though the transpiler is optional, if $gwtExport is found, it's\n        // a sign the transpiler was loaded and the $jscomp.transpile *should*\n        // be there.\n        if (goog.global['$gwtExport'] && goog.global['$gwtExport']['$jscomp'] &&\n            !goog.global['$gwtExport']['$jscomp']['transpile']) {\n          throw new Error(\n              'The transpiler did not properly export the \"transpile\" ' +\n              'method. $gwtExport: ' + JSON.stringify(goog.global['$gwtExport']));\n        }\n        // transpile.js only exports a single $jscomp function, transpile. We\n        // grab just that and add it to the existing definition of $jscomp which\n        // contains the polyfills.\n        goog.global['$jscomp'].transpile =\n            goog.global['$gwtExport']['$jscomp']['transpile'];\n        jscomp = goog.global['$jscomp'];\n        transpile = jscomp.transpile;\n      }\n    }\n    if (!transpile) {\n      // The transpiler is an optional component.  If it's not available then\n      // replace it with a pass-through function that simply logs.\n      var suffix = ' requires transpilation but no transpiler was found.';\n      transpile = jscomp.transpile = function(code, path) {\n        // TODO(user): figure out some way to get this error to show up\n        // in test results, noting that the failure may occur in many\n        // different ways, including in loadModule() before the test\n        // runner even comes up.\n        goog.logToConsole_(path + suffix);\n        return code;\n      };\n    }\n    // Note: any transpilation errors/warnings will be logged to the console.\n    return transpile(code, path);\n  };\n  \n  \n  //==============================================================================\n  // Language Enhancements\n  //==============================================================================\n  \n  \n  /**\n   * This is a \"fixed\" version of the typeof operator.  It differs from the typeof\n   * operator in such a way that null returns 'null' and arrays return 'array'.\n   * @param {?} value The value to get the type of.\n   * @return {string} The name of the type.\n   */\n  goog.typeOf = function(value) {\n    var s = typeof value;\n    if (s == 'object') {\n      if (value) {\n        // Check these first, so we can avoid calling Object.prototype.toString if\n        // possible.\n        //\n        // IE improperly marshals typeof across execution contexts, but a\n        // cross-context object will still return false for \"instanceof Object\".\n        if (value instanceof Array) {\n          return 'array';\n        } else if (value instanceof Object) {\n          return s;\n        }\n  \n        // HACK: In order to use an Object prototype method on the arbitrary\n        //   value, the compiler requires the value be cast to type Object,\n        //   even though the ECMA spec explicitly allows it.\n        var className = Object.prototype.toString.call(\n            /** @type {!Object} */ (value));\n        // In Firefox 3.6, attempting to access iframe window objects' length\n        // property throws an NS_ERROR_FAILURE, so we need to special-case it\n        // here.\n        if (className == '[object Window]') {\n          return 'object';\n        }\n  \n        // We cannot always use constructor == Array or instanceof Array because\n        // different frames have different Array objects. In IE6, if the iframe\n        // where the array was created is destroyed, the array loses its\n        // prototype. Then dereferencing val.splice here throws an exception, so\n        // we can't use goog.isFunction. Calling typeof directly returns 'unknown'\n        // so that will work. In this case, this function will return false and\n        // most array functions will still work because the array is still\n        // array-like (supports length and []) even though it has lost its\n        // prototype.\n        // Mark Miller noticed that Object.prototype.toString\n        // allows access to the unforgeable [[Class]] property.\n        //  15.2.4.2 Object.prototype.toString ( )\n        //  When the toString method is called, the following steps are taken:\n        //      1. Get the [[Class]] property of this object.\n        //      2. Compute a string value by concatenating the three strings\n        //         \"[object \", Result(1), and \"]\".\n        //      3. Return Result(2).\n        // and this behavior survives the destruction of the execution context.\n        if ((className == '[object Array]' ||\n             // In IE all non value types are wrapped as objects across window\n             // boundaries (not iframe though) so we have to do object detection\n             // for this edge case.\n             typeof value.length == 'number' &&\n                 typeof value.splice != 'undefined' &&\n                 typeof value.propertyIsEnumerable != 'undefined' &&\n                 !value.propertyIsEnumerable('splice')\n  \n                 )) {\n          return 'array';\n        }\n        // HACK: There is still an array case that fails.\n        //     function ArrayImpostor() {}\n        //     ArrayImpostor.prototype = [];\n        //     var impostor = new ArrayImpostor;\n        // this can be fixed by getting rid of the fast path\n        // (value instanceof Array) and solely relying on\n        // (value && Object.prototype.toString.vall(value) === '[object Array]')\n        // but that would require many more function calls and is not warranted\n        // unless closure code is receiving objects from untrusted sources.\n  \n        // IE in cross-window calls does not correctly marshal the function type\n        // (it appears just as an object) so we cannot use just typeof val ==\n        // 'function'. However, if the object has a call property, it is a\n        // function.\n        if ((className == '[object Function]' ||\n             typeof value.call != 'undefined' &&\n                 typeof value.propertyIsEnumerable != 'undefined' &&\n                 !value.propertyIsEnumerable('call'))) {\n          return 'function';\n        }\n  \n      } else {\n        return 'null';\n      }\n  \n    } else if (s == 'function' && typeof value.call == 'undefined') {\n      // In Safari typeof nodeList returns 'function', and on Firefox typeof\n      // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We\n      // would like to return object for those and we can detect an invalid\n      // function by making sure that the function object has a call method.\n      return 'object';\n    }\n    return s;\n  };\n  \n  \n  /**\n   * Returns true if the specified value is null.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is null.\n   */\n  goog.isNull = function(val) {\n    return val === null;\n  };\n  \n  \n  /**\n   * Returns true if the specified value is defined and not null.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is defined and not null.\n   */\n  goog.isDefAndNotNull = function(val) {\n    // Note that undefined == null.\n    return val != null;\n  };\n  \n  \n  /**\n   * Returns true if the specified value is an array.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is an array.\n   */\n  goog.isArray = function(val) {\n    return goog.typeOf(val) == 'array';\n  };\n  \n  \n  /**\n   * Returns true if the object looks like an array. To qualify as array like\n   * the value needs to be either a NodeList or an object with a Number length\n   * property. As a special case, a function value is not array like, because its\n   * length property is fixed to correspond to the number of expected arguments.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is an array.\n   */\n  goog.isArrayLike = function(val) {\n    var type = goog.typeOf(val);\n    // We do not use goog.isObject here in order to exclude function values.\n    return type == 'array' || type == 'object' && typeof val.length == 'number';\n  };\n  \n  \n  /**\n   * Returns true if the object looks like a Date. To qualify as Date-like the\n   * value needs to be an object and have a getFullYear() function.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is a like a Date.\n   */\n  goog.isDateLike = function(val) {\n    return goog.isObject(val) && typeof val.getFullYear == 'function';\n  };\n  \n  \n  /**\n   * Returns true if the specified value is a function.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is a function.\n   */\n  goog.isFunction = function(val) {\n    return goog.typeOf(val) == 'function';\n  };\n  \n  \n  /**\n   * Returns true if the specified value is an object.  This includes arrays and\n   * functions.\n   * @param {?} val Variable to test.\n   * @return {boolean} Whether variable is an object.\n   */\n  goog.isObject = function(val) {\n    var type = typeof val;\n    return type == 'object' && val != null || type == 'function';\n    // return Object(val) === val also works, but is slower, especially if val is\n    // not an object.\n  };\n  \n  \n  /**\n   * Gets a unique ID for an object. This mutates the object so that further calls\n   * with the same object as a parameter returns the same value. The unique ID is\n   * guaranteed to be unique across the current session amongst objects that are\n   * passed into {@code getUid}. There is no guarantee that the ID is unique or\n   * consistent across sessions. It is unsafe to generate unique ID for function\n   * prototypes.\n   *\n   * @param {Object} obj The object to get the unique ID for.\n   * @return {number} The unique ID for the object.\n   */\n  goog.getUid = function(obj) {\n    // TODO(arv): Make the type stricter, do not accept null.\n  \n    // In Opera window.hasOwnProperty exists but always returns false so we avoid\n    // using it. As a consequence the unique ID generated for BaseClass.prototype\n    // and SubClass.prototype will be the same.\n    return obj[goog.UID_PROPERTY_] ||\n        (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);\n  };\n  \n  \n  /**\n   * Whether the given object is already assigned a unique ID.\n   *\n   * This does not modify the object.\n   *\n   * @param {!Object} obj The object to check.\n   * @return {boolean} Whether there is an assigned unique id for the object.\n   */\n  goog.hasUid = function(obj) {\n    return !!obj[goog.UID_PROPERTY_];\n  };\n  \n  \n  /**\n   * Removes the unique ID from an object. This is useful if the object was\n   * previously mutated using {@code goog.getUid} in which case the mutation is\n   * undone.\n   * @param {Object} obj The object to remove the unique ID field from.\n   */\n  goog.removeUid = function(obj) {\n    // TODO(arv): Make the type stricter, do not accept null.\n  \n    // In IE, DOM nodes are not instances of Object and throw an exception if we\n    // try to delete.  Instead we try to use removeAttribute.\n    if (obj !== null && 'removeAttribute' in obj) {\n      obj.removeAttribute(goog.UID_PROPERTY_);\n    }\n  \n    try {\n      delete obj[goog.UID_PROPERTY_];\n    } catch (ex) {\n    }\n  };\n  \n  \n  /**\n   * Name for unique ID property. Initialized in a way to help avoid collisions\n   * with other closure JavaScript on the same page.\n   * @type {string}\n   * @private\n   */\n  goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);\n  \n  \n  /**\n   * Counter for UID.\n   * @type {number}\n   * @private\n   */\n  goog.uidCounter_ = 0;\n  \n  \n  /**\n   * Adds a hash code field to an object. The hash code is unique for the\n   * given object.\n   * @param {Object} obj The object to get the hash code for.\n   * @return {number} The hash code for the object.\n   * @deprecated Use goog.getUid instead.\n   */\n  goog.getHashCode = goog.getUid;\n  \n  \n  /**\n   * Removes the hash code field from an object.\n   * @param {Object} obj The object to remove the field from.\n   * @deprecated Use goog.removeUid instead.\n   */\n  goog.removeHashCode = goog.removeUid;\n  \n  \n  /**\n   * Clones a value. The input may be an Object, Array, or basic type. Objects and\n   * arrays will be cloned recursively.\n   *\n   * WARNINGS:\n   * <code>goog.cloneObject</code> does not detect reference loops. Objects that\n   * refer to themselves will cause infinite recursion.\n   *\n   * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies\n   * UIDs created by <code>getUid</code> into cloned results.\n   *\n   * @param {*} obj The value to clone.\n   * @return {*} A clone of the input value.\n   * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.\n   */\n  goog.cloneObject = function(obj) {\n    var type = goog.typeOf(obj);\n    if (type == 'object' || type == 'array') {\n      if (obj.clone) {\n        return obj.clone();\n      }\n      var clone = type == 'array' ? [] : {};\n      for (var key in obj) {\n        clone[key] = goog.cloneObject(obj[key]);\n      }\n      return clone;\n    }\n  \n    return obj;\n  };\n  \n  \n  /**\n   * A native implementation of goog.bind.\n   * @param {?function(this:T, ...)} fn A function to partially apply.\n   * @param {T} selfObj Specifies the object which this should point to when the\n   *     function is run.\n   * @param {...*} var_args Additional arguments that are partially applied to the\n   *     function.\n   * @return {!Function} A partially-applied form of the function goog.bind() was\n   *     invoked as a method of.\n   * @template T\n   * @private\n   */\n  goog.bindNative_ = function(fn, selfObj, var_args) {\n    return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));\n  };\n  \n  \n  /**\n   * A pure-JS implementation of goog.bind.\n   * @param {?function(this:T, ...)} fn A function to partially apply.\n   * @param {T} selfObj Specifies the object which this should point to when the\n   *     function is run.\n   * @param {...*} var_args Additional arguments that are partially applied to the\n   *     function.\n   * @return {!Function} A partially-applied form of the function goog.bind() was\n   *     invoked as a method of.\n   * @template T\n   * @private\n   */\n  goog.bindJs_ = function(fn, selfObj, var_args) {\n    if (!fn) {\n      throw new Error();\n    }\n  \n    if (arguments.length > 2) {\n      var boundArgs = Array.prototype.slice.call(arguments, 2);\n      return function() {\n        // Prepend the bound arguments to the current arguments.\n        var newArgs = Array.prototype.slice.call(arguments);\n        Array.prototype.unshift.apply(newArgs, boundArgs);\n        return fn.apply(selfObj, newArgs);\n      };\n  \n    } else {\n      return function() {\n        return fn.apply(selfObj, arguments);\n      };\n    }\n  };\n  \n  \n  /**\n   * Partially applies this function to a particular 'this object' and zero or\n   * more arguments. The result is a new function with some arguments of the first\n   * function pre-filled and the value of this 'pre-specified'.\n   *\n   * Remaining arguments specified at call-time are appended to the pre-specified\n   * ones.\n   *\n   * Also see: {@link #partial}.\n   *\n   * Usage:\n   * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');\n   * barMethBound('arg3', 'arg4');</pre>\n   *\n   * @param {?function(this:T, ...)} fn A function to partially apply.\n   * @param {T} selfObj Specifies the object which this should point to when the\n   *     function is run.\n   * @param {...*} var_args Additional arguments that are partially applied to the\n   *     function.\n   * @return {!Function} A partially-applied form of the function goog.bind() was\n   *     invoked as a method of.\n   * @template T\n   * @suppress {deprecated} See above.\n   */\n  goog.bind = function(fn, selfObj, var_args) {\n    // TODO(nicksantos): narrow the type signature.\n    if (Function.prototype.bind &&\n        // NOTE(nicksantos): Somebody pulled base.js into the default Chrome\n        // extension environment. This means that for Chrome extensions, they get\n        // the implementation of Function.prototype.bind that calls goog.bind\n        // instead of the native one. Even worse, we don't want to introduce a\n        // circular dependency between goog.bind and Function.prototype.bind, so\n        // we have to hack this to make sure it works correctly.\n        Function.prototype.bind.toString().indexOf('native code') != -1) {\n      goog.bind = goog.bindNative_;\n    } else {\n      goog.bind = goog.bindJs_;\n    }\n    return goog.bind.apply(null, arguments);\n  };\n  \n  \n  /**\n   * Like goog.bind(), except that a 'this object' is not required. Useful when\n   * the target function is already bound.\n   *\n   * Usage:\n   * var g = goog.partial(f, arg1, arg2);\n   * g(arg3, arg4);\n   *\n   * @param {Function} fn A function to partially apply.\n   * @param {...*} var_args Additional arguments that are partially applied to fn.\n   * @return {!Function} A partially-applied form of the function goog.partial()\n   *     was invoked as a method of.\n   */\n  goog.partial = function(fn, var_args) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function() {\n      // Clone the array (with slice()) and append additional arguments\n      // to the existing arguments.\n      var newArgs = args.slice();\n      newArgs.push.apply(newArgs, arguments);\n      return fn.apply(this, newArgs);\n    };\n  };\n  \n  \n  /**\n   * Copies all the members of a source object to a target object. This method\n   * does not work on all browsers for all objects that contain keys such as\n   * toString or hasOwnProperty. Use goog.object.extend for this purpose.\n   * @param {Object} target Target.\n   * @param {Object} source Source.\n   */\n  goog.mixin = function(target, source) {\n    for (var x in source) {\n      target[x] = source[x];\n    }\n  \n    // For IE7 or lower, the for-in-loop does not contain any properties that are\n    // not enumerable on the prototype object (for example, isPrototypeOf from\n    // Object.prototype) but also it will not include 'replace' on objects that\n    // extend String and change 'replace' (not that it is common for anyone to\n    // extend anything except Object).\n  };\n  \n  \n  /**\n   * @return {number} An integer value representing the number of milliseconds\n   *     between midnight, January 1, 1970 and the current time.\n   */\n  goog.now = (goog.TRUSTED_SITE && Date.now) || (function() {\n               // Unary plus operator converts its operand to a number which in\n               // the case of\n               // a date is done by calling getTime().\n               return +new Date();\n             });\n  \n  \n  /**\n   * Evals JavaScript in the global scope.  In IE this uses execScript, other\n   * browsers use goog.global.eval. If goog.global.eval does not evaluate in the\n   * global scope (for example, in Safari), appends a script tag instead.\n   * Throws an exception if neither execScript or eval is defined.\n   * @param {string} script JavaScript string.\n   */\n  goog.globalEval = function(script) {\n    if (goog.global.execScript) {\n      goog.global.execScript(script, 'JavaScript');\n    } else if (goog.global.eval) {\n      // Test to see if eval works\n      if (goog.evalWorksForGlobals_ == null) {\n        goog.global.eval('var _evalTest_ = 1;');\n        if (typeof goog.global['_evalTest_'] != 'undefined') {\n          try {\n            delete goog.global['_evalTest_'];\n          } catch (ignore) {\n            // Microsoft edge fails the deletion above in strict mode.\n          }\n          goog.evalWorksForGlobals_ = true;\n        } else {\n          goog.evalWorksForGlobals_ = false;\n        }\n      }\n  \n      if (goog.evalWorksForGlobals_) {\n        goog.global.eval(script);\n      } else {\n        /** @type {Document} */\n        var doc = goog.global.document;\n        var scriptElt =\n            /** @type {!HTMLScriptElement} */ (doc.createElement('SCRIPT'));\n        scriptElt.type = 'text/javascript';\n        scriptElt.defer = false;\n        // Note(user): can't use .innerHTML since \"t('<test>')\" will fail and\n        // .text doesn't work in Safari 2.  Therefore we append a text node.\n        scriptElt.appendChild(doc.createTextNode(script));\n        doc.body.appendChild(scriptElt);\n        doc.body.removeChild(scriptElt);\n      }\n    } else {\n      throw new Error('goog.globalEval not available');\n    }\n  };\n  \n  \n  /**\n   * Indicates whether or not we can call 'eval' directly to eval code in the\n   * global scope. Set to a Boolean by the first call to goog.globalEval (which\n   * empirically tests whether eval works for globals). @see goog.globalEval\n   * @type {?boolean}\n   * @private\n   */\n  goog.evalWorksForGlobals_ = null;\n  \n  \n  /**\n   * Optional map of CSS class names to obfuscated names used with\n   * goog.getCssName().\n   * @private {!Object<string, string>|undefined}\n   * @see goog.setCssNameMapping\n   */\n  goog.cssNameMapping_;\n  \n  \n  /**\n   * Optional obfuscation style for CSS class names. Should be set to either\n   * 'BY_WHOLE' or 'BY_PART' if defined.\n   * @type {string|undefined}\n   * @private\n   * @see goog.setCssNameMapping\n   */\n  goog.cssNameMappingStyle_;\n  \n  \n  \n  /**\n   * A hook for modifying the default behavior goog.getCssName. The function\n   * if present, will recieve the standard output of the goog.getCssName as\n   * its input.\n   *\n   * @type {(function(string):string)|undefined}\n   */\n  goog.global.CLOSURE_CSS_NAME_MAP_FN;\n  \n  \n  /**\n   * Handles strings that are intended to be used as CSS class names.\n   *\n   * This function works in tandem with @see goog.setCssNameMapping.\n   *\n   * Without any mapping set, the arguments are simple joined with a hyphen and\n   * passed through unaltered.\n   *\n   * When there is a mapping, there are two possible styles in which these\n   * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)\n   * of the passed in css name is rewritten according to the map. In the BY_WHOLE\n   * style, the full css name is looked up in the map directly. If a rewrite is\n   * not specified by the map, the compiler will output a warning.\n   *\n   * When the mapping is passed to the compiler, it will replace calls to\n   * goog.getCssName with the strings from the mapping, e.g.\n   *     var x = goog.getCssName('foo');\n   *     var y = goog.getCssName(this.baseClass, 'active');\n   *  becomes:\n   *     var x = 'foo';\n   *     var y = this.baseClass + '-active';\n   *\n   * If one argument is passed it will be processed, if two are passed only the\n   * modifier will be processed, as it is assumed the first argument was generated\n   * as a result of calling goog.getCssName.\n   *\n   * @param {string} className The class name.\n   * @param {string=} opt_modifier A modifier to be appended to the class name.\n   * @return {string} The class name or the concatenation of the class name and\n   *     the modifier.\n   */\n  goog.getCssName = function(className, opt_modifier) {\n    // String() is used for compatibility with compiled soy where the passed\n    // className can be non-string objects.\n    if (String(className).charAt(0) == '.') {\n      throw new Error(\n          'className passed in goog.getCssName must not start with \".\".' +\n          ' You passed: ' + className);\n    }\n  \n    var getMapping = function(cssName) {\n      return goog.cssNameMapping_[cssName] || cssName;\n    };\n  \n    var renameByParts = function(cssName) {\n      // Remap all the parts individually.\n      var parts = cssName.split('-');\n      var mapped = [];\n      for (var i = 0; i < parts.length; i++) {\n        mapped.push(getMapping(parts[i]));\n      }\n      return mapped.join('-');\n    };\n  \n    var rename;\n    if (goog.cssNameMapping_) {\n      rename =\n          goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;\n    } else {\n      rename = function(a) {\n        return a;\n      };\n    }\n  \n    var result =\n        opt_modifier ? className + '-' + rename(opt_modifier) : rename(className);\n  \n    // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further\n    // processing of the class name.\n    if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {\n      return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);\n    }\n  \n    return result;\n  };\n  \n  \n  /**\n   * Sets the map to check when returning a value from goog.getCssName(). Example:\n   * <pre>\n   * goog.setCssNameMapping({\n   *   \"goog\": \"a\",\n   *   \"disabled\": \"b\",\n   * });\n   *\n   * var x = goog.getCssName('goog');\n   * // The following evaluates to: \"a a-b\".\n   * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')\n   * </pre>\n   * When declared as a map of string literals to string literals, the JSCompiler\n   * will replace all calls to goog.getCssName() using the supplied map if the\n   * --process_closure_primitives flag is set.\n   *\n   * @param {!Object} mapping A map of strings to strings where keys are possible\n   *     arguments to goog.getCssName() and values are the corresponding values\n   *     that should be returned.\n   * @param {string=} opt_style The style of css name mapping. There are two valid\n   *     options: 'BY_PART', and 'BY_WHOLE'.\n   * @see goog.getCssName for a description.\n   */\n  goog.setCssNameMapping = function(mapping, opt_style) {\n    goog.cssNameMapping_ = mapping;\n    goog.cssNameMappingStyle_ = opt_style;\n  };\n  \n  \n  /**\n   * To use CSS renaming in compiled mode, one of the input files should have a\n   * call to goog.setCssNameMapping() with an object literal that the JSCompiler\n   * can extract and use to replace all calls to goog.getCssName(). In uncompiled\n   * mode, JavaScript code should be loaded before this base.js file that declares\n   * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is\n   * to ensure that the mapping is loaded before any calls to goog.getCssName()\n   * are made in uncompiled mode.\n   *\n   * A hook for overriding the CSS name mapping.\n   * @type {!Object<string, string>|undefined}\n   */\n  goog.global.CLOSURE_CSS_NAME_MAPPING;\n  \n  \n  if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {\n    // This does not call goog.setCssNameMapping() because the JSCompiler\n    // requires that goog.setCssNameMapping() be called with an object literal.\n    goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;\n  }\n  \n  \n  /**\n   * Gets a localized message.\n   *\n   * This function is a compiler primitive. If you give the compiler a localized\n   * message bundle, it will replace the string at compile-time with a localized\n   * version, and expand goog.getMsg call to a concatenated string.\n   *\n   * Messages must be initialized in the form:\n   * <code>\n   * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});\n   * </code>\n   *\n   * This function produces a string which should be treated as plain text. Use\n   * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to\n   * produce SafeHtml.\n   *\n   * @param {string} str Translatable string, places holders in the form {$foo}.\n   * @param {Object<string, string>=} opt_values Maps place holder name to value.\n   * @return {string} message with placeholders filled.\n   */\n  goog.getMsg = function(str, opt_values) {\n    if (opt_values) {\n      str = str.replace(/\\{\\$([^}]+)}/g, function(match, key) {\n        return (opt_values != null && key in opt_values) ? opt_values[key] :\n                                                           match;\n      });\n    }\n    return str;\n  };\n  \n  \n  /**\n   * Gets a localized message. If the message does not have a translation, gives a\n   * fallback message.\n   *\n   * This is useful when introducing a new message that has not yet been\n   * translated into all languages.\n   *\n   * This function is a compiler primitive. Must be used in the form:\n   * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>\n   * where MSG_A and MSG_B were initialized with goog.getMsg.\n   *\n   * @param {string} a The preferred message.\n   * @param {string} b The fallback message.\n   * @return {string} The best translated message.\n   */\n  goog.getMsgWithFallback = function(a, b) {\n    return a;\n  };\n  \n  \n  /**\n   * Exposes an unobfuscated global namespace path for the given object.\n   * Note that fields of the exported object *will* be obfuscated, unless they are\n   * exported in turn via this function or goog.exportProperty.\n   *\n   * Also handy for making public items that are defined in anonymous closures.\n   *\n   * ex. goog.exportSymbol('public.path.Foo', Foo);\n   *\n   * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);\n   *     public.path.Foo.staticFunction();\n   *\n   * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\n   *                       Foo.prototype.myMethod);\n   *     new public.path.Foo().myMethod();\n   *\n   * @param {string} publicPath Unobfuscated name to export.\n   * @param {*} object Object the name should point to.\n   * @param {Object=} opt_objectToExportTo The object to add the path to; default\n   *     is goog.global.\n   */\n  goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {\n    goog.exportPath_(publicPath, object, opt_objectToExportTo);\n  };\n  \n  \n  /**\n   * Exports a property unobfuscated into the object's namespace.\n   * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\n   * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\n   * @param {Object} object Object whose static property is being exported.\n   * @param {string} publicName Unobfuscated name to export.\n   * @param {*} symbol Object the name should point to.\n   */\n  goog.exportProperty = function(object, publicName, symbol) {\n    object[publicName] = symbol;\n  };\n  \n  \n  /**\n   * Inherit the prototype methods from one constructor into another.\n   *\n   * Usage:\n   * <pre>\n   * function ParentClass(a, b) { }\n   * ParentClass.prototype.foo = function(a) { };\n   *\n   * function ChildClass(a, b, c) {\n   *   ChildClass.base(this, 'constructor', a, b);\n   * }\n   * goog.inherits(ChildClass, ParentClass);\n   *\n   * var child = new ChildClass('a', 'b', 'see');\n   * child.foo(); // This works.\n   * </pre>\n   *\n   * @param {!Function} childCtor Child class.\n   * @param {!Function} parentCtor Parent class.\n   */\n  goog.inherits = function(childCtor, parentCtor) {\n    /** @constructor */\n    function tempCtor() {}\n    tempCtor.prototype = parentCtor.prototype;\n    childCtor.superClass_ = parentCtor.prototype;\n    childCtor.prototype = new tempCtor();\n    /** @override */\n    childCtor.prototype.constructor = childCtor;\n  \n    /**\n     * Calls superclass constructor/method.\n     *\n     * This function is only available if you use goog.inherits to\n     * express inheritance relationships between classes.\n     *\n     * NOTE: This is a replacement for goog.base and for superClass_\n     * property defined in childCtor.\n     *\n     * @param {!Object} me Should always be \"this\".\n     * @param {string} methodName The method name to call. Calling\n     *     superclass constructor can be done with the special string\n     *     'constructor'.\n     * @param {...*} var_args The arguments to pass to superclass\n     *     method/constructor.\n     * @return {*} The return value of the superclass method/constructor.\n     */\n    childCtor.base = function(me, methodName, var_args) {\n      // Copying using loop to avoid deop due to passing arguments object to\n      // function. This is faster in many JS engines as of late 2014.\n      var args = new Array(arguments.length - 2);\n      for (var i = 2; i < arguments.length; i++) {\n        args[i - 2] = arguments[i];\n      }\n      return parentCtor.prototype[methodName].apply(me, args);\n    };\n  };\n  \n  \n  /**\n   * Call up to the superclass.\n   *\n   * If this is called from a constructor, then this calls the superclass\n   * constructor with arguments 1-N.\n   *\n   * If this is called from a prototype method, then you must pass the name of the\n   * method as the second argument to this function. If you do not, you will get a\n   * runtime error. This calls the superclass' method with arguments 2-N.\n   *\n   * This function only works if you use goog.inherits to express inheritance\n   * relationships between your classes.\n   *\n   * This function is a compiler primitive. At compile-time, the compiler will do\n   * macro expansion to remove a lot of the extra overhead that this function\n   * introduces. The compiler will also enforce a lot of the assumptions that this\n   * function makes, and treat it as a compiler error if you break them.\n   *\n   * @param {!Object} me Should always be \"this\".\n   * @param {*=} opt_methodName The method name if calling a super method.\n   * @param {...*} var_args The rest of the arguments.\n   * @return {*} The return value of the superclass method.\n   * @suppress {es5Strict} This method can not be used in strict mode, but\n   *     all Closure Library consumers must depend on this file.\n   * @deprecated goog.base is not strict mode compatible.  Prefer the static\n   *     \"base\" method added to the constructor by goog.inherits\n   *     or ES6 classes and the \"super\" keyword.\n   */\n  goog.base = function(me, opt_methodName, var_args) {\n    var caller = arguments.callee.caller;\n  \n    if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {\n      throw new Error(\n          'arguments.caller not defined.  goog.base() cannot be used ' +\n          'with strict mode code. See ' +\n          'http://www.ecma-international.org/ecma-262/5.1/#sec-C');\n    }\n  \n    if (caller.superClass_) {\n      // Copying using loop to avoid deop due to passing arguments object to\n      // function. This is faster in many JS engines as of late 2014.\n      var ctorArgs = new Array(arguments.length - 1);\n      for (var i = 1; i < arguments.length; i++) {\n        ctorArgs[i - 1] = arguments[i];\n      }\n      // This is a constructor. Call the superclass constructor.\n      return caller.superClass_.constructor.apply(me, ctorArgs);\n    }\n  \n    // Copying using loop to avoid deop due to passing arguments object to\n    // function. This is faster in many JS engines as of late 2014.\n    var args = new Array(arguments.length - 2);\n    for (var i = 2; i < arguments.length; i++) {\n      args[i - 2] = arguments[i];\n    }\n    var foundCaller = false;\n    for (var ctor = me.constructor; ctor;\n         ctor = ctor.superClass_ && ctor.superClass_.constructor) {\n      if (ctor.prototype[opt_methodName] === caller) {\n        foundCaller = true;\n      } else if (foundCaller) {\n        return ctor.prototype[opt_methodName].apply(me, args);\n      }\n    }\n  \n    // If we did not find the caller in the prototype chain, then one of two\n    // things happened:\n    // 1) The caller is an instance method.\n    // 2) This method was not called by the right caller.\n    if (me[opt_methodName] === caller) {\n      return me.constructor.prototype[opt_methodName].apply(me, args);\n    } else {\n      throw new Error(\n          'goog.base called from a method of one name ' +\n          'to a method of a different name');\n    }\n  };\n  \n  \n  /**\n   * Allow for aliasing within scope functions.  This function exists for\n   * uncompiled code - in compiled code the calls will be inlined and the aliases\n   * applied.  In uncompiled code the function is simply run since the aliases as\n   * written are valid JavaScript.\n   *\n   *\n   * @param {function()} fn Function to call.  This function can contain aliases\n   *     to namespaces (e.g. \"var dom = goog.dom\") or classes\n   *     (e.g. \"var Timer = goog.Timer\").\n   */\n  goog.scope = function(fn) {\n    if (goog.isInModuleLoader_()) {\n      throw new Error('goog.scope is not supported within a goog.module.');\n    }\n    fn.call(goog.global);\n  };\n  \n  \n  /*\n   * To support uncompiled, strict mode bundles that use eval to divide source\n   * like so:\n   *    eval('someSource;//# sourceUrl sourcefile.js');\n   * We need to export the globally defined symbols \"goog\" and \"COMPILED\".\n   * Exporting \"goog\" breaks the compiler optimizations, so we required that\n   * be defined externally.\n   * NOTE: We don't use goog.exportSymbol here because we don't want to trigger\n   * extern generation when that compiler option is enabled.\n   */\n  if (!COMPILED) {\n    goog.global['COMPILED'] = COMPILED;\n  }\n  \n  \n  //==============================================================================\n  // goog.defineClass implementation\n  //==============================================================================\n  \n  \n  /**\n   * Creates a restricted form of a Closure \"class\":\n   *   - from the compiler's perspective, the instance returned from the\n   *     constructor is sealed (no new properties may be added).  This enables\n   *     better checks.\n   *   - the compiler will rewrite this definition to a form that is optimal\n   *     for type checking and optimization (initially this will be a more\n   *     traditional form).\n   *\n   * @param {Function} superClass The superclass, Object or null.\n   * @param {goog.defineClass.ClassDescriptor} def\n   *     An object literal describing\n   *     the class.  It may have the following properties:\n   *     \"constructor\": the constructor function\n   *     \"statics\": an object literal containing methods to add to the constructor\n   *        as \"static\" methods or a function that will receive the constructor\n   *        function as its only parameter to which static properties can\n   *        be added.\n   *     all other properties are added to the prototype.\n   * @return {!Function} The class constructor.\n   */\n  goog.defineClass = function(superClass, def) {\n    // TODO(johnlenz): consider making the superClass an optional parameter.\n    var constructor = def.constructor;\n    var statics = def.statics;\n    // Wrap the constructor prior to setting up the prototype and static methods.\n    if (!constructor || constructor == Object.prototype.constructor) {\n      constructor = function() {\n        throw new Error(\n            'cannot instantiate an interface (no constructor defined).');\n      };\n    }\n  \n    var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);\n    if (superClass) {\n      goog.inherits(cls, superClass);\n    }\n  \n    // Remove all the properties that should not be copied to the prototype.\n    delete def.constructor;\n    delete def.statics;\n  \n    goog.defineClass.applyProperties_(cls.prototype, def);\n    if (statics != null) {\n      if (statics instanceof Function) {\n        statics(cls);\n      } else {\n        goog.defineClass.applyProperties_(cls, statics);\n      }\n    }\n  \n    return cls;\n  };\n  \n  \n  /**\n   * @typedef {{\n   *   constructor: (!Function|undefined),\n   *   statics: (Object|undefined|function(Function):void)\n   * }}\n   */\n  goog.defineClass.ClassDescriptor;\n  \n  \n  /**\n   * @define {boolean} Whether the instances returned by goog.defineClass should\n   *     be sealed when possible.\n   *\n   * When sealing is disabled the constructor function will not be wrapped by\n   * goog.defineClass, making it incompatible with ES6 class methods.\n   */\n  goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);\n  \n  \n  /**\n   * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is\n   * defined, this function will wrap the constructor in a function that seals the\n   * results of the provided constructor function.\n   *\n   * @param {!Function} ctr The constructor whose results maybe be sealed.\n   * @param {Function} superClass The superclass constructor.\n   * @return {!Function} The replacement constructor.\n   * @private\n   */\n  goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {\n    if (!goog.defineClass.SEAL_CLASS_INSTANCES) {\n      // Do now wrap the constructor when sealing is disabled. Angular code\n      // depends on this for injection to work properly.\n      return ctr;\n    }\n  \n    // Compute whether the constructor is sealable at definition time, rather\n    // than when the instance is being constructed.\n    var superclassSealable = !goog.defineClass.isUnsealable_(superClass);\n  \n    /**\n     * @this {Object}\n     * @return {?}\n     */\n    var wrappedCtr = function() {\n      // Don't seal an instance of a subclass when it calls the constructor of\n      // its super class as there is most likely still setup to do.\n      var instance = ctr.apply(this, arguments) || this;\n      instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];\n  \n      if (this.constructor === wrappedCtr && superclassSealable &&\n          Object.seal instanceof Function) {\n        Object.seal(instance);\n      }\n      return instance;\n    };\n  \n    return wrappedCtr;\n  };\n  \n  \n  /**\n   * @param {Function} ctr The constructor to test.\n   * @return {boolean} Whether the constructor has been tagged as unsealable\n   *     using goog.tagUnsealableClass.\n   * @private\n   */\n  goog.defineClass.isUnsealable_ = function(ctr) {\n    return ctr && ctr.prototype &&\n        ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];\n  };\n  \n  \n  // TODO(johnlenz): share these values with the goog.object\n  /**\n   * The names of the fields that are defined on Object.prototype.\n   * @type {!Array<string>}\n   * @private\n   * @const\n   */\n  goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [\n    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n    'toLocaleString', 'toString', 'valueOf'\n  ];\n  \n  \n  // TODO(johnlenz): share this function with the goog.object\n  /**\n   * @param {!Object} target The object to add properties to.\n   * @param {!Object} source The object to copy properties from.\n   * @private\n   */\n  goog.defineClass.applyProperties_ = function(target, source) {\n    // TODO(johnlenz): update this to support ES5 getters/setters\n  \n    var key;\n    for (key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  \n    // For IE the for-in-loop does not contain any properties that are not\n    // enumerable on the prototype object (for example isPrototypeOf from\n    // Object.prototype) and it will also not include 'replace' on objects that\n    // extend String and change 'replace' (not that it is common for anyone to\n    // extend anything except Object).\n    for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {\n      key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  };\n  \n  \n  /**\n   * Sealing classes breaks the older idiom of assigning properties on the\n   * prototype rather than in the constructor. As such, goog.defineClass\n   * must not seal subclasses of these old-style classes until they are fixed.\n   * Until then, this marks a class as \"broken\", instructing defineClass\n   * not to seal subclasses.\n   * @param {!Function} ctr The legacy constructor to tag as unsealable.\n   */\n  goog.tagUnsealableClass = function(ctr) {\n    if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {\n      ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;\n    }\n  };\n  \n  \n  /**\n   * Name for unsealable tag property.\n   * @const @private {string}\n   */\n  goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';\n  \n  \n  /**\n   * Returns a newly created map from language mode string to a boolean\n   * indicating whether transpilation should be done for that mode.\n   *\n   * Guaranteed invariant:\n   * For any two modes, l1 and l2 where l2 is a newer mode than l1,\n   * `map[l1] == true` implies that `map[l2] == true`.\n   * @private\n   * @return {!Object<string, boolean>}\n   */\n  goog.createRequiresTranspilation_ = function() {\n    var /** !Object<string, boolean> */ requiresTranspilation = {'es3': false};\n    var transpilationRequiredForAllLaterModes = false;\n  \n    /**\n     * Adds an entry to requiresTranspliation for the given language mode.\n     *\n     * IMPORTANT: Calls must be made in order from oldest to newest language\n     * mode.\n     * @param {string} modeName\n     * @param {function(): boolean} isSupported Returns true if the JS engine\n     *     supports the given mode.\n     */\n    function addNewerLanguageTranspilationCheck(modeName, isSupported) {\n      if (transpilationRequiredForAllLaterModes) {\n        requiresTranspilation[modeName] = true;\n      } else if (isSupported()) {\n        requiresTranspilation[modeName] = false;\n      } else {\n        requiresTranspilation[modeName] = true;\n        transpilationRequiredForAllLaterModes = true;\n      }\n    }\n  \n    /**\n     * Does the given code evaluate without syntax errors and return a truthy\n     * result?\n     */\n    function /** boolean */ evalCheck(/** string */ code) {\n      try {\n        return !!eval(code);\n      } catch (ignored) {\n        return false;\n      }\n    }\n  \n    var userAgent = goog.global.navigator && goog.global.navigator.userAgent ?\n        goog.global.navigator.userAgent :\n        '';\n  \n    // Identify ES3-only browsers by their incorrect treatment of commas.\n    addNewerLanguageTranspilationCheck('es5', function() {\n      return evalCheck('[1,].length==1');\n    });\n    addNewerLanguageTranspilationCheck('es6', function() {\n      // Edge has a non-deterministic (i.e., not reproducible) bug with ES6:\n      // https://github.com/Microsoft/ChakraCore/issues/1496.\n      var re = /Edge\\/(\\d+)(\\.\\d)*/i;\n      var edgeUserAgent = userAgent.match(re);\n      if (edgeUserAgent && Number(edgeUserAgent[1]) < 15) {\n        return false;\n      }\n      // Test es6: [FF50 (?), Edge 14 (?), Chrome 50]\n      //   (a) default params (specifically shadowing locals),\n      //   (b) destructuring, (c) block-scoped functions,\n      //   (d) for-of (const), (e) new.target/Reflect.construct\n      var es6fullTest =\n          'class X{constructor(){if(new.target!=String)throw 1;this.x=42}}' +\n          'let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof ' +\n          'String))throw 1;for(const a of[2,3]){if(a==2)continue;function ' +\n          'f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()' +\n          '==3}';\n  \n      return evalCheck('(()=>{\"use strict\";' + es6fullTest + '})()');\n    });\n    // TODO(joeltine): Remove es6-impl references for b/31340605.\n    // Consider es6-impl (widely-implemented es6 features) to be supported\n    // whenever es6 is supported. Technically es6-impl is a lower level of\n    // support than es6, but we don't have tests specifically for it.\n    addNewerLanguageTranspilationCheck('es6-impl', function() {\n      return true;\n    });\n    // ** and **= are the only new features in 'es7'\n    addNewerLanguageTranspilationCheck('es7', function() {\n      return evalCheck('2 ** 2 == 4');\n    });\n    // async functions are the only new features in 'es8'\n    addNewerLanguageTranspilationCheck('es8', function() {\n      return evalCheck('async () => 1, true');\n    });\n    return requiresTranspilation;\n  };\n  \n  goog.provide('ol.array');\n  \n  \n  /**\n   * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n   * https://github.com/darkskyapp/binary-search\n   *\n   * @param {Array.<*>} haystack Items to search through.\n   * @param {*} needle The item to look for.\n   * @param {Function=} opt_comparator Comparator function.\n   * @return {number} The index of the item if found, -1 if not.\n   */\n  ol.array.binarySearch = function(haystack, needle, opt_comparator) {\n    var mid, cmp;\n    var comparator = opt_comparator || ol.array.numberSafeCompareFunction;\n    var low = 0;\n    var high = haystack.length;\n    var found = false;\n  \n    while (low < high) {\n      /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n       * to double (which gives the wrong results). */\n      mid = low + (high - low >> 1);\n      cmp = +comparator(haystack[mid], needle);\n  \n      if (cmp < 0.0) { /* Too low. */\n        low  = mid + 1;\n  \n      } else { /* Key found or too high */\n        high = mid;\n        found = !cmp;\n      }\n    }\n  \n    /* Key not found. */\n    return found ? low : ~low;\n  };\n  \n  \n  /**\n   * Compare function for array sort that is safe for numbers.\n   * @param {*} a The first object to be compared.\n   * @param {*} b The second object to be compared.\n   * @return {number} A negative number, zero, or a positive number as the first\n   *     argument is less than, equal to, or greater than the second.\n   */\n  ol.array.numberSafeCompareFunction = function(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  };\n  \n  \n  /**\n   * Whether the array contains the given object.\n   * @param {Array.<*>} arr The array to test for the presence of the element.\n   * @param {*} obj The object for which to test.\n   * @return {boolean} The object is in the array.\n   */\n  ol.array.includes = function(arr, obj) {\n    return arr.indexOf(obj) >= 0;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} arr Array.\n   * @param {number} target Target.\n   * @param {number} direction 0 means return the nearest, > 0\n   *    means return the largest nearest, < 0 means return the\n   *    smallest nearest.\n   * @return {number} Index.\n   */\n  ol.array.linearFindNearest = function(arr, target, direction) {\n    var n = arr.length;\n    if (arr[0] <= target) {\n      return 0;\n    } else if (target <= arr[n - 1]) {\n      return n - 1;\n    } else {\n      var i;\n      if (direction > 0) {\n        for (i = 1; i < n; ++i) {\n          if (arr[i] < target) {\n            return i - 1;\n          }\n        }\n      } else if (direction < 0) {\n        for (i = 1; i < n; ++i) {\n          if (arr[i] <= target) {\n            return i;\n          }\n        }\n      } else {\n        for (i = 1; i < n; ++i) {\n          if (arr[i] == target) {\n            return i;\n          } else if (arr[i] < target) {\n            if (arr[i - 1] - target < target - arr[i]) {\n              return i - 1;\n            } else {\n              return i;\n            }\n          }\n        }\n      }\n      return n - 1;\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<*>} arr Array.\n   * @param {number} begin Begin index.\n   * @param {number} end End index.\n   */\n  ol.array.reverseSubArray = function(arr, begin, end) {\n    while (begin < end) {\n      var tmp = arr[begin];\n      arr[begin] = arr[end];\n      arr[end] = tmp;\n      ++begin;\n      --end;\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<VALUE>} arr The array to modify.\n   * @param {Array.<VALUE>|VALUE} data The elements or arrays of elements\n   *     to add to arr.\n   * @template VALUE\n   */\n  ol.array.extend = function(arr, data) {\n    var i;\n    var extension = Array.isArray(data) ? data : [data];\n    var length = extension.length;\n    for (i = 0; i < length; i++) {\n      arr[arr.length] = extension[i];\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<VALUE>} arr The array to modify.\n   * @param {VALUE} obj The element to remove.\n   * @template VALUE\n   * @return {boolean} If the element was removed.\n   */\n  ol.array.remove = function(arr, obj) {\n    var i = arr.indexOf(obj);\n    var found = i > -1;\n    if (found) {\n      arr.splice(i, 1);\n    }\n    return found;\n  };\n  \n  \n  /**\n   * @param {Array.<VALUE>} arr The array to search in.\n   * @param {function(VALUE, number, ?) : boolean} func The function to compare.\n   * @template VALUE\n   * @return {VALUE} The element found.\n   */\n  ol.array.find = function(arr, func) {\n    var length = arr.length >>> 0;\n    var value;\n  \n    for (var i = 0; i < length; i++) {\n      value = arr[i];\n      if (func(value, i, arr)) {\n        return value;\n      }\n    }\n    return null;\n  };\n  \n  \n  /**\n   * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\n   * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\n   * @return {boolean} Whether the two arrays are equal.\n   */\n  ol.array.equals = function(arr1, arr2) {\n    var len1 = arr1.length;\n    if (len1 !== arr2.length) {\n      return false;\n    }\n    for (var i = 0; i < len1; i++) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  \n  \n  /**\n   * @param {Array.<*>} arr The array to sort (modifies original).\n   * @param {Function} compareFnc Comparison function.\n   */\n  ol.array.stableSort = function(arr, compareFnc) {\n    var length = arr.length;\n    var tmp = Array(arr.length);\n    var i;\n    for (i = 0; i < length; i++) {\n      tmp[i] = {index: i, value: arr[i]};\n    }\n    tmp.sort(function(a, b) {\n      return compareFnc(a.value, b.value) || a.index - b.index;\n    });\n    for (i = 0; i < arr.length; i++) {\n      arr[i] = tmp[i].value;\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<*>} arr The array to search in.\n   * @param {Function} func Comparison function.\n   * @return {number} Return index.\n   */\n  ol.array.findIndex = function(arr, func) {\n    var index;\n    var found = !arr.every(function(el, idx) {\n      index = idx;\n      return !func(el, idx, arr);\n    });\n    return found ? index : -1;\n  };\n  \n  \n  /**\n   * @param {Array.<*>} arr The array to test.\n   * @param {Function=} opt_func Comparison function.\n   * @param {boolean=} opt_strict Strictly sorted (default false).\n   * @return {boolean} Return index.\n   */\n  ol.array.isSorted = function(arr, opt_func, opt_strict) {\n    var compare = opt_func || ol.array.numberSafeCompareFunction;\n    return arr.every(function(currentVal, index) {\n      if (index === 0) {\n        return true;\n      }\n      var res = compare(arr[index - 1], currentVal);\n      return !(res > 0 || opt_strict && res === 0);\n    });\n  };\n  \n  goog.provide('ol');\n  \n  \n  /**\n   * Constants defined with the define tag cannot be changed in application\n   * code, but can be set at compile time.\n   * Some reduce the size of the build in advanced compile mode.\n   */\n  \n  \n  /**\n   * @define {boolean} Assume touch.  Default is `false`.\n   */\n  ol.ASSUME_TOUCH = false;\n  \n  \n  /**\n   * TODO: rename this to something having to do with tile grids\n   * see https://github.com/openlayers/openlayers/issues/2076\n   * @define {number} Default maximum zoom for default tile grids.\n   */\n  ol.DEFAULT_MAX_ZOOM = 42;\n  \n  \n  /**\n   * @define {number} Default min zoom level for the map view.  Default is `0`.\n   */\n  ol.DEFAULT_MIN_ZOOM = 0;\n  \n  \n  /**\n   * @define {number} Default maximum allowed threshold  (in pixels) for\n   *     reprojection triangulation. Default is `0.5`.\n   */\n  ol.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD = 0.5;\n  \n  \n  /**\n   * @define {number} Default tile size.\n   */\n  ol.DEFAULT_TILE_SIZE = 256;\n  \n  \n  /**\n   * @define {string} Default WMS version.\n   */\n  ol.DEFAULT_WMS_VERSION = '1.3.0';\n  \n  \n  /**\n   * @define {boolean} Enable the Canvas renderer.  Default is `true`. Setting\n   *     this to false at compile time in advanced mode removes all code\n   *     supporting the Canvas renderer from the build.\n   */\n  ol.ENABLE_CANVAS = true;\n  \n  \n  /**\n   * @define {boolean} Enable integration with the Proj4js library.  Default is\n   *     `true`.\n   */\n  ol.ENABLE_PROJ4JS = true;\n  \n  \n  /**\n   * @define {boolean} Enable automatic reprojection of raster sources. Default is\n   *     `true`.\n   */\n  ol.ENABLE_RASTER_REPROJECTION = true;\n  \n  \n  /**\n   * @define {boolean} Enable the WebGL renderer.  Default is `true`. Setting\n   *     this to false at compile time in advanced mode removes all code\n   *     supporting the WebGL renderer from the build.\n   */\n  ol.ENABLE_WEBGL = true;\n  \n  \n  /**\n   * @define {boolean} Include debuggable shader sources.  Default is `true`.\n   *     This should be set to `false` for production builds (if `ol.ENABLE_WEBGL`\n   *     is `true`).\n   */\n  ol.DEBUG_WEBGL = true;\n  \n  \n  /**\n   * @define {number} The size in pixels of the first atlas image. Default is\n   * `256`.\n   */\n  ol.INITIAL_ATLAS_SIZE = 256;\n  \n  \n  /**\n   * @define {number} The maximum size in pixels of atlas images. Default is\n   * `-1`, meaning it is not used (and `ol.WEBGL_MAX_TEXTURE_SIZE` is\n   * used instead).\n   */\n  ol.MAX_ATLAS_SIZE = -1;\n  \n  \n  /**\n   * @define {number} Maximum mouse wheel delta.\n   */\n  ol.MOUSEWHEELZOOM_MAXDELTA = 1;\n  \n  \n  /**\n   * @define {number} Maximum width and/or height extent ratio that determines\n   * when the overview map should be zoomed out.\n   */\n  ol.OVERVIEWMAP_MAX_RATIO = 0.75;\n  \n  \n  /**\n   * @define {number} Minimum width and/or height extent ratio that determines\n   * when the overview map should be zoomed in.\n   */\n  ol.OVERVIEWMAP_MIN_RATIO = 0.1;\n  \n  \n  /**\n   * @define {number} Maximum number of source tiles for raster reprojection of\n   *     a single tile.\n   *     If too many source tiles are determined to be loaded to create a single\n   *     reprojected tile the browser can become unresponsive or even crash.\n   *     This can happen if the developer defines projections improperly and/or\n   *     with unlimited extents.\n   *     If too many tiles are required, no tiles are loaded and\n   *     `ol.TileState.ERROR` state is set. Default is `100`.\n   */\n  ol.RASTER_REPROJECTION_MAX_SOURCE_TILES = 100;\n  \n  \n  /**\n   * @define {number} Maximum number of subdivision steps during raster\n   *     reprojection triangulation. Prevents high memory usage and large\n   *     number of proj4 calls (for certain transformations and areas).\n   *     At most `2*(2^this)` triangles are created for each triangulated\n   *     extent (tile/image). Default is `10`.\n   */\n  ol.RASTER_REPROJECTION_MAX_SUBDIVISION = 10;\n  \n  \n  /**\n   * @define {number} Maximum allowed size of triangle relative to world width.\n   *     When transforming corners of world extent between certain projections,\n   *     the resulting triangulation seems to have zero error and no subdivision\n   *     is performed.\n   *     If the triangle width is more than this (relative to world width; 0-1),\n   *     subdivison is forced (up to `ol.RASTER_REPROJECTION_MAX_SUBDIVISION`).\n   *     Default is `0.25`.\n   */\n  ol.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH = 0.25;\n  \n  \n  /**\n   * @define {number} Tolerance for geometry simplification in device pixels.\n   */\n  ol.SIMPLIFY_TOLERANCE = 0.5;\n  \n  \n  /**\n   * @define {number} Texture cache high water mark.\n   */\n  ol.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;\n  \n  \n  /**\n   * @define {string} OpenLayers version.\n   */\n  ol.VERSION = '';\n  \n  \n  /**\n   * The maximum supported WebGL texture size in pixels. If WebGL is not\n   * supported, the value is set to `undefined`.\n   * @const\n   * @type {number|undefined}\n   */\n  ol.WEBGL_MAX_TEXTURE_SIZE; // value is set in `ol.has`\n  \n  \n  /**\n   * List of supported WebGL extensions.\n   * @const\n   * @type {Array.<string>}\n   */\n  ol.WEBGL_EXTENSIONS; // value is set in `ol.has`\n  \n  \n  /**\n   * Inherit the prototype methods from one constructor into another.\n   *\n   * Usage:\n   *\n   *     function ParentClass(a, b) { }\n   *     ParentClass.prototype.foo = function(a) { }\n   *\n   *     function ChildClass(a, b, c) {\n   *       // Call parent constructor\n   *       ParentClass.call(this, a, b);\n   *     }\n   *     ol.inherits(ChildClass, ParentClass);\n   *\n   *     var child = new ChildClass('a', 'b', 'see');\n   *     child.foo(); // This works.\n   *\n   * @param {!Function} childCtor Child constructor.\n   * @param {!Function} parentCtor Parent constructor.\n   * @function\n   * @api\n   */\n  ol.inherits = function(childCtor, parentCtor) {\n    childCtor.prototype = Object.create(parentCtor.prototype);\n    childCtor.prototype.constructor = childCtor;\n  };\n  \n  \n  /**\n   * A reusable function, used e.g. as a default for callbacks.\n   *\n   * @return {undefined} Nothing.\n   */\n  ol.nullFunction = function() {};\n  \n  \n  /**\n   * Gets a unique ID for an object. This mutates the object so that further calls\n   * with the same object as a parameter returns the same value. Unique IDs are generated\n   * as a strictly increasing sequence. Adapted from goog.getUid.\n   *\n   * @param {Object} obj The object to get the unique ID for.\n   * @return {number} The unique ID for the object.\n   */\n  ol.getUid = function(obj) {\n    return obj.ol_uid ||\n        (obj.ol_uid = ++ol.uidCounter_);\n  };\n  \n  \n  /**\n   * Counter for getUid.\n   * @type {number}\n   * @private\n   */\n  ol.uidCounter_ = 0;\n  \n  goog.provide('ol.AssertionError');\n  \n  goog.require('ol');\n  \n  /**\n   * Error object thrown when an assertion failed. This is an ECMA-262 Error,\n   * extended with a `code` property.\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}\n   * @constructor\n   * @extends {Error}\n   * @implements {oli.AssertionError}\n   * @param {number} code Error code.\n   */\n  ol.AssertionError = function(code) {\n  \n    var path = ol.VERSION ? ol.VERSION.split('-')[0] : 'latest';\n  \n    /**\n     * @type {string}\n     */\n    this.message = 'Assertion failed. See https://openlayers.org/en/' + path +\n        '/doc/errors/#' + code + ' for details.';\n  \n    /**\n     * Error code. The meaning of the code can be found on\n     * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with\n     * the version found in the OpenLayers script's header comment if a version\n     * other than the latest is used).\n     * @type {number}\n     * @api\n     */\n    this.code = code;\n  \n    this.name = 'AssertionError';\n  \n  };\n  ol.inherits(ol.AssertionError, Error);\n  \n  goog.provide('ol.asserts');\n  \n  goog.require('ol.AssertionError');\n  \n  \n  /**\n   * @param {*} assertion Assertion we expected to be truthy.\n   * @param {number} errorCode Error code.\n   */\n  ol.asserts.assert = function(assertion, errorCode) {\n    if (!assertion) {\n      throw new ol.AssertionError(errorCode);\n    }\n  };\n  \n  goog.provide('ol.TileRange');\n  \n  \n  /**\n   * A representation of a contiguous block of tiles.  A tile range is specified\n   * by its min/max tile coordinates and is inclusive of coordinates.\n   *\n   * @constructor\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   * @struct\n   */\n  ol.TileRange = function(minX, maxX, minY, maxY) {\n  \n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n  \n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n  \n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n  \n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  \n  };\n  \n  \n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   * @param {ol.TileRange|undefined} tileRange TileRange.\n   * @return {ol.TileRange} Tile range.\n   */\n  ol.TileRange.createOrUpdate = function(minX, maxX, minY, maxY, tileRange) {\n    if (tileRange !== undefined) {\n      tileRange.minX = minX;\n      tileRange.maxX = maxX;\n      tileRange.minY = minY;\n      tileRange.maxY = maxY;\n      return tileRange;\n    } else {\n      return new ol.TileRange(minX, maxX, minY, maxY);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  ol.TileRange.prototype.contains = function(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  };\n  \n  \n  /**\n   * @param {ol.TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  ol.TileRange.prototype.containsTileRange = function(tileRange) {\n    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX &&\n        this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;\n  };\n  \n  \n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  ol.TileRange.prototype.containsXY = function(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  };\n  \n  \n  /**\n   * @param {ol.TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  ol.TileRange.prototype.equals = function(tileRange) {\n    return this.minX == tileRange.minX && this.minY == tileRange.minY &&\n        this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;\n  };\n  \n  \n  /**\n   * @param {ol.TileRange} tileRange Tile range.\n   */\n  ol.TileRange.prototype.extend = function(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  };\n  \n  \n  /**\n   * @return {number} Height.\n   */\n  ol.TileRange.prototype.getHeight = function() {\n    return this.maxY - this.minY + 1;\n  };\n  \n  \n  /**\n   * @return {ol.Size} Size.\n   */\n  ol.TileRange.prototype.getSize = function() {\n    return [this.getWidth(), this.getHeight()];\n  };\n  \n  \n  /**\n   * @return {number} Width.\n   */\n  ol.TileRange.prototype.getWidth = function() {\n    return this.maxX - this.minX + 1;\n  };\n  \n  \n  /**\n   * @param {ol.TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  ol.TileRange.prototype.intersects = function(tileRange) {\n    return this.minX <= tileRange.maxX &&\n        this.maxX >= tileRange.minX &&\n        this.minY <= tileRange.maxY &&\n        this.maxY >= tileRange.minY;\n  };\n  \n  goog.provide('ol.math');\n  \n  goog.require('ol.asserts');\n  \n  \n  /**\n   * Takes a number and clamps it to within the provided bounds.\n   * @param {number} value The input number.\n   * @param {number} min The minimum value to return.\n   * @param {number} max The maximum value to return.\n   * @return {number} The input number if it is within bounds, or the nearest\n   *     number within the bounds.\n   */\n  ol.math.clamp = function(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n  };\n  \n  \n  /**\n   * Return the hyperbolic cosine of a given number. The method will use the\n   * native `Math.cosh` function if it is available, otherwise the hyperbolic\n   * cosine will be calculated via the reference implementation of the Mozilla\n   * developer network.\n   *\n   * @param {number} x X.\n   * @return {number} Hyperbolic cosine of x.\n   */\n  ol.math.cosh = (function() {\n    // Wrapped in a iife, to save the overhead of checking for the native\n    // implementation on every invocation.\n    var cosh;\n    if ('cosh' in Math) {\n      // The environment supports the native Math.cosh function, use it…\n      cosh = Math.cosh;\n    } else {\n      // … else, use the reference implementation of MDN:\n      cosh = function(x) {\n        var y = Math.exp(x);\n        return (y + 1 / y) / 2;\n      };\n    }\n    return cosh;\n  }());\n  \n  \n  /**\n   * @param {number} x X.\n   * @return {number} The smallest power of two greater than or equal to x.\n   */\n  ol.math.roundUpToPowerOfTwo = function(x) {\n    ol.asserts.assert(0 < x, 29); // `x` must be greater than `0`\n    return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));\n  };\n  \n  \n  /**\n   * Returns the square of the closest distance between the point (x, y) and the\n   * line segment (x1, y1) to (x2, y2).\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} x1 X1.\n   * @param {number} y1 Y1.\n   * @param {number} x2 X2.\n   * @param {number} y2 Y2.\n   * @return {number} Squared distance.\n   */\n  ol.math.squaredSegmentDistance = function(x, y, x1, y1, x2, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    if (dx !== 0 || dy !== 0) {\n      var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n      if (t > 1) {\n        x1 = x2;\n        y1 = y2;\n      } else if (t > 0) {\n        x1 += dx * t;\n        y1 += dy * t;\n      }\n    }\n    return ol.math.squaredDistance(x, y, x1, y1);\n  };\n  \n  \n  /**\n   * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n   * @param {number} x1 X1.\n   * @param {number} y1 Y1.\n   * @param {number} x2 X2.\n   * @param {number} y2 Y2.\n   * @return {number} Squared distance.\n   */\n  ol.math.squaredDistance = function(x1, y1, x2, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    return dx * dx + dy * dy;\n  };\n  \n  \n  /**\n   * Solves system of linear equations using Gaussian elimination method.\n   *\n   * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)\n   *                                     in row-major order.\n   * @return {Array.<number>} The resulting vector.\n   */\n  ol.math.solveLinearSystem = function(mat) {\n    var n = mat.length;\n  \n    for (var i = 0; i < n; i++) {\n      // Find max in the i-th column (ignoring i - 1 first rows)\n      var maxRow = i;\n      var maxEl = Math.abs(mat[i][i]);\n      for (var r = i + 1; r < n; r++) {\n        var absValue = Math.abs(mat[r][i]);\n        if (absValue > maxEl) {\n          maxEl = absValue;\n          maxRow = r;\n        }\n      }\n  \n      if (maxEl === 0) {\n        return null; // matrix is singular\n      }\n  \n      // Swap max row with i-th (current) row\n      var tmp = mat[maxRow];\n      mat[maxRow] = mat[i];\n      mat[i] = tmp;\n  \n      // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n      for (var j = i + 1; j < n; j++) {\n        var coef = -mat[j][i] / mat[i][i];\n        for (var k = i; k < n + 1; k++) {\n          if (i == k) {\n            mat[j][k] = 0;\n          } else {\n            mat[j][k] += coef * mat[i][k];\n          }\n        }\n      }\n    }\n  \n    // Solve Ax=b for upper triangular matrix A (mat)\n    var x = new Array(n);\n    for (var l = n - 1; l >= 0; l--) {\n      x[l] = mat[l][n] / mat[l][l];\n      for (var m = l - 1; m >= 0; m--) {\n        mat[m][n] -= mat[m][l] * x[l];\n      }\n    }\n    return x;\n  };\n  \n  \n  /**\n   * Converts radians to to degrees.\n   *\n   * @param {number} angleInRadians Angle in radians.\n   * @return {number} Angle in degrees.\n   */\n  ol.math.toDegrees = function(angleInRadians) {\n    return angleInRadians * 180 / Math.PI;\n  };\n  \n  \n  /**\n   * Converts degrees to radians.\n   *\n   * @param {number} angleInDegrees Angle in degrees.\n   * @return {number} Angle in radians.\n   */\n  ol.math.toRadians = function(angleInDegrees) {\n    return angleInDegrees * Math.PI / 180;\n  };\n  \n  /**\n   * Returns the modulo of a / b, depending on the sign of b.\n   *\n   * @param {number} a Dividend.\n   * @param {number} b Divisor.\n   * @return {number} Modulo.\n   */\n  ol.math.modulo = function(a, b) {\n    var r = a % b;\n    return r * b < 0 ? r + b : r;\n  };\n  \n  /**\n   * Calculates the linearly interpolated value of x between a and b.\n   *\n   * @param {number} a Number\n   * @param {number} b Number\n   * @param {number} x Value to be interpolated.\n   * @return {number} Interpolated value.\n   */\n  ol.math.lerp = function(a, b, x) {\n    return a + x * (b - a);\n  };\n  \n  goog.provide('ol.size');\n  \n  \n  /**\n   * Returns a buffered size.\n   * @param {ol.Size} size Size.\n   * @param {number} buffer Buffer.\n   * @param {ol.Size=} opt_size Optional reusable size array.\n   * @return {ol.Size} The buffered size.\n   */\n  ol.size.buffer = function(size, buffer, opt_size) {\n    if (opt_size === undefined) {\n      opt_size = [0, 0];\n    }\n    opt_size[0] = size[0] + 2 * buffer;\n    opt_size[1] = size[1] + 2 * buffer;\n    return opt_size;\n  };\n  \n  \n  /**\n   * Determines if a size has a positive area.\n   * @param {ol.Size} size The size to test.\n   * @return {boolean} The size has a positive area.\n   */\n  ol.size.hasArea = function(size) {\n    return size[0] > 0 && size[1] > 0;\n  };\n  \n  \n  /**\n   * Returns a size scaled by a ratio. The result will be an array of integers.\n   * @param {ol.Size} size Size.\n   * @param {number} ratio Ratio.\n   * @param {ol.Size=} opt_size Optional reusable size array.\n   * @return {ol.Size} The scaled size.\n   */\n  ol.size.scale = function(size, ratio, opt_size) {\n    if (opt_size === undefined) {\n      opt_size = [0, 0];\n    }\n    opt_size[0] = (size[0] * ratio + 0.5) | 0;\n    opt_size[1] = (size[1] * ratio + 0.5) | 0;\n    return opt_size;\n  };\n  \n  \n  /**\n   * Returns an `ol.Size` array for the passed in number (meaning: square) or\n   * `ol.Size` array.\n   * (meaning: non-square),\n   * @param {number|ol.Size} size Width and height.\n   * @param {ol.Size=} opt_size Optional reusable size array.\n   * @return {ol.Size} Size.\n   * @api\n   */\n  ol.size.toSize = function(size, opt_size) {\n    if (Array.isArray(size)) {\n      return size;\n    } else {\n      if (opt_size === undefined) {\n        opt_size = [size, size];\n      } else {\n        opt_size[0] = opt_size[1] = /** @type {number} */ (size);\n      }\n      return opt_size;\n    }\n  };\n  \n  goog.provide('ol.extent.Corner');\n  \n  /**\n   * Extent corner.\n   * @enum {string}\n   */\n  ol.extent.Corner = {\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_RIGHT: 'bottom-right',\n    TOP_LEFT: 'top-left',\n    TOP_RIGHT: 'top-right'\n  };\n  \n  goog.provide('ol.extent.Relationship');\n  \n  \n  /**\n   * Relationship to an extent.\n   * @enum {number}\n   */\n  ol.extent.Relationship = {\n    UNKNOWN: 0,\n    INTERSECTING: 1,\n    ABOVE: 2,\n    RIGHT: 4,\n    BELOW: 8,\n    LEFT: 16\n  };\n  \n  goog.provide('ol.extent');\n  \n  goog.require('ol.asserts');\n  goog.require('ol.extent.Corner');\n  goog.require('ol.extent.Relationship');\n  \n  \n  /**\n   * Build an extent that includes all given coordinates.\n   *\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @return {ol.Extent} Bounding extent.\n   * @api\n   */\n  ol.extent.boundingExtent = function(coordinates) {\n    var extent = ol.extent.createEmpty();\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n      ol.extent.extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} xs Xs.\n   * @param {Array.<number>} ys Ys.\n   * @param {ol.Extent=} opt_extent Destination extent.\n   * @private\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.boundingExtentXYs_ = function(xs, ys, opt_extent) {\n    var minX = Math.min.apply(null, xs);\n    var minY = Math.min.apply(null, ys);\n    var maxX = Math.max.apply(null, xs);\n    var maxY = Math.max.apply(null, ys);\n    return ol.extent.createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  };\n  \n  \n  /**\n   * Return extent increased by the provided value.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} value The amount by which the extent should be buffered.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} Extent.\n   * @api\n   */\n  ol.extent.buffer = function(extent, value, opt_extent) {\n    if (opt_extent) {\n      opt_extent[0] = extent[0] - value;\n      opt_extent[1] = extent[1] - value;\n      opt_extent[2] = extent[2] + value;\n      opt_extent[3] = extent[3] + value;\n      return opt_extent;\n    } else {\n      return [\n        extent[0] - value,\n        extent[1] - value,\n        extent[2] + value,\n        extent[3] + value\n      ];\n    }\n  };\n  \n  \n  /**\n   * Creates a clone of an extent.\n   *\n   * @param {ol.Extent} extent Extent to clone.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} The clone.\n   */\n  ol.extent.clone = function(extent, opt_extent) {\n    if (opt_extent) {\n      opt_extent[0] = extent[0];\n      opt_extent[1] = extent[1];\n      opt_extent[2] = extent[2];\n      opt_extent[3] = extent[3];\n      return opt_extent;\n    } else {\n      return extent.slice();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {number} Closest squared distance.\n   */\n  ol.extent.closestSquaredDistanceXY = function(extent, x, y) {\n    var dx, dy;\n    if (x < extent[0]) {\n      dx = extent[0] - x;\n    } else if (extent[2] < x) {\n      dx = x - extent[2];\n    } else {\n      dx = 0;\n    }\n    if (y < extent[1]) {\n      dy = extent[1] - y;\n    } else if (extent[3] < y) {\n      dy = y - extent[3];\n    } else {\n      dy = 0;\n    }\n    return dx * dx + dy * dy;\n  };\n  \n  \n  /**\n   * Check if the passed coordinate is contained or on the edge of the extent.\n   *\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @return {boolean} The coordinate is contained in the extent.\n   * @api\n   */\n  ol.extent.containsCoordinate = function(extent, coordinate) {\n    return ol.extent.containsXY(extent, coordinate[0], coordinate[1]);\n  };\n  \n  \n  /**\n   * Check if one extent contains another.\n   *\n   * An extent is deemed contained if it lies completely within the other extent,\n   * including if they share one or more edges.\n   *\n   * @param {ol.Extent} extent1 Extent 1.\n   * @param {ol.Extent} extent2 Extent 2.\n   * @return {boolean} The second extent is contained by or on the edge of the\n   *     first.\n   * @api\n   */\n  ol.extent.containsExtent = function(extent1, extent2) {\n    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&\n        extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\n  };\n  \n  \n  /**\n   * Check if the passed coordinate is contained or on the edge of the extent.\n   *\n   * @param {ol.Extent} extent Extent.\n   * @param {number} x X coordinate.\n   * @param {number} y Y coordinate.\n   * @return {boolean} The x, y values are contained in the extent.\n   * @api\n   */\n  ol.extent.containsXY = function(extent, x, y) {\n    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n  };\n  \n  \n  /**\n   * Get the relationship between a coordinate and extent.\n   * @param {ol.Extent} extent The extent.\n   * @param {ol.Coordinate} coordinate The coordinate.\n   * @return {number} The relationship (bitwise compare with\n   *     ol.extent.Relationship).\n   */\n  ol.extent.coordinateRelationship = function(extent, coordinate) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var x = coordinate[0];\n    var y = coordinate[1];\n    var relationship = ol.extent.Relationship.UNKNOWN;\n    if (x < minX) {\n      relationship = relationship | ol.extent.Relationship.LEFT;\n    } else if (x > maxX) {\n      relationship = relationship | ol.extent.Relationship.RIGHT;\n    }\n    if (y < minY) {\n      relationship = relationship | ol.extent.Relationship.BELOW;\n    } else if (y > maxY) {\n      relationship = relationship | ol.extent.Relationship.ABOVE;\n    }\n    if (relationship === ol.extent.Relationship.UNKNOWN) {\n      relationship = ol.extent.Relationship.INTERSECTING;\n    }\n    return relationship;\n  };\n  \n  \n  /**\n   * Create an empty extent.\n   * @return {ol.Extent} Empty extent.\n   * @api\n   */\n  ol.extent.createEmpty = function() {\n    return [Infinity, Infinity, -Infinity, -Infinity];\n  };\n  \n  \n  /**\n   * Create a new extent or update the provided extent.\n   * @param {number} minX Minimum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxX Maximum X.\n   * @param {number} maxY Maximum Y.\n   * @param {ol.Extent=} opt_extent Destination extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.createOrUpdate = function(minX, minY, maxX, maxY, opt_extent) {\n    if (opt_extent) {\n      opt_extent[0] = minX;\n      opt_extent[1] = minY;\n      opt_extent[2] = maxX;\n      opt_extent[3] = maxY;\n      return opt_extent;\n    } else {\n      return [minX, minY, maxX, maxY];\n    }\n  };\n  \n  \n  /**\n   * Create a new empty extent or make the provided one empty.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.createOrUpdateEmpty = function(opt_extent) {\n    return ol.extent.createOrUpdate(\n        Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.createOrUpdateFromCoordinate = function(coordinate, opt_extent) {\n    var x = coordinate[0];\n    var y = coordinate[1];\n    return ol.extent.createOrUpdate(x, y, x, y, opt_extent);\n  };\n  \n  \n  /**\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.createOrUpdateFromCoordinates = function(coordinates, opt_extent) {\n    var extent = ol.extent.createOrUpdateEmpty(opt_extent);\n    return ol.extent.extendCoordinates(extent, coordinates);\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.createOrUpdateFromFlatCoordinates = function(flatCoordinates, offset, end, stride, opt_extent) {\n    var extent = ol.extent.createOrUpdateEmpty(opt_extent);\n    return ol.extent.extendFlatCoordinates(\n        extent, flatCoordinates, offset, end, stride);\n  };\n  \n  \n  /**\n   * @param {Array.<Array.<ol.Coordinate>>} rings Rings.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.createOrUpdateFromRings = function(rings, opt_extent) {\n    var extent = ol.extent.createOrUpdateEmpty(opt_extent);\n    return ol.extent.extendRings(extent, rings);\n  };\n  \n  \n  /**\n   * Determine if two extents are equivalent.\n   * @param {ol.Extent} extent1 Extent 1.\n   * @param {ol.Extent} extent2 Extent 2.\n   * @return {boolean} The two extents are equivalent.\n   * @api\n   */\n  ol.extent.equals = function(extent1, extent2) {\n    return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&\n        extent1[1] == extent2[1] && extent1[3] == extent2[3];\n  };\n  \n  \n  /**\n   * Modify an extent to include another extent.\n   * @param {ol.Extent} extent1 The extent to be modified.\n   * @param {ol.Extent} extent2 The extent that will be included in the first.\n   * @return {ol.Extent} A reference to the first (extended) extent.\n   * @api\n   */\n  ol.extent.extend = function(extent1, extent2) {\n    if (extent2[0] < extent1[0]) {\n      extent1[0] = extent2[0];\n    }\n    if (extent2[2] > extent1[2]) {\n      extent1[2] = extent2[2];\n    }\n    if (extent2[1] < extent1[1]) {\n      extent1[1] = extent2[1];\n    }\n    if (extent2[3] > extent1[3]) {\n      extent1[3] = extent2[3];\n    }\n    return extent1;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   */\n  ol.extent.extendCoordinate = function(extent, coordinate) {\n    if (coordinate[0] < extent[0]) {\n      extent[0] = coordinate[0];\n    }\n    if (coordinate[0] > extent[2]) {\n      extent[2] = coordinate[0];\n    }\n    if (coordinate[1] < extent[1]) {\n      extent[1] = coordinate[1];\n    }\n    if (coordinate[1] > extent[3]) {\n      extent[3] = coordinate[1];\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.extendCoordinates = function(extent, coordinates) {\n    var i, ii;\n    for (i = 0, ii = coordinates.length; i < ii; ++i) {\n      ol.extent.extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.extendFlatCoordinates = function(extent, flatCoordinates, offset, end, stride) {\n    for (; offset < end; offset += stride) {\n      ol.extent.extendXY(\n          extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    }\n    return extent;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {Array.<Array.<ol.Coordinate>>} rings Rings.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.extendRings = function(extent, rings) {\n    var i, ii;\n    for (i = 0, ii = rings.length; i < ii; ++i) {\n      ol.extent.extendCoordinates(extent, rings[i]);\n    }\n    return extent;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {number} x X.\n   * @param {number} y Y.\n   */\n  ol.extent.extendXY = function(extent, x, y) {\n    extent[0] = Math.min(extent[0], x);\n    extent[1] = Math.min(extent[1], y);\n    extent[2] = Math.max(extent[2], x);\n    extent[3] = Math.max(extent[3], y);\n  };\n  \n  \n  /**\n   * This function calls `callback` for each corner of the extent. If the\n   * callback returns a truthy value the function returns that value\n   * immediately. Otherwise the function returns `false`.\n   * @param {ol.Extent} extent Extent.\n   * @param {function(this:T, ol.Coordinate): S} callback Callback.\n   * @param {T=} opt_this Value to use as `this` when executing `callback`.\n   * @return {S|boolean} Value.\n   * @template S, T\n   */\n  ol.extent.forEachCorner = function(extent, callback, opt_this) {\n    var val;\n    val = callback.call(opt_this, ol.extent.getBottomLeft(extent));\n    if (val) {\n      return val;\n    }\n    val = callback.call(opt_this, ol.extent.getBottomRight(extent));\n    if (val) {\n      return val;\n    }\n    val = callback.call(opt_this, ol.extent.getTopRight(extent));\n    if (val) {\n      return val;\n    }\n    val = callback.call(opt_this, ol.extent.getTopLeft(extent));\n    if (val) {\n      return val;\n    }\n    return false;\n  };\n  \n  \n  /**\n   * Get the size of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {number} Area.\n   * @api\n   */\n  ol.extent.getArea = function(extent) {\n    var area = 0;\n    if (!ol.extent.isEmpty(extent)) {\n      area = ol.extent.getWidth(extent) * ol.extent.getHeight(extent);\n    }\n    return area;\n  };\n  \n  \n  /**\n   * Get the bottom left coordinate of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {ol.Coordinate} Bottom left coordinate.\n   * @api\n   */\n  ol.extent.getBottomLeft = function(extent) {\n    return [extent[0], extent[1]];\n  };\n  \n  \n  /**\n   * Get the bottom right coordinate of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {ol.Coordinate} Bottom right coordinate.\n   * @api\n   */\n  ol.extent.getBottomRight = function(extent) {\n    return [extent[2], extent[1]];\n  };\n  \n  \n  /**\n   * Get the center coordinate of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {ol.Coordinate} Center.\n   * @api\n   */\n  ol.extent.getCenter = function(extent) {\n    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n  };\n  \n  \n  /**\n   * Get a corner coordinate of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.extent.Corner} corner Corner.\n   * @return {ol.Coordinate} Corner coordinate.\n   */\n  ol.extent.getCorner = function(extent, corner) {\n    var coordinate;\n    if (corner === ol.extent.Corner.BOTTOM_LEFT) {\n      coordinate = ol.extent.getBottomLeft(extent);\n    } else if (corner === ol.extent.Corner.BOTTOM_RIGHT) {\n      coordinate = ol.extent.getBottomRight(extent);\n    } else if (corner === ol.extent.Corner.TOP_LEFT) {\n      coordinate = ol.extent.getTopLeft(extent);\n    } else if (corner === ol.extent.Corner.TOP_RIGHT) {\n      coordinate = ol.extent.getTopRight(extent);\n    } else {\n      ol.asserts.assert(false, 13); // Invalid corner\n    }\n    return /** @type {!ol.Coordinate} */ (coordinate);\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent1 Extent 1.\n   * @param {ol.Extent} extent2 Extent 2.\n   * @return {number} Enlarged area.\n   */\n  ol.extent.getEnlargedArea = function(extent1, extent2) {\n    var minX = Math.min(extent1[0], extent2[0]);\n    var minY = Math.min(extent1[1], extent2[1]);\n    var maxX = Math.max(extent1[2], extent2[2]);\n    var maxY = Math.max(extent1[3], extent2[3]);\n    return (maxX - minX) * (maxY - minY);\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {ol.Size} size Size.\n   * @param {ol.Extent=} opt_extent Destination extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.getForViewAndSize = function(center, resolution, rotation, size, opt_extent) {\n    var dx = resolution * size[0] / 2;\n    var dy = resolution * size[1] / 2;\n    var cosRotation = Math.cos(rotation);\n    var sinRotation = Math.sin(rotation);\n    var xCos = dx * cosRotation;\n    var xSin = dx * sinRotation;\n    var yCos = dy * cosRotation;\n    var ySin = dy * sinRotation;\n    var x = center[0];\n    var y = center[1];\n    var x0 = x - xCos + ySin;\n    var x1 = x - xCos - ySin;\n    var x2 = x + xCos - ySin;\n    var x3 = x + xCos + ySin;\n    var y0 = y - xSin - yCos;\n    var y1 = y - xSin + yCos;\n    var y2 = y + xSin + yCos;\n    var y3 = y + xSin - yCos;\n    return ol.extent.createOrUpdate(\n        Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3),\n        Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3),\n        opt_extent);\n  };\n  \n  \n  /**\n   * Get the height of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {number} Height.\n   * @api\n   */\n  ol.extent.getHeight = function(extent) {\n    return extent[3] - extent[1];\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent1 Extent 1.\n   * @param {ol.Extent} extent2 Extent 2.\n   * @return {number} Intersection area.\n   */\n  ol.extent.getIntersectionArea = function(extent1, extent2) {\n    var intersection = ol.extent.getIntersection(extent1, extent2);\n    return ol.extent.getArea(intersection);\n  };\n  \n  \n  /**\n   * Get the intersection of two extents.\n   * @param {ol.Extent} extent1 Extent 1.\n   * @param {ol.Extent} extent2 Extent 2.\n   * @param {ol.Extent=} opt_extent Optional extent to populate with intersection.\n   * @return {ol.Extent} Intersecting extent.\n   * @api\n   */\n  ol.extent.getIntersection = function(extent1, extent2, opt_extent) {\n    var intersection = opt_extent ? opt_extent : ol.extent.createEmpty();\n    if (ol.extent.intersects(extent1, extent2)) {\n      if (extent1[0] > extent2[0]) {\n        intersection[0] = extent1[0];\n      } else {\n        intersection[0] = extent2[0];\n      }\n      if (extent1[1] > extent2[1]) {\n        intersection[1] = extent1[1];\n      } else {\n        intersection[1] = extent2[1];\n      }\n      if (extent1[2] < extent2[2]) {\n        intersection[2] = extent1[2];\n      } else {\n        intersection[2] = extent2[2];\n      }\n      if (extent1[3] < extent2[3]) {\n        intersection[3] = extent1[3];\n      } else {\n        intersection[3] = extent2[3];\n      }\n    }\n    return intersection;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @return {number} Margin.\n   */\n  ol.extent.getMargin = function(extent) {\n    return ol.extent.getWidth(extent) + ol.extent.getHeight(extent);\n  };\n  \n  \n  /**\n   * Get the size (width, height) of an extent.\n   * @param {ol.Extent} extent The extent.\n   * @return {ol.Size} The extent size.\n   * @api\n   */\n  ol.extent.getSize = function(extent) {\n    return [extent[2] - extent[0], extent[3] - extent[1]];\n  };\n  \n  \n  /**\n   * Get the top left coordinate of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {ol.Coordinate} Top left coordinate.\n   * @api\n   */\n  ol.extent.getTopLeft = function(extent) {\n    return [extent[0], extent[3]];\n  };\n  \n  \n  /**\n   * Get the top right coordinate of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {ol.Coordinate} Top right coordinate.\n   * @api\n   */\n  ol.extent.getTopRight = function(extent) {\n    return [extent[2], extent[3]];\n  };\n  \n  \n  /**\n   * Get the width of an extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {number} Width.\n   * @api\n   */\n  ol.extent.getWidth = function(extent) {\n    return extent[2] - extent[0];\n  };\n  \n  \n  /**\n   * Determine if one extent intersects another.\n   * @param {ol.Extent} extent1 Extent 1.\n   * @param {ol.Extent} extent2 Extent.\n   * @return {boolean} The two extents intersect.\n   * @api\n   */\n  ol.extent.intersects = function(extent1, extent2) {\n    return extent1[0] <= extent2[2] &&\n        extent1[2] >= extent2[0] &&\n        extent1[1] <= extent2[3] &&\n        extent1[3] >= extent2[1];\n  };\n  \n  \n  /**\n   * Determine if an extent is empty.\n   * @param {ol.Extent} extent Extent.\n   * @return {boolean} Is empty.\n   * @api\n   */\n  ol.extent.isEmpty = function(extent) {\n    return extent[2] < extent[0] || extent[3] < extent[1];\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.extent.returnOrUpdate = function(extent, opt_extent) {\n    if (opt_extent) {\n      opt_extent[0] = extent[0];\n      opt_extent[1] = extent[1];\n      opt_extent[2] = extent[2];\n      opt_extent[3] = extent[3];\n      return opt_extent;\n    } else {\n      return extent;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {number} value Value.\n   */\n  ol.extent.scaleFromCenter = function(extent, value) {\n    var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n    var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n    extent[0] -= deltaX;\n    extent[2] += deltaX;\n    extent[1] -= deltaY;\n    extent[3] += deltaY;\n  };\n  \n  \n  /**\n   * Determine if the segment between two coordinates intersects (crosses,\n   * touches, or is contained by) the provided extent.\n   * @param {ol.Extent} extent The extent.\n   * @param {ol.Coordinate} start Segment start coordinate.\n   * @param {ol.Coordinate} end Segment end coordinate.\n   * @return {boolean} The segment intersects the extent.\n   */\n  ol.extent.intersectsSegment = function(extent, start, end) {\n    var intersects = false;\n    var startRel = ol.extent.coordinateRelationship(extent, start);\n    var endRel = ol.extent.coordinateRelationship(extent, end);\n    if (startRel === ol.extent.Relationship.INTERSECTING ||\n        endRel === ol.extent.Relationship.INTERSECTING) {\n      intersects = true;\n    } else {\n      var minX = extent[0];\n      var minY = extent[1];\n      var maxX = extent[2];\n      var maxY = extent[3];\n      var startX = start[0];\n      var startY = start[1];\n      var endX = end[0];\n      var endY = end[1];\n      var slope = (endY - startY) / (endX - startX);\n      var x, y;\n      if (!!(endRel & ol.extent.Relationship.ABOVE) &&\n          !(startRel & ol.extent.Relationship.ABOVE)) {\n        // potentially intersects top\n        x = endX - ((endY - maxY) / slope);\n        intersects = x >= minX && x <= maxX;\n      }\n      if (!intersects && !!(endRel & ol.extent.Relationship.RIGHT) &&\n          !(startRel & ol.extent.Relationship.RIGHT)) {\n        // potentially intersects right\n        y = endY - ((endX - maxX) * slope);\n        intersects = y >= minY && y <= maxY;\n      }\n      if (!intersects && !!(endRel & ol.extent.Relationship.BELOW) &&\n          !(startRel & ol.extent.Relationship.BELOW)) {\n        // potentially intersects bottom\n        x = endX - ((endY - minY) / slope);\n        intersects = x >= minX && x <= maxX;\n      }\n      if (!intersects && !!(endRel & ol.extent.Relationship.LEFT) &&\n          !(startRel & ol.extent.Relationship.LEFT)) {\n        // potentially intersects left\n        y = endY - ((endX - minX) * slope);\n        intersects = y >= minY && y <= maxY;\n      }\n  \n    }\n    return intersects;\n  };\n  \n  \n  /**\n   * Apply a transform function to the extent.\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.TransformFunction} transformFn Transform function.  Called with\n   * [minX, minY, maxX, maxY] extent coordinates.\n   * @param {ol.Extent=} opt_extent Destination extent.\n   * @return {ol.Extent} Extent.\n   * @api\n   */\n  ol.extent.applyTransform = function(extent, transformFn, opt_extent) {\n    var coordinates = [\n      extent[0], extent[1],\n      extent[0], extent[3],\n      extent[2], extent[1],\n      extent[2], extent[3]\n    ];\n    transformFn(coordinates, coordinates, 2);\n    var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];\n    var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];\n    return ol.extent.boundingExtentXYs_(xs, ys, opt_extent);\n  };\n  \n  goog.provide('ol.obj');\n  \n  \n  /**\n   * Polyfill for Object.assign().  Assigns enumerable and own properties from\n   * one or more source objects to a target object.\n   *\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n   * @param {!Object} target The target object.\n   * @param {...Object} var_sources The source object(s).\n   * @return {!Object} The modified target object.\n   */\n  ol.obj.assign = (typeof Object.assign === 'function') ? Object.assign : function(target, var_sources) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n  \n    var output = Object(target);\n    for (var i = 1, ii = arguments.length; i < ii; ++i) {\n      var source = arguments[i];\n      if (source !== undefined && source !== null) {\n        for (var key in source) {\n          if (source.hasOwnProperty(key)) {\n            output[key] = source[key];\n          }\n        }\n      }\n    }\n    return output;\n  };\n  \n  \n  /**\n   * Removes all properties from an object.\n   * @param {Object} object The object to clear.\n   */\n  ol.obj.clear = function(object) {\n    for (var property in object) {\n      delete object[property];\n    }\n  };\n  \n  \n  /**\n   * Get an array of property values from an object.\n   * @param {Object<K,V>} object The object from which to get the values.\n   * @return {!Array<V>} The property values.\n   * @template K,V\n   */\n  ol.obj.getValues = function(object) {\n    var values = [];\n    for (var property in object) {\n      values.push(object[property]);\n    }\n    return values;\n  };\n  \n  \n  /**\n   * Determine if an object has any properties.\n   * @param {Object} object The object to check.\n   * @return {boolean} The object is empty.\n   */\n  ol.obj.isEmpty = function(object) {\n    var property;\n    for (property in object) {\n      return false;\n    }\n    return !property;\n  };\n  \n  goog.provide('ol.geom.GeometryType');\n  \n  \n  /**\n   * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n   * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n   * `'GeometryCollection'`, `'Circle'`.\n   * @enum {string}\n   */\n  ol.geom.GeometryType = {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    LINEAR_RING: 'LinearRing',\n    POLYGON: 'Polygon',\n    MULTI_POINT: 'MultiPoint',\n    MULTI_LINE_STRING: 'MultiLineString',\n    MULTI_POLYGON: 'MultiPolygon',\n    GEOMETRY_COLLECTION: 'GeometryCollection',\n    CIRCLE: 'Circle'\n  };\n  \n  /**\n   * @license\n   * Latitude/longitude spherical geodesy formulae taken from\n   * http://www.movable-type.co.uk/scripts/latlong.html\n   * Licensed under CC-BY-3.0.\n   */\n  \n  goog.provide('ol.Sphere');\n  \n  goog.require('ol.math');\n  goog.require('ol.geom.GeometryType');\n  \n  \n  /**\n   * @classdesc\n   * Class to create objects that can be used with {@link\n   * ol.geom.Polygon.circular}.\n   *\n   * For example to create a sphere whose radius is equal to the semi-major\n   * axis of the WGS84 ellipsoid:\n   *\n   * ```js\n   * var wgs84Sphere= new ol.Sphere(6378137);\n   * ```\n   *\n   * @constructor\n   * @param {number} radius Radius.\n   * @api\n   */\n  ol.Sphere = function(radius) {\n  \n    /**\n     * @type {number}\n     */\n    this.radius = radius;\n  \n  };\n  \n  \n  /**\n   * Returns the geodesic area for a list of coordinates.\n   *\n   * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n   * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n   * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n   * Laboratory, Pasadena, CA, June 2007\n   *\n   * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n   * ring. If the ring is oriented clockwise, the area will be positive,\n   * otherwise it will be negative.\n   * @return {number} Area.\n   * @api\n   */\n  ol.Sphere.prototype.geodesicArea = function(coordinates) {\n    return ol.Sphere.getArea_(coordinates, this.radius);\n  };\n  \n  \n  /**\n   * Returns the distance from c1 to c2 using the haversine formula.\n   *\n   * @param {ol.Coordinate} c1 Coordinate 1.\n   * @param {ol.Coordinate} c2 Coordinate 2.\n   * @return {number} Haversine distance.\n   * @api\n   */\n  ol.Sphere.prototype.haversineDistance = function(c1, c2) {\n    return ol.Sphere.getDistance_(c1, c2, this.radius);\n  };\n  \n  \n  /**\n   * Returns the coordinate at the given distance and bearing from `c1`.\n   *\n   * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n   * @param {number} distance The great-circle distance between the origin\n   *     point and the target point.\n   * @param {number} bearing The bearing (in radians).\n   * @return {ol.Coordinate} The target point.\n   */\n  ol.Sphere.prototype.offset = function(c1, distance, bearing) {\n    var lat1 = ol.math.toRadians(c1[1]);\n    var lon1 = ol.math.toRadians(c1[0]);\n    var dByR = distance / this.radius;\n    var lat = Math.asin(\n        Math.sin(lat1) * Math.cos(dByR) +\n        Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n    var lon = lon1 + Math.atan2(\n        Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n        Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n    return [ol.math.toDegrees(lon), ol.math.toDegrees(lat)];\n  };\n  \n  \n  /**\n   * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n   * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n   * @type {number}\n   */\n  ol.Sphere.DEFAULT_RADIUS = 6371008.8;\n  \n  \n  /**\n   * Get the spherical length of a geometry.  This length is the sum of the\n   * great circle distances between coordinates.  For polygons, the length is\n   * the sum of all rings.  For points, the length is zero.  For multi-part\n   * geometries, the length is the sum of the length of each part.\n   * @param {ol.geom.Geometry} geometry A geometry.\n   * @param {olx.SphereMetricOptions=} opt_options Options for the length\n   *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n   *     You can change this by providing a `projection` option.\n   * @return {number} The spherical length (in meters).\n   * @api\n   */\n  ol.Sphere.getLength = function(geometry, opt_options) {\n    var options = opt_options || {};\n    var radius = options.radius || ol.Sphere.DEFAULT_RADIUS;\n    var projection = options.projection || 'EPSG:3857';\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n    var type = geometry.getType();\n    var length = 0;\n    var coordinates, coords, i, ii, j, jj;\n    switch (type) {\n      case ol.geom.GeometryType.POINT:\n      case ol.geom.GeometryType.MULTI_POINT: {\n        break;\n      }\n      case ol.geom.GeometryType.LINE_STRING:\n      case ol.geom.GeometryType.LINEAR_RING: {\n        coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n        length = ol.Sphere.getLength_(coordinates, radius);\n        break;\n      }\n      case ol.geom.GeometryType.MULTI_LINE_STRING:\n      case ol.geom.GeometryType.POLYGON: {\n        coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          length += ol.Sphere.getLength_(coordinates[i], radius);\n        }\n        break;\n      }\n      case ol.geom.GeometryType.MULTI_POLYGON: {\n        coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          for (j = 0, jj = coords.length; j < jj; ++j) {\n            length += ol.Sphere.getLength_(coords[j], radius);\n          }\n        }\n        break;\n      }\n      case ol.geom.GeometryType.GEOMETRY_COLLECTION: {\n        var geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          length += ol.Sphere.getLength(geometries[i], opt_options);\n        }\n        break;\n      }\n      default: {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n    }\n    return length;\n  };\n  \n  \n  /**\n   * Get the cumulative great circle length of linestring coordinates (geographic).\n   * @param {Array} coordinates Linestring coordinates.\n   * @param {number} radius The sphere radius to use.\n   * @return {number} The length (in meters).\n   */\n  ol.Sphere.getLength_ = function(coordinates, radius) {\n    var length = 0;\n    for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n      length += ol.Sphere.getDistance_(coordinates[i], coordinates[i + 1], radius);\n    }\n    return length;\n  };\n  \n  \n  /**\n   * Get the great circle distance between two geographic coordinates.\n   * @param {Array} c1 Starting coordinate.\n   * @param {Array} c2 Ending coordinate.\n   * @param {number} radius The sphere radius to use.\n   * @return {number} The great circle distance between the points (in meters).\n   */\n  ol.Sphere.getDistance_ = function(c1, c2, radius) {\n    var lat1 = ol.math.toRadians(c1[1]);\n    var lat2 = ol.math.toRadians(c2[1]);\n    var deltaLatBy2 = (lat2 - lat1) / 2;\n    var deltaLonBy2 = ol.math.toRadians(c2[0] - c1[0]) / 2;\n    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n        Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *\n        Math.cos(lat1) * Math.cos(lat2);\n    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  };\n  \n  \n  /**\n   * Get the spherical area of a geometry.  This is the area (in meters) assuming\n   * that polygon edges are segments of great circles on a sphere.\n   * @param {ol.geom.Geometry} geometry A geometry.\n   * @param {olx.SphereMetricOptions=} opt_options Options for the area\n   *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n   *     You can change this by providing a `projection` option.\n   * @return {number} The spherical area (in square meters).\n   * @api\n   */\n  ol.Sphere.getArea = function(geometry, opt_options) {\n    var options = opt_options || {};\n    var radius = options.radius || ol.Sphere.DEFAULT_RADIUS;\n    var projection = options.projection || 'EPSG:3857';\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n    var type = geometry.getType();\n    var area = 0;\n    var coordinates, coords, i, ii, j, jj;\n    switch (type) {\n      case ol.geom.GeometryType.POINT:\n      case ol.geom.GeometryType.MULTI_POINT:\n      case ol.geom.GeometryType.LINE_STRING:\n      case ol.geom.GeometryType.MULTI_LINE_STRING:\n      case ol.geom.GeometryType.LINEAR_RING: {\n        break;\n      }\n      case ol.geom.GeometryType.POLYGON: {\n        coordinates = /** @type {ol.geom.Polygon} */ (geometry).getCoordinates();\n        area = Math.abs(ol.Sphere.getArea_(coordinates[0], radius));\n        for (i = 1, ii = coordinates.length; i < ii; ++i) {\n          area -= Math.abs(ol.Sphere.getArea_(coordinates[i], radius));\n        }\n        break;\n      }\n      case ol.geom.GeometryType.MULTI_POLYGON: {\n        coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          area += Math.abs(ol.Sphere.getArea_(coords[0], radius));\n          for (j = 1, jj = coords.length; j < jj; ++j) {\n            area -= Math.abs(ol.Sphere.getArea_(coords[j], radius));\n          }\n        }\n        break;\n      }\n      case ol.geom.GeometryType.GEOMETRY_COLLECTION: {\n        var geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          area += ol.Sphere.getArea(geometries[i], opt_options);\n        }\n        break;\n      }\n      default: {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n    }\n    return area;\n  };\n  \n  \n  /**\n   * Returns the spherical area for a list of coordinates.\n   *\n   * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n   * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n   * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n   * Laboratory, Pasadena, CA, June 2007\n   *\n   * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n   * ring. If the ring is oriented clockwise, the area will be positive,\n   * otherwise it will be negative.\n   * @param {number} radius The sphere radius.\n   * @return {number} Area (in square meters).\n   */\n  ol.Sphere.getArea_ = function(coordinates, radius) {\n    var area = 0, len = coordinates.length;\n    var x1 = coordinates[len - 1][0];\n    var y1 = coordinates[len - 1][1];\n    for (var i = 0; i < len; i++) {\n      var x2 = coordinates[i][0], y2 = coordinates[i][1];\n      area += ol.math.toRadians(x2 - x1) *\n          (2 + Math.sin(ol.math.toRadians(y1)) +\n          Math.sin(ol.math.toRadians(y2)));\n      x1 = x2;\n      y1 = y2;\n    }\n    return area * radius * radius / 2.0;\n  };\n  \n  goog.provide('ol.proj.Units');\n  \n  \n  /**\n   * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or\n   * `'us-ft'`.\n   * @enum {string}\n   */\n  ol.proj.Units = {\n    DEGREES: 'degrees',\n    FEET: 'ft',\n    METERS: 'm',\n    PIXELS: 'pixels',\n    TILE_PIXELS: 'tile-pixels',\n    USFEET: 'us-ft'\n  };\n  \n  \n  /**\n   * Meters per unit lookup table.\n   * @const\n   * @type {Object.<ol.proj.Units, number>}\n   * @api\n   */\n  ol.proj.Units.METERS_PER_UNIT = {};\n  // use the radius of the Normal sphere\n  ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.DEGREES] =\n      2 * Math.PI * 6370997 / 360;\n  ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.FEET] = 0.3048;\n  ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.METERS] = 1;\n  ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.USFEET] = 1200 / 3937;\n  \n  goog.provide('ol.proj.proj4');\n  \n  \n  /**\n   * @private\n   * @type {Proj4}\n   */\n  ol.proj.proj4.cache_ = null;\n  \n  \n  /**\n   * Store the proj4 function.\n   * @param {Proj4} proj4 The proj4 function.\n   */\n  ol.proj.proj4.set = function(proj4) {\n    ol.proj.proj4.cache_ = proj4;\n  };\n  \n  \n  /**\n   * Get proj4.\n   * @return {Proj4} The proj4 function set above or available globally.\n   */\n  ol.proj.proj4.get = function() {\n    return ol.proj.proj4.cache_ || window['proj4'];\n  };\n  \n  goog.provide('ol.proj.Projection');\n  \n  goog.require('ol');\n  goog.require('ol.proj.Units');\n  goog.require('ol.proj.proj4');\n  \n  \n  /**\n   * @classdesc\n   * Projection definition class. One of these is created for each projection\n   * supported in the application and stored in the {@link ol.proj} namespace.\n   * You can use these in applications, but this is not required, as API params\n   * and options use {@link ol.ProjectionLike} which means the simple string\n   * code will suffice.\n   *\n   * You can use {@link ol.proj.get} to retrieve the object for a particular\n   * projection.\n   *\n   * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n   * with the following aliases:\n   * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n   *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n   *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n   *     urn:x-ogc:def:crs:EPSG:4326\n   * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n   *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n   *     http://www.opengis.net/gml/srs/epsg.xml#3857\n   *\n   * If you use proj4js, aliases can be added using `proj4.defs()`; see\n   * [documentation](https://github.com/proj4js/proj4js). To set an alternative\n   * namespace for proj4, use {@link ol.proj.setProj4}.\n   *\n   * @constructor\n   * @param {olx.ProjectionOptions} options Projection options.\n   * @struct\n   * @api\n   */\n  ol.proj.Projection = function(options) {\n    /**\n     * @private\n     * @type {string}\n     */\n    this.code_ = options.code;\n  \n    /**\n     * Units of projected coordinates. When set to `ol.proj.Units.TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {ol.proj.Units}\n     */\n    this.units_ = /** @type {ol.proj.Units} */ (options.units);\n  \n    /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `ol.proj.Units.TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {ol.Extent}\n     */\n    this.extent_ = options.extent !== undefined ? options.extent : null;\n  \n    /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `ol.proj.Units.TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {ol.Extent}\n     */\n    this.worldExtent_ = options.worldExtent !== undefined ?\n      options.worldExtent : null;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.axisOrientation_ = options.axisOrientation !== undefined ?\n      options.axisOrientation : 'enu';\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.global_ = options.global !== undefined ? options.global : false;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n  \n    /**\n     * @private\n     * @type {function(number, ol.Coordinate):number|undefined}\n     */\n    this.getPointResolutionFunc_ = options.getPointResolution;\n  \n    /**\n     * @private\n     * @type {ol.tilegrid.TileGrid}\n     */\n    this.defaultTileGrid_ = null;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.metersPerUnit_ = options.metersPerUnit;\n  \n    var code = options.code;\n    if (ol.ENABLE_PROJ4JS) {\n      var proj4js = ol.proj.proj4.get();\n      if (typeof proj4js == 'function') {\n        var def = proj4js.defs(code);\n        if (def !== undefined) {\n          if (def.axis !== undefined && options.axisOrientation === undefined) {\n            this.axisOrientation_ = def.axis;\n          }\n          if (options.metersPerUnit === undefined) {\n            this.metersPerUnit_ = def.to_meter;\n          }\n          if (options.units === undefined) {\n            this.units_ = def.units;\n          }\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */\n  ol.proj.Projection.prototype.canWrapX = function() {\n    return this.canWrapX_;\n  };\n  \n  \n  /**\n   * Get the code for this projection, e.g. 'EPSG:4326'.\n   * @return {string} Code.\n   * @api\n   */\n  ol.proj.Projection.prototype.getCode = function() {\n    return this.code_;\n  };\n  \n  \n  /**\n   * Get the validity extent for this projection.\n   * @return {ol.Extent} Extent.\n   * @api\n   */\n  ol.proj.Projection.prototype.getExtent = function() {\n    return this.extent_;\n  };\n  \n  \n  /**\n   * Get the units of this projection.\n   * @return {ol.proj.Units} Units.\n   * @api\n   */\n  ol.proj.Projection.prototype.getUnits = function() {\n    return this.units_;\n  };\n  \n  \n  /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */\n  ol.proj.Projection.prototype.getMetersPerUnit = function() {\n    return this.metersPerUnit_ || ol.proj.Units.METERS_PER_UNIT[this.units_];\n  };\n  \n  \n  /**\n   * Get the world extent for this projection.\n   * @return {ol.Extent} Extent.\n   * @api\n   */\n  ol.proj.Projection.prototype.getWorldExtent = function() {\n    return this.worldExtent_;\n  };\n  \n  \n  /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     \"west positive\" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */\n  ol.proj.Projection.prototype.getAxisOrientation = function() {\n    return this.axisOrientation_;\n  };\n  \n  \n  /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */\n  ol.proj.Projection.prototype.isGlobal = function() {\n    return this.global_;\n  };\n  \n  \n  /**\n  * Set if the projection is a global projection which spans the whole world\n  * @param {boolean} global Whether the projection is global.\n  * @api\n  */\n  ol.proj.Projection.prototype.setGlobal = function(global) {\n    this.global_ = global;\n    this.canWrapX_ = !!(global && this.extent_);\n  };\n  \n  \n  /**\n   * @return {ol.tilegrid.TileGrid} The default tile grid.\n   */\n  ol.proj.Projection.prototype.getDefaultTileGrid = function() {\n    return this.defaultTileGrid_;\n  };\n  \n  \n  /**\n   * @param {ol.tilegrid.TileGrid} tileGrid The default tile grid.\n   */\n  ol.proj.Projection.prototype.setDefaultTileGrid = function(tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  };\n  \n  \n  /**\n   * Set the validity extent for this projection.\n   * @param {ol.Extent} extent Extent.\n   * @api\n   */\n  ol.proj.Projection.prototype.setExtent = function(extent) {\n    this.extent_ = extent;\n    this.canWrapX_ = !!(this.global_ && extent);\n  };\n  \n  \n  /**\n   * Set the world extent for this projection.\n   * @param {ol.Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */\n  ol.proj.Projection.prototype.setWorldExtent = function(worldExtent) {\n    this.worldExtent_ = worldExtent;\n  };\n  \n  \n  /**\n   * Set the getPointResolution function (see {@link ol.proj#getPointResolution}\n   * for this projection.\n   * @param {function(number, ol.Coordinate):number} func Function\n   * @api\n   */\n  ol.proj.Projection.prototype.setGetPointResolution = function(func) {\n    this.getPointResolutionFunc_ = func;\n  };\n  \n  \n  /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {function(number, ol.Coordinate):number|undefined} The custom point\n   * resolution function (if set).\n   */\n  ol.proj.Projection.prototype.getPointResolutionFunc = function() {\n    return this.getPointResolutionFunc_;\n  };\n  \n  goog.provide('ol.proj.EPSG3857');\n  \n  goog.require('ol');\n  goog.require('ol.math');\n  goog.require('ol.proj.Projection');\n  goog.require('ol.proj.Units');\n  \n  \n  /**\n   * @classdesc\n   * Projection object for web/spherical Mercator (EPSG:3857).\n   *\n   * @constructor\n   * @extends {ol.proj.Projection}\n   * @param {string} code Code.\n   * @private\n   */\n  ol.proj.EPSG3857.Projection_ = function(code) {\n    ol.proj.Projection.call(this, {\n      code: code,\n      units: ol.proj.Units.METERS,\n      extent: ol.proj.EPSG3857.EXTENT,\n      global: true,\n      worldExtent: ol.proj.EPSG3857.WORLD_EXTENT,\n      getPointResolution: function(resolution, point) {\n        return resolution / ol.math.cosh(point[1] / ol.proj.EPSG3857.RADIUS);\n      }\n    });\n  };\n  ol.inherits(ol.proj.EPSG3857.Projection_, ol.proj.Projection);\n  \n  \n  /**\n   * Radius of WGS84 sphere\n   *\n   * @const\n   * @type {number}\n   */\n  ol.proj.EPSG3857.RADIUS = 6378137;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.proj.EPSG3857.HALF_SIZE = Math.PI * ol.proj.EPSG3857.RADIUS;\n  \n  \n  /**\n   * @const\n   * @type {ol.Extent}\n   */\n  ol.proj.EPSG3857.EXTENT = [\n    -ol.proj.EPSG3857.HALF_SIZE, -ol.proj.EPSG3857.HALF_SIZE,\n    ol.proj.EPSG3857.HALF_SIZE, ol.proj.EPSG3857.HALF_SIZE\n  ];\n  \n  \n  /**\n   * @const\n   * @type {ol.Extent}\n   */\n  ol.proj.EPSG3857.WORLD_EXTENT = [-180, -85, 180, 85];\n  \n  \n  /**\n   * Projections equal to EPSG:3857.\n   *\n   * @const\n   * @type {Array.<ol.proj.Projection>}\n   */\n  ol.proj.EPSG3857.PROJECTIONS = [\n    new ol.proj.EPSG3857.Projection_('EPSG:3857'),\n    new ol.proj.EPSG3857.Projection_('EPSG:102100'),\n    new ol.proj.EPSG3857.Projection_('EPSG:102113'),\n    new ol.proj.EPSG3857.Projection_('EPSG:900913'),\n    new ol.proj.EPSG3857.Projection_('urn:ogc:def:crs:EPSG:6.18:3:3857'),\n    new ol.proj.EPSG3857.Projection_('urn:ogc:def:crs:EPSG::3857'),\n    new ol.proj.EPSG3857.Projection_('http://www.opengis.net/gml/srs/epsg.xml#3857')\n  ];\n  \n  \n  /**\n   * Transformation from EPSG:4326 to EPSG:3857.\n   *\n   * @param {Array.<number>} input Input array of coordinate values.\n   * @param {Array.<number>=} opt_output Output array of coordinate values.\n   * @param {number=} opt_dimension Dimension (default is `2`).\n   * @return {Array.<number>} Output array of coordinate values.\n   */\n  ol.proj.EPSG3857.fromEPSG4326 = function(input, opt_output, opt_dimension) {\n    var length = input.length,\n        dimension = opt_dimension > 1 ? opt_dimension : 2,\n        output = opt_output;\n    if (output === undefined) {\n      if (dimension > 2) {\n        // preserve values beyond second dimension\n        output = input.slice();\n      } else {\n        output = new Array(length);\n      }\n    }\n    var halfSize = ol.proj.EPSG3857.HALF_SIZE;\n    for (var i = 0; i < length; i += dimension) {\n      output[i] = halfSize * input[i] / 180;\n      var y = ol.proj.EPSG3857.RADIUS *\n          Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));\n      if (y > halfSize) {\n        y = halfSize;\n      } else if (y < -halfSize) {\n        y = -halfSize;\n      }\n      output[i + 1] = y;\n    }\n    return output;\n  };\n  \n  \n  /**\n   * Transformation from EPSG:3857 to EPSG:4326.\n   *\n   * @param {Array.<number>} input Input array of coordinate values.\n   * @param {Array.<number>=} opt_output Output array of coordinate values.\n   * @param {number=} opt_dimension Dimension (default is `2`).\n   * @return {Array.<number>} Output array of coordinate values.\n   */\n  ol.proj.EPSG3857.toEPSG4326 = function(input, opt_output, opt_dimension) {\n    var length = input.length,\n        dimension = opt_dimension > 1 ? opt_dimension : 2,\n        output = opt_output;\n    if (output === undefined) {\n      if (dimension > 2) {\n        // preserve values beyond second dimension\n        output = input.slice();\n      } else {\n        output = new Array(length);\n      }\n    }\n    for (var i = 0; i < length; i += dimension) {\n      output[i] = 180 * input[i] / ol.proj.EPSG3857.HALF_SIZE;\n      output[i + 1] = 360 * Math.atan(\n          Math.exp(input[i + 1] / ol.proj.EPSG3857.RADIUS)) / Math.PI - 90;\n    }\n    return output;\n  };\n  \n  goog.provide('ol.proj.EPSG4326');\n  \n  goog.require('ol');\n  goog.require('ol.proj.Projection');\n  goog.require('ol.proj.Units');\n  \n  \n  /**\n   * @classdesc\n   * Projection object for WGS84 geographic coordinates (EPSG:4326).\n   *\n   * Note that OpenLayers does not strictly comply with the EPSG definition.\n   * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n   * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n   *\n   * @constructor\n   * @extends {ol.proj.Projection}\n   * @param {string} code Code.\n   * @param {string=} opt_axisOrientation Axis orientation.\n   * @private\n   */\n  ol.proj.EPSG4326.Projection_ = function(code, opt_axisOrientation) {\n    ol.proj.Projection.call(this, {\n      code: code,\n      units: ol.proj.Units.DEGREES,\n      extent: ol.proj.EPSG4326.EXTENT,\n      axisOrientation: opt_axisOrientation,\n      global: true,\n      metersPerUnit: ol.proj.EPSG4326.METERS_PER_UNIT,\n      worldExtent: ol.proj.EPSG4326.EXTENT\n    });\n  };\n  ol.inherits(ol.proj.EPSG4326.Projection_, ol.proj.Projection);\n  \n  \n  /**\n   * Radius of WGS84 sphere\n   *\n   * @const\n   * @type {number}\n   */\n  ol.proj.EPSG4326.RADIUS = 6378137;\n  \n  \n  /**\n   * Extent of the EPSG:4326 projection which is the whole world.\n   *\n   * @const\n   * @type {ol.Extent}\n   */\n  ol.proj.EPSG4326.EXTENT = [-180, -90, 180, 90];\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.proj.EPSG4326.METERS_PER_UNIT = Math.PI * ol.proj.EPSG4326.RADIUS / 180;\n  \n  \n  /**\n   * Projections equal to EPSG:4326.\n   *\n   * @const\n   * @type {Array.<ol.proj.Projection>}\n   */\n  ol.proj.EPSG4326.PROJECTIONS = [\n    new ol.proj.EPSG4326.Projection_('CRS:84'),\n    new ol.proj.EPSG4326.Projection_('EPSG:4326', 'neu'),\n    new ol.proj.EPSG4326.Projection_('urn:ogc:def:crs:EPSG::4326', 'neu'),\n    new ol.proj.EPSG4326.Projection_('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),\n    new ol.proj.EPSG4326.Projection_('urn:ogc:def:crs:OGC:1.3:CRS84'),\n    new ol.proj.EPSG4326.Projection_('urn:ogc:def:crs:OGC:2:84'),\n    new ol.proj.EPSG4326.Projection_('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\n    new ol.proj.EPSG4326.Projection_('urn:x-ogc:def:crs:EPSG:4326', 'neu')\n  ];\n  \n  goog.provide('ol.proj.projections');\n  \n  \n  /**\n   * @private\n   * @type {Object.<string, ol.proj.Projection>}\n   */\n  ol.proj.projections.cache_ = {};\n  \n  \n  /**\n   * Clear the projections cache.\n   */\n  ol.proj.projections.clear = function() {\n    ol.proj.projections.cache_ = {};\n  };\n  \n  \n  /**\n   * Get a cached projection by code.\n   * @param {string} code The code for the projection.\n   * @return {ol.proj.Projection} The projection (if cached).\n   */\n  ol.proj.projections.get = function(code) {\n    var projections = ol.proj.projections.cache_;\n    return projections[code] || null;\n  };\n  \n  \n  /**\n   * Add a projection to the cache.\n   * @param {string} code The projection code.\n   * @param {ol.proj.Projection} projection The projection to cache.\n   */\n  ol.proj.projections.add = function(code, projection) {\n    var projections = ol.proj.projections.cache_;\n    projections[code] = projection;\n  };\n  \n  goog.provide('ol.proj.transforms');\n  \n  goog.require('ol.obj');\n  \n  \n  /**\n   * @private\n   * @type {Object.<string, Object.<string, ol.TransformFunction>>}\n   */\n  ol.proj.transforms.cache_ = {};\n  \n  \n  /**\n   * Clear the transform cache.\n   */\n  ol.proj.transforms.clear = function() {\n    ol.proj.transforms.cache_ = {};\n  };\n  \n  \n  /**\n   * Registers a conversion function to convert coordinates from the source\n   * projection to the destination projection.\n   *\n   * @param {ol.proj.Projection} source Source.\n   * @param {ol.proj.Projection} destination Destination.\n   * @param {ol.TransformFunction} transformFn Transform.\n   */\n  ol.proj.transforms.add = function(source, destination, transformFn) {\n    var sourceCode = source.getCode();\n    var destinationCode = destination.getCode();\n    var transforms = ol.proj.transforms.cache_;\n    if (!(sourceCode in transforms)) {\n      transforms[sourceCode] = {};\n    }\n    transforms[sourceCode][destinationCode] = transformFn;\n  };\n  \n  \n  /**\n   * Unregisters the conversion function to convert coordinates from the source\n   * projection to the destination projection.  This method is used to clean up\n   * cached transforms during testing.\n   *\n   * @param {ol.proj.Projection} source Source projection.\n   * @param {ol.proj.Projection} destination Destination projection.\n   * @return {ol.TransformFunction} transformFn The unregistered transform.\n   */\n  ol.proj.transforms.remove = function(source, destination) {\n    var sourceCode = source.getCode();\n    var destinationCode = destination.getCode();\n    var transforms = ol.proj.transforms.cache_;\n    var transform = transforms[sourceCode][destinationCode];\n    delete transforms[sourceCode][destinationCode];\n    if (ol.obj.isEmpty(transforms[sourceCode])) {\n      delete transforms[sourceCode];\n    }\n    return transform;\n  };\n  \n  \n  /**\n   * Get a transform given a source code and a destination code.\n   * @param {string} sourceCode The code for the source projection.\n   * @param {string} destinationCode The code for the destination projection.\n   * @return {ol.TransformFunction|undefined} The transform function (if found).\n   */\n  ol.proj.transforms.get = function(sourceCode, destinationCode) {\n    var transform;\n    var transforms = ol.proj.transforms.cache_;\n    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n      transform = transforms[sourceCode][destinationCode];\n    }\n    return transform;\n  };\n  \n  goog.provide('ol.proj');\n  \n  goog.require('ol');\n  goog.require('ol.Sphere');\n  goog.require('ol.extent');\n  goog.require('ol.math');\n  goog.require('ol.proj.EPSG3857');\n  goog.require('ol.proj.EPSG4326');\n  goog.require('ol.proj.Projection');\n  goog.require('ol.proj.Units');\n  goog.require('ol.proj.proj4');\n  goog.require('ol.proj.projections');\n  goog.require('ol.proj.transforms');\n  \n  \n  /**\n   * Meters per unit lookup table.\n   * @const\n   * @type {Object.<ol.proj.Units, number>}\n   * @api\n   */\n  ol.proj.METERS_PER_UNIT = ol.proj.Units.METERS_PER_UNIT;\n  \n  \n  /**\n   * A place to store the mean radius of the Earth.\n   * @private\n   * @type {ol.Sphere}\n   */\n  ol.proj.SPHERE_ = new ol.Sphere(ol.Sphere.DEFAULT_RADIUS);\n  \n  \n  if (ol.ENABLE_PROJ4JS) {\n    /**\n     * Register proj4. If not explicitly registered, it will be assumed that\n     * proj4js will be loaded in the global namespace. For example in a\n     * browserify ES6 environment you could use:\n     *\n     *     import ol from 'openlayers';\n     *     import proj4 from 'proj4';\n     *     ol.proj.setProj4(proj4);\n     *\n     * @param {Proj4} proj4 Proj4.\n     * @api\n     */\n    ol.proj.setProj4 = function(proj4) {\n      ol.proj.proj4.set(proj4);\n    };\n  }\n  \n  \n  /**\n   * Get the resolution of the point in degrees or distance units.\n   * For projections with degrees as the unit this will simply return the\n   * provided resolution. For other projections the point resolution is\n   * by default estimated by transforming the 'point' pixel to EPSG:4326,\n   * measuring its width and height on the normal sphere,\n   * and taking the average of the width and height.\n   * A custom function can be provided for a specific projection, either\n   * by setting the `getPointResolution` option in the\n   * {@link ol.proj.Projection} constructor or by using\n   * {@link ol.proj.Projection#setGetPointResolution} to change an existing\n   * projection object.\n   * @param {ol.ProjectionLike} projection The projection.\n   * @param {number} resolution Nominal resolution in projection units.\n   * @param {ol.Coordinate} point Point to find adjusted resolution at.\n   * @param {ol.proj.Units=} opt_units Units to get the point resolution in.\n   * Default is the projection's units.\n   * @return {number} Point resolution.\n   * @api\n   */\n  ol.proj.getPointResolution = function(projection, resolution, point, opt_units) {\n    projection = ol.proj.get(projection);\n    var pointResolution;\n    var getter = projection.getPointResolutionFunc();\n    if (getter) {\n      pointResolution = getter(resolution, point);\n    } else {\n      var units = projection.getUnits();\n      if (units == ol.proj.Units.DEGREES && !opt_units || opt_units == ol.proj.Units.DEGREES) {\n        pointResolution = resolution;\n      } else {\n        // Estimate point resolution by transforming the center pixel to EPSG:4326,\n        // measuring its width and height on the normal sphere, and taking the\n        // average of the width and height.\n        var toEPSG4326 = ol.proj.getTransformFromProjections(projection, ol.proj.get('EPSG:4326'));\n        var vertices = [\n          point[0] - resolution / 2, point[1],\n          point[0] + resolution / 2, point[1],\n          point[0], point[1] - resolution / 2,\n          point[0], point[1] + resolution / 2\n        ];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        var width = ol.proj.SPHERE_.haversineDistance(\n            vertices.slice(0, 2), vertices.slice(2, 4));\n        var height = ol.proj.SPHERE_.haversineDistance(\n            vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n        var metersPerUnit = opt_units ?\n          ol.proj.Units.METERS_PER_UNIT[opt_units] :\n          projection.getMetersPerUnit();\n        if (metersPerUnit !== undefined) {\n          pointResolution /= metersPerUnit;\n        }\n      }\n    }\n    return pointResolution;\n  };\n  \n  \n  /**\n   * Registers transformation functions that don't alter coordinates. Those allow\n   * to transform between projections with equal meaning.\n   *\n   * @param {Array.<ol.proj.Projection>} projections Projections.\n   * @api\n   */\n  ol.proj.addEquivalentProjections = function(projections) {\n    ol.proj.addProjections(projections);\n    projections.forEach(function(source) {\n      projections.forEach(function(destination) {\n        if (source !== destination) {\n          ol.proj.transforms.add(source, destination, ol.proj.cloneTransform);\n        }\n      });\n    });\n  };\n  \n  \n  /**\n   * Registers transformation functions to convert coordinates in any projection\n   * in projection1 to any projection in projection2.\n   *\n   * @param {Array.<ol.proj.Projection>} projections1 Projections with equal\n   *     meaning.\n   * @param {Array.<ol.proj.Projection>} projections2 Projections with equal\n   *     meaning.\n   * @param {ol.TransformFunction} forwardTransform Transformation from any\n   *   projection in projection1 to any projection in projection2.\n   * @param {ol.TransformFunction} inverseTransform Transform from any projection\n   *   in projection2 to any projection in projection1..\n   */\n  ol.proj.addEquivalentTransforms = function(projections1, projections2, forwardTransform, inverseTransform) {\n    projections1.forEach(function(projection1) {\n      projections2.forEach(function(projection2) {\n        ol.proj.transforms.add(projection1, projection2, forwardTransform);\n        ol.proj.transforms.add(projection2, projection1, inverseTransform);\n      });\n    });\n  };\n  \n  \n  /**\n   * Add a Projection object to the list of supported projections that can be\n   * looked up by their code.\n   *\n   * @param {ol.proj.Projection} projection Projection instance.\n   * @api\n   */\n  ol.proj.addProjection = function(projection) {\n    ol.proj.projections.add(projection.getCode(), projection);\n    ol.proj.transforms.add(projection, projection, ol.proj.cloneTransform);\n  };\n  \n  \n  /**\n   * @param {Array.<ol.proj.Projection>} projections Projections.\n   */\n  ol.proj.addProjections = function(projections) {\n    projections.forEach(ol.proj.addProjection);\n  };\n  \n  \n  /**\n   * Clear all cached projections and transforms.\n   */\n  ol.proj.clearAllProjections = function() {\n    ol.proj.projections.clear();\n    ol.proj.transforms.clear();\n  };\n  \n  \n  /**\n   * @param {ol.proj.Projection|string|undefined} projection Projection.\n   * @param {string} defaultCode Default code.\n   * @return {ol.proj.Projection} Projection.\n   */\n  ol.proj.createProjection = function(projection, defaultCode) {\n    if (!projection) {\n      return ol.proj.get(defaultCode);\n    } else if (typeof projection === 'string') {\n      return ol.proj.get(projection);\n    } else {\n      return /** @type {ol.proj.Projection} */ (projection);\n    }\n  };\n  \n  \n  /**\n   * Registers coordinate transform functions to convert coordinates between the\n   * source projection and the destination projection.\n   * The forward and inverse functions convert coordinate pairs; this function\n   * converts these into the functions used internally which also handle\n   * extents and coordinate arrays.\n   *\n   * @param {ol.ProjectionLike} source Source projection.\n   * @param {ol.ProjectionLike} destination Destination projection.\n   * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform\n   *     function (that is, from the source projection to the destination\n   *     projection) that takes a {@link ol.Coordinate} as argument and returns\n   *     the transformed {@link ol.Coordinate}.\n   * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform\n   *     function (that is, from the destination projection to the source\n   *     projection) that takes a {@link ol.Coordinate} as argument and returns\n   *     the transformed {@link ol.Coordinate}.\n   * @api\n   */\n  ol.proj.addCoordinateTransforms = function(source, destination, forward, inverse) {\n    var sourceProj = ol.proj.get(source);\n    var destProj = ol.proj.get(destination);\n    ol.proj.transforms.add(sourceProj, destProj,\n        ol.proj.createTransformFromCoordinateTransform(forward));\n    ol.proj.transforms.add(destProj, sourceProj,\n        ol.proj.createTransformFromCoordinateTransform(inverse));\n  };\n  \n  \n  /**\n   * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform\n   * function.\n   * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate\n   *     transform.\n   * @return {ol.TransformFunction} Transform function.\n   */\n  ol.proj.createTransformFromCoordinateTransform = function(transform) {\n    return (\n      /**\n       * @param {Array.<number>} input Input.\n       * @param {Array.<number>=} opt_output Output.\n       * @param {number=} opt_dimension Dimension.\n       * @return {Array.<number>} Output.\n       */\n      function(input, opt_output, opt_dimension) {\n        var length = input.length;\n        var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n        var output = opt_output !== undefined ? opt_output : new Array(length);\n        var point, i, j;\n        for (i = 0; i < length; i += dimension) {\n          point = transform([input[i], input[i + 1]]);\n          output[i] = point[0];\n          output[i + 1] = point[1];\n          for (j = dimension - 1; j >= 2; --j) {\n            output[i + j] = input[i + j];\n          }\n        }\n        return output;\n      });\n  };\n  \n  \n  /**\n   * Transforms a coordinate from longitude/latitude to a different projection.\n   * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n   *     an array with longitude as 1st and latitude as 2nd element.\n   * @param {ol.ProjectionLike=} opt_projection Target projection. The\n   *     default is Web Mercator, i.e. 'EPSG:3857'.\n   * @return {ol.Coordinate} Coordinate projected to the target projection.\n   * @api\n   */\n  ol.proj.fromLonLat = function(coordinate, opt_projection) {\n    return ol.proj.transform(coordinate, 'EPSG:4326',\n        opt_projection !== undefined ? opt_projection : 'EPSG:3857');\n  };\n  \n  \n  /**\n   * Transforms a coordinate to longitude/latitude.\n   * @param {ol.Coordinate} coordinate Projected coordinate.\n   * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.\n   *     The default is Web Mercator, i.e. 'EPSG:3857'.\n   * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array\n   *     with longitude as 1st and latitude as 2nd element.\n   * @api\n   */\n  ol.proj.toLonLat = function(coordinate, opt_projection) {\n    var lonLat = ol.proj.transform(coordinate,\n        opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\n    var lon = lonLat[0];\n    if (lon < -180 || lon > 180) {\n      lonLat[0] = ol.math.modulo(lon + 180, 360) - 180;\n    }\n    return lonLat;\n  };\n  \n  \n  /**\n   * Fetches a Projection object for the code specified.\n   *\n   * @param {ol.ProjectionLike} projectionLike Either a code string which is\n   *     a combination of authority and identifier such as \"EPSG:4326\", or an\n   *     existing projection object, or undefined.\n   * @return {ol.proj.Projection} Projection object, or null if not in list.\n   * @api\n   */\n  ol.proj.get = function(projectionLike) {\n    var projection = null;\n    if (projectionLike instanceof ol.proj.Projection) {\n      projection = projectionLike;\n    } else if (typeof projectionLike === 'string') {\n      var code = projectionLike;\n      projection = ol.proj.projections.get(code);\n      if (ol.ENABLE_PROJ4JS && !projection) {\n        var proj4js = ol.proj.proj4.get();\n        if (typeof proj4js == 'function' &&\n            proj4js.defs(code) !== undefined) {\n          projection = new ol.proj.Projection({code: code});\n          ol.proj.addProjection(projection);\n        }\n      }\n    }\n    return projection;\n  };\n  \n  \n  /**\n   * Checks if two projections are the same, that is every coordinate in one\n   * projection does represent the same geographic point as the same coordinate in\n   * the other projection.\n   *\n   * @param {ol.proj.Projection} projection1 Projection 1.\n   * @param {ol.proj.Projection} projection2 Projection 2.\n   * @return {boolean} Equivalent.\n   * @api\n   */\n  ol.proj.equivalent = function(projection1, projection2) {\n    if (projection1 === projection2) {\n      return true;\n    }\n    var equalUnits = projection1.getUnits() === projection2.getUnits();\n    if (projection1.getCode() === projection2.getCode()) {\n      return equalUnits;\n    } else {\n      var transformFn = ol.proj.getTransformFromProjections(\n          projection1, projection2);\n      return transformFn === ol.proj.cloneTransform && equalUnits;\n    }\n  };\n  \n  \n  /**\n   * Given the projection-like objects, searches for a transformation\n   * function to convert a coordinates array from the source projection to the\n   * destination projection.\n   *\n   * @param {ol.ProjectionLike} source Source.\n   * @param {ol.ProjectionLike} destination Destination.\n   * @return {ol.TransformFunction} Transform function.\n   * @api\n   */\n  ol.proj.getTransform = function(source, destination) {\n    var sourceProjection = ol.proj.get(source);\n    var destinationProjection = ol.proj.get(destination);\n    return ol.proj.getTransformFromProjections(\n        sourceProjection, destinationProjection);\n  };\n  \n  \n  /**\n   * Searches in the list of transform functions for the function for converting\n   * coordinates from the source projection to the destination projection.\n   *\n   * @param {ol.proj.Projection} sourceProjection Source Projection object.\n   * @param {ol.proj.Projection} destinationProjection Destination Projection\n   *     object.\n   * @return {ol.TransformFunction} Transform function.\n   */\n  ol.proj.getTransformFromProjections = function(sourceProjection, destinationProjection) {\n    var sourceCode = sourceProjection.getCode();\n    var destinationCode = destinationProjection.getCode();\n    var transform = ol.proj.transforms.get(sourceCode, destinationCode);\n    if (ol.ENABLE_PROJ4JS && !transform) {\n      var proj4js = ol.proj.proj4.get();\n      if (typeof proj4js == 'function') {\n        var sourceDef = proj4js.defs(sourceCode);\n        var destinationDef = proj4js.defs(destinationCode);\n  \n        if (sourceDef !== undefined && destinationDef !== undefined) {\n          if (sourceDef === destinationDef) {\n            ol.proj.addEquivalentProjections([destinationProjection, sourceProjection]);\n          } else {\n            var proj4Transform = proj4js(destinationCode, sourceCode);\n            ol.proj.addCoordinateTransforms(destinationProjection, sourceProjection,\n                proj4Transform.forward, proj4Transform.inverse);\n          }\n          transform = ol.proj.transforms.get(sourceCode, destinationCode);\n        }\n      }\n    }\n    if (!transform) {\n      transform = ol.proj.identityTransform;\n    }\n    return transform;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} input Input coordinate array.\n   * @param {Array.<number>=} opt_output Output array of coordinate values.\n   * @param {number=} opt_dimension Dimension.\n   * @return {Array.<number>} Input coordinate array (same array as input).\n   */\n  ol.proj.identityTransform = function(input, opt_output, opt_dimension) {\n    if (opt_output !== undefined && input !== opt_output) {\n      for (var i = 0, ii = input.length; i < ii; ++i) {\n        opt_output[i] = input[i];\n      }\n      input = opt_output;\n    }\n    return input;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} input Input coordinate array.\n   * @param {Array.<number>=} opt_output Output array of coordinate values.\n   * @param {number=} opt_dimension Dimension.\n   * @return {Array.<number>} Output coordinate array (new array, same coordinate\n   *     values).\n   */\n  ol.proj.cloneTransform = function(input, opt_output, opt_dimension) {\n    var output;\n    if (opt_output !== undefined) {\n      for (var i = 0, ii = input.length; i < ii; ++i) {\n        opt_output[i] = input[i];\n      }\n      output = opt_output;\n    } else {\n      output = input.slice();\n    }\n    return output;\n  };\n  \n  \n  /**\n   * Transforms a coordinate from source projection to destination projection.\n   * This returns a new coordinate (and does not modify the original).\n   *\n   * See {@link ol.proj.transformExtent} for extent transformation.\n   * See the transform method of {@link ol.geom.Geometry} and its subclasses for\n   * geometry transforms.\n   *\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {ol.ProjectionLike} source Source projection-like.\n   * @param {ol.ProjectionLike} destination Destination projection-like.\n   * @return {ol.Coordinate} Coordinate.\n   * @api\n   */\n  ol.proj.transform = function(coordinate, source, destination) {\n    var transformFn = ol.proj.getTransform(source, destination);\n    return transformFn(coordinate, undefined, coordinate.length);\n  };\n  \n  \n  /**\n   * Transforms an extent from source projection to destination projection.  This\n   * returns a new extent (and does not modify the original).\n   *\n   * @param {ol.Extent} extent The extent to transform.\n   * @param {ol.ProjectionLike} source Source projection-like.\n   * @param {ol.ProjectionLike} destination Destination projection-like.\n   * @return {ol.Extent} The transformed extent.\n   * @api\n   */\n  ol.proj.transformExtent = function(extent, source, destination) {\n    var transformFn = ol.proj.getTransform(source, destination);\n    return ol.extent.applyTransform(extent, transformFn);\n  };\n  \n  \n  /**\n   * Transforms the given point to the destination projection.\n   *\n   * @param {ol.Coordinate} point Point.\n   * @param {ol.proj.Projection} sourceProjection Source projection.\n   * @param {ol.proj.Projection} destinationProjection Destination projection.\n   * @return {ol.Coordinate} Point.\n   */\n  ol.proj.transformWithProjections = function(point, sourceProjection, destinationProjection) {\n    var transformFn = ol.proj.getTransformFromProjections(\n        sourceProjection, destinationProjection);\n    return transformFn(point);\n  };\n  \n  /**\n   * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n   * by when this module is executed and should only need to be called again after\n   * `ol.proj.clearAllProjections()` is called (e.g. in tests).\n   */\n  ol.proj.addCommon = function() {\n    // Add transformations that don't alter coordinates to convert within set of\n    // projections with equal meaning.\n    ol.proj.addEquivalentProjections(ol.proj.EPSG3857.PROJECTIONS);\n    ol.proj.addEquivalentProjections(ol.proj.EPSG4326.PROJECTIONS);\n    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n    // coordinates and back.\n    ol.proj.addEquivalentTransforms(\n        ol.proj.EPSG4326.PROJECTIONS,\n        ol.proj.EPSG3857.PROJECTIONS,\n        ol.proj.EPSG3857.fromEPSG4326,\n        ol.proj.EPSG3857.toEPSG4326);\n  };\n  \n  ol.proj.addCommon();\n  \n  goog.provide('ol.tilecoord');\n  \n  \n  /**\n   * @param {number} z Z.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {ol.TileCoord=} opt_tileCoord Tile coordinate.\n   * @return {ol.TileCoord} Tile coordinate.\n   */\n  ol.tilecoord.createOrUpdate = function(z, x, y, opt_tileCoord) {\n    if (opt_tileCoord !== undefined) {\n      opt_tileCoord[0] = z;\n      opt_tileCoord[1] = x;\n      opt_tileCoord[2] = y;\n      return opt_tileCoord;\n    } else {\n      return [z, x, y];\n    }\n  };\n  \n  \n  /**\n   * @param {number} z Z.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {string} Key.\n   */\n  ol.tilecoord.getKeyZXY = function(z, x, y) {\n    return z + '/' + x + '/' + y;\n  };\n  \n  \n  /**\n   * Get the key for a tile coord.\n   * @param {ol.TileCoord} tileCoord The tile coord.\n   * @return {string} Key.\n   */\n  ol.tilecoord.getKey = function(tileCoord) {\n    return ol.tilecoord.getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n  };\n  \n  \n  /**\n   * Get a tile coord given a key.\n   * @param {string} key The tile coord key.\n   * @return {ol.TileCoord} The tile coord.\n   */\n  ol.tilecoord.fromKey = function(key) {\n    return key.split('/').map(Number);\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coord.\n   * @return {number} Hash.\n   */\n  ol.tilecoord.hash = function(tileCoord) {\n    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coord.\n   * @return {string} Quad key.\n   */\n  ol.tilecoord.quadKey = function(tileCoord) {\n    var z = tileCoord[0];\n    var digits = new Array(z);\n    var mask = 1 << (z - 1);\n    var i, charCode;\n    for (i = 0; i < z; ++i) {\n      // 48 is charCode for 0 - '0'.charCodeAt(0)\n      charCode = 48;\n      if (tileCoord[1] & mask) {\n        charCode += 1;\n      }\n      if (tileCoord[2] & mask) {\n        charCode += 2;\n      }\n      digits[i] = String.fromCharCode(charCode);\n      mask >>= 1;\n    }\n    return digits.join('');\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.\n   * @return {boolean} Tile coordinate is within extent and zoom level range.\n   */\n  ol.tilecoord.withinExtentAndZ = function(tileCoord, tileGrid) {\n    var z = tileCoord[0];\n    var x = tileCoord[1];\n    var y = tileCoord[2];\n  \n    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n      return false;\n    }\n    var extent = tileGrid.getExtent();\n    var tileRange;\n    if (!extent) {\n      tileRange = tileGrid.getFullTileRange(z);\n    } else {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    }\n    if (!tileRange) {\n      return true;\n    } else {\n      return tileRange.containsXY(x, y);\n    }\n  };\n  \n  goog.provide('ol.tilegrid.TileGrid');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.TileRange');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.math');\n  goog.require('ol.size');\n  goog.require('ol.tilecoord');\n  \n  \n  /**\n   * @classdesc\n   * Base class for setting the grid pattern for sources accessing tiled-image\n   * servers.\n   *\n   * @constructor\n   * @param {olx.tilegrid.TileGridOptions} options Tile grid options.\n   * @struct\n   * @api\n   */\n  ol.tilegrid.TileGrid = function(options) {\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n  \n    /**\n     * @private\n     * @type {!Array.<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    ol.asserts.assert(ol.array.isSorted(this.resolutions_, function(a, b) {\n      return b - a;\n    }, true), 17); // `resolutions` must be sorted in descending order\n  \n  \n    // check if we've got a consistent zoom factor and origin\n    var zoomFactor;\n    if (!options.origins) {\n      for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n  \n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n  \n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n  \n    /**\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n  \n    /**\n     * @private\n     * @type {Array.<ol.Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      ol.asserts.assert(this.origins_.length == this.resolutions_.length,\n          20); // Number of `origins` and `resolutions` must be equal\n    }\n  \n    var extent = options.extent;\n  \n    if (extent !== undefined &&\n        !this.origin_ && !this.origins_) {\n      this.origin_ = ol.extent.getTopLeft(extent);\n    }\n  \n    ol.asserts.assert(\n        (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n        18); // Either `origin` or `origins` must be configured, never both\n  \n    /**\n     * @private\n     * @type {Array.<number|ol.Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      ol.asserts.assert(this.tileSizes_.length == this.resolutions_.length,\n          19); // Number of `tileSizes` and `resolutions` must be equal\n    }\n  \n    /**\n     * @private\n     * @type {number|ol.Size}\n     */\n    this.tileSize_ = options.tileSize !== undefined ?\n      options.tileSize :\n      !this.tileSizes_ ? ol.DEFAULT_TILE_SIZE : null;\n    ol.asserts.assert(\n        (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n        22); // Either `tileSize` or `tileSizes` must be configured, never both\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n  \n  \n    /**\n     * @private\n     * @type {Array.<ol.TileRange>}\n     */\n    this.fullTileRanges_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.tmpSize_ = [0, 0];\n  \n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map(function(size, z) {\n        var tileRange = new ol.TileRange(\n            Math.min(0, size[0]), Math.max(size[0] - 1, -1),\n            Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n        return tileRange;\n      }, this);\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  \n  };\n  \n  \n  /**\n   * @private\n   * @type {ol.TileCoord}\n   */\n  ol.tilegrid.TileGrid.tmpTileCoord_ = [0, 0, 0];\n  \n  \n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {ol.Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(ol.TileCoord)} callback Function called with each tile coordinate.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.forEachTileCoord = function(extent, zoom, callback) {\n    var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {function(this: T, number, ol.TileRange): boolean} callback Callback.\n   * @param {T=} opt_this The object to use as `this` in `callback`.\n   * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.\n   * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n   * @return {boolean} Callback succeeded.\n   * @template T\n   */\n  ol.tilegrid.TileGrid.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\n    var tileRange, x, y;\n    var tileCoordExtent = null;\n    var z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    }\n    while (z >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = ol.TileRange.createOrUpdate(x, x, y, y, opt_tileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n      }\n      if (callback.call(opt_this, z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  };\n  \n  \n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {ol.Extent} Extent.\n   */\n  ol.tilegrid.TileGrid.prototype.getExtent = function() {\n    return this.extent_;\n  };\n  \n  \n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getMaxZoom = function() {\n    return this.maxZoom;\n  };\n  \n  \n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getMinZoom = function() {\n    return this.minZoom;\n  };\n  \n  \n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {ol.Coordinate} Origin.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getOrigin = function(z) {\n    if (this.origin_) {\n      return this.origin_;\n    } else {\n      return this.origins_[z];\n    }\n  };\n  \n  \n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getResolution = function(z) {\n    return this.resolutions_[z];\n  };\n  \n  \n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array.<number>} Resolutions.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getResolutions = function() {\n    return this.resolutions_;\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.\n   * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n   * @return {ol.TileRange} Tile range.\n   */\n  ol.tilegrid.TileGrid.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        var minX = tileCoord[1] * 2;\n        var minY = tileCoord[2] * 2;\n        return ol.TileRange.createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);\n      }\n      var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n      return this.getTileRangeForExtentAndZ(\n          tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n    }\n    return null;\n  };\n  \n  \n  /**\n   * Get the extent for a tile range.\n   * @param {number} z Integer zoom level.\n   * @param {ol.TileRange} tileRange Tile range.\n   * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n   * @return {ol.Extent} Extent.\n   */\n  ol.tilegrid.TileGrid.prototype.getTileRangeExtent = function(z, tileRange, opt_extent) {\n    var origin = this.getOrigin(z);\n    var resolution = this.getResolution(z);\n    var tileSize = ol.size.toSize(this.getTileSize(z), this.tmpSize_);\n    var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return ol.extent.createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  };\n  \n  \n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {ol.TileRange=} opt_tileRange Temporary tile range object.\n   * @return {ol.TileRange} Tile range.\n   */\n  ol.tilegrid.TileGrid.prototype.getTileRangeForExtentAndZ = function(extent, z, opt_tileRange) {\n    var tileCoord = ol.tilegrid.TileGrid.tmpTileCoord_;\n    this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\n    var minX = tileCoord[1];\n    var minY = tileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\n    return ol.TileRange.createOrUpdate(\n        minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @return {ol.Coordinate} Tile center.\n   */\n  ol.tilegrid.TileGrid.prototype.getTileCoordCenter = function(tileCoord) {\n    var origin = this.getOrigin(tileCoord[0]);\n    var resolution = this.getResolution(tileCoord[0]);\n    var tileSize = ol.size.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution\n    ];\n  };\n  \n  \n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.Extent=} opt_extent Temporary extent object.\n   * @return {ol.Extent} Extent.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {\n    var origin = this.getOrigin(tileCoord[0]);\n    var resolution = this.getResolution(tileCoord[0]);\n    var tileSize = ol.size.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\n    var maxX = minX + tileSize[0] * resolution;\n    var maxY = minY + tileSize[1] * resolution;\n    return ol.extent.createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  };\n  \n  \n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.\n   * @return {ol.TileCoord} Tile coordinate.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n        coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n  };\n  \n  \n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.\n   * @return {ol.TileCoord} Tile coordinate.\n   * @private\n   */\n  ol.tilegrid.TileGrid.prototype.getTileCoordForXYAndResolution_ = function(\n      x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n    var z = this.getZForResolution(resolution);\n    var scale = resolution / this.getResolution(z);\n    var origin = this.getOrigin(z);\n    var tileSize = ol.size.toSize(this.getTileSize(z), this.tmpSize_);\n  \n    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n    var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n    var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n    var tileCoordX = scale * xFromOrigin / tileSize[0];\n    var tileCoordY = scale * yFromOrigin / tileSize[1];\n  \n    if (reverseIntersectionPolicy) {\n      tileCoordX = Math.ceil(tileCoordX) - 1;\n      tileCoordY = Math.ceil(tileCoordY) - 1;\n    } else {\n      tileCoordX = Math.floor(tileCoordX);\n      tileCoordY = Math.floor(tileCoordY);\n    }\n  \n    return ol.tilecoord.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);\n  };\n  \n  \n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.\n   * @return {ol.TileCoord} Tile coordinate.\n   * @private\n   */\n  ol.tilegrid.TileGrid.prototype.getTileCoordForXYAndZ_ = function(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    var origin = this.getOrigin(z);\n    var resolution = this.getResolution(z);\n    var tileSize = ol.size.toSize(this.getTileSize(z), this.tmpSize_);\n  \n    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n    var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n    var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n    var tileCoordX = xFromOrigin / tileSize[0];\n    var tileCoordY = yFromOrigin / tileSize[1];\n  \n    if (reverseIntersectionPolicy) {\n      tileCoordX = Math.ceil(tileCoordX) - 1;\n      tileCoordY = Math.ceil(tileCoordY) - 1;\n    } else {\n      tileCoordX = Math.floor(tileCoordX);\n      tileCoordY = Math.floor(tileCoordY);\n    }\n  \n    return ol.tilecoord.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);\n  };\n  \n  \n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} z Zoom level.\n   * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.\n   * @return {ol.TileCoord} Tile coordinate.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n        coordinate[0], coordinate[1], z, false, opt_tileCoord);\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  ol.tilegrid.TileGrid.prototype.getTileCoordResolution = function(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  };\n  \n  \n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an `ol.Size`, run the result through `ol.size.toSize()`.\n   * @param {number} z Z.\n   * @return {number|ol.Size} Tile size.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getTileSize = function(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    } else {\n      return this.tileSizes_[z];\n    }\n  };\n  \n  \n  /**\n   * @param {number} z Zoom level.\n   * @return {ol.TileRange} Extent tile range for the specified zoom level.\n   */\n  ol.tilegrid.TileGrid.prototype.getFullTileRange = function(z) {\n    if (!this.fullTileRanges_) {\n      return null;\n    } else {\n      return this.fullTileRanges_[z];\n    }\n  };\n  \n  \n  /**\n   * @param {number} resolution Resolution.\n   * @param {number=} opt_direction If 0, the nearest resolution will be used.\n   *     If 1, the nearest lower resolution will be used. If -1, the nearest\n   *     higher resolution will be used. Default is 0.\n   * @return {number} Z.\n   * @api\n   */\n  ol.tilegrid.TileGrid.prototype.getZForResolution = function(\n      resolution, opt_direction) {\n    var z = ol.array.linearFindNearest(this.resolutions_, resolution,\n        opt_direction || 0);\n    return ol.math.clamp(z, this.minZoom, this.maxZoom);\n  };\n  \n  \n  /**\n   * @param {!ol.Extent} extent Extent for this tile grid.\n   * @private\n   */\n  ol.tilegrid.TileGrid.prototype.calculateTileRanges_ = function(extent) {\n    var length = this.resolutions_.length;\n    var fullTileRanges = new Array(length);\n    for (var z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  };\n  \n  goog.provide('ol.tilegrid');\n  \n  goog.require('ol');\n  goog.require('ol.size');\n  goog.require('ol.extent');\n  goog.require('ol.extent.Corner');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.proj.Units');\n  goog.require('ol.tilegrid.TileGrid');\n  \n  \n  /**\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {!ol.tilegrid.TileGrid} Default tile grid for the passed projection.\n   */\n  ol.tilegrid.getForProjection = function(projection) {\n    var tileGrid = projection.getDefaultTileGrid();\n    if (!tileGrid) {\n      tileGrid = ol.tilegrid.createForProjection(projection);\n      projection.setDefaultTileGrid(tileGrid);\n    }\n    return tileGrid;\n  };\n  \n  \n  /**\n   * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {ol.TileCoord} Tile coordinate.\n   */\n  ol.tilegrid.wrapX = function(tileGrid, tileCoord, projection) {\n    var z = tileCoord[0];\n    var center = tileGrid.getTileCoordCenter(tileCoord);\n    var projectionExtent = ol.tilegrid.extentFromProjection(projection);\n    if (!ol.extent.containsCoordinate(projectionExtent, center)) {\n      var worldWidth = ol.extent.getWidth(projectionExtent);\n      var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n      center[0] += worldWidth * worldsAway;\n      return tileGrid.getTileCoordForCoordAndZ(center, z);\n    } else {\n      return tileCoord;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {number=} opt_maxZoom Maximum zoom level (default is\n   *     ol.DEFAULT_MAX_ZOOM).\n   * @param {number|ol.Size=} opt_tileSize Tile size (default uses\n   *     ol.DEFAULT_TILE_SIZE).\n   * @param {ol.extent.Corner=} opt_corner Extent corner (default is\n   *     ol.extent.Corner.TOP_LEFT).\n   * @return {!ol.tilegrid.TileGrid} TileGrid instance.\n   */\n  ol.tilegrid.createForExtent = function(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n    var corner = opt_corner !== undefined ?\n      opt_corner : ol.extent.Corner.TOP_LEFT;\n  \n    var resolutions = ol.tilegrid.resolutionsFromExtent(\n        extent, opt_maxZoom, opt_tileSize);\n  \n    return new ol.tilegrid.TileGrid({\n      extent: extent,\n      origin: ol.extent.getCorner(extent, corner),\n      resolutions: resolutions,\n      tileSize: opt_tileSize\n    });\n  };\n  \n  \n  /**\n   * Creates a tile grid with a standard XYZ tiling scheme.\n   * @param {olx.tilegrid.XYZOptions=} opt_options Tile grid options.\n   * @return {!ol.tilegrid.TileGrid} Tile grid instance.\n   * @api\n   */\n  ol.tilegrid.createXYZ = function(opt_options) {\n    var options = /** @type {olx.tilegrid.TileGridOptions} */ ({});\n    ol.obj.assign(options, opt_options !== undefined ?\n      opt_options : /** @type {olx.tilegrid.XYZOptions} */ ({}));\n    if (options.extent === undefined) {\n      options.extent = ol.proj.get('EPSG:3857').getExtent();\n    }\n    options.resolutions = ol.tilegrid.resolutionsFromExtent(\n        options.extent, options.maxZoom, options.tileSize);\n    delete options.maxZoom;\n  \n    return new ol.tilegrid.TileGrid(options);\n  };\n  \n  \n  /**\n   * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n   * @param {ol.Extent} extent Extent.\n   * @param {number=} opt_maxZoom Maximum zoom level (default is\n   *     ol.DEFAULT_MAX_ZOOM).\n   * @param {number|ol.Size=} opt_tileSize Tile size (default uses\n   *     ol.DEFAULT_TILE_SIZE).\n   * @return {!Array.<number>} Resolutions array.\n   */\n  ol.tilegrid.resolutionsFromExtent = function(extent, opt_maxZoom, opt_tileSize) {\n    var maxZoom = opt_maxZoom !== undefined ?\n      opt_maxZoom : ol.DEFAULT_MAX_ZOOM;\n  \n    var height = ol.extent.getHeight(extent);\n    var width = ol.extent.getWidth(extent);\n  \n    var tileSize = ol.size.toSize(opt_tileSize !== undefined ?\n      opt_tileSize : ol.DEFAULT_TILE_SIZE);\n    var maxResolution = Math.max(\n        width / tileSize[0], height / tileSize[1]);\n  \n    var length = maxZoom + 1;\n    var resolutions = new Array(length);\n    for (var z = 0; z < length; ++z) {\n      resolutions[z] = maxResolution / Math.pow(2, z);\n    }\n    return resolutions;\n  };\n  \n  \n  /**\n   * @param {ol.ProjectionLike} projection Projection.\n   * @param {number=} opt_maxZoom Maximum zoom level (default is\n   *     ol.DEFAULT_MAX_ZOOM).\n   * @param {number|ol.Size=} opt_tileSize Tile size (default uses\n   *     ol.DEFAULT_TILE_SIZE).\n   * @param {ol.extent.Corner=} opt_corner Extent corner (default is\n   *     ol.extent.Corner.BOTTOM_LEFT).\n   * @return {!ol.tilegrid.TileGrid} TileGrid instance.\n   */\n  ol.tilegrid.createForProjection = function(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n    var extent = ol.tilegrid.extentFromProjection(projection);\n    return ol.tilegrid.createForExtent(\n        extent, opt_maxZoom, opt_tileSize, opt_corner);\n  };\n  \n  \n  /**\n   * Generate a tile grid extent from a projection.  If the projection has an\n   * extent, it is used.  If not, a global extent is assumed.\n   * @param {ol.ProjectionLike} projection Projection.\n   * @return {ol.Extent} Extent.\n   */\n  ol.tilegrid.extentFromProjection = function(projection) {\n    projection = ol.proj.get(projection);\n    var extent = projection.getExtent();\n    if (!extent) {\n      var half = 180 * ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES] /\n          projection.getMetersPerUnit();\n      extent = ol.extent.createOrUpdate(-half, -half, half, half);\n    }\n    return extent;\n  };\n  \n  goog.provide('ol.Attribution');\n  \n  goog.require('ol.TileRange');\n  goog.require('ol.math');\n  goog.require('ol.tilegrid');\n  \n  \n  /**\n   * @classdesc\n   * An attribution for a layer source.\n   *\n   * Example:\n   *\n   *     source: new ol.source.OSM({\n   *       attributions: [\n   *         new ol.Attribution({\n   *           html: 'All maps &copy; ' +\n   *               '<a href=\"https://www.opencyclemap.org/\">OpenCycleMap</a>'\n   *         }),\n   *         ol.source.OSM.ATTRIBUTION\n   *       ],\n   *     ..\n   *\n   * @constructor\n   * @deprecated This class is deprecated and will removed in the next major release.\n   * @param {olx.AttributionOptions} options Attribution options.\n   * @struct\n   * @api\n   */\n  ol.Attribution = function(options) {\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.html_ = options.html;\n  \n    /**\n     * @private\n     * @type {Object.<string, Array.<ol.TileRange>>}\n     */\n    this.tileRanges_ = options.tileRanges ? options.tileRanges : null;\n  \n  };\n  \n  \n  /**\n   * Get the attribution markup.\n   * @return {string} The attribution HTML.\n   * @api\n   */\n  ol.Attribution.prototype.getHTML = function() {\n    return this.html_;\n  };\n  \n  \n  /**\n   * @param {Object.<string, ol.TileRange>} tileRanges Tile ranges.\n   * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.\n   * @param {!ol.proj.Projection} projection Projection.\n   * @return {boolean} Intersects any tile range.\n   */\n  ol.Attribution.prototype.intersectsAnyTileRange = function(tileRanges, tileGrid, projection) {\n    if (!this.tileRanges_) {\n      return true;\n    }\n    var i, ii, tileRange, zKey;\n    for (zKey in tileRanges) {\n      if (!(zKey in this.tileRanges_)) {\n        continue;\n      }\n      tileRange = tileRanges[zKey];\n      var testTileRange;\n      for (i = 0, ii = this.tileRanges_[zKey].length; i < ii; ++i) {\n        testTileRange = this.tileRanges_[zKey][i];\n        if (testTileRange.intersects(tileRange)) {\n          return true;\n        }\n        var extentTileRange = tileGrid.getTileRangeForExtentAndZ(\n            ol.tilegrid.extentFromProjection(projection), parseInt(zKey, 10));\n        var width = extentTileRange.getWidth();\n        if (tileRange.minX < extentTileRange.minX ||\n            tileRange.maxX > extentTileRange.maxX) {\n          if (testTileRange.intersects(new ol.TileRange(\n              ol.math.modulo(tileRange.minX, width),\n              ol.math.modulo(tileRange.maxX, width),\n              tileRange.minY, tileRange.maxY))) {\n            return true;\n          }\n          if (tileRange.getWidth() > width &&\n              testTileRange.intersects(extentTileRange)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n  \n  goog.provide('ol.CollectionEventType');\n  \n  /**\n   * @enum {string}\n   */\n  ol.CollectionEventType = {\n    /**\n     * Triggered when an item is added to the collection.\n     * @event ol.Collection.Event#add\n     * @api\n     */\n    ADD: 'add',\n    /**\n     * Triggered when an item is removed from the collection.\n     * @event ol.Collection.Event#remove\n     * @api\n     */\n    REMOVE: 'remove'\n  };\n  \n  goog.provide('ol.ObjectEventType');\n  \n  /**\n   * @enum {string}\n   */\n  ol.ObjectEventType = {\n    /**\n     * Triggered when a property is changed.\n     * @event ol.Object.Event#propertychange\n     * @api\n     */\n    PROPERTYCHANGE: 'propertychange'\n  };\n  \n  goog.provide('ol.events');\n  \n  goog.require('ol.obj');\n  \n  \n  /**\n   * @param {ol.EventsKey} listenerObj Listener object.\n   * @return {ol.EventsListenerFunctionType} Bound listener.\n   */\n  ol.events.bindListener_ = function(listenerObj) {\n    var boundListener = function(evt) {\n      var listener = listenerObj.listener;\n      var bindTo = listenerObj.bindTo || listenerObj.target;\n      if (listenerObj.callOnce) {\n        ol.events.unlistenByKey(listenerObj);\n      }\n      return listener.call(bindTo, evt);\n    };\n    listenerObj.boundListener = boundListener;\n    return boundListener;\n  };\n  \n  \n  /**\n   * Finds the matching {@link ol.EventsKey} in the given listener\n   * array.\n   *\n   * @param {!Array<!ol.EventsKey>} listeners Array of listeners.\n   * @param {!Function} listener The listener function.\n   * @param {Object=} opt_this The `this` value inside the listener.\n   * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching\n   *     listener, for {@link ol.events.unlistenByKey}.\n   * @return {ol.EventsKey|undefined} The matching listener object.\n   * @private\n   */\n  ol.events.findListener_ = function(listeners, listener, opt_this,\n      opt_setDeleteIndex) {\n    var listenerObj;\n    for (var i = 0, ii = listeners.length; i < ii; ++i) {\n      listenerObj = listeners[i];\n      if (listenerObj.listener === listener &&\n          listenerObj.bindTo === opt_this) {\n        if (opt_setDeleteIndex) {\n          listenerObj.deleteIndex = i;\n        }\n        return listenerObj;\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @param {ol.EventTargetLike} target Target.\n   * @param {string} type Type.\n   * @return {Array.<ol.EventsKey>|undefined} Listeners.\n   */\n  ol.events.getListeners = function(target, type) {\n    var listenerMap = target.ol_lm;\n    return listenerMap ? listenerMap[type] : undefined;\n  };\n  \n  \n  /**\n   * Get the lookup of listeners.  If one does not exist on the target, it is\n   * created.\n   * @param {ol.EventTargetLike} target Target.\n   * @return {!Object.<string, Array.<ol.EventsKey>>} Map of\n   *     listeners by event type.\n   * @private\n   */\n  ol.events.getListenerMap_ = function(target) {\n    var listenerMap = target.ol_lm;\n    if (!listenerMap) {\n      listenerMap = target.ol_lm = {};\n    }\n    return listenerMap;\n  };\n  \n  \n  /**\n   * Clean up all listener objects of the given type.  All properties on the\n   * listener objects will be removed, and if no listeners remain in the listener\n   * map, it will be removed from the target.\n   * @param {ol.EventTargetLike} target Target.\n   * @param {string} type Type.\n   * @private\n   */\n  ol.events.removeListeners_ = function(target, type) {\n    var listeners = ol.events.getListeners(target, type);\n    if (listeners) {\n      for (var i = 0, ii = listeners.length; i < ii; ++i) {\n        target.removeEventListener(type, listeners[i].boundListener);\n        ol.obj.clear(listeners[i]);\n      }\n      listeners.length = 0;\n      var listenerMap = target.ol_lm;\n      if (listenerMap) {\n        delete listenerMap[type];\n        if (Object.keys(listenerMap).length === 0) {\n          delete target.ol_lm;\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * Registers an event listener on an event target. Inspired by\n   * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n   *\n   * This function efficiently binds a `listener` to a `this` object, and returns\n   * a key for use with {@link ol.events.unlistenByKey}.\n   *\n   * @param {ol.EventTargetLike} target Event target.\n   * @param {string} type Event type.\n   * @param {ol.EventsListenerFunctionType} listener Listener.\n   * @param {Object=} opt_this Object referenced by the `this` keyword in the\n   *     listener. Default is the `target`.\n   * @param {boolean=} opt_once If true, add the listener as one-off listener.\n   * @return {ol.EventsKey} Unique key for the listener.\n   */\n  ol.events.listen = function(target, type, listener, opt_this, opt_once) {\n    var listenerMap = ol.events.getListenerMap_(target);\n    var listeners = listenerMap[type];\n    if (!listeners) {\n      listeners = listenerMap[type] = [];\n    }\n    var listenerObj = ol.events.findListener_(listeners, listener, opt_this,\n        false);\n    if (listenerObj) {\n      if (!opt_once) {\n        // Turn one-off listener into a permanent one.\n        listenerObj.callOnce = false;\n      }\n    } else {\n      listenerObj = /** @type {ol.EventsKey} */ ({\n        bindTo: opt_this,\n        callOnce: !!opt_once,\n        listener: listener,\n        target: target,\n        type: type\n      });\n      target.addEventListener(type, ol.events.bindListener_(listenerObj));\n      listeners.push(listenerObj);\n    }\n  \n    return listenerObj;\n  };\n  \n  \n  /**\n   * Registers a one-off event listener on an event target. Inspired by\n   * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n   *\n   * This function efficiently binds a `listener` as self-unregistering listener\n   * to a `this` object, and returns a key for use with\n   * {@link ol.events.unlistenByKey} in case the listener needs to be unregistered\n   * before it is called.\n   *\n   * When {@link ol.events.listen} is called with the same arguments after this\n   * function, the self-unregistering listener will be turned into a permanent\n   * listener.\n   *\n   * @param {ol.EventTargetLike} target Event target.\n   * @param {string} type Event type.\n   * @param {ol.EventsListenerFunctionType} listener Listener.\n   * @param {Object=} opt_this Object referenced by the `this` keyword in the\n   *     listener. Default is the `target`.\n   * @return {ol.EventsKey} Key for unlistenByKey.\n   */\n  ol.events.listenOnce = function(target, type, listener, opt_this) {\n    return ol.events.listen(target, type, listener, opt_this, true);\n  };\n  \n  \n  /**\n   * Unregisters an event listener on an event target. Inspired by\n   * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n   *\n   * To return a listener, this function needs to be called with the exact same\n   * arguments that were used for a previous {@link ol.events.listen} call.\n   *\n   * @param {ol.EventTargetLike} target Event target.\n   * @param {string} type Event type.\n   * @param {ol.EventsListenerFunctionType} listener Listener.\n   * @param {Object=} opt_this Object referenced by the `this` keyword in the\n   *     listener. Default is the `target`.\n   */\n  ol.events.unlisten = function(target, type, listener, opt_this) {\n    var listeners = ol.events.getListeners(target, type);\n    if (listeners) {\n      var listenerObj = ol.events.findListener_(listeners, listener, opt_this,\n          true);\n      if (listenerObj) {\n        ol.events.unlistenByKey(listenerObj);\n      }\n    }\n  };\n  \n  \n  /**\n   * Unregisters event listeners on an event target. Inspired by\n   * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n   *\n   * The argument passed to this function is the key returned from\n   * {@link ol.events.listen} or {@link ol.events.listenOnce}.\n   *\n   * @param {ol.EventsKey} key The key.\n   */\n  ol.events.unlistenByKey = function(key) {\n    if (key && key.target) {\n      key.target.removeEventListener(key.type, key.boundListener);\n      var listeners = ol.events.getListeners(key.target, key.type);\n      if (listeners) {\n        var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);\n        if (i !== -1) {\n          listeners.splice(i, 1);\n        }\n        if (listeners.length === 0) {\n          ol.events.removeListeners_(key.target, key.type);\n        }\n      }\n      ol.obj.clear(key);\n    }\n  };\n  \n  \n  /**\n   * Unregisters all event listeners on an event target. Inspired by\n   * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\n   *\n   * @param {ol.EventTargetLike} target Target.\n   */\n  ol.events.unlistenAll = function(target) {\n    var listenerMap = ol.events.getListenerMap_(target);\n    for (var type in listenerMap) {\n      ol.events.removeListeners_(target, type);\n    }\n  };\n  \n  goog.provide('ol.Disposable');\n  \n  goog.require('ol');\n  \n  /**\n   * Objects that need to clean up after themselves.\n   * @constructor\n   */\n  ol.Disposable = function() {};\n  \n  /**\n   * The object has already been disposed.\n   * @type {boolean}\n   * @private\n   */\n  ol.Disposable.prototype.disposed_ = false;\n  \n  /**\n   * Clean up.\n   */\n  ol.Disposable.prototype.dispose = function() {\n    if (!this.disposed_) {\n      this.disposed_ = true;\n      this.disposeInternal();\n    }\n  };\n  \n  /**\n   * Extension point for disposable objects.\n   * @protected\n   */\n  ol.Disposable.prototype.disposeInternal = ol.nullFunction;\n  \n  goog.provide('ol.events.Event');\n  \n  \n  /**\n   * @classdesc\n   * Stripped down implementation of the W3C DOM Level 2 Event interface.\n   * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}\n   *\n   * This implementation only provides `type` and `target` properties, and\n   * `stopPropagation` and `preventDefault` methods. It is meant as base class\n   * for higher level events defined in the library, and works with\n   * {@link ol.events.EventTarget}.\n   *\n   * @constructor\n   * @implements {oli.events.Event}\n   * @param {string} type Type.\n   */\n  ol.events.Event = function(type) {\n  \n    /**\n     * @type {boolean}\n     */\n    this.propagationStopped;\n  \n    /**\n     * The event type.\n     * @type {string}\n     * @api\n     */\n    this.type = type;\n  \n    /**\n     * The event target.\n     * @type {Object}\n     * @api\n     */\n    this.target = null;\n  \n  };\n  \n  \n  /**\n   * Stop event propagation.\n   * @function\n   * @override\n   * @api\n   */\n  ol.events.Event.prototype.preventDefault =\n  \n    /**\n     * Stop event propagation.\n     * @function\n     * @override\n     * @api\n     */\n    ol.events.Event.prototype.stopPropagation = function() {\n      this.propagationStopped = true;\n    };\n  \n  \n  /**\n   * @param {Event|ol.events.Event} evt Event\n   */\n  ol.events.Event.stopPropagation = function(evt) {\n    evt.stopPropagation();\n  };\n  \n  \n  /**\n   * @param {Event|ol.events.Event} evt Event\n   */\n  ol.events.Event.preventDefault = function(evt) {\n    evt.preventDefault();\n  };\n  \n  goog.provide('ol.events.EventTarget');\n  \n  goog.require('ol');\n  goog.require('ol.Disposable');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  \n  \n  /**\n   * @classdesc\n   * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n   * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}\n   *\n   * There are two important simplifications compared to the specification:\n   *\n   * 1. The handling of `useCapture` in `addEventListener` and\n   *    `removeEventListener`. There is no real capture model.\n   * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n   *    There is no event target hierarchy. When a listener calls\n   *    `stopPropagation` or `preventDefault` on an event object, it means that no\n   *    more listeners after this one will be called. Same as when the listener\n   *    returns false.\n   *\n   * @constructor\n   * @extends {ol.Disposable}\n   */\n  ol.events.EventTarget = function() {\n  \n    ol.Disposable.call(this);\n  \n    /**\n     * @private\n     * @type {!Object.<string, number>}\n     */\n    this.pendingRemovals_ = {};\n  \n    /**\n     * @private\n     * @type {!Object.<string, number>}\n     */\n    this.dispatching_ = {};\n  \n    /**\n     * @private\n     * @type {!Object.<string, Array.<ol.EventsListenerFunctionType>>}\n     */\n    this.listeners_ = {};\n  \n  };\n  ol.inherits(ol.events.EventTarget, ol.Disposable);\n  \n  \n  /**\n   * @param {string} type Type.\n   * @param {ol.EventsListenerFunctionType} listener Listener.\n   */\n  ol.events.EventTarget.prototype.addEventListener = function(type, listener) {\n    var listeners = this.listeners_[type];\n    if (!listeners) {\n      listeners = this.listeners_[type] = [];\n    }\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener);\n    }\n  };\n  \n  \n  /**\n   * @param {{type: string,\n   *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|\n   *     string} event Event or event type.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   */\n  ol.events.EventTarget.prototype.dispatchEvent = function(event) {\n    var evt = typeof event === 'string' ? new ol.events.Event(event) : event;\n    var type = evt.type;\n    evt.target = this;\n    var listeners = this.listeners_[type];\n    var propagate;\n    if (listeners) {\n      if (!(type in this.dispatching_)) {\n        this.dispatching_[type] = 0;\n        this.pendingRemovals_[type] = 0;\n      }\n      ++this.dispatching_[type];\n      for (var i = 0, ii = listeners.length; i < ii; ++i) {\n        if (listeners[i].call(this, evt) === false || evt.propagationStopped) {\n          propagate = false;\n          break;\n        }\n      }\n      --this.dispatching_[type];\n      if (this.dispatching_[type] === 0) {\n        var pendingRemovals = this.pendingRemovals_[type];\n        delete this.pendingRemovals_[type];\n        while (pendingRemovals--) {\n          this.removeEventListener(type, ol.nullFunction);\n        }\n        delete this.dispatching_[type];\n      }\n      return propagate;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.events.EventTarget.prototype.disposeInternal = function() {\n    ol.events.unlistenAll(this);\n  };\n  \n  \n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array.<ol.EventsListenerFunctionType>} Listeners.\n   */\n  ol.events.EventTarget.prototype.getListeners = function(type) {\n    return this.listeners_[type];\n  };\n  \n  \n  /**\n   * @param {string=} opt_type Type. If not provided,\n   *     `true` will be returned if this EventTarget has any listeners.\n   * @return {boolean} Has listeners.\n   */\n  ol.events.EventTarget.prototype.hasListener = function(opt_type) {\n    return opt_type ?\n      opt_type in this.listeners_ :\n      Object.keys(this.listeners_).length > 0;\n  };\n  \n  \n  /**\n   * @param {string} type Type.\n   * @param {ol.EventsListenerFunctionType} listener Listener.\n   */\n  ol.events.EventTarget.prototype.removeEventListener = function(type, listener) {\n    var listeners = this.listeners_[type];\n    if (listeners) {\n      var index = listeners.indexOf(listener);\n      if (type in this.pendingRemovals_) {\n        // make listener a no-op, and remove later in #dispatchEvent()\n        listeners[index] = ol.nullFunction;\n        ++this.pendingRemovals_[type];\n      } else {\n        listeners.splice(index, 1);\n        if (listeners.length === 0) {\n          delete this.listeners_[type];\n        }\n      }\n    }\n  };\n  \n  goog.provide('ol.events.EventType');\n  \n  /**\n   * @enum {string}\n   * @const\n   */\n  ol.events.EventType = {\n    /**\n     * Generic change event. Triggered when the revision counter is increased.\n     * @event ol.events.Event#change\n     * @api\n     */\n    CHANGE: 'change',\n  \n    CLEAR: 'clear',\n    CLICK: 'click',\n    DBLCLICK: 'dblclick',\n    DRAGENTER: 'dragenter',\n    DRAGOVER: 'dragover',\n    DROP: 'drop',\n    ERROR: 'error',\n    KEYDOWN: 'keydown',\n    KEYPRESS: 'keypress',\n    LOAD: 'load',\n    MOUSEDOWN: 'mousedown',\n    MOUSEMOVE: 'mousemove',\n    MOUSEOUT: 'mouseout',\n    MOUSEUP: 'mouseup',\n    MOUSEWHEEL: 'mousewheel',\n    MSPOINTERDOWN: 'MSPointerDown',\n    RESIZE: 'resize',\n    TOUCHSTART: 'touchstart',\n    TOUCHMOVE: 'touchmove',\n    TOUCHEND: 'touchend',\n    WHEEL: 'wheel'\n  };\n  \n  goog.provide('ol.Observable');\n  \n  goog.require('ol');\n  goog.require('ol.events');\n  goog.require('ol.events.EventTarget');\n  goog.require('ol.events.EventType');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * An event target providing convenient methods for listener registration\n   * and unregistration. A generic `change` event is always available through\n   * {@link ol.Observable#changed}.\n   *\n   * @constructor\n   * @extends {ol.events.EventTarget}\n   * @fires ol.events.Event\n   * @struct\n   * @api\n   */\n  ol.Observable = function() {\n  \n    ol.events.EventTarget.call(this);\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.revision_ = 0;\n  \n  };\n  ol.inherits(ol.Observable, ol.events.EventTarget);\n  \n  \n  /**\n   * Removes an event listener using the key returned by `on()` or `once()`.\n   * @param {ol.EventsKey|Array.<ol.EventsKey>} key The key returned by `on()`\n   *     or `once()` (or an array of keys).\n   * @api\n   */\n  ol.Observable.unByKey = function(key) {\n    if (Array.isArray(key)) {\n      for (var i = 0, ii = key.length; i < ii; ++i) {\n        ol.events.unlistenByKey(key[i]);\n      }\n    } else {\n      ol.events.unlistenByKey(/** @type {ol.EventsKey} */ (key));\n    }\n  };\n  \n  \n  /**\n   * Increases the revision counter and dispatches a 'change' event.\n   * @api\n   */\n  ol.Observable.prototype.changed = function() {\n    ++this.revision_;\n    this.dispatchEvent(ol.events.EventType.CHANGE);\n  };\n  \n  \n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {{type: string,\n   *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|\n   *     string} event Event object.\n   * @function\n   * @api\n   */\n  ol.Observable.prototype.dispatchEvent;\n  \n  \n  /**\n   * Get the version number for this object.  Each time the object is modified,\n   * its version number will be incremented.\n   * @return {number} Revision.\n   * @api\n   */\n  ol.Observable.prototype.getRevision = function() {\n    return this.revision_;\n  };\n  \n  \n  /**\n   * Listen for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @param {Object=} opt_this The object to use as `this` in `listener`.\n   * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n  ol.Observable.prototype.on = function(type, listener, opt_this) {\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n      for (var i = 0; i < len; ++i) {\n        keys[i] = ol.events.listen(this, type[i], listener, opt_this);\n      }\n      return keys;\n    } else {\n      return ol.events.listen(\n          this, /** @type {string} */ (type), listener, opt_this);\n    }\n  };\n  \n  \n  /**\n   * Listen once for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @param {Object=} opt_this The object to use as `this` in `listener`.\n   * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n  ol.Observable.prototype.once = function(type, listener, opt_this) {\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n      for (var i = 0; i < len; ++i) {\n        keys[i] = ol.events.listenOnce(this, type[i], listener, opt_this);\n      }\n      return keys;\n    } else {\n      return ol.events.listenOnce(\n          this, /** @type {string} */ (type), listener, opt_this);\n    }\n  };\n  \n  \n  /**\n   * Unlisten for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @param {Object=} opt_this The object which was used as `this` by the\n   * `listener`.\n   * @api\n   */\n  ol.Observable.prototype.un = function(type, listener, opt_this) {\n    if (Array.isArray(type)) {\n      for (var i = 0, ii = type.length; i < ii; ++i) {\n        ol.events.unlisten(this, type[i], listener, opt_this);\n      }\n      return;\n    } else {\n      ol.events.unlisten(this, /** @type {string} */ (type), listener, opt_this);\n    }\n  };\n  \n  goog.provide('ol.Object');\n  \n  goog.require('ol');\n  goog.require('ol.ObjectEventType');\n  goog.require('ol.Observable');\n  goog.require('ol.events.Event');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Most non-trivial classes inherit from this.\n   *\n   * This extends {@link ol.Observable} with observable properties, where each\n   * property is observable as well as the object as a whole.\n   *\n   * Classes that inherit from this have pre-defined properties, to which you can\n   * add your owns. The pre-defined properties are listed in this documentation as\n   * 'Observable Properties', and have their own accessors; for example,\n   * {@link ol.Map} has a `target` property, accessed with `getTarget()`  and\n   * changed with `setTarget()`. Not all properties are however settable. There\n   * are also general-purpose accessors `get()` and `set()`. For example,\n   * `get('target')` is equivalent to `getTarget()`.\n   *\n   * The `set` accessors trigger a change event, and you can monitor this by\n   * registering a listener. For example, {@link ol.View} has a `center`\n   * property, so `view.on('change:center', function(evt) {...});` would call the\n   * function whenever the value of the center property changes. Within the\n   * function, `evt.target` would be the view, so `evt.target.getCenter()` would\n   * return the new center.\n   *\n   * You can add your own observable properties with\n   * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\n   * You can listen for changes on that property value with\n   * `object.on('change:prop', listener)`. You can get a list of all\n   * properties with {@link ol.Object#getProperties object.getProperties()}.\n   *\n   * Note that the observable properties are separate from standard JS properties.\n   * You can, for example, give your map object a title with\n   * `map.title='New title'` and with `map.set('title', 'Another title')`. The\n   * first will be a `hasOwnProperty`; the second will appear in\n   * `getProperties()`. Only the second is observable.\n   *\n   * Properties can be deleted by using the unset method. E.g.\n   * object.unset('foo').\n   *\n   * @constructor\n   * @extends {ol.Observable}\n   * @param {Object.<string, *>=} opt_values An object with key-value pairs.\n   * @fires ol.Object.Event\n   * @api\n   */\n  ol.Object = function(opt_values) {\n    ol.Observable.call(this);\n  \n    // Call ol.getUid to ensure that the order of objects' ids is the same as\n    // the order in which they were created.  This also helps to ensure that\n    // object properties are always added in the same order, which helps many\n    // JavaScript engines generate faster code.\n    ol.getUid(this);\n  \n    /**\n     * @private\n     * @type {!Object.<string, *>}\n     */\n    this.values_ = {};\n  \n    if (opt_values !== undefined) {\n      this.setProperties(opt_values);\n    }\n  };\n  ol.inherits(ol.Object, ol.Observable);\n  \n  \n  /**\n   * @private\n   * @type {Object.<string, string>}\n   */\n  ol.Object.changeEventTypeCache_ = {};\n  \n  \n  /**\n   * @param {string} key Key name.\n   * @return {string} Change name.\n   */\n  ol.Object.getChangeEventType = function(key) {\n    return ol.Object.changeEventTypeCache_.hasOwnProperty(key) ?\n      ol.Object.changeEventTypeCache_[key] :\n      (ol.Object.changeEventTypeCache_[key] = 'change:' + key);\n  };\n  \n  \n  /**\n   * Gets a value.\n   * @param {string} key Key name.\n   * @return {*} Value.\n   * @api\n   */\n  ol.Object.prototype.get = function(key) {\n    var value;\n    if (this.values_.hasOwnProperty(key)) {\n      value = this.values_[key];\n    }\n    return value;\n  };\n  \n  \n  /**\n   * Get a list of object property names.\n   * @return {Array.<string>} List of property names.\n   * @api\n   */\n  ol.Object.prototype.getKeys = function() {\n    return Object.keys(this.values_);\n  };\n  \n  \n  /**\n   * Get an object of all property names and values.\n   * @return {Object.<string, *>} Object.\n   * @api\n   */\n  ol.Object.prototype.getProperties = function() {\n    return ol.obj.assign({}, this.values_);\n  };\n  \n  \n  /**\n   * @param {string} key Key name.\n   * @param {*} oldValue Old value.\n   */\n  ol.Object.prototype.notify = function(key, oldValue) {\n    var eventType;\n    eventType = ol.Object.getChangeEventType(key);\n    this.dispatchEvent(new ol.Object.Event(eventType, key, oldValue));\n    eventType = ol.ObjectEventType.PROPERTYCHANGE;\n    this.dispatchEvent(new ol.Object.Event(eventType, key, oldValue));\n  };\n  \n  \n  /**\n   * Sets a value.\n   * @param {string} key Key name.\n   * @param {*} value Value.\n   * @param {boolean=} opt_silent Update without triggering an event.\n   * @api\n   */\n  ol.Object.prototype.set = function(key, value, opt_silent) {\n    if (opt_silent) {\n      this.values_[key] = value;\n    } else {\n      var oldValue = this.values_[key];\n      this.values_[key] = value;\n      if (oldValue !== value) {\n        this.notify(key, oldValue);\n      }\n    }\n  };\n  \n  \n  /**\n   * Sets a collection of key-value pairs.  Note that this changes any existing\n   * properties and adds new ones (it does not remove any existing properties).\n   * @param {Object.<string, *>} values Values.\n   * @param {boolean=} opt_silent Update without triggering an event.\n   * @api\n   */\n  ol.Object.prototype.setProperties = function(values, opt_silent) {\n    var key;\n    for (key in values) {\n      this.set(key, values[key], opt_silent);\n    }\n  };\n  \n  \n  /**\n   * Unsets a property.\n   * @param {string} key Key name.\n   * @param {boolean=} opt_silent Unset without triggering an event.\n   * @api\n   */\n  ol.Object.prototype.unset = function(key, opt_silent) {\n    if (key in this.values_) {\n      var oldValue = this.values_[key];\n      delete this.values_[key];\n      if (!opt_silent) {\n        this.notify(key, oldValue);\n      }\n    }\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.Object} instances are instances of this type.\n   *\n   * @param {string} type The event type.\n   * @param {string} key The property name.\n   * @param {*} oldValue The old value for `key`.\n   * @extends {ol.events.Event}\n   * @implements {oli.Object.Event}\n   * @constructor\n   */\n  ol.Object.Event = function(type, key, oldValue) {\n    ol.events.Event.call(this, type);\n  \n    /**\n     * The name of the property whose value is changing.\n     * @type {string}\n     * @api\n     */\n    this.key = key;\n  \n    /**\n     * The old value. To get the new value use `e.target.get(e.key)` where\n     * `e` is the event object.\n     * @type {*}\n     * @api\n     */\n    this.oldValue = oldValue;\n  \n  };\n  ol.inherits(ol.Object.Event, ol.events.Event);\n  \n  /**\n   * An implementation of Google Maps' MVCArray.\n   * @see https://developers.google.com/maps/documentation/javascript/reference\n   */\n  \n  goog.provide('ol.Collection');\n  \n  goog.require('ol');\n  goog.require('ol.AssertionError');\n  goog.require('ol.CollectionEventType');\n  goog.require('ol.Object');\n  goog.require('ol.events.Event');\n  \n  \n  /**\n   * @classdesc\n   * An expanded version of standard JS Array, adding convenience methods for\n   * manipulation. Add and remove changes to the Collection trigger a Collection\n   * event. Note that this does not cover changes to the objects _within_ the\n   * Collection; they trigger events on the appropriate object, not on the\n   * Collection as a whole.\n   *\n   * @constructor\n   * @extends {ol.Object}\n   * @fires ol.Collection.Event\n   * @param {Array.<T>=} opt_array Array.\n   * @param {olx.CollectionOptions=} opt_options Collection options.\n   * @template T\n   * @api\n   */\n  ol.Collection = function(opt_array, opt_options) {\n  \n    ol.Object.call(this);\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.unique_ = !!options.unique;\n  \n    /**\n     * @private\n     * @type {!Array.<T>}\n     */\n    this.array_ = opt_array ? opt_array : [];\n  \n    if (this.unique_) {\n      for (var i = 0, ii = this.array_.length; i < ii; ++i) {\n        this.assertUnique_(this.array_[i], i);\n      }\n    }\n  \n    this.updateLength_();\n  \n  };\n  ol.inherits(ol.Collection, ol.Object);\n  \n  \n  /**\n   * Remove all elements from the collection.\n   * @api\n   */\n  ol.Collection.prototype.clear = function() {\n    while (this.getLength() > 0) {\n      this.pop();\n    }\n  };\n  \n  \n  /**\n   * Add elements to the collection.  This pushes each item in the provided array\n   * to the end of the collection.\n   * @param {!Array.<T>} arr Array.\n   * @return {ol.Collection.<T>} This collection.\n   * @api\n   */\n  ol.Collection.prototype.extend = function(arr) {\n    var i, ii;\n    for (i = 0, ii = arr.length; i < ii; ++i) {\n      this.push(arr[i]);\n    }\n    return this;\n  };\n  \n  \n  /**\n   * Iterate over each element, calling the provided callback.\n   * @param {function(this: S, T, number, Array.<T>): *} f The function to call\n   *     for every element. This function takes 3 arguments (the element, the\n   *     index and the array). The return value is ignored.\n   * @param {S=} opt_this The object to use as `this` in `f`.\n   * @template S\n   * @api\n   */\n  ol.Collection.prototype.forEach = function(f, opt_this) {\n    var fn = (opt_this) ? f.bind(opt_this) : f;\n    var array = this.array_;\n    for (var i = 0, ii = array.length; i < ii; ++i) {\n      fn(array[i], i, array);\n    }\n  };\n  \n  \n  /**\n   * Get a reference to the underlying Array object. Warning: if the array\n   * is mutated, no events will be dispatched by the collection, and the\n   * collection's \"length\" property won't be in sync with the actual length\n   * of the array.\n   * @return {!Array.<T>} Array.\n   * @api\n   */\n  ol.Collection.prototype.getArray = function() {\n    return this.array_;\n  };\n  \n  \n  /**\n   * Get the element at the provided index.\n   * @param {number} index Index.\n   * @return {T} Element.\n   * @api\n   */\n  ol.Collection.prototype.item = function(index) {\n    return this.array_[index];\n  };\n  \n  \n  /**\n   * Get the length of this collection.\n   * @return {number} The length of the array.\n   * @observable\n   * @api\n   */\n  ol.Collection.prototype.getLength = function() {\n    return /** @type {number} */ (this.get(ol.Collection.Property_.LENGTH));\n  };\n  \n  \n  /**\n   * Insert an element at the provided index.\n   * @param {number} index Index.\n   * @param {T} elem Element.\n   * @api\n   */\n  ol.Collection.prototype.insertAt = function(index, elem) {\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n    this.array_.splice(index, 0, elem);\n    this.updateLength_();\n    this.dispatchEvent(\n        new ol.Collection.Event(ol.CollectionEventType.ADD, elem));\n  };\n  \n  \n  /**\n   * Remove the last element of the collection and return it.\n   * Return `undefined` if the collection is empty.\n   * @return {T|undefined} Element.\n   * @api\n   */\n  ol.Collection.prototype.pop = function() {\n    return this.removeAt(this.getLength() - 1);\n  };\n  \n  \n  /**\n   * Insert the provided element at the end of the collection.\n   * @param {T} elem Element.\n   * @return {number} New length of the collection.\n   * @api\n   */\n  ol.Collection.prototype.push = function(elem) {\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n    var n = this.getLength();\n    this.insertAt(n, elem);\n    return this.getLength();\n  };\n  \n  \n  /**\n   * Remove the first occurrence of an element from the collection.\n   * @param {T} elem Element.\n   * @return {T|undefined} The removed element or undefined if none found.\n   * @api\n   */\n  ol.Collection.prototype.remove = function(elem) {\n    var arr = this.array_;\n    var i, ii;\n    for (i = 0, ii = arr.length; i < ii; ++i) {\n      if (arr[i] === elem) {\n        return this.removeAt(i);\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * Remove the element at the provided index and return it.\n   * Return `undefined` if the collection does not contain this index.\n   * @param {number} index Index.\n   * @return {T|undefined} Value.\n   * @api\n   */\n  ol.Collection.prototype.removeAt = function(index) {\n    var prev = this.array_[index];\n    this.array_.splice(index, 1);\n    this.updateLength_();\n    this.dispatchEvent(\n        new ol.Collection.Event(ol.CollectionEventType.REMOVE, prev));\n    return prev;\n  };\n  \n  \n  /**\n   * Set the element at the provided index.\n   * @param {number} index Index.\n   * @param {T} elem Element.\n   * @api\n   */\n  ol.Collection.prototype.setAt = function(index, elem) {\n    var n = this.getLength();\n    if (index < n) {\n      if (this.unique_) {\n        this.assertUnique_(elem, index);\n      }\n      var prev = this.array_[index];\n      this.array_[index] = elem;\n      this.dispatchEvent(\n          new ol.Collection.Event(ol.CollectionEventType.REMOVE, prev));\n      this.dispatchEvent(\n          new ol.Collection.Event(ol.CollectionEventType.ADD, elem));\n    } else {\n      var j;\n      for (j = n; j < index; ++j) {\n        this.insertAt(j, undefined);\n      }\n      this.insertAt(index, elem);\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.Collection.prototype.updateLength_ = function() {\n    this.set(ol.Collection.Property_.LENGTH, this.array_.length);\n  };\n  \n  \n  /**\n   * @private\n   * @param {T} elem Element.\n   * @param {number=} opt_except Optional index to ignore.\n   */\n  ol.Collection.prototype.assertUnique_ = function(elem, opt_except) {\n    for (var i = 0, ii = this.array_.length; i < ii; ++i) {\n      if (this.array_[i] === elem && i !== opt_except) {\n        throw new ol.AssertionError(58);\n      }\n    }\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.Collection.Property_ = {\n    LENGTH: 'length'\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.Collection} instances are instances of this\n   * type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.Collection.Event}\n   * @param {ol.CollectionEventType} type Type.\n   * @param {*=} opt_element Element.\n   */\n  ol.Collection.Event = function(type, opt_element) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The element that is added to or removed from the collection.\n     * @type {*}\n     * @api\n     */\n    this.element = opt_element;\n  \n  };\n  ol.inherits(ol.Collection.Event, ol.events.Event);\n  \n  goog.provide('ol.MapEvent');\n  \n  goog.require('ol');\n  goog.require('ol.events.Event');\n  \n  \n  /**\n   * @classdesc\n   * Events emitted as map events are instances of this type.\n   * See {@link ol.Map} for which events trigger a map event.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.MapEvent}\n   * @param {string} type Event type.\n   * @param {ol.PluggableMap} map Map.\n   * @param {?olx.FrameState=} opt_frameState Frame state.\n   */\n  ol.MapEvent = function(type, map, opt_frameState) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The map where the event occurred.\n     * @type {ol.PluggableMap}\n     * @api\n     */\n    this.map = map;\n  \n    /**\n     * The frame state at the time of the event.\n     * @type {?olx.FrameState}\n     * @api\n     */\n    this.frameState = opt_frameState !== undefined ? opt_frameState : null;\n  \n  };\n  ol.inherits(ol.MapEvent, ol.events.Event);\n  \n  goog.provide('ol.MapBrowserEvent');\n  \n  goog.require('ol');\n  goog.require('ol.MapEvent');\n  \n  \n  /**\n   * @classdesc\n   * Events emitted as map browser events are instances of this type.\n   * See {@link ol.Map} for which events trigger a map browser event.\n   *\n   * @constructor\n   * @extends {ol.MapEvent}\n   * @implements {oli.MapBrowserEvent}\n   * @param {string} type Event type.\n   * @param {ol.PluggableMap} map Map.\n   * @param {Event} browserEvent Browser event.\n   * @param {boolean=} opt_dragging Is the map currently being dragged?\n   * @param {?olx.FrameState=} opt_frameState Frame state.\n   */\n  ol.MapBrowserEvent = function(type, map, browserEvent, opt_dragging,\n      opt_frameState) {\n  \n    ol.MapEvent.call(this, type, map, opt_frameState);\n  \n    /**\n     * The original browser event.\n     * @const\n     * @type {Event}\n     * @api\n     */\n    this.originalEvent = browserEvent;\n  \n    /**\n     * The map pixel relative to the viewport corresponding to the original browser event.\n     * @type {ol.Pixel}\n     * @api\n     */\n    this.pixel = map.getEventPixel(browserEvent);\n  \n    /**\n     * The coordinate in view projection corresponding to the original browser event.\n     * @type {ol.Coordinate}\n     * @api\n     */\n    this.coordinate = map.getCoordinateFromPixel(this.pixel);\n  \n    /**\n     * Indicates if the map is currently being dragged. Only set for\n     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.\n     *\n     * @type {boolean}\n     * @api\n     */\n    this.dragging = opt_dragging !== undefined ? opt_dragging : false;\n  \n  };\n  ol.inherits(ol.MapBrowserEvent, ol.MapEvent);\n  \n  \n  /**\n   * Prevents the default browser action.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault\n   * @override\n   * @api\n   */\n  ol.MapBrowserEvent.prototype.preventDefault = function() {\n    ol.MapEvent.prototype.preventDefault.call(this);\n    this.originalEvent.preventDefault();\n  };\n  \n  \n  /**\n   * Prevents further propagation of the current event.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation\n   * @override\n   * @api\n   */\n  ol.MapBrowserEvent.prototype.stopPropagation = function() {\n    ol.MapEvent.prototype.stopPropagation.call(this);\n    this.originalEvent.stopPropagation();\n  };\n  \n  goog.provide('ol.webgl');\n  \n  /**\n   * Constants taken from goog.webgl\n   */\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.ONE = 1;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.SRC_ALPHA = 0x0302;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.COLOR_ATTACHMENT0 = 0x8CE0;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.COLOR_BUFFER_BIT = 0x00004000;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.TRIANGLES = 0x0004;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.TRIANGLE_STRIP = 0x0005;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.ONE_MINUS_SRC_ALPHA = 0x0303;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.ARRAY_BUFFER = 0x8892;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.ELEMENT_ARRAY_BUFFER = 0x8893;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.STREAM_DRAW = 0x88E0;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.STATIC_DRAW = 0x88E4;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.DYNAMIC_DRAW = 0x88E8;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.CULL_FACE = 0x0B44;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.BLEND = 0x0BE2;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.STENCIL_TEST = 0x0B90;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.DEPTH_TEST = 0x0B71;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.SCISSOR_TEST = 0x0C11;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.UNSIGNED_BYTE = 0x1401;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.UNSIGNED_SHORT = 0x1403;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.UNSIGNED_INT = 0x1405;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.FLOAT = 0x1406;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.RGBA = 0x1908;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.FRAGMENT_SHADER = 0x8B30;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.VERTEX_SHADER = 0x8B31;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.LINK_STATUS = 0x8B82;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.LINEAR = 0x2601;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.TEXTURE_MAG_FILTER = 0x2800;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.TEXTURE_MIN_FILTER = 0x2801;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.TEXTURE_WRAP_S = 0x2802;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.TEXTURE_WRAP_T = 0x2803;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.TEXTURE_2D = 0x0DE1;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.TEXTURE0 = 0x84C0;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.CLAMP_TO_EDGE = 0x812F;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.COMPILE_STATUS = 0x8B81;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.webgl.FRAMEBUFFER = 0x8D40;\n  \n  \n  /** end of goog.webgl constants\n   */\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Array.<string>}\n   */\n  ol.webgl.CONTEXT_IDS_ = [\n    'experimental-webgl',\n    'webgl',\n    'webkit-3d',\n    'moz-webgl'\n  ];\n  \n  \n  /**\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {Object=} opt_attributes Attributes.\n   * @return {WebGLRenderingContext} WebGL rendering context.\n   */\n  ol.webgl.getContext = function(canvas, opt_attributes) {\n    var context, i, ii = ol.webgl.CONTEXT_IDS_.length;\n    for (i = 0; i < ii; ++i) {\n      try {\n        context = canvas.getContext(ol.webgl.CONTEXT_IDS_[i], opt_attributes);\n        if (context) {\n          return /** @type {!WebGLRenderingContext} */ (context);\n        }\n      } catch (e) {\n        // pass\n      }\n    }\n    return null;\n  };\n  \n  goog.provide('ol.has');\n  \n  goog.require('ol');\n  goog.require('ol.webgl');\n  \n  var ua = typeof navigator !== 'undefined' ?\n    navigator.userAgent.toLowerCase() : '';\n  \n  /**\n   * User agent string says we are dealing with Firefox as browser.\n   * @type {boolean}\n   */\n  ol.has.FIREFOX = ua.indexOf('firefox') !== -1;\n  \n  /**\n   * User agent string says we are dealing with Safari as browser.\n   * @type {boolean}\n   */\n  ol.has.SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;\n  \n  /**\n   * User agent string says we are dealing with a WebKit engine.\n   * @type {boolean}\n   */\n  ol.has.WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;\n  \n  /**\n   * User agent string says we are dealing with a Mac as platform.\n   * @type {boolean}\n   */\n  ol.has.MAC = ua.indexOf('macintosh') !== -1;\n  \n  \n  /**\n   * The ratio between physical pixels and device-independent pixels\n   * (dips) on the device (`window.devicePixelRatio`).\n   * @const\n   * @type {number}\n   * @api\n   */\n  ol.has.DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;\n  \n  \n  /**\n   * True if the browser's Canvas implementation implements {get,set}LineDash.\n   * @type {boolean}\n   */\n  ol.has.CANVAS_LINE_DASH = false;\n  \n  \n  /**\n   * True if both the library and browser support Canvas.  Always `false`\n   * if `ol.ENABLE_CANVAS` is set to `false` at compile time.\n   * @const\n   * @type {boolean}\n   * @api\n   */\n  ol.has.CANVAS = ol.ENABLE_CANVAS && (\n    /**\n     * @return {boolean} Canvas supported.\n     */\n    function() {\n      if (!('HTMLCanvasElement' in window)) {\n        return false;\n      }\n      try {\n        var context = document.createElement('CANVAS').getContext('2d');\n        if (!context) {\n          return false;\n        } else {\n          if (context.setLineDash !== undefined) {\n            ol.has.CANVAS_LINE_DASH = true;\n          }\n          return true;\n        }\n      } catch (e) {\n        return false;\n      }\n    })();\n  \n  \n  /**\n   * Indicates if DeviceOrientation is supported in the user's browser.\n   * @const\n   * @type {boolean}\n   * @api\n   */\n  ol.has.DEVICE_ORIENTATION = 'DeviceOrientationEvent' in window;\n  \n  \n  /**\n   * Is HTML5 geolocation supported in the current browser?\n   * @const\n   * @type {boolean}\n   * @api\n   */\n  ol.has.GEOLOCATION = 'geolocation' in navigator;\n  \n  \n  /**\n   * True if browser supports touch events.\n   * @const\n   * @type {boolean}\n   * @api\n   */\n  ol.has.TOUCH = ol.ASSUME_TOUCH || 'ontouchstart' in window;\n  \n  \n  /**\n   * True if browser supports pointer events.\n   * @const\n   * @type {boolean}\n   */\n  ol.has.POINTER = 'PointerEvent' in window;\n  \n  \n  /**\n   * True if browser supports ms pointer events (IE 10).\n   * @const\n   * @type {boolean}\n   */\n  ol.has.MSPOINTER = !!(navigator.msPointerEnabled);\n  \n  \n  /**\n   * True if both OpenLayers and browser support WebGL.  Always `false`\n   * if `ol.ENABLE_WEBGL` is set to `false` at compile time.\n   * @const\n   * @type {boolean}\n   * @api\n   */\n  ol.has.WEBGL;\n  \n  \n  (function() {\n    if (ol.ENABLE_WEBGL) {\n      var hasWebGL = false;\n      var textureSize;\n      var /** @type {Array.<string>} */ extensions = [];\n  \n      if ('WebGLRenderingContext' in window) {\n        try {\n          var canvas = /** @type {HTMLCanvasElement} */\n              (document.createElement('CANVAS'));\n          var gl = ol.webgl.getContext(canvas, {\n            failIfMajorPerformanceCaveat: true\n          });\n          if (gl) {\n            hasWebGL = true;\n            textureSize = /** @type {number} */\n              (gl.getParameter(gl.MAX_TEXTURE_SIZE));\n            extensions = gl.getSupportedExtensions();\n          }\n        } catch (e) {\n          // pass\n        }\n      }\n      ol.has.WEBGL = hasWebGL;\n      ol.WEBGL_EXTENSIONS = extensions;\n      ol.WEBGL_MAX_TEXTURE_SIZE = textureSize;\n    }\n  })();\n  \n  goog.provide('ol.MapBrowserEventType');\n  \n  goog.require('ol.events.EventType');\n  \n  \n  /**\n   * Constants for event names.\n   * @enum {string}\n   */\n  ol.MapBrowserEventType = {\n  \n    /**\n     * A true single click with no dragging and no double click. Note that this\n     * event is delayed by 250 ms to ensure that it is not a double click.\n     * @event ol.MapBrowserEvent#singleclick\n     * @api\n     */\n    SINGLECLICK: 'singleclick',\n  \n    /**\n     * A click with no dragging. A double click will fire two of this.\n     * @event ol.MapBrowserEvent#click\n     * @api\n     */\n    CLICK: ol.events.EventType.CLICK,\n  \n    /**\n     * A true double click, with no dragging.\n     * @event ol.MapBrowserEvent#dblclick\n     * @api\n     */\n    DBLCLICK: ol.events.EventType.DBLCLICK,\n  \n    /**\n     * Triggered when a pointer is dragged.\n     * @event ol.MapBrowserEvent#pointerdrag\n     * @api\n     */\n    POINTERDRAG: 'pointerdrag',\n  \n    /**\n     * Triggered when a pointer is moved. Note that on touch devices this is\n     * triggered when the map is panned, so is not the same as mousemove.\n     * @event ol.MapBrowserEvent#pointermove\n     * @api\n     */\n    POINTERMOVE: 'pointermove',\n  \n    POINTERDOWN: 'pointerdown',\n    POINTERUP: 'pointerup',\n    POINTEROVER: 'pointerover',\n    POINTEROUT: 'pointerout',\n    POINTERENTER: 'pointerenter',\n    POINTERLEAVE: 'pointerleave',\n    POINTERCANCEL: 'pointercancel'\n  };\n  \n  goog.provide('ol.MapBrowserPointerEvent');\n  \n  goog.require('ol');\n  goog.require('ol.MapBrowserEvent');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.MapBrowserEvent}\n   * @param {string} type Event type.\n   * @param {ol.PluggableMap} map Map.\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @param {boolean=} opt_dragging Is the map currently being dragged?\n   * @param {?olx.FrameState=} opt_frameState Frame state.\n   */\n  ol.MapBrowserPointerEvent = function(type, map, pointerEvent, opt_dragging,\n      opt_frameState) {\n  \n    ol.MapBrowserEvent.call(this, type, map, pointerEvent.originalEvent, opt_dragging,\n        opt_frameState);\n  \n    /**\n     * @const\n     * @type {ol.pointer.PointerEvent}\n     */\n    this.pointerEvent = pointerEvent;\n  \n  };\n  ol.inherits(ol.MapBrowserPointerEvent, ol.MapBrowserEvent);\n  \n  goog.provide('ol.pointer.EventType');\n  \n  \n  /**\n   * Constants for event names.\n   * @enum {string}\n   */\n  ol.pointer.EventType = {\n    POINTERMOVE: 'pointermove',\n    POINTERDOWN: 'pointerdown',\n    POINTERUP: 'pointerup',\n    POINTEROVER: 'pointerover',\n    POINTEROUT: 'pointerout',\n    POINTERENTER: 'pointerenter',\n    POINTERLEAVE: 'pointerleave',\n    POINTERCANCEL: 'pointercancel'\n  };\n  \n  goog.provide('ol.pointer.EventSource');\n  \n  \n  /**\n   * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.\n   * @param {!Object.<string, function(Event)>} mapping Event\n   *     mapping.\n   * @constructor\n   */\n  ol.pointer.EventSource = function(dispatcher, mapping) {\n    /**\n     * @type {ol.pointer.PointerEventHandler}\n     */\n    this.dispatcher = dispatcher;\n  \n    /**\n     * @private\n     * @const\n     * @type {!Object.<string, function(Event)>}\n     */\n    this.mapping_ = mapping;\n  };\n  \n  \n  /**\n   * List of events supported by this source.\n   * @return {Array.<string>} Event names\n   */\n  ol.pointer.EventSource.prototype.getEvents = function() {\n    return Object.keys(this.mapping_);\n  };\n  \n  \n  /**\n   * Returns the handler that should handle a given event type.\n   * @param {string} eventType The event type.\n   * @return {function(Event)} Handler\n   */\n  ol.pointer.EventSource.prototype.getHandlerForEvent = function(eventType) {\n    return this.mapping_[eventType];\n  };\n  \n  // Based on https://github.com/Polymer/PointerEvents\n  \n  // Copyright (c) 2013 The Polymer Authors. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions are\n  // met:\n  //\n  // * Redistributions of source code must retain the above copyright\n  // notice, this list of conditions and the following disclaimer.\n  // * Redistributions in binary form must reproduce the above\n  // copyright notice, this list of conditions and the following disclaimer\n  // in the documentation and/or other materials provided with the\n  // distribution.\n  // * Neither the name of Google Inc. nor the names of its\n  // contributors may be used to endorse or promote products derived from\n  // this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n  goog.provide('ol.pointer.MouseSource');\n  \n  goog.require('ol');\n  goog.require('ol.pointer.EventSource');\n  \n  \n  /**\n   * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.\n   * @constructor\n   * @extends {ol.pointer.EventSource}\n   */\n  ol.pointer.MouseSource = function(dispatcher) {\n    var mapping = {\n      'mousedown': this.mousedown,\n      'mousemove': this.mousemove,\n      'mouseup': this.mouseup,\n      'mouseover': this.mouseover,\n      'mouseout': this.mouseout\n    };\n    ol.pointer.EventSource.call(this, dispatcher, mapping);\n  \n    /**\n     * @const\n     * @type {!Object.<string, Event|Object>}\n     */\n    this.pointerMap = dispatcher.pointerMap;\n  \n    /**\n     * @const\n     * @type {Array.<ol.Pixel>}\n     */\n    this.lastTouches = [];\n  };\n  ol.inherits(ol.pointer.MouseSource, ol.pointer.EventSource);\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.pointer.MouseSource.POINTER_ID = 1;\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.pointer.MouseSource.POINTER_TYPE = 'mouse';\n  \n  \n  /**\n   * Radius around touchend that swallows mouse events.\n   *\n   * @const\n   * @type {number}\n   */\n  ol.pointer.MouseSource.DEDUP_DIST = 25;\n  \n  \n  /**\n   * Detect if a mouse event was simulated from a touch by\n   * checking if previously there was a touch event at the\n   * same position.\n   *\n   * FIXME - Known problem with the native Android browser on\n   * Samsung GT-I9100 (Android 4.1.2):\n   * In case the page is scrolled, this function does not work\n   * correctly when a canvas is used (WebGL or canvas renderer).\n   * Mouse listeners on canvas elements (for this browser), create\n   * two mouse events: One 'good' and one 'bad' one (on other browsers or\n   * when a div is used, there is only one event). For the 'bad' one,\n   * clientX/clientY and also pageX/pageY are wrong when the page\n   * is scrolled. Because of that, this function can not detect if\n   * the events were simulated from a touch event. As result, a\n   * pointer event at a wrong position is dispatched, which confuses\n   * the map interactions.\n   * It is unclear, how one can get the correct position for the event\n   * or detect that the positions are invalid.\n   *\n   * @private\n   * @param {Event} inEvent The in event.\n   * @return {boolean} True, if the event was generated by a touch.\n   */\n  ol.pointer.MouseSource.prototype.isEventSimulatedFromTouch_ = function(inEvent) {\n    var lts = this.lastTouches;\n    var x = inEvent.clientX, y = inEvent.clientY;\n    for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {\n      // simulated mouse events will be swallowed near a primary touchend\n      var dx = Math.abs(x - t[0]), dy = Math.abs(y - t[1]);\n      if (dx <= ol.pointer.MouseSource.DEDUP_DIST &&\n          dy <= ol.pointer.MouseSource.DEDUP_DIST) {\n        return true;\n      }\n    }\n    return false;\n  };\n  \n  \n  /**\n   * Creates a copy of the original event that will be used\n   * for the fake pointer event.\n   *\n   * @param {Event} inEvent The in event.\n   * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.\n   * @return {Object} The copied event.\n   */\n  ol.pointer.MouseSource.prepareEvent = function(inEvent, dispatcher) {\n    var e = dispatcher.cloneEvent(inEvent, inEvent);\n  \n    // forward mouse preventDefault\n    var pd = e.preventDefault;\n    e.preventDefault = function() {\n      inEvent.preventDefault();\n      pd();\n    };\n  \n    e.pointerId = ol.pointer.MouseSource.POINTER_ID;\n    e.isPrimary = true;\n    e.pointerType = ol.pointer.MouseSource.POINTER_TYPE;\n  \n    return e;\n  };\n  \n  \n  /**\n   * Handler for `mousedown`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MouseSource.prototype.mousedown = function(inEvent) {\n    if (!this.isEventSimulatedFromTouch_(inEvent)) {\n      // TODO(dfreedman) workaround for some elements not sending mouseup\n      // http://crbug/149091\n      if (ol.pointer.MouseSource.POINTER_ID.toString() in this.pointerMap) {\n        this.cancel(inEvent);\n      }\n      var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);\n      this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()] = inEvent;\n      this.dispatcher.down(e, inEvent);\n    }\n  };\n  \n  \n  /**\n   * Handler for `mousemove`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MouseSource.prototype.mousemove = function(inEvent) {\n    if (!this.isEventSimulatedFromTouch_(inEvent)) {\n      var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);\n      this.dispatcher.move(e, inEvent);\n    }\n  };\n  \n  \n  /**\n   * Handler for `mouseup`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MouseSource.prototype.mouseup = function(inEvent) {\n    if (!this.isEventSimulatedFromTouch_(inEvent)) {\n      var p = this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()];\n  \n      if (p && p.button === inEvent.button) {\n        var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);\n        this.dispatcher.up(e, inEvent);\n        this.cleanupMouse();\n      }\n    }\n  };\n  \n  \n  /**\n   * Handler for `mouseover`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MouseSource.prototype.mouseover = function(inEvent) {\n    if (!this.isEventSimulatedFromTouch_(inEvent)) {\n      var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);\n      this.dispatcher.enterOver(e, inEvent);\n    }\n  };\n  \n  \n  /**\n   * Handler for `mouseout`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MouseSource.prototype.mouseout = function(inEvent) {\n    if (!this.isEventSimulatedFromTouch_(inEvent)) {\n      var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);\n      this.dispatcher.leaveOut(e, inEvent);\n    }\n  };\n  \n  \n  /**\n   * Dispatches a `pointercancel` event.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MouseSource.prototype.cancel = function(inEvent) {\n    var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.cancel(e, inEvent);\n    this.cleanupMouse();\n  };\n  \n  \n  /**\n   * Remove the mouse from the list of active pointers.\n   */\n  ol.pointer.MouseSource.prototype.cleanupMouse = function() {\n    delete this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()];\n  };\n  \n  // Based on https://github.com/Polymer/PointerEvents\n  \n  // Copyright (c) 2013 The Polymer Authors. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions are\n  // met:\n  //\n  // * Redistributions of source code must retain the above copyright\n  // notice, this list of conditions and the following disclaimer.\n  // * Redistributions in binary form must reproduce the above\n  // copyright notice, this list of conditions and the following disclaimer\n  // in the documentation and/or other materials provided with the\n  // distribution.\n  // * Neither the name of Google Inc. nor the names of its\n  // contributors may be used to endorse or promote products derived from\n  // this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n  goog.provide('ol.pointer.MsSource');\n  \n  goog.require('ol');\n  goog.require('ol.pointer.EventSource');\n  \n  \n  /**\n   * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.\n   * @constructor\n   * @extends {ol.pointer.EventSource}\n   */\n  ol.pointer.MsSource = function(dispatcher) {\n    var mapping = {\n      'MSPointerDown': this.msPointerDown,\n      'MSPointerMove': this.msPointerMove,\n      'MSPointerUp': this.msPointerUp,\n      'MSPointerOut': this.msPointerOut,\n      'MSPointerOver': this.msPointerOver,\n      'MSPointerCancel': this.msPointerCancel,\n      'MSGotPointerCapture': this.msGotPointerCapture,\n      'MSLostPointerCapture': this.msLostPointerCapture\n    };\n    ol.pointer.EventSource.call(this, dispatcher, mapping);\n  \n    /**\n     * @const\n     * @type {!Object.<string, Event|Object>}\n     */\n    this.pointerMap = dispatcher.pointerMap;\n  \n    /**\n     * @const\n     * @type {Array.<string>}\n     */\n    this.POINTER_TYPES = [\n      '',\n      'unavailable',\n      'touch',\n      'pen',\n      'mouse'\n    ];\n  };\n  ol.inherits(ol.pointer.MsSource, ol.pointer.EventSource);\n  \n  \n  /**\n   * Creates a copy of the original event that will be used\n   * for the fake pointer event.\n   *\n   * @private\n   * @param {Event} inEvent The in event.\n   * @return {Object} The copied event.\n   */\n  ol.pointer.MsSource.prototype.prepareEvent_ = function(inEvent) {\n    var e = inEvent;\n    if (typeof inEvent.pointerType === 'number') {\n      e = this.dispatcher.cloneEvent(inEvent, inEvent);\n      e.pointerType = this.POINTER_TYPES[inEvent.pointerType];\n    }\n  \n    return e;\n  };\n  \n  \n  /**\n   * Remove this pointer from the list of active pointers.\n   * @param {number} pointerId Pointer identifier.\n   */\n  ol.pointer.MsSource.prototype.cleanup = function(pointerId) {\n    delete this.pointerMap[pointerId.toString()];\n  };\n  \n  \n  /**\n   * Handler for `msPointerDown`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MsSource.prototype.msPointerDown = function(inEvent) {\n    this.pointerMap[inEvent.pointerId.toString()] = inEvent;\n    var e = this.prepareEvent_(inEvent);\n    this.dispatcher.down(e, inEvent);\n  };\n  \n  \n  /**\n   * Handler for `msPointerMove`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MsSource.prototype.msPointerMove = function(inEvent) {\n    var e = this.prepareEvent_(inEvent);\n    this.dispatcher.move(e, inEvent);\n  };\n  \n  \n  /**\n   * Handler for `msPointerUp`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MsSource.prototype.msPointerUp = function(inEvent) {\n    var e = this.prepareEvent_(inEvent);\n    this.dispatcher.up(e, inEvent);\n    this.cleanup(inEvent.pointerId);\n  };\n  \n  \n  /**\n   * Handler for `msPointerOut`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MsSource.prototype.msPointerOut = function(inEvent) {\n    var e = this.prepareEvent_(inEvent);\n    this.dispatcher.leaveOut(e, inEvent);\n  };\n  \n  \n  /**\n   * Handler for `msPointerOver`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MsSource.prototype.msPointerOver = function(inEvent) {\n    var e = this.prepareEvent_(inEvent);\n    this.dispatcher.enterOver(e, inEvent);\n  };\n  \n  \n  /**\n   * Handler for `msPointerCancel`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MsSource.prototype.msPointerCancel = function(inEvent) {\n    var e = this.prepareEvent_(inEvent);\n    this.dispatcher.cancel(e, inEvent);\n    this.cleanup(inEvent.pointerId);\n  };\n  \n  \n  /**\n   * Handler for `msLostPointerCapture`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MsSource.prototype.msLostPointerCapture = function(inEvent) {\n    var e = this.dispatcher.makeEvent('lostpointercapture',\n        inEvent, inEvent);\n    this.dispatcher.dispatchEvent(e);\n  };\n  \n  \n  /**\n   * Handler for `msGotPointerCapture`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.MsSource.prototype.msGotPointerCapture = function(inEvent) {\n    var e = this.dispatcher.makeEvent('gotpointercapture',\n        inEvent, inEvent);\n    this.dispatcher.dispatchEvent(e);\n  };\n  \n  // Based on https://github.com/Polymer/PointerEvents\n  \n  // Copyright (c) 2013 The Polymer Authors. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions are\n  // met:\n  //\n  // * Redistributions of source code must retain the above copyright\n  // notice, this list of conditions and the following disclaimer.\n  // * Redistributions in binary form must reproduce the above\n  // copyright notice, this list of conditions and the following disclaimer\n  // in the documentation and/or other materials provided with the\n  // distribution.\n  // * Neither the name of Google Inc. nor the names of its\n  // contributors may be used to endorse or promote products derived from\n  // this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n  goog.provide('ol.pointer.NativeSource');\n  \n  goog.require('ol');\n  goog.require('ol.pointer.EventSource');\n  \n  \n  /**\n   * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.\n   * @constructor\n   * @extends {ol.pointer.EventSource}\n   */\n  ol.pointer.NativeSource = function(dispatcher) {\n    var mapping = {\n      'pointerdown': this.pointerDown,\n      'pointermove': this.pointerMove,\n      'pointerup': this.pointerUp,\n      'pointerout': this.pointerOut,\n      'pointerover': this.pointerOver,\n      'pointercancel': this.pointerCancel,\n      'gotpointercapture': this.gotPointerCapture,\n      'lostpointercapture': this.lostPointerCapture\n    };\n    ol.pointer.EventSource.call(this, dispatcher, mapping);\n  };\n  ol.inherits(ol.pointer.NativeSource, ol.pointer.EventSource);\n  \n  \n  /**\n   * Handler for `pointerdown`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.NativeSource.prototype.pointerDown = function(inEvent) {\n    this.dispatcher.fireNativeEvent(inEvent);\n  };\n  \n  \n  /**\n   * Handler for `pointermove`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.NativeSource.prototype.pointerMove = function(inEvent) {\n    this.dispatcher.fireNativeEvent(inEvent);\n  };\n  \n  \n  /**\n   * Handler for `pointerup`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.NativeSource.prototype.pointerUp = function(inEvent) {\n    this.dispatcher.fireNativeEvent(inEvent);\n  };\n  \n  \n  /**\n   * Handler for `pointerout`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.NativeSource.prototype.pointerOut = function(inEvent) {\n    this.dispatcher.fireNativeEvent(inEvent);\n  };\n  \n  \n  /**\n   * Handler for `pointerover`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.NativeSource.prototype.pointerOver = function(inEvent) {\n    this.dispatcher.fireNativeEvent(inEvent);\n  };\n  \n  \n  /**\n   * Handler for `pointercancel`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.NativeSource.prototype.pointerCancel = function(inEvent) {\n    this.dispatcher.fireNativeEvent(inEvent);\n  };\n  \n  \n  /**\n   * Handler for `lostpointercapture`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.NativeSource.prototype.lostPointerCapture = function(inEvent) {\n    this.dispatcher.fireNativeEvent(inEvent);\n  };\n  \n  \n  /**\n   * Handler for `gotpointercapture`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.NativeSource.prototype.gotPointerCapture = function(inEvent) {\n    this.dispatcher.fireNativeEvent(inEvent);\n  };\n  \n  // Based on https://github.com/Polymer/PointerEvents\n  \n  // Copyright (c) 2013 The Polymer Authors. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions are\n  // met:\n  //\n  // * Redistributions of source code must retain the above copyright\n  // notice, this list of conditions and the following disclaimer.\n  // * Redistributions in binary form must reproduce the above\n  // copyright notice, this list of conditions and the following disclaimer\n  // in the documentation and/or other materials provided with the\n  // distribution.\n  // * Neither the name of Google Inc. nor the names of its\n  // contributors may be used to endorse or promote products derived from\n  // this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n  goog.provide('ol.pointer.PointerEvent');\n  \n  \n  goog.require('ol');\n  goog.require('ol.events.Event');\n  \n  \n  /**\n   * A class for pointer events.\n   *\n   * This class is used as an abstraction for mouse events,\n   * touch events and even native pointer events.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @param {string} type The type of the event to create.\n   * @param {Event} originalEvent The event.\n   * @param {Object.<string, ?>=} opt_eventDict An optional dictionary of\n   *    initial event properties.\n   */\n  ol.pointer.PointerEvent = function(type, originalEvent, opt_eventDict) {\n    ol.events.Event.call(this, type);\n  \n    /**\n     * @const\n     * @type {Event}\n     */\n    this.originalEvent = originalEvent;\n  \n    var eventDict = opt_eventDict ? opt_eventDict : {};\n  \n    /**\n     * @type {number}\n     */\n    this.buttons = this.getButtons_(eventDict);\n  \n    /**\n     * @type {number}\n     */\n    this.pressure = this.getPressure_(eventDict, this.buttons);\n  \n    // MouseEvent related properties\n  \n    /**\n     * @type {boolean}\n     */\n    this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;\n  \n    /**\n     * @type {boolean}\n     */\n    this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;\n  \n    /**\n     * @type {Object}\n     */\n    this.view = 'view' in eventDict ? eventDict['view'] : null;\n  \n    /**\n     * @type {number}\n     */\n    this.detail = 'detail' in eventDict ? eventDict['detail'] : null;\n  \n    /**\n     * @type {number}\n     */\n    this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;\n  \n    /**\n     * @type {number}\n     */\n    this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;\n  \n    /**\n     * @type {number}\n     */\n    this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;\n  \n    /**\n     * @type {number}\n     */\n    this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;\n  \n    /**\n     * @type {boolean}\n     */\n    this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;\n  \n    /**\n     * @type {boolean}\n     */\n    this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;\n  \n    /**\n     * @type {boolean}\n     */\n    this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;\n  \n    /**\n     * @type {boolean}\n     */\n    this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;\n  \n    /**\n     * @type {number}\n     */\n    this.button = 'button' in eventDict ? eventDict['button'] : 0;\n  \n    /**\n     * @type {Node}\n     */\n    this.relatedTarget = 'relatedTarget' in eventDict ?\n      eventDict['relatedTarget'] : null;\n  \n    // PointerEvent related properties\n  \n    /**\n     * @const\n     * @type {number}\n     */\n    this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;\n  \n    /**\n     * @type {number}\n     */\n    this.width = 'width' in eventDict ? eventDict['width'] : 0;\n  \n    /**\n     * @type {number}\n     */\n    this.height = 'height' in eventDict ? eventDict['height'] : 0;\n  \n    /**\n     * @type {number}\n     */\n    this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;\n  \n    /**\n     * @type {number}\n     */\n    this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;\n  \n    /**\n     * @type {string}\n     */\n    this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';\n  \n    /**\n     * @type {number}\n     */\n    this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;\n  \n    /**\n     * @type {boolean}\n     */\n    this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false;\n  \n    // keep the semantics of preventDefault\n    if (originalEvent.preventDefault) {\n      this.preventDefault = function() {\n        originalEvent.preventDefault();\n      };\n    }\n  };\n  ol.inherits(ol.pointer.PointerEvent, ol.events.Event);\n  \n  \n  /**\n   * @private\n   * @param {Object.<string, ?>} eventDict The event dictionary.\n   * @return {number} Button indicator.\n   */\n  ol.pointer.PointerEvent.prototype.getButtons_ = function(eventDict) {\n    // According to the w3c spec,\n    // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button\n    // MouseEvent.button == 0 can mean either no mouse button depressed, or the\n    // left mouse button depressed.\n    //\n    // As of now, the only way to distinguish between the two states of\n    // MouseEvent.button is by using the deprecated MouseEvent.which property, as\n    // this maps mouse buttons to positive integers > 0, and uses 0 to mean that\n    // no mouse button is held.\n    //\n    // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,\n    // but initMouseEvent does not expose an argument with which to set\n    // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set\n    // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations\n    // of app developers.\n    //\n    // The only way to propagate the correct state of MouseEvent.which and\n    // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0\n    // is to call initMouseEvent with a buttonArg value of -1.\n    //\n    // This is fixed with DOM Level 4's use of buttons\n    var buttons;\n    if (eventDict.buttons || ol.pointer.PointerEvent.HAS_BUTTONS) {\n      buttons = eventDict.buttons;\n    } else {\n      switch (eventDict.which) {\n        case 1: buttons = 1; break;\n        case 2: buttons = 4; break;\n        case 3: buttons = 2; break;\n        default: buttons = 0;\n      }\n    }\n    return buttons;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Object.<string, ?>} eventDict The event dictionary.\n   * @param {number} buttons Button indicator.\n   * @return {number} The pressure.\n   */\n  ol.pointer.PointerEvent.prototype.getPressure_ = function(eventDict, buttons) {\n    // Spec requires that pointers without pressure specified use 0.5 for down\n    // state and 0 for up state.\n    var pressure = 0;\n    if (eventDict.pressure) {\n      pressure = eventDict.pressure;\n    } else {\n      pressure = buttons ? 0.5 : 0;\n    }\n    return pressure;\n  };\n  \n  \n  /**\n   * Is the `buttons` property supported?\n   * @type {boolean}\n   */\n  ol.pointer.PointerEvent.HAS_BUTTONS = false;\n  \n  \n  /**\n   * Checks if the `buttons` property is supported.\n   */\n  (function() {\n    try {\n      var ev = new MouseEvent('click', {buttons: 1});\n      ol.pointer.PointerEvent.HAS_BUTTONS = ev.buttons === 1;\n    } catch (e) {\n      // pass\n    }\n  })();\n  \n  // Based on https://github.com/Polymer/PointerEvents\n  \n  // Copyright (c) 2013 The Polymer Authors. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions are\n  // met:\n  //\n  // * Redistributions of source code must retain the above copyright\n  // notice, this list of conditions and the following disclaimer.\n  // * Redistributions in binary form must reproduce the above\n  // copyright notice, this list of conditions and the following disclaimer\n  // in the documentation and/or other materials provided with the\n  // distribution.\n  // * Neither the name of Google Inc. nor the names of its\n  // contributors may be used to endorse or promote products derived from\n  // this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n  goog.provide('ol.pointer.TouchSource');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.pointer.EventSource');\n  goog.require('ol.pointer.MouseSource');\n  \n  \n  /**\n   * @constructor\n   * @param {ol.pointer.PointerEventHandler} dispatcher The event handler.\n   * @param {ol.pointer.MouseSource} mouseSource Mouse source.\n   * @extends {ol.pointer.EventSource}\n   */\n  ol.pointer.TouchSource = function(dispatcher, mouseSource) {\n    var mapping = {\n      'touchstart': this.touchstart,\n      'touchmove': this.touchmove,\n      'touchend': this.touchend,\n      'touchcancel': this.touchcancel\n    };\n    ol.pointer.EventSource.call(this, dispatcher, mapping);\n  \n    /**\n     * @const\n     * @type {!Object.<string, Event|Object>}\n     */\n    this.pointerMap = dispatcher.pointerMap;\n  \n    /**\n     * @const\n     * @type {ol.pointer.MouseSource}\n     */\n    this.mouseSource = mouseSource;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.firstTouchId_ = undefined;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.clickCount_ = 0;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.resetId_ = undefined;\n  };\n  ol.inherits(ol.pointer.TouchSource, ol.pointer.EventSource);\n  \n  \n  /**\n   * Mouse event timeout: This should be long enough to\n   * ignore compat mouse events made by touch.\n   * @const\n   * @type {number}\n   */\n  ol.pointer.TouchSource.DEDUP_TIMEOUT = 2500;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.pointer.TouchSource.CLICK_COUNT_TIMEOUT = 200;\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.pointer.TouchSource.POINTER_TYPE = 'touch';\n  \n  \n  /**\n   * @private\n   * @param {Touch} inTouch The in touch.\n   * @return {boolean} True, if this is the primary touch.\n   */\n  ol.pointer.TouchSource.prototype.isPrimaryTouch_ = function(inTouch) {\n    return this.firstTouchId_ === inTouch.identifier;\n  };\n  \n  \n  /**\n   * Set primary touch if there are no pointers, or the only pointer is the mouse.\n   * @param {Touch} inTouch The in touch.\n   * @private\n   */\n  ol.pointer.TouchSource.prototype.setPrimaryTouch_ = function(inTouch) {\n    var count = Object.keys(this.pointerMap).length;\n    if (count === 0 || (count === 1 &&\n        ol.pointer.MouseSource.POINTER_ID.toString() in this.pointerMap)) {\n      this.firstTouchId_ = inTouch.identifier;\n      this.cancelResetClickCount_();\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Object} inPointer The in pointer object.\n   */\n  ol.pointer.TouchSource.prototype.removePrimaryPointer_ = function(inPointer) {\n    if (inPointer.isPrimary) {\n      this.firstTouchId_ = undefined;\n      this.resetClickCount_();\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.pointer.TouchSource.prototype.resetClickCount_ = function() {\n    this.resetId_ = setTimeout(\n        this.resetClickCountHandler_.bind(this),\n        ol.pointer.TouchSource.CLICK_COUNT_TIMEOUT);\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.pointer.TouchSource.prototype.resetClickCountHandler_ = function() {\n    this.clickCount_ = 0;\n    this.resetId_ = undefined;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.pointer.TouchSource.prototype.cancelResetClickCount_ = function() {\n    if (this.resetId_ !== undefined) {\n      clearTimeout(this.resetId_);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} browserEvent Browser event\n   * @param {Touch} inTouch Touch event\n   * @return {Object} A pointer object.\n   */\n  ol.pointer.TouchSource.prototype.touchToPointer_ = function(browserEvent, inTouch) {\n    var e = this.dispatcher.cloneEvent(browserEvent, inTouch);\n    // Spec specifies that pointerId 1 is reserved for Mouse.\n    // Touch identifiers can start at 0.\n    // Add 2 to the touch identifier for compatibility.\n    e.pointerId = inTouch.identifier + 2;\n    // TODO: check if this is necessary?\n    //e.target = findTarget(e);\n    e.bubbles = true;\n    e.cancelable = true;\n    e.detail = this.clickCount_;\n    e.button = 0;\n    e.buttons = 1;\n    e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;\n    e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;\n    e.pressure = inTouch.webkitForce || inTouch.force || 0.5;\n    e.isPrimary = this.isPrimaryTouch_(inTouch);\n    e.pointerType = ol.pointer.TouchSource.POINTER_TYPE;\n  \n    // make sure that the properties that are different for\n    // each `Touch` object are not copied from the BrowserEvent object\n    e.clientX = inTouch.clientX;\n    e.clientY = inTouch.clientY;\n    e.screenX = inTouch.screenX;\n    e.screenY = inTouch.screenY;\n  \n    return e;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} inEvent Touch event\n   * @param {function(Event, Object)} inFunction In function.\n   */\n  ol.pointer.TouchSource.prototype.processTouches_ = function(inEvent, inFunction) {\n    var touches = Array.prototype.slice.call(\n        inEvent.changedTouches);\n    var count = touches.length;\n    function preventDefault() {\n      inEvent.preventDefault();\n    }\n    var i, pointer;\n    for (i = 0; i < count; ++i) {\n      pointer = this.touchToPointer_(inEvent, touches[i]);\n      // forward touch preventDefaults\n      pointer.preventDefault = preventDefault;\n      inFunction.call(this, inEvent, pointer);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {TouchList} touchList The touch list.\n   * @param {number} searchId Search identifier.\n   * @return {boolean} True, if the `Touch` with the given id is in the list.\n   */\n  ol.pointer.TouchSource.prototype.findTouch_ = function(touchList, searchId) {\n    var l = touchList.length;\n    var touch;\n    for (var i = 0; i < l; i++) {\n      touch = touchList[i];\n      if (touch.identifier === searchId) {\n        return true;\n      }\n    }\n    return false;\n  };\n  \n  \n  /**\n   * In some instances, a touchstart can happen without a touchend. This\n   * leaves the pointermap in a broken state.\n   * Therefore, on every touchstart, we remove the touches that did not fire a\n   * touchend event.\n   * To keep state globally consistent, we fire a pointercancel for\n   * this \"abandoned\" touch\n   *\n   * @private\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.TouchSource.prototype.vacuumTouches_ = function(inEvent) {\n    var touchList = inEvent.touches;\n    // pointerMap.getCount() should be < touchList.length here,\n    // as the touchstart has not been processed yet.\n    var keys = Object.keys(this.pointerMap);\n    var count = keys.length;\n    if (count >= touchList.length) {\n      var d = [];\n      var i, key, value;\n      for (i = 0; i < count; ++i) {\n        key = keys[i];\n        value = this.pointerMap[key];\n        // Never remove pointerId == 1, which is mouse.\n        // Touch identifiers are 2 smaller than their pointerId, which is the\n        // index in pointermap.\n        if (key != ol.pointer.MouseSource.POINTER_ID &&\n            !this.findTouch_(touchList, key - 2)) {\n          d.push(value.out);\n        }\n      }\n      for (i = 0; i < d.length; ++i) {\n        this.cancelOut_(inEvent, d[i]);\n      }\n    }\n  };\n  \n  \n  /**\n   * Handler for `touchstart`, triggers `pointerover`,\n   * `pointerenter` and `pointerdown` events.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.TouchSource.prototype.touchstart = function(inEvent) {\n    this.vacuumTouches_(inEvent);\n    this.setPrimaryTouch_(inEvent.changedTouches[0]);\n    this.dedupSynthMouse_(inEvent);\n    this.clickCount_++;\n    this.processTouches_(inEvent, this.overDown_);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} browserEvent The event.\n   * @param {Object} inPointer The in pointer object.\n   */\n  ol.pointer.TouchSource.prototype.overDown_ = function(browserEvent, inPointer) {\n    this.pointerMap[inPointer.pointerId] = {\n      target: inPointer.target,\n      out: inPointer,\n      outTarget: inPointer.target\n    };\n    this.dispatcher.over(inPointer, browserEvent);\n    this.dispatcher.enter(inPointer, browserEvent);\n    this.dispatcher.down(inPointer, browserEvent);\n  };\n  \n  \n  /**\n   * Handler for `touchmove`.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.TouchSource.prototype.touchmove = function(inEvent) {\n    inEvent.preventDefault();\n    this.processTouches_(inEvent, this.moveOverOut_);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} browserEvent The event.\n   * @param {Object} inPointer The in pointer.\n   */\n  ol.pointer.TouchSource.prototype.moveOverOut_ = function(browserEvent, inPointer) {\n    var event = inPointer;\n    var pointer = this.pointerMap[event.pointerId];\n    // a finger drifted off the screen, ignore it\n    if (!pointer) {\n      return;\n    }\n    var outEvent = pointer.out;\n    var outTarget = pointer.outTarget;\n    this.dispatcher.move(event, browserEvent);\n    if (outEvent && outTarget !== event.target) {\n      outEvent.relatedTarget = event.target;\n      event.relatedTarget = outTarget;\n      // recover from retargeting by shadow\n      outEvent.target = outTarget;\n      if (event.target) {\n        this.dispatcher.leaveOut(outEvent, browserEvent);\n        this.dispatcher.enterOver(event, browserEvent);\n      } else {\n        // clean up case when finger leaves the screen\n        event.target = outTarget;\n        event.relatedTarget = null;\n        this.cancelOut_(browserEvent, event);\n      }\n    }\n    pointer.out = event;\n    pointer.outTarget = event.target;\n  };\n  \n  \n  /**\n   * Handler for `touchend`, triggers `pointerup`,\n   * `pointerout` and `pointerleave` events.\n   *\n   * @param {Event} inEvent The event.\n   */\n  ol.pointer.TouchSource.prototype.touchend = function(inEvent) {\n    this.dedupSynthMouse_(inEvent);\n    this.processTouches_(inEvent, this.upOut_);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} browserEvent An event.\n   * @param {Object} inPointer The inPointer object.\n   */\n  ol.pointer.TouchSource.prototype.upOut_ = function(browserEvent, inPointer) {\n    this.dispatcher.up(inPointer, browserEvent);\n    this.dispatcher.out(inPointer, browserEvent);\n    this.dispatcher.leave(inPointer, browserEvent);\n    this.cleanUpPointer_(inPointer);\n  };\n  \n  \n  /**\n   * Handler for `touchcancel`, triggers `pointercancel`,\n   * `pointerout` and `pointerleave` events.\n   *\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.TouchSource.prototype.touchcancel = function(inEvent) {\n    this.processTouches_(inEvent, this.cancelOut_);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} browserEvent The event.\n   * @param {Object} inPointer The in pointer.\n   */\n  ol.pointer.TouchSource.prototype.cancelOut_ = function(browserEvent, inPointer) {\n    this.dispatcher.cancel(inPointer, browserEvent);\n    this.dispatcher.out(inPointer, browserEvent);\n    this.dispatcher.leave(inPointer, browserEvent);\n    this.cleanUpPointer_(inPointer);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Object} inPointer The inPointer object.\n   */\n  ol.pointer.TouchSource.prototype.cleanUpPointer_ = function(inPointer) {\n    delete this.pointerMap[inPointer.pointerId];\n    this.removePrimaryPointer_(inPointer);\n  };\n  \n  \n  /**\n   * Prevent synth mouse events from creating pointer events.\n   *\n   * @private\n   * @param {Event} inEvent The in event.\n   */\n  ol.pointer.TouchSource.prototype.dedupSynthMouse_ = function(inEvent) {\n    var lts = this.mouseSource.lastTouches;\n    var t = inEvent.changedTouches[0];\n    // only the primary finger will synth mouse events\n    if (this.isPrimaryTouch_(t)) {\n      // remember x/y of last touch\n      var lt = [t.clientX, t.clientY];\n      lts.push(lt);\n  \n      setTimeout(function() {\n        // remove touch after timeout\n        ol.array.remove(lts, lt);\n      }, ol.pointer.TouchSource.DEDUP_TIMEOUT);\n    }\n  };\n  \n  // Based on https://github.com/Polymer/PointerEvents\n  \n  // Copyright (c) 2013 The Polymer Authors. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions are\n  // met:\n  //\n  // * Redistributions of source code must retain the above copyright\n  // notice, this list of conditions and the following disclaimer.\n  // * Redistributions in binary form must reproduce the above\n  // copyright notice, this list of conditions and the following disclaimer\n  // in the documentation and/or other materials provided with the\n  // distribution.\n  // * Neither the name of Google Inc. nor the names of its\n  // contributors may be used to endorse or promote products derived from\n  // this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n  goog.provide('ol.pointer.PointerEventHandler');\n  \n  goog.require('ol');\n  goog.require('ol.events');\n  goog.require('ol.events.EventTarget');\n  \n  goog.require('ol.has');\n  goog.require('ol.pointer.EventType');\n  goog.require('ol.pointer.MouseSource');\n  goog.require('ol.pointer.MsSource');\n  goog.require('ol.pointer.NativeSource');\n  goog.require('ol.pointer.PointerEvent');\n  goog.require('ol.pointer.TouchSource');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.events.EventTarget}\n   * @param {Element|HTMLDocument} element Viewport element.\n   */\n  ol.pointer.PointerEventHandler = function(element) {\n    ol.events.EventTarget.call(this);\n  \n    /**\n     * @const\n     * @private\n     * @type {Element|HTMLDocument}\n     */\n    this.element_ = element;\n  \n    /**\n     * @const\n     * @type {!Object.<string, Event|Object>}\n     */\n    this.pointerMap = {};\n  \n    /**\n     * @type {Object.<string, function(Event)>}\n     * @private\n     */\n    this.eventMap_ = {};\n  \n    /**\n     * @type {Array.<ol.pointer.EventSource>}\n     * @private\n     */\n    this.eventSourceList_ = [];\n  \n    this.registerSources();\n  };\n  ol.inherits(ol.pointer.PointerEventHandler, ol.events.EventTarget);\n  \n  \n  /**\n   * Set up the event sources (mouse, touch and native pointers)\n   * that generate pointer events.\n   */\n  ol.pointer.PointerEventHandler.prototype.registerSources = function() {\n    if (ol.has.POINTER) {\n      this.registerSource('native', new ol.pointer.NativeSource(this));\n    } else if (ol.has.MSPOINTER) {\n      this.registerSource('ms', new ol.pointer.MsSource(this));\n    } else {\n      var mouseSource = new ol.pointer.MouseSource(this);\n      this.registerSource('mouse', mouseSource);\n  \n      if (ol.has.TOUCH) {\n        this.registerSource('touch',\n            new ol.pointer.TouchSource(this, mouseSource));\n      }\n    }\n  \n    // register events on the viewport element\n    this.register_();\n  };\n  \n  \n  /**\n   * Add a new event source that will generate pointer events.\n   *\n   * @param {string} name A name for the event source\n   * @param {ol.pointer.EventSource} source The source event.\n   */\n  ol.pointer.PointerEventHandler.prototype.registerSource = function(name, source) {\n    var s = source;\n    var newEvents = s.getEvents();\n  \n    if (newEvents) {\n      newEvents.forEach(function(e) {\n        var handler = s.getHandlerForEvent(e);\n  \n        if (handler) {\n          this.eventMap_[e] = handler.bind(s);\n        }\n      }, this);\n      this.eventSourceList_.push(s);\n    }\n  };\n  \n  \n  /**\n   * Set up the events for all registered event sources.\n   * @private\n   */\n  ol.pointer.PointerEventHandler.prototype.register_ = function() {\n    var l = this.eventSourceList_.length;\n    var eventSource;\n    for (var i = 0; i < l; i++) {\n      eventSource = this.eventSourceList_[i];\n      this.addEvents_(eventSource.getEvents());\n    }\n  };\n  \n  \n  /**\n   * Remove all registered events.\n   * @private\n   */\n  ol.pointer.PointerEventHandler.prototype.unregister_ = function() {\n    var l = this.eventSourceList_.length;\n    var eventSource;\n    for (var i = 0; i < l; i++) {\n      eventSource = this.eventSourceList_[i];\n      this.removeEvents_(eventSource.getEvents());\n    }\n  };\n  \n  \n  /**\n   * Calls the right handler for a new event.\n   * @private\n   * @param {Event} inEvent Browser event.\n   */\n  ol.pointer.PointerEventHandler.prototype.eventHandler_ = function(inEvent) {\n    var type = inEvent.type;\n    var handler = this.eventMap_[type];\n    if (handler) {\n      handler(inEvent);\n    }\n  };\n  \n  \n  /**\n   * Setup listeners for the given events.\n   * @private\n   * @param {Array.<string>} events List of events.\n   */\n  ol.pointer.PointerEventHandler.prototype.addEvents_ = function(events) {\n    events.forEach(function(eventName) {\n      ol.events.listen(this.element_, eventName, this.eventHandler_, this);\n    }, this);\n  };\n  \n  \n  /**\n   * Unregister listeners for the given events.\n   * @private\n   * @param {Array.<string>} events List of events.\n   */\n  ol.pointer.PointerEventHandler.prototype.removeEvents_ = function(events) {\n    events.forEach(function(e) {\n      ol.events.unlisten(this.element_, e, this.eventHandler_, this);\n    }, this);\n  };\n  \n  \n  /**\n   * Returns a snapshot of inEvent, with writable properties.\n   *\n   * @param {Event} event Browser event.\n   * @param {Event|Touch} inEvent An event that contains\n   *    properties to copy.\n   * @return {Object} An object containing shallow copies of\n   *    `inEvent`'s properties.\n   */\n  ol.pointer.PointerEventHandler.prototype.cloneEvent = function(event, inEvent) {\n    var eventCopy = {}, p;\n    for (var i = 0, ii = ol.pointer.PointerEventHandler.CLONE_PROPS.length; i < ii; i++) {\n      p = ol.pointer.PointerEventHandler.CLONE_PROPS[i][0];\n      eventCopy[p] = event[p] || inEvent[p] || ol.pointer.PointerEventHandler.CLONE_PROPS[i][1];\n    }\n  \n    return eventCopy;\n  };\n  \n  \n  // EVENTS\n  \n  \n  /**\n   * Triggers a 'pointerdown' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.down = function(data, event) {\n    this.fireEvent(ol.pointer.EventType.POINTERDOWN, data, event);\n  };\n  \n  \n  /**\n   * Triggers a 'pointermove' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.move = function(data, event) {\n    this.fireEvent(ol.pointer.EventType.POINTERMOVE, data, event);\n  };\n  \n  \n  /**\n   * Triggers a 'pointerup' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.up = function(data, event) {\n    this.fireEvent(ol.pointer.EventType.POINTERUP, data, event);\n  };\n  \n  \n  /**\n   * Triggers a 'pointerenter' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.enter = function(data, event) {\n    data.bubbles = false;\n    this.fireEvent(ol.pointer.EventType.POINTERENTER, data, event);\n  };\n  \n  \n  /**\n   * Triggers a 'pointerleave' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.leave = function(data, event) {\n    data.bubbles = false;\n    this.fireEvent(ol.pointer.EventType.POINTERLEAVE, data, event);\n  };\n  \n  \n  /**\n   * Triggers a 'pointerover' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.over = function(data, event) {\n    data.bubbles = true;\n    this.fireEvent(ol.pointer.EventType.POINTEROVER, data, event);\n  };\n  \n  \n  /**\n   * Triggers a 'pointerout' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.out = function(data, event) {\n    data.bubbles = true;\n    this.fireEvent(ol.pointer.EventType.POINTEROUT, data, event);\n  };\n  \n  \n  /**\n   * Triggers a 'pointercancel' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.cancel = function(data, event) {\n    this.fireEvent(ol.pointer.EventType.POINTERCANCEL, data, event);\n  };\n  \n  \n  /**\n   * Triggers a combination of 'pointerout' and 'pointerleave' events.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.leaveOut = function(data, event) {\n    this.out(data, event);\n    if (!this.contains_(data.target, data.relatedTarget)) {\n      this.leave(data, event);\n    }\n  };\n  \n  \n  /**\n   * Triggers a combination of 'pointerover' and 'pointerevents' events.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.enterOver = function(data, event) {\n    this.over(data, event);\n    if (!this.contains_(data.target, data.relatedTarget)) {\n      this.enter(data, event);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Element} container The container element.\n   * @param {Element} contained The contained element.\n   * @return {boolean} Returns true if the container element\n   *   contains the other element.\n   */\n  ol.pointer.PointerEventHandler.prototype.contains_ = function(container, contained) {\n    if (!container || !contained) {\n      return false;\n    }\n    return container.contains(contained);\n  };\n  \n  \n  // EVENT CREATION AND TRACKING\n  /**\n   * Creates a new Event of type `inType`, based on the information in\n   * `data`.\n   *\n   * @param {string} inType A string representing the type of event to create.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   * @return {ol.pointer.PointerEvent} A PointerEvent of type `inType`.\n   */\n  ol.pointer.PointerEventHandler.prototype.makeEvent = function(inType, data, event) {\n    return new ol.pointer.PointerEvent(inType, event, data);\n  };\n  \n  \n  /**\n   * Make and dispatch an event in one call.\n   * @param {string} inType A string representing the type of event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n  ol.pointer.PointerEventHandler.prototype.fireEvent = function(inType, data, event) {\n    var e = this.makeEvent(inType, data, event);\n    this.dispatchEvent(e);\n  };\n  \n  \n  /**\n   * Creates a pointer event from a native pointer event\n   * and dispatches this event.\n   * @param {Event} event A platform event with a target.\n   */\n  ol.pointer.PointerEventHandler.prototype.fireNativeEvent = function(event) {\n    var e = this.makeEvent(event.type, event, event);\n    this.dispatchEvent(e);\n  };\n  \n  \n  /**\n   * Wrap a native mouse event into a pointer event.\n   * This proxy method is required for the legacy IE support.\n   * @param {string} eventType The pointer event type.\n   * @param {Event} event The event.\n   * @return {ol.pointer.PointerEvent} The wrapped event.\n   */\n  ol.pointer.PointerEventHandler.prototype.wrapMouseEvent = function(eventType, event) {\n    var pointerEvent = this.makeEvent(\n        eventType, ol.pointer.MouseSource.prepareEvent(event, this), event);\n    return pointerEvent;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.pointer.PointerEventHandler.prototype.disposeInternal = function() {\n    this.unregister_();\n    ol.events.EventTarget.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * Properties to copy when cloning an event, with default values.\n   * @type {Array.<Array>}\n   */\n  ol.pointer.PointerEventHandler.CLONE_PROPS = [\n    // MouseEvent\n    ['bubbles', false],\n    ['cancelable', false],\n    ['view', null],\n    ['detail', null],\n    ['screenX', 0],\n    ['screenY', 0],\n    ['clientX', 0],\n    ['clientY', 0],\n    ['ctrlKey', false],\n    ['altKey', false],\n    ['shiftKey', false],\n    ['metaKey', false],\n    ['button', 0],\n    ['relatedTarget', null],\n    // DOM Level 3\n    ['buttons', 0],\n    // PointerEvent\n    ['pointerId', 0],\n    ['width', 0],\n    ['height', 0],\n    ['pressure', 0],\n    ['tiltX', 0],\n    ['tiltY', 0],\n    ['pointerType', ''],\n    ['hwTimestamp', 0],\n    ['isPrimary', false],\n    // event instance\n    ['type', ''],\n    ['target', null],\n    ['currentTarget', null],\n    ['which', 0]\n  ];\n  \n  goog.provide('ol.MapBrowserEventHandler');\n  \n  goog.require('ol');\n  goog.require('ol.has');\n  goog.require('ol.MapBrowserEventType');\n  goog.require('ol.MapBrowserPointerEvent');\n  goog.require('ol.events');\n  goog.require('ol.events.EventTarget');\n  goog.require('ol.pointer.EventType');\n  goog.require('ol.pointer.PointerEventHandler');\n  \n  \n  /**\n   * @param {ol.PluggableMap} map The map with the viewport to listen to events on.\n   * @param {number|undefined} moveTolerance The minimal distance the pointer must travel to trigger a move.\n   * @constructor\n   * @extends {ol.events.EventTarget}\n   */\n  ol.MapBrowserEventHandler = function(map, moveTolerance) {\n  \n    ol.events.EventTarget.call(this);\n  \n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {ol.PluggableMap}\n     * @private\n     */\n    this.map_ = map;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.clickTimeoutId_ = 0;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n  \n    /**\n     * @type {!Array.<ol.EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance ?\n      moveTolerance * ol.has.DEVICE_PIXEL_RATIO : ol.has.DEVICE_PIXEL_RATIO;\n  \n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {ol.pointer.PointerEvent}\n     * @private\n     */\n    this.down_ = null;\n  \n    var element = this.map_.getViewport();\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.activePointers_ = 0;\n  \n    /**\n     * @type {!Object.<number, boolean>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n  \n    /**\n     * Event handler which generates pointer events for\n     * the viewport element.\n     *\n     * @type {ol.pointer.PointerEventHandler}\n     * @private\n     */\n    this.pointerEventHandler_ = new ol.pointer.PointerEventHandler(element);\n  \n    /**\n     * Event handler which generates pointer events for\n     * the document (used when dragging).\n     *\n     * @type {ol.pointer.PointerEventHandler}\n     * @private\n     */\n    this.documentPointerEventHandler_ = null;\n  \n    /**\n     * @type {?ol.EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = ol.events.listen(this.pointerEventHandler_,\n        ol.pointer.EventType.POINTERDOWN,\n        this.handlePointerDown_, this);\n  \n    /**\n     * @type {?ol.EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = ol.events.listen(this.pointerEventHandler_,\n        ol.pointer.EventType.POINTERMOVE,\n        this.relayEvent_, this);\n  \n  };\n  ol.inherits(ol.MapBrowserEventHandler, ol.events.EventTarget);\n  \n  \n  /**\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @private\n   */\n  ol.MapBrowserEventHandler.prototype.emulateClick_ = function(pointerEvent) {\n    var newEvent = new ol.MapBrowserPointerEvent(\n        ol.MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== 0) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = 0;\n      newEvent = new ol.MapBrowserPointerEvent(\n          ol.MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(function() {\n        this.clickTimeoutId_ = 0;\n        var newEvent = new ol.MapBrowserPointerEvent(\n            ol.MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n  \n  \n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @private\n   */\n  ol.MapBrowserEventHandler.prototype.updateActivePointers_ = function(pointerEvent) {\n    var event = pointerEvent;\n  \n    if (event.type == ol.MapBrowserEventType.POINTERUP ||\n        event.type == ol.MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == ol.MapBrowserEventType.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  };\n  \n  \n  /**\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @private\n   */\n  ol.MapBrowserEventHandler.prototype.handlePointerUp_ = function(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new ol.MapBrowserPointerEvent(\n        ol.MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n  \n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n  \n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(ol.events.unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  ol.MapBrowserEventHandler.prototype.isMouseActionButton_ = function(pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n  \n  \n  /**\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @private\n   */\n  ol.MapBrowserEventHandler.prototype.handlePointerDown_ = function(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new ol.MapBrowserPointerEvent(\n        ol.MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n  \n    this.down_ = pointerEvent;\n  \n    if (this.dragListenerKeys_.length === 0) {\n      /* Set up a pointer event handler on the `document`,\n       * which is required when the pointer is moved outside\n       * the viewport when dragging.\n       */\n      this.documentPointerEventHandler_ =\n          new ol.pointer.PointerEventHandler(document);\n  \n      this.dragListenerKeys_.push(\n          ol.events.listen(this.documentPointerEventHandler_,\n              ol.MapBrowserEventType.POINTERMOVE,\n              this.handlePointerMove_, this),\n          ol.events.listen(this.documentPointerEventHandler_,\n              ol.MapBrowserEventType.POINTERUP,\n              this.handlePointerUp_, this),\n          /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n          ol.events.listen(this.pointerEventHandler_,\n              ol.MapBrowserEventType.POINTERCANCEL,\n              this.handlePointerUp_, this)\n      );\n    }\n  };\n  \n  \n  /**\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @private\n   */\n  ol.MapBrowserEventHandler.prototype.handlePointerMove_ = function(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      var newEvent = new ol.MapBrowserPointerEvent(\n          ol.MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent,\n          this.dragging_);\n      this.dispatchEvent(newEvent);\n    }\n  \n    // Some native android browser triggers mousemove events during small period\n    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n    // https://code.google.com/p/android/issues/detail?id=19827\n    // ex: Galaxy Tab P3110 + Android 4.1.1\n    pointerEvent.preventDefault();\n  };\n  \n  \n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserPointerEvent matches the PointerEvent type.\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @private\n   */\n  ol.MapBrowserEventHandler.prototype.relayEvent_ = function(pointerEvent) {\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new ol.MapBrowserPointerEvent(\n        pointerEvent.type, this.map_, pointerEvent, dragging));\n  };\n  \n  \n  /**\n   * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  ol.MapBrowserEventHandler.prototype.isMoving_ = function(pointerEvent) {\n    return Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||\n        Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.MapBrowserEventHandler.prototype.disposeInternal = function() {\n    if (this.relayedListenerKey_) {\n      ol.events.unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    if (this.pointerdownListenerKey_) {\n      ol.events.unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n  \n    this.dragListenerKeys_.forEach(ol.events.unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n  \n    if (this.documentPointerEventHandler_) {\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n    if (this.pointerEventHandler_) {\n      this.pointerEventHandler_.dispose();\n      this.pointerEventHandler_ = null;\n    }\n    ol.events.EventTarget.prototype.disposeInternal.call(this);\n  };\n  \n  goog.provide('ol.MapEventType');\n  \n  /**\n   * @enum {string}\n   */\n  ol.MapEventType = {\n  \n    /**\n     * Triggered after a map frame is rendered.\n     * @event ol.MapEvent#postrender\n     * @api\n     */\n    POSTRENDER: 'postrender',\n  \n    /**\n     * Triggered when the map starts moving.\n     * @event ol.MapEvent#movestart\n     * @api\n     */\n    MOVESTART: 'movestart',\n  \n    /**\n     * Triggered after the map is moved.\n     * @event ol.MapEvent#moveend\n     * @api\n     */\n    MOVEEND: 'moveend'\n  \n  };\n  \n  goog.provide('ol.MapProperty');\n  \n  /**\n   * @enum {string}\n   */\n  ol.MapProperty = {\n    LAYERGROUP: 'layergroup',\n    SIZE: 'size',\n    TARGET: 'target',\n    VIEW: 'view'\n  };\n  \n  goog.provide('ol.TileState');\n  \n  /**\n   * @enum {number}\n   */\n  ol.TileState = {\n    IDLE: 0,\n    LOADING: 1,\n    LOADED: 2,\n    ERROR: 3,\n    EMPTY: 4,\n    ABORT: 5\n  };\n  \n  goog.provide('ol.structs.PriorityQueue');\n  \n  goog.require('ol.asserts');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * Priority queue.\n   *\n   * The implementation is inspired from the Closure Library's Heap class and\n   * Python's heapq module.\n   *\n   * @see http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html\n   * @see http://hg.python.org/cpython/file/2.7/Lib/heapq.py\n   *\n   * @constructor\n   * @param {function(T): number} priorityFunction Priority function.\n   * @param {function(T): string} keyFunction Key function.\n   * @struct\n   * @template T\n   */\n  ol.structs.PriorityQueue = function(priorityFunction, keyFunction) {\n  \n    /**\n     * @type {function(T): number}\n     * @private\n     */\n    this.priorityFunction_ = priorityFunction;\n  \n    /**\n     * @type {function(T): string}\n     * @private\n     */\n    this.keyFunction_ = keyFunction;\n  \n    /**\n     * @type {Array.<T>}\n     * @private\n     */\n    this.elements_ = [];\n  \n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n    this.priorities_ = [];\n  \n    /**\n     * @type {Object.<string, boolean>}\n     * @private\n     */\n    this.queuedElements_ = {};\n  \n  };\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.structs.PriorityQueue.DROP = Infinity;\n  \n  \n  /**\n   * FIXME empty description for jsdoc\n   */\n  ol.structs.PriorityQueue.prototype.clear = function() {\n    this.elements_.length = 0;\n    this.priorities_.length = 0;\n    ol.obj.clear(this.queuedElements_);\n  };\n  \n  \n  /**\n   * Remove and return the highest-priority element. O(log N).\n   * @return {T} Element.\n   */\n  ol.structs.PriorityQueue.prototype.dequeue = function() {\n    var elements = this.elements_;\n    var priorities = this.priorities_;\n    var element = elements[0];\n    if (elements.length == 1) {\n      elements.length = 0;\n      priorities.length = 0;\n    } else {\n      elements[0] = elements.pop();\n      priorities[0] = priorities.pop();\n      this.siftUp_(0);\n    }\n    var elementKey = this.keyFunction_(element);\n    delete this.queuedElements_[elementKey];\n    return element;\n  };\n  \n  \n  /**\n   * Enqueue an element. O(log N).\n   * @param {T} element Element.\n   * @return {boolean} The element was added to the queue.\n   */\n  ol.structs.PriorityQueue.prototype.enqueue = function(element) {\n    ol.asserts.assert(!(this.keyFunction_(element) in this.queuedElements_),\n        31); // Tried to enqueue an `element` that was already added to the queue\n    var priority = this.priorityFunction_(element);\n    if (priority != ol.structs.PriorityQueue.DROP) {\n      this.elements_.push(element);\n      this.priorities_.push(priority);\n      this.queuedElements_[this.keyFunction_(element)] = true;\n      this.siftDown_(0, this.elements_.length - 1);\n      return true;\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @return {number} Count.\n   */\n  ol.structs.PriorityQueue.prototype.getCount = function() {\n    return this.elements_.length;\n  };\n  \n  \n  /**\n   * Gets the index of the left child of the node at the given index.\n   * @param {number} index The index of the node to get the left child for.\n   * @return {number} The index of the left child.\n   * @private\n   */\n  ol.structs.PriorityQueue.prototype.getLeftChildIndex_ = function(index) {\n    return index * 2 + 1;\n  };\n  \n  \n  /**\n   * Gets the index of the right child of the node at the given index.\n   * @param {number} index The index of the node to get the right child for.\n   * @return {number} The index of the right child.\n   * @private\n   */\n  ol.structs.PriorityQueue.prototype.getRightChildIndex_ = function(index) {\n    return index * 2 + 2;\n  };\n  \n  \n  /**\n   * Gets the index of the parent of the node at the given index.\n   * @param {number} index The index of the node to get the parent for.\n   * @return {number} The index of the parent.\n   * @private\n   */\n  ol.structs.PriorityQueue.prototype.getParentIndex_ = function(index) {\n    return (index - 1) >> 1;\n  };\n  \n  \n  /**\n   * Make this a heap. O(N).\n   * @private\n   */\n  ol.structs.PriorityQueue.prototype.heapify_ = function() {\n    var i;\n    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n      this.siftUp_(i);\n    }\n  };\n  \n  \n  /**\n   * @return {boolean} Is empty.\n   */\n  ol.structs.PriorityQueue.prototype.isEmpty = function() {\n    return this.elements_.length === 0;\n  };\n  \n  \n  /**\n   * @param {string} key Key.\n   * @return {boolean} Is key queued.\n   */\n  ol.structs.PriorityQueue.prototype.isKeyQueued = function(key) {\n    return key in this.queuedElements_;\n  };\n  \n  \n  /**\n   * @param {T} element Element.\n   * @return {boolean} Is queued.\n   */\n  ol.structs.PriorityQueue.prototype.isQueued = function(element) {\n    return this.isKeyQueued(this.keyFunction_(element));\n  };\n  \n  \n  /**\n   * @param {number} index The index of the node to move down.\n   * @private\n   */\n  ol.structs.PriorityQueue.prototype.siftUp_ = function(index) {\n    var elements = this.elements_;\n    var priorities = this.priorities_;\n    var count = elements.length;\n    var element = elements[index];\n    var priority = priorities[index];\n    var startIndex = index;\n  \n    while (index < (count >> 1)) {\n      var lIndex = this.getLeftChildIndex_(index);\n      var rIndex = this.getRightChildIndex_(index);\n  \n      var smallerChildIndex = rIndex < count &&\n          priorities[rIndex] < priorities[lIndex] ?\n        rIndex : lIndex;\n  \n      elements[index] = elements[smallerChildIndex];\n      priorities[index] = priorities[smallerChildIndex];\n      index = smallerChildIndex;\n    }\n  \n    elements[index] = element;\n    priorities[index] = priority;\n    this.siftDown_(startIndex, index);\n  };\n  \n  \n  /**\n   * @param {number} startIndex The index of the root.\n   * @param {number} index The index of the node to move up.\n   * @private\n   */\n  ol.structs.PriorityQueue.prototype.siftDown_ = function(startIndex, index) {\n    var elements = this.elements_;\n    var priorities = this.priorities_;\n    var element = elements[index];\n    var priority = priorities[index];\n  \n    while (index > startIndex) {\n      var parentIndex = this.getParentIndex_(index);\n      if (priorities[parentIndex] > priority) {\n        elements[index] = elements[parentIndex];\n        priorities[index] = priorities[parentIndex];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n    elements[index] = element;\n    priorities[index] = priority;\n  };\n  \n  \n  /**\n   * FIXME empty description for jsdoc\n   */\n  ol.structs.PriorityQueue.prototype.reprioritize = function() {\n    var priorityFunction = this.priorityFunction_;\n    var elements = this.elements_;\n    var priorities = this.priorities_;\n    var index = 0;\n    var n = elements.length;\n    var element, i, priority;\n    for (i = 0; i < n; ++i) {\n      element = elements[i];\n      priority = priorityFunction(element);\n      if (priority == ol.structs.PriorityQueue.DROP) {\n        delete this.queuedElements_[this.keyFunction_(element)];\n      } else {\n        priorities[index] = priority;\n        elements[index++] = element;\n      }\n    }\n    elements.length = index;\n    priorities.length = index;\n    this.heapify_();\n  };\n  \n  goog.provide('ol.TileQueue');\n  \n  goog.require('ol');\n  goog.require('ol.TileState');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.structs.PriorityQueue');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.structs.PriorityQueue.<Array>}\n   * @param {ol.TilePriorityFunction} tilePriorityFunction\n   *     Tile priority function.\n   * @param {function(): ?} tileChangeCallback\n   *     Function called on each tile change event.\n   * @struct\n   */\n  ol.TileQueue = function(tilePriorityFunction, tileChangeCallback) {\n  \n    ol.structs.PriorityQueue.call(\n        this,\n        /**\n         * @param {Array} element Element.\n         * @return {number} Priority.\n         */\n        function(element) {\n          return tilePriorityFunction.apply(null, element);\n        },\n        /**\n         * @param {Array} element Element.\n         * @return {string} Key.\n         */\n        function(element) {\n          return /** @type {ol.Tile} */ (element[0]).getKey();\n        });\n  \n    /**\n     * @private\n     * @type {function(): ?}\n     */\n    this.tileChangeCallback_ = tileChangeCallback;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilesLoading_ = 0;\n  \n    /**\n     * @private\n     * @type {!Object.<string,boolean>}\n     */\n    this.tilesLoadingKeys_ = {};\n  \n  };\n  ol.inherits(ol.TileQueue, ol.structs.PriorityQueue);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.TileQueue.prototype.enqueue = function(element) {\n    var added = ol.structs.PriorityQueue.prototype.enqueue.call(this, element);\n    if (added) {\n      var tile = element[0];\n      ol.events.listen(tile, ol.events.EventType.CHANGE,\n          this.handleTileChange, this);\n    }\n    return added;\n  };\n  \n  \n  /**\n   * @return {number} Number of tiles loading.\n   */\n  ol.TileQueue.prototype.getTilesLoading = function() {\n    return this.tilesLoading_;\n  };\n  \n  \n  /**\n   * @param {ol.events.Event} event Event.\n   * @protected\n   */\n  ol.TileQueue.prototype.handleTileChange = function(event) {\n    var tile = /** @type {ol.Tile} */ (event.target);\n    var state = tile.getState();\n    if (state === ol.TileState.LOADED || state === ol.TileState.ERROR ||\n        state === ol.TileState.EMPTY || state === ol.TileState.ABORT) {\n      ol.events.unlisten(tile, ol.events.EventType.CHANGE,\n          this.handleTileChange, this);\n      var tileKey = tile.getKey();\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n      this.tileChangeCallback_();\n    }\n  };\n  \n  \n  /**\n   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n   * @param {number} maxNewLoads Maximum number of new tiles to load.\n   */\n  ol.TileQueue.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {\n    var newLoads = 0;\n    var abortedTiles = false;\n    var state, tile, tileKey;\n    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads &&\n           this.getCount() > 0) {\n      tile = /** @type {ol.Tile} */ (this.dequeue()[0]);\n      tileKey = tile.getKey();\n      state = tile.getState();\n      if (state === ol.TileState.ABORT) {\n        abortedTiles = true;\n      } else if (state === ol.TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile.load();\n      }\n    }\n    if (newLoads === 0 && abortedTiles) {\n      // Do not stop the render loop when all wanted tiles were aborted due to\n      // a small, saturated tile cache.\n      this.tileChangeCallback_();\n    }\n  };\n  \n  goog.provide('ol.CenterConstraint');\n  \n  goog.require('ol.math');\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @return {ol.CenterConstraintType} The constraint.\n   */\n  ol.CenterConstraint.createExtent = function(extent) {\n    return (\n      /**\n       * @param {ol.Coordinate|undefined} center Center.\n       * @return {ol.Coordinate|undefined} Center.\n       */\n      function(center) {\n        if (center) {\n          return [\n            ol.math.clamp(center[0], extent[0], extent[2]),\n            ol.math.clamp(center[1], extent[1], extent[3])\n          ];\n        } else {\n          return undefined;\n        }\n      });\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate|undefined} center Center.\n   * @return {ol.Coordinate|undefined} Center.\n   */\n  ol.CenterConstraint.none = function(center) {\n    return center;\n  };\n  \n  goog.provide('ol.ResolutionConstraint');\n  \n  goog.require('ol.array');\n  goog.require('ol.math');\n  \n  \n  /**\n   * @param {Array.<number>} resolutions Resolutions.\n   * @return {ol.ResolutionConstraintType} Zoom function.\n   */\n  ol.ResolutionConstraint.createSnapToResolutions = function(resolutions) {\n    return (\n      /**\n       * @param {number|undefined} resolution Resolution.\n       * @param {number} delta Delta.\n       * @param {number} direction Direction.\n       * @return {number|undefined} Resolution.\n       */\n      function(resolution, delta, direction) {\n        if (resolution !== undefined) {\n          var z =\n                ol.array.linearFindNearest(resolutions, resolution, direction);\n          z = ol.math.clamp(z + delta, 0, resolutions.length - 1);\n          var index = Math.floor(z);\n          if (z != index && index < resolutions.length - 1) {\n            var power = resolutions[index] / resolutions[index + 1];\n            return resolutions[index] / Math.pow(power, z - index);\n          } else {\n            return resolutions[index];\n          }\n        } else {\n          return undefined;\n        }\n      });\n  };\n  \n  \n  /**\n   * @param {number} power Power.\n   * @param {number} maxResolution Maximum resolution.\n   * @param {number=} opt_maxLevel Maximum level.\n   * @return {ol.ResolutionConstraintType} Zoom function.\n   */\n  ol.ResolutionConstraint.createSnapToPower = function(power, maxResolution, opt_maxLevel) {\n    return (\n      /**\n       * @param {number|undefined} resolution Resolution.\n       * @param {number} delta Delta.\n       * @param {number} direction Direction.\n       * @return {number|undefined} Resolution.\n       */\n      function(resolution, delta, direction) {\n        if (resolution !== undefined) {\n          var offset = -direction / 2 + 0.5;\n          var oldLevel = Math.floor(\n              Math.log(maxResolution / resolution) / Math.log(power) + offset);\n          var newLevel = Math.max(oldLevel + delta, 0);\n          if (opt_maxLevel !== undefined) {\n            newLevel = Math.min(newLevel, opt_maxLevel);\n          }\n          return maxResolution / Math.pow(power, newLevel);\n        } else {\n          return undefined;\n        }\n      });\n  };\n  \n  goog.provide('ol.RotationConstraint');\n  \n  goog.require('ol.math');\n  \n  \n  /**\n   * @param {number|undefined} rotation Rotation.\n   * @param {number} delta Delta.\n   * @return {number|undefined} Rotation.\n   */\n  ol.RotationConstraint.disable = function(rotation, delta) {\n    if (rotation !== undefined) {\n      return 0;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {number|undefined} rotation Rotation.\n   * @param {number} delta Delta.\n   * @return {number|undefined} Rotation.\n   */\n  ol.RotationConstraint.none = function(rotation, delta) {\n    if (rotation !== undefined) {\n      return rotation + delta;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {number} n N.\n   * @return {ol.RotationConstraintType} Rotation constraint.\n   */\n  ol.RotationConstraint.createSnapToN = function(n) {\n    var theta = 2 * Math.PI / n;\n    return (\n      /**\n       * @param {number|undefined} rotation Rotation.\n       * @param {number} delta Delta.\n       * @return {number|undefined} Rotation.\n       */\n      function(rotation, delta) {\n        if (rotation !== undefined) {\n          rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;\n          return rotation;\n        } else {\n          return undefined;\n        }\n      });\n  };\n  \n  \n  /**\n   * @param {number=} opt_tolerance Tolerance.\n   * @return {ol.RotationConstraintType} Rotation constraint.\n   */\n  ol.RotationConstraint.createSnapToZero = function(opt_tolerance) {\n    var tolerance = opt_tolerance || ol.math.toRadians(5);\n    return (\n      /**\n       * @param {number|undefined} rotation Rotation.\n       * @param {number} delta Delta.\n       * @return {number|undefined} Rotation.\n       */\n      function(rotation, delta) {\n        if (rotation !== undefined) {\n          if (Math.abs(rotation + delta) <= tolerance) {\n            return 0;\n          } else {\n            return rotation + delta;\n          }\n        } else {\n          return undefined;\n        }\n      });\n  };\n  \n  goog.provide('ol.ViewHint');\n  \n  /**\n   * @enum {number}\n   */\n  ol.ViewHint = {\n    ANIMATING: 0,\n    INTERACTING: 1\n  };\n  \n  goog.provide('ol.ViewProperty');\n  \n  /**\n   * @enum {string}\n   */\n  ol.ViewProperty = {\n    CENTER: 'center',\n    RESOLUTION: 'resolution',\n    ROTATION: 'rotation'\n  };\n  \n  goog.provide('ol.string');\n  \n  /**\n   * @param {number} number Number to be formatted\n   * @param {number} width The desired width\n   * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)\n   * @returns {string} Formatted string\n  */\n  ol.string.padNumber = function(number, width, opt_precision) {\n    var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;\n    var decimal = numberString.indexOf('.');\n    decimal = decimal === -1 ? numberString.length : decimal;\n    return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;\n  };\n  \n  /**\n   * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n   * @param {string|number} v1 First version\n   * @param {string|number} v2 Second version\n   * @returns {number} Value\n   */\n  ol.string.compareVersions = function(v1, v2) {\n    var s1 = ('' + v1).split('.');\n    var s2 = ('' + v2).split('.');\n  \n    for (var i = 0; i < Math.max(s1.length, s2.length); i++) {\n      var n1 = parseInt(s1[i] || '0', 10);\n      var n2 = parseInt(s2[i] || '0', 10);\n  \n      if (n1 > n2) {\n        return 1;\n      }\n      if (n2 > n1) {\n        return -1;\n      }\n    }\n  \n    return 0;\n  };\n  \n  goog.provide('ol.coordinate');\n  \n  goog.require('ol.math');\n  goog.require('ol.string');\n  \n  \n  /**\n   * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n   * by the function.\n   *\n   * Example:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     ol.coordinate.add(coord, [-2, 4]);\n   *     // coord is now [5.85, 51.983333]\n   *\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {ol.Coordinate} delta Delta.\n   * @return {ol.Coordinate} The input coordinate adjusted by the given delta.\n   * @api\n   */\n  ol.coordinate.add = function(coordinate, delta) {\n    coordinate[0] += delta[0];\n    coordinate[1] += delta[1];\n    return coordinate;\n  };\n  \n  \n  /**\n   * Calculates the point closest to the passed coordinate on the passed circle.\n   *\n   * @param {ol.Coordinate} coordinate The coordinate.\n   * @param {ol.geom.Circle} circle The circle.\n   * @return {ol.Coordinate} Closest point on the circumference\n   */\n  ol.coordinate.closestOnCircle = function(coordinate, circle) {\n    var r = circle.getRadius();\n    var center = circle.getCenter();\n    var x0 = center[0];\n    var y0 = center[1];\n    var x1 = coordinate[0];\n    var y1 = coordinate[1];\n  \n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    if (dx === 0 && dy === 0) {\n      dx = 1;\n    }\n    var d = Math.sqrt(dx * dx + dy * dy);\n  \n    var x, y;\n  \n    x = x0 + r * dx / d;\n    y = y0 + r * dy / d;\n  \n    return [x, y];\n  };\n  \n  \n  /**\n   * Calculates the point closest to the passed coordinate on the passed segment.\n   * This is the foot of the perpendicular of the coordinate to the segment when\n   * the foot is on the segment, or the closest segment coordinate when the foot\n   * is outside the segment.\n   *\n   * @param {ol.Coordinate} coordinate The coordinate.\n   * @param {Array.<ol.Coordinate>} segment The two coordinates of the segment.\n   * @return {ol.Coordinate} The foot of the perpendicular of the coordinate to\n   *     the segment.\n   */\n  ol.coordinate.closestOnSegment = function(coordinate, segment) {\n    var x0 = coordinate[0];\n    var y0 = coordinate[1];\n    var start = segment[0];\n    var end = segment[1];\n    var x1 = start[0];\n    var y1 = start[1];\n    var x2 = end[0];\n    var y2 = end[1];\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var along = (dx === 0 && dy === 0) ? 0 :\n      ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);\n    var x, y;\n    if (along <= 0) {\n      x = x1;\n      y = y1;\n    } else if (along >= 1) {\n      x = x2;\n      y = y2;\n    } else {\n      x = x1 + along * dx;\n      y = y1 + along * dy;\n    }\n    return [x, y];\n  };\n  \n  \n  /**\n   * Returns a {@link ol.CoordinateFormatType} function that can be used to format\n   * a {ol.Coordinate} to a string.\n   *\n   * Example without specifying the fractional digits:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var stringifyFunc = ol.coordinate.createStringXY();\n   *     var out = stringifyFunc(coord);\n   *     // out is now '8, 48'\n   *\n   * Example with explicitly specifying 2 fractional digits:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var stringifyFunc = ol.coordinate.createStringXY(2);\n   *     var out = stringifyFunc(coord);\n   *     // out is now '7.85, 47.98'\n   *\n   * @param {number=} opt_fractionDigits The number of digits to include\n   *    after the decimal point. Default is `0`.\n   * @return {ol.CoordinateFormatType} Coordinate format.\n   * @api\n   */\n  ol.coordinate.createStringXY = function(opt_fractionDigits) {\n    return (\n      /**\n       * @param {ol.Coordinate|undefined} coordinate Coordinate.\n       * @return {string} String XY.\n       */\n      function(coordinate) {\n        return ol.coordinate.toStringXY(coordinate, opt_fractionDigits);\n      });\n  };\n  \n  \n  /**\n   * @param {string} hemispheres Hemispheres.\n   * @param {number} degrees Degrees.\n   * @param {number=} opt_fractionDigits The number of digits to include\n   *    after the decimal point. Default is `0`.\n   * @return {string} String.\n   */\n  ol.coordinate.degreesToStringHDMS = function(hemispheres, degrees, opt_fractionDigits) {\n    var normalizedDegrees = ol.math.modulo(degrees + 180, 360) - 180;\n    var x = Math.abs(3600 * normalizedDegrees);\n    var dflPrecision = opt_fractionDigits || 0;\n    var precision = Math.pow(10, dflPrecision);\n  \n    var deg = Math.floor(x / 3600);\n    var min = Math.floor((x - deg * 3600) / 60);\n    var sec = x - (deg * 3600) - (min * 60);\n    sec = Math.ceil(sec * precision) / precision;\n  \n    if (sec >= 60) {\n      sec = 0;\n      min += 1;\n    }\n  \n    if (min >= 60) {\n      min = 0;\n      deg += 1;\n    }\n  \n    return deg + '\\u00b0 ' + ol.string.padNumber(min, 2) + '\\u2032 ' +\n      ol.string.padNumber(sec, 2, dflPrecision) + '\\u2033' +\n      (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));\n  };\n  \n  \n  /**\n   * Transforms the given {@link ol.Coordinate} to a string using the given string\n   * template. The strings `{x}` and `{y}` in the template will be replaced with\n   * the first and second coordinate values respectively.\n   *\n   * Example without specifying the fractional digits:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var template = 'Coordinate is ({x}|{y}).';\n   *     var out = ol.coordinate.format(coord, template);\n   *     // out is now 'Coordinate is (8|48).'\n   *\n   * Example explicitly specifying the fractional digits:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var template = 'Coordinate is ({x}|{y}).';\n   *     var out = ol.coordinate.format(coord, template, 2);\n   *     // out is now 'Coordinate is (7.85|47.98).'\n   *\n   * @param {ol.Coordinate|undefined} coordinate Coordinate.\n   * @param {string} template A template string with `{x}` and `{y}` placeholders\n   *     that will be replaced by first and second coordinate values.\n   * @param {number=} opt_fractionDigits The number of digits to include\n   *    after the decimal point. Default is `0`.\n   * @return {string} Formatted coordinate.\n   * @api\n   */\n  ol.coordinate.format = function(coordinate, template, opt_fractionDigits) {\n    if (coordinate) {\n      return template\n          .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))\n          .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));\n    } else {\n      return '';\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate1 First coordinate.\n   * @param {ol.Coordinate} coordinate2 Second coordinate.\n   * @return {boolean} Whether the passed coordinates are equal.\n   */\n  ol.coordinate.equals = function(coordinate1, coordinate2) {\n    var equals = true;\n    for (var i = coordinate1.length - 1; i >= 0; --i) {\n      if (coordinate1[i] != coordinate2[i]) {\n        equals = false;\n        break;\n      }\n    }\n    return equals;\n  };\n  \n  \n  /**\n   * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n   * returned by the function.\n   *\n   * Example:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var rotateRadians = Math.PI / 2; // 90 degrees\n   *     ol.coordinate.rotate(coord, rotateRadians);\n   *     // coord is now [-47.983333, 7.85]\n   *\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} angle Angle in radian.\n   * @return {ol.Coordinate} Coordinate.\n   * @api\n   */\n  ol.coordinate.rotate = function(coordinate, angle) {\n    var cosAngle = Math.cos(angle);\n    var sinAngle = Math.sin(angle);\n    var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    coordinate[0] = x;\n    coordinate[1] = y;\n    return coordinate;\n  };\n  \n  \n  /**\n   * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n   * by the function.\n   *\n   * Example:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var scale = 1.2;\n   *     ol.coordinate.scale(coord, scale);\n   *     // coord is now [9.42, 57.5799996]\n   *\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} scale Scale factor.\n   * @return {ol.Coordinate} Coordinate.\n   */\n  ol.coordinate.scale = function(coordinate, scale) {\n    coordinate[0] *= scale;\n    coordinate[1] *= scale;\n    return coordinate;\n  };\n  \n  \n  /**\n   * Subtract `delta` to `coordinate`. `coordinate` is modified in place and\n   * returned by the function.\n   *\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {ol.Coordinate} delta Delta.\n   * @return {ol.Coordinate} Coordinate.\n   */\n  ol.coordinate.sub = function(coordinate, delta) {\n    coordinate[0] -= delta[0];\n    coordinate[1] -= delta[1];\n    return coordinate;\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coord1 First coordinate.\n   * @param {ol.Coordinate} coord2 Second coordinate.\n   * @return {number} Squared distance between coord1 and coord2.\n   */\n  ol.coordinate.squaredDistance = function(coord1, coord2) {\n    var dx = coord1[0] - coord2[0];\n    var dy = coord1[1] - coord2[1];\n    return dx * dx + dy * dy;\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coord1 First coordinate.\n   * @param {ol.Coordinate} coord2 Second coordinate.\n   * @return {number} Distance between coord1 and coord2.\n   */\n  ol.coordinate.distance = function(coord1, coord2) {\n    return Math.sqrt(ol.coordinate.squaredDistance(coord1, coord2));\n  };\n  \n  \n  /**\n   * Calculate the squared distance from a coordinate to a line segment.\n   *\n   * @param {ol.Coordinate} coordinate Coordinate of the point.\n   * @param {Array.<ol.Coordinate>} segment Line segment (2 coordinates).\n   * @return {number} Squared distance from the point to the line segment.\n   */\n  ol.coordinate.squaredDistanceToSegment = function(coordinate, segment) {\n    return ol.coordinate.squaredDistance(coordinate,\n        ol.coordinate.closestOnSegment(coordinate, segment));\n  };\n  \n  \n  /**\n   * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n   * seconds.\n   *\n   * Example without specifying fractional digits:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var out = ol.coordinate.toStringHDMS(coord);\n   *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'\n   *\n   * Example explicitly specifying 1 fractional digit:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var out = ol.coordinate.toStringHDMS(coord, 1);\n   *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'\n   *\n   * @param {ol.Coordinate|undefined} coordinate Coordinate.\n   * @param {number=} opt_fractionDigits The number of digits to include\n   *    after the decimal point. Default is `0`.\n   * @return {string} Hemisphere, degrees, minutes and seconds.\n   * @api\n   */\n  ol.coordinate.toStringHDMS = function(coordinate, opt_fractionDigits) {\n    if (coordinate) {\n      return ol.coordinate.degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' +\n          ol.coordinate.degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);\n    } else {\n      return '';\n    }\n  };\n  \n  \n  /**\n   * Format a coordinate as a comma delimited string.\n   *\n   * Example without specifying fractional digits:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var out = ol.coordinate.toStringXY(coord);\n   *     // out is now '8, 48'\n   *\n   * Example explicitly specifying 1 fractional digit:\n   *\n   *     var coord = [7.85, 47.983333];\n   *     var out = ol.coordinate.toStringXY(coord, 1);\n   *     // out is now '7.8, 48.0'\n   *\n   * @param {ol.Coordinate|undefined} coordinate Coordinate.\n   * @param {number=} opt_fractionDigits The number of digits to include\n   *    after the decimal point. Default is `0`.\n   * @return {string} XY.\n   * @api\n   */\n  ol.coordinate.toStringXY = function(coordinate, opt_fractionDigits) {\n    return ol.coordinate.format(coordinate, '{x}, {y}', opt_fractionDigits);\n  };\n  \n  goog.provide('ol.easing');\n  \n  \n  /**\n   * Start slow and speed up.\n   * @param {number} t Input between 0 and 1.\n   * @return {number} Output between 0 and 1.\n   * @api\n   */\n  ol.easing.easeIn = function(t) {\n    return Math.pow(t, 3);\n  };\n  \n  \n  /**\n   * Start fast and slow down.\n   * @param {number} t Input between 0 and 1.\n   * @return {number} Output between 0 and 1.\n   * @api\n   */\n  ol.easing.easeOut = function(t) {\n    return 1 - ol.easing.easeIn(1 - t);\n  };\n  \n  \n  /**\n   * Start slow, speed up, and then slow down again.\n   * @param {number} t Input between 0 and 1.\n   * @return {number} Output between 0 and 1.\n   * @api\n   */\n  ol.easing.inAndOut = function(t) {\n    return 3 * t * t - 2 * t * t * t;\n  };\n  \n  \n  /**\n   * Maintain a constant speed over time.\n   * @param {number} t Input between 0 and 1.\n   * @return {number} Output between 0 and 1.\n   * @api\n   */\n  ol.easing.linear = function(t) {\n    return t;\n  };\n  \n  \n  /**\n   * Start slow, speed up, and at the very end slow down again.  This has the\n   * same general behavior as {@link ol.easing.inAndOut}, but the final slowdown\n   * is delayed.\n   * @param {number} t Input between 0 and 1.\n   * @return {number} Output between 0 and 1.\n   * @api\n   */\n  ol.easing.upAndDown = function(t) {\n    if (t < 0.5) {\n      return ol.easing.inAndOut(2 * t);\n    } else {\n      return 1 - ol.easing.inAndOut(2 * (t - 0.5));\n    }\n  };\n  \n  goog.provide('ol.geom.GeometryLayout');\n  \n  \n  /**\n   * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n   * or measure ('M') coordinate is available. Supported values are `'XY'`,\n   * `'XYZ'`, `'XYM'`, `'XYZM'`.\n   * @enum {string}\n   */\n  ol.geom.GeometryLayout = {\n    XY: 'XY',\n    XYZ: 'XYZ',\n    XYM: 'XYM',\n    XYZM: 'XYZM'\n  };\n  \n  goog.provide('ol.functions');\n  \n  /**\n   * Always returns true.\n   * @returns {boolean} true.\n   */\n  ol.functions.TRUE = function() {\n    return true;\n  };\n  \n  /**\n   * Always returns false.\n   * @returns {boolean} false.\n   */\n  ol.functions.FALSE = function() {\n    return false;\n  };\n  \n  goog.provide('ol.geom.flat.transform');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {ol.Transform} transform Transform.\n   * @param {Array.<number>=} opt_dest Destination.\n   * @return {Array.<number>} Transformed coordinates.\n   */\n  ol.geom.flat.transform.transform2D = function(flatCoordinates, offset, end, stride, transform, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var i = 0;\n    var j;\n    for (j = offset; j < end; j += stride) {\n      var x = flatCoordinates[j];\n      var y = flatCoordinates[j + 1];\n      dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n      dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n    }\n    if (opt_dest && dest.length != i) {\n      dest.length = i;\n    }\n    return dest;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} angle Angle.\n   * @param {Array.<number>} anchor Rotation anchor point.\n   * @param {Array.<number>=} opt_dest Destination.\n   * @return {Array.<number>} Transformed coordinates.\n   */\n  ol.geom.flat.transform.rotate = function(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var anchorX = anchor[0];\n    var anchorY = anchor[1];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n      var deltaX = flatCoordinates[j] - anchorX;\n      var deltaY = flatCoordinates[j + 1] - anchorY;\n      dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n      dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n      for (var k = j + 2; k < j + stride; ++k) {\n        dest[i++] = flatCoordinates[k];\n      }\n    }\n    if (opt_dest && dest.length != i) {\n      dest.length = i;\n    }\n    return dest;\n  };\n  \n  \n  /**\n   * Scale the coordinates.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} sx Scale factor in the x-direction.\n   * @param {number} sy Scale factor in the y-direction.\n   * @param {Array.<number>} anchor Scale anchor point.\n   * @param {Array.<number>=} opt_dest Destination.\n   * @return {Array.<number>} Transformed coordinates.\n   */\n  ol.geom.flat.transform.scale = function(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var anchorX = anchor[0];\n    var anchorY = anchor[1];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n      var deltaX = flatCoordinates[j] - anchorX;\n      var deltaY = flatCoordinates[j + 1] - anchorY;\n      dest[i++] = anchorX + sx * deltaX;\n      dest[i++] = anchorY + sy * deltaY;\n      for (var k = j + 2; k < j + stride; ++k) {\n        dest[i++] = flatCoordinates[k];\n      }\n    }\n    if (opt_dest && dest.length != i) {\n      dest.length = i;\n    }\n    return dest;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @param {Array.<number>=} opt_dest Destination.\n   * @return {Array.<number>} Transformed coordinates.\n   */\n  ol.geom.flat.transform.translate = function(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var i = 0;\n    var j, k;\n    for (j = offset; j < end; j += stride) {\n      dest[i++] = flatCoordinates[j] + deltaX;\n      dest[i++] = flatCoordinates[j + 1] + deltaY;\n      for (k = j + 2; k < j + stride; ++k) {\n        dest[i++] = flatCoordinates[k];\n      }\n    }\n    if (opt_dest && dest.length != i) {\n      dest.length = i;\n    }\n    return dest;\n  };\n  \n  goog.provide('ol.transform');\n  \n  goog.require('ol.asserts');\n  \n  \n  /**\n   * Collection of affine 2d transformation functions. The functions work on an\n   * array of 6 elements. The element order is compatible with the [SVGMatrix\n   * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n   * a subset (elements a to f) of a 3x3 martrix:\n   * ```\n   * [ a c e ]\n   * [ b d f ]\n   * [ 0 0 1 ]\n   * ```\n   */\n  \n  \n  /**\n   * @private\n   * @type {ol.Transform}\n   */\n  ol.transform.tmp_ = new Array(6);\n  \n  \n  /**\n   * Create an identity transform.\n   * @return {!ol.Transform} Identity transform.\n   */\n  ol.transform.create = function() {\n    return [1, 0, 0, 1, 0, 0];\n  };\n  \n  \n  /**\n   * Resets the given transform to an identity transform.\n   * @param {!ol.Transform} transform Transform.\n   * @return {!ol.Transform} Transform.\n   */\n  ol.transform.reset = function(transform) {\n    return ol.transform.set(transform, 1, 0, 0, 1, 0, 0);\n  };\n  \n  \n  /**\n   * Multiply the underlying matrices of two transforms and return the result in\n   * the first transform.\n   * @param {!ol.Transform} transform1 Transform parameters of matrix 1.\n   * @param {!ol.Transform} transform2 Transform parameters of matrix 2.\n   * @return {!ol.Transform} transform1 multiplied with transform2.\n   */\n  ol.transform.multiply = function(transform1, transform2) {\n    var a1 = transform1[0];\n    var b1 = transform1[1];\n    var c1 = transform1[2];\n    var d1 = transform1[3];\n    var e1 = transform1[4];\n    var f1 = transform1[5];\n    var a2 = transform2[0];\n    var b2 = transform2[1];\n    var c2 = transform2[2];\n    var d2 = transform2[3];\n    var e2 = transform2[4];\n    var f2 = transform2[5];\n  \n    transform1[0] = a1 * a2 + c1 * b2;\n    transform1[1] = b1 * a2 + d1 * b2;\n    transform1[2] = a1 * c2 + c1 * d2;\n    transform1[3] = b1 * c2 + d1 * d2;\n    transform1[4] = a1 * e2 + c1 * f2 + e1;\n    transform1[5] = b1 * e2 + d1 * f2 + f1;\n  \n    return transform1;\n  };\n  \n  /**\n   * Set the transform components a-f on a given transform.\n   * @param {!ol.Transform} transform Transform.\n   * @param {number} a The a component of the transform.\n   * @param {number} b The b component of the transform.\n   * @param {number} c The c component of the transform.\n   * @param {number} d The d component of the transform.\n   * @param {number} e The e component of the transform.\n   * @param {number} f The f component of the transform.\n   * @return {!ol.Transform} Matrix with transform applied.\n   */\n  ol.transform.set = function(transform, a, b, c, d, e, f) {\n    transform[0] = a;\n    transform[1] = b;\n    transform[2] = c;\n    transform[3] = d;\n    transform[4] = e;\n    transform[5] = f;\n    return transform;\n  };\n  \n  \n  /**\n   * Set transform on one matrix from another matrix.\n   * @param {!ol.Transform} transform1 Matrix to set transform to.\n   * @param {!ol.Transform} transform2 Matrix to set transform from.\n   * @return {!ol.Transform} transform1 with transform from transform2 applied.\n   */\n  ol.transform.setFromArray = function(transform1, transform2) {\n    transform1[0] = transform2[0];\n    transform1[1] = transform2[1];\n    transform1[2] = transform2[2];\n    transform1[3] = transform2[3];\n    transform1[4] = transform2[4];\n    transform1[5] = transform2[5];\n    return transform1;\n  };\n  \n  \n  /**\n   * Transforms the given coordinate with the given transform returning the\n   * resulting, transformed coordinate. The coordinate will be modified in-place.\n   *\n   * @param {ol.Transform} transform The transformation.\n   * @param {ol.Coordinate|ol.Pixel} coordinate The coordinate to transform.\n   * @return {ol.Coordinate|ol.Pixel} return coordinate so that operations can be\n   *     chained together.\n   */\n  ol.transform.apply = function(transform, coordinate) {\n    var x = coordinate[0], y = coordinate[1];\n    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n    return coordinate;\n  };\n  \n  \n  /**\n   * Applies rotation to the given transform.\n   * @param {!ol.Transform} transform Transform.\n   * @param {number} angle Angle in radians.\n   * @return {!ol.Transform} The rotated transform.\n   */\n  ol.transform.rotate = function(transform, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return ol.transform.multiply(transform,\n        ol.transform.set(ol.transform.tmp_, cos, sin, -sin, cos, 0, 0));\n  };\n  \n  \n  /**\n   * Applies scale to a given transform.\n   * @param {!ol.Transform} transform Transform.\n   * @param {number} x Scale factor x.\n   * @param {number} y Scale factor y.\n   * @return {!ol.Transform} The scaled transform.\n   */\n  ol.transform.scale = function(transform, x, y) {\n    return ol.transform.multiply(transform,\n        ol.transform.set(ol.transform.tmp_, x, 0, 0, y, 0, 0));\n  };\n  \n  \n  /**\n   * Applies translation to the given transform.\n   * @param {!ol.Transform} transform Transform.\n   * @param {number} dx Translation x.\n   * @param {number} dy Translation y.\n   * @return {!ol.Transform} The translated transform.\n   */\n  ol.transform.translate = function(transform, dx, dy) {\n    return ol.transform.multiply(transform,\n        ol.transform.set(ol.transform.tmp_, 1, 0, 0, 1, dx, dy));\n  };\n  \n  \n  /**\n   * Creates a composite transform given an initial translation, scale, rotation, and\n   * final translation (in that order only, not commutative).\n   * @param {!ol.Transform} transform The transform (will be modified in place).\n   * @param {number} dx1 Initial translation x.\n   * @param {number} dy1 Initial translation y.\n   * @param {number} sx Scale factor x.\n   * @param {number} sy Scale factor y.\n   * @param {number} angle Rotation (in counter-clockwise radians).\n   * @param {number} dx2 Final translation x.\n   * @param {number} dy2 Final translation y.\n   * @return {!ol.Transform} The composite transform.\n   */\n  ol.transform.compose = function(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n    var sin = Math.sin(angle);\n    var cos = Math.cos(angle);\n    transform[0] = sx * cos;\n    transform[1] = sy * sin;\n    transform[2] = -sx * sin;\n    transform[3] = sy * cos;\n    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n    return transform;\n  };\n  \n  \n  /**\n   * Invert the given transform.\n   * @param {!ol.Transform} transform Transform.\n   * @return {!ol.Transform} Inverse of the transform.\n   */\n  ol.transform.invert = function(transform) {\n    var det = ol.transform.determinant(transform);\n    ol.asserts.assert(det !== 0, 32); // Transformation matrix cannot be inverted\n  \n    var a = transform[0];\n    var b = transform[1];\n    var c = transform[2];\n    var d = transform[3];\n    var e = transform[4];\n    var f = transform[5];\n  \n    transform[0] = d / det;\n    transform[1] = -b / det;\n    transform[2] = -c / det;\n    transform[3] = a / det;\n    transform[4] = (c * f - d * e) / det;\n    transform[5] = -(a * f - b * e) / det;\n  \n    return transform;\n  };\n  \n  \n  /**\n   * Returns the determinant of the given matrix.\n   * @param {!ol.Transform} mat Matrix.\n   * @return {number} Determinant.\n   */\n  ol.transform.determinant = function(mat) {\n    return mat[0] * mat[3] - mat[1] * mat[2];\n  };\n  \n  goog.provide('ol.geom.Geometry');\n  \n  goog.require('ol');\n  goog.require('ol.Object');\n  goog.require('ol.extent');\n  goog.require('ol.functions');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.proj');\n  goog.require('ol.proj.Units');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Base class for vector geometries.\n   *\n   * To get notified of changes to the geometry, register a listener for the\n   * generic `change` event on your geometry instance.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.Object}\n   * @api\n   */\n  ol.geom.Geometry = function() {\n  \n    ol.Object.call(this);\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.extent_ = ol.extent.createEmpty();\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n  \n    /**\n     * @protected\n     * @type {Object.<string, ol.geom.Geometry>}\n     */\n    this.simplifiedGeometryCache = {};\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.tmpTransform_ = ol.transform.create();\n  \n  };\n  ol.inherits(ol.geom.Geometry, ol.Object);\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!ol.geom.Geometry} Clone.\n   */\n  ol.geom.Geometry.prototype.clone = function() {};\n  \n  \n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {ol.Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  ol.geom.Geometry.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {};\n  \n  \n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link ol.Coordinate coordinate}.\n   * @param {ol.Coordinate} point Point.\n   * @param {ol.Coordinate=} opt_closestPoint Closest point.\n   * @return {ol.Coordinate} Closest point.\n   * @api\n   */\n  ol.geom.Geometry.prototype.getClosestPoint = function(point, opt_closestPoint) {\n    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  };\n  \n  \n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  ol.geom.Geometry.prototype.intersectsCoordinate = function(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {ol.Extent} extent Extent.\n   * @protected\n   * @return {ol.Extent} extent Extent.\n   */\n  ol.geom.Geometry.prototype.computeExtent = function(extent) {};\n  \n  \n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  ol.geom.Geometry.prototype.containsXY = ol.functions.FALSE;\n  \n  \n  /**\n   * Get the extent of the geometry.\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} extent Extent.\n   * @api\n   */\n  ol.geom.Geometry.prototype.getExtent = function(opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      this.extent_ = this.computeExtent(this.extent_);\n      this.extentRevision_ = this.getRevision();\n    }\n    return ol.extent.returnOrUpdate(this.extent_, opt_extent);\n  };\n  \n  \n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {ol.Coordinate} anchor The rotation center.\n   * @api\n   */\n  ol.geom.Geometry.prototype.rotate = function(angle, anchor) {};\n  \n  \n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n   *     sx).\n   * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  ol.geom.Geometry.prototype.scale = function(sx, opt_sy, opt_anchor) {};\n  \n  \n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the the {@link\n   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n   * Douglas Peucker} algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @function\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {ol.geom.Geometry} A new, simplified version of the original\n   *     geometry.\n   * @api\n   */\n  ol.geom.Geometry.prototype.simplify = function(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  };\n  \n  \n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {ol.geom.Geometry} Simplified geometry.\n   */\n  ol.geom.Geometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {};\n  \n  \n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {ol.geom.GeometryType} Geometry type.\n   */\n  ol.geom.Geometry.prototype.getType = function() {};\n  \n  \n  /**\n   * Apply a transform function to each coordinate of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {ol.TransformFunction} transformFn Transform.\n   */\n  ol.geom.Geometry.prototype.applyTransform = function(transformFn) {};\n  \n  \n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {ol.Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  ol.geom.Geometry.prototype.intersectsExtent = function(extent) {};\n  \n  \n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   */\n  ol.geom.Geometry.prototype.translate = function(deltaX, deltaY) {};\n  \n  \n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {ol.ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link ol.proj.Projection} object.\n   * @param {ol.ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link ol.proj.Projection} object.\n   * @return {ol.geom.Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  ol.geom.Geometry.prototype.transform = function(source, destination) {\n    var tmpTransform = this.tmpTransform_;\n    source = ol.proj.get(source);\n    var transformFn = source.getUnits() == ol.proj.Units.TILE_PIXELS ?\n      function(inCoordinates, outCoordinates, stride) {\n        var pixelExtent = source.getExtent();\n        var projectedExtent = source.getWorldExtent();\n        var scale = ol.extent.getHeight(projectedExtent) / ol.extent.getHeight(pixelExtent);\n        ol.transform.compose(tmpTransform,\n            projectedExtent[0], projectedExtent[3],\n            scale, -scale, 0,\n            0, 0);\n        ol.geom.flat.transform.transform2D(inCoordinates, 0, inCoordinates.length, stride,\n            tmpTransform, outCoordinates);\n        return ol.proj.getTransform(source, destination)(inCoordinates, outCoordinates, stride);\n      } :\n      ol.proj.getTransform(source, destination);\n    this.applyTransform(transformFn);\n    return this;\n  };\n  \n  goog.provide('ol.geom.SimpleGeometry');\n  \n  goog.require('ol');\n  goog.require('ol.functions');\n  goog.require('ol.extent');\n  goog.require('ol.geom.Geometry');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; only used for creating subclasses; do not instantiate\n   * in apps, as cannot be rendered.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.geom.Geometry}\n   * @api\n   */\n  ol.geom.SimpleGeometry = function() {\n  \n    ol.geom.Geometry.call(this);\n  \n    /**\n     * @protected\n     * @type {ol.geom.GeometryLayout}\n     */\n    this.layout = ol.geom.GeometryLayout.XY;\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n  \n    /**\n     * @protected\n     * @type {Array.<number>}\n     */\n    this.flatCoordinates = null;\n  \n  };\n  ol.inherits(ol.geom.SimpleGeometry, ol.geom.Geometry);\n  \n  \n  /**\n   * @param {number} stride Stride.\n   * @private\n   * @return {ol.geom.GeometryLayout} layout Layout.\n   */\n  ol.geom.SimpleGeometry.getLayoutForStride_ = function(stride) {\n    var layout;\n    if (stride == 2) {\n      layout = ol.geom.GeometryLayout.XY;\n    } else if (stride == 3) {\n      layout = ol.geom.GeometryLayout.XYZ;\n    } else if (stride == 4) {\n      layout = ol.geom.GeometryLayout.XYZM;\n    }\n    return /** @type {ol.geom.GeometryLayout} */ (layout);\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @return {number} Stride.\n   */\n  ol.geom.SimpleGeometry.getStrideForLayout = function(layout) {\n    var stride;\n    if (layout == ol.geom.GeometryLayout.XY) {\n      stride = 2;\n    } else if (layout == ol.geom.GeometryLayout.XYZ || layout == ol.geom.GeometryLayout.XYM) {\n      stride = 3;\n    } else if (layout == ol.geom.GeometryLayout.XYZM) {\n      stride = 4;\n    }\n    return /** @type {number} */ (stride);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.SimpleGeometry.prototype.containsXY = ol.functions.FALSE;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.SimpleGeometry.prototype.computeExtent = function(extent) {\n    return ol.extent.createOrUpdateFromFlatCoordinates(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n        extent);\n  };\n  \n  \n  /**\n   * @abstract\n   * @return {Array} Coordinates.\n   */\n  ol.geom.SimpleGeometry.prototype.getCoordinates = function() {};\n  \n  \n  /**\n   * Return the first coordinate of the geometry.\n   * @return {ol.Coordinate} First coordinate.\n   * @api\n   */\n  ol.geom.SimpleGeometry.prototype.getFirstCoordinate = function() {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.geom.SimpleGeometry.prototype.getFlatCoordinates = function() {\n    return this.flatCoordinates;\n  };\n  \n  \n  /**\n   * Return the last coordinate of the geometry.\n   * @return {ol.Coordinate} Last point.\n   * @api\n   */\n  ol.geom.SimpleGeometry.prototype.getLastCoordinate = function() {\n    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n  };\n  \n  \n  /**\n   * Return the {@link ol.geom.GeometryLayout layout} of the geometry.\n   * @return {ol.geom.GeometryLayout} Layout.\n   * @api\n   */\n  ol.geom.SimpleGeometry.prototype.getLayout = function() {\n    return this.layout;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.SimpleGeometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {\n    if (this.simplifiedGeometryRevision != this.getRevision()) {\n      ol.obj.clear(this.simplifiedGeometryCache);\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (squaredTolerance < 0 ||\n        (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n         squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {\n      return this;\n    }\n    var key = squaredTolerance.toString();\n    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n      return this.simplifiedGeometryCache[key];\n    } else {\n      var simplifiedGeometry =\n          this.getSimplifiedGeometryInternal(squaredTolerance);\n      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n        this.simplifiedGeometryCache[key] = simplifiedGeometry;\n        return simplifiedGeometry;\n      } else {\n        // Simplification did not actually remove any coordinates.  We now know\n        // that any calls to getSimplifiedGeometry with a squaredTolerance less\n        // than or equal to the current squaredTolerance will also not have any\n        // effect.  This allows us to short circuit simplification (saving CPU\n        // cycles) and prevents the cache of simplified geometries from filling\n        // up with useless identical copies of this geometry (saving memory).\n        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n        return this;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {ol.geom.SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  ol.geom.SimpleGeometry.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    return this;\n  };\n  \n  \n  /**\n   * @return {number} Stride.\n   */\n  ol.geom.SimpleGeometry.prototype.getStride = function() {\n    return this.stride;\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @protected\n   */\n  ol.geom.SimpleGeometry.prototype.setFlatCoordinatesInternal = function(layout, flatCoordinates) {\n    this.stride = ol.geom.SimpleGeometry.getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Array} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   */\n  ol.geom.SimpleGeometry.prototype.setCoordinates = function(coordinates, opt_layout) {};\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout|undefined} layout Layout.\n   * @param {Array} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  ol.geom.SimpleGeometry.prototype.setLayout = function(layout, coordinates, nesting) {\n    /** @type {number} */\n    var stride;\n    if (layout) {\n      stride = ol.geom.SimpleGeometry.getStrideForLayout(layout);\n    } else {\n      var i;\n      for (i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = ol.geom.GeometryLayout.XY;\n          this.stride = 2;\n          return;\n        } else {\n          coordinates = /** @type {Array} */ (coordinates[0]);\n        }\n      }\n      stride = coordinates.length;\n      layout = ol.geom.SimpleGeometry.getLayoutForStride_(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.SimpleGeometry.prototype.applyTransform = function(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.SimpleGeometry.prototype.rotate = function(angle, anchor) {\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      ol.geom.flat.transform.rotate(\n          flatCoordinates, 0, flatCoordinates.length,\n          stride, angle, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.SimpleGeometry.prototype.scale = function(sx, opt_sy, opt_anchor) {\n    var sy = opt_sy;\n    if (sy === undefined) {\n      sy = sx;\n    }\n    var anchor = opt_anchor;\n    if (!anchor) {\n      anchor = ol.extent.getCenter(this.getExtent());\n    }\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      ol.geom.flat.transform.scale(\n          flatCoordinates, 0, flatCoordinates.length,\n          stride, sx, sy, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.SimpleGeometry.prototype.translate = function(deltaX, deltaY) {\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      ol.geom.flat.transform.translate(\n          flatCoordinates, 0, flatCoordinates.length, stride,\n          deltaX, deltaY, flatCoordinates);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.SimpleGeometry} simpleGeometry Simple geometry.\n   * @param {ol.Transform} transform Transform.\n   * @param {Array.<number>=} opt_dest Destination.\n   * @return {Array.<number>} Transformed flat coordinates.\n   */\n  ol.geom.SimpleGeometry.transform2D = function(simpleGeometry, transform, opt_dest) {\n    var flatCoordinates = simpleGeometry.getFlatCoordinates();\n    if (!flatCoordinates) {\n      return null;\n    } else {\n      var stride = simpleGeometry.getStride();\n      return ol.geom.flat.transform.transform2D(\n          flatCoordinates, 0, flatCoordinates.length, stride,\n          transform, opt_dest);\n    }\n  };\n  \n  goog.provide('ol.geom.flat.area');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {number} Area.\n   */\n  ol.geom.flat.area.linearRing = function(flatCoordinates, offset, end, stride) {\n    var twiceArea = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n      var x2 = flatCoordinates[offset];\n      var y2 = flatCoordinates[offset + 1];\n      twiceArea += y1 * x2 - x1 * y2;\n      x1 = x2;\n      y1 = y2;\n    }\n    return twiceArea / 2;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @return {number} Area.\n   */\n  ol.geom.flat.area.linearRings = function(flatCoordinates, offset, ends, stride) {\n    var area = 0;\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      area += ol.geom.flat.area.linearRing(flatCoordinates, offset, end, stride);\n      offset = end;\n    }\n    return area;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @return {number} Area.\n   */\n  ol.geom.flat.area.linearRingss = function(flatCoordinates, offset, endss, stride) {\n    var area = 0;\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      area +=\n          ol.geom.flat.area.linearRings(flatCoordinates, offset, ends, stride);\n      offset = ends[ends.length - 1];\n    }\n    return area;\n  };\n  \n  goog.provide('ol.geom.flat.closest');\n  \n  goog.require('ol.math');\n  \n  \n  /**\n   * Returns the point on the 2D line segment flatCoordinates[offset1] to\n   * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n   * dimensions are linearly interpolated.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset1 Offset 1.\n   * @param {number} offset2 Offset 2.\n   * @param {number} stride Stride.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {Array.<number>} closestPoint Closest point.\n   */\n  ol.geom.flat.closest.point = function(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n    var x1 = flatCoordinates[offset1];\n    var y1 = flatCoordinates[offset1 + 1];\n    var dx = flatCoordinates[offset2] - x1;\n    var dy = flatCoordinates[offset2 + 1] - y1;\n    var i, offset;\n    if (dx === 0 && dy === 0) {\n      offset = offset1;\n    } else {\n      var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n      if (t > 1) {\n        offset = offset2;\n      } else if (t > 0) {\n        for (i = 0; i < stride; ++i) {\n          closestPoint[i] = ol.math.lerp(flatCoordinates[offset1 + i],\n              flatCoordinates[offset2 + i], t);\n        }\n        closestPoint.length = stride;\n        return;\n      } else {\n        offset = offset1;\n      }\n    }\n    for (i = 0; i < stride; ++i) {\n      closestPoint[i] = flatCoordinates[offset + i];\n    }\n    closestPoint.length = stride;\n  };\n  \n  \n  /**\n   * Return the squared of the largest distance between any pair of consecutive\n   * coordinates.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} maxSquaredDelta Max squared delta.\n   * @return {number} Max squared delta.\n   */\n  ol.geom.flat.closest.getMaxSquaredDelta = function(flatCoordinates, offset, end, stride, maxSquaredDelta) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    for (offset += stride; offset < end; offset += stride) {\n      var x2 = flatCoordinates[offset];\n      var y2 = flatCoordinates[offset + 1];\n      var squaredDelta = ol.math.squaredDistance(x1, y1, x2, y2);\n      if (squaredDelta > maxSquaredDelta) {\n        maxSquaredDelta = squaredDelta;\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n    return maxSquaredDelta;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {number} maxSquaredDelta Max squared delta.\n   * @return {number} Max squared delta.\n   */\n  ol.geom.flat.closest.getsMaxSquaredDelta = function(flatCoordinates, offset, ends, stride, maxSquaredDelta) {\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      maxSquaredDelta = ol.geom.flat.closest.getMaxSquaredDelta(\n          flatCoordinates, offset, end, stride, maxSquaredDelta);\n      offset = end;\n    }\n    return maxSquaredDelta;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @param {number} maxSquaredDelta Max squared delta.\n   * @return {number} Max squared delta.\n   */\n  ol.geom.flat.closest.getssMaxSquaredDelta = function(flatCoordinates, offset, endss, stride, maxSquaredDelta) {\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      maxSquaredDelta = ol.geom.flat.closest.getsMaxSquaredDelta(\n          flatCoordinates, offset, ends, stride, maxSquaredDelta);\n      offset = ends[ends.length - 1];\n    }\n    return maxSquaredDelta;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} maxDelta Max delta.\n   * @param {boolean} isRing Is ring.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {Array.<number>} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n   * @return {number} Minimum squared distance.\n   */\n  ol.geom.flat.closest.getClosestPoint = function(flatCoordinates, offset, end,\n      stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n      opt_tmpPoint) {\n    if (offset == end) {\n      return minSquaredDistance;\n    }\n    var i, squaredDistance;\n    if (maxDelta === 0) {\n      // All points are identical, so just test the first point.\n      squaredDistance = ol.math.squaredDistance(\n          x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n      if (squaredDistance < minSquaredDistance) {\n        for (i = 0; i < stride; ++i) {\n          closestPoint[i] = flatCoordinates[offset + i];\n        }\n        closestPoint.length = stride;\n        return squaredDistance;\n      } else {\n        return minSquaredDistance;\n      }\n    }\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    var index = offset + stride;\n    while (index < end) {\n      ol.geom.flat.closest.point(\n          flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n      squaredDistance = ol.math.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (i = 0; i < stride; ++i) {\n          closestPoint[i] = tmpPoint[i];\n        }\n        closestPoint.length = stride;\n        index += stride;\n      } else {\n        // Skip ahead multiple points, because we know that all the skipped\n        // points cannot be any closer than the closest point we have found so\n        // far.  We know this because we know how close the current point is, how\n        // close the closest point we have found so far is, and the maximum\n        // distance between consecutive points.  For example, if we're currently\n        // at distance 10, the best we've found so far is 3, and that the maximum\n        // distance between consecutive points is 2, then we'll need to skip at\n        // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n        // finding a closer point.  We use Math.max(..., 1) to ensure that we\n        // always advance at least one point, to avoid an infinite loop.\n        index += stride * Math.max(\n            ((Math.sqrt(squaredDistance) -\n              Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\n      }\n    }\n    if (isRing) {\n      // Check the closing segment.\n      ol.geom.flat.closest.point(\n          flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n      squaredDistance = ol.math.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (i = 0; i < stride; ++i) {\n          closestPoint[i] = tmpPoint[i];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {number} maxDelta Max delta.\n   * @param {boolean} isRing Is ring.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {Array.<number>} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n   * @return {number} Minimum squared distance.\n   */\n  ol.geom.flat.closest.getsClosestPoint = function(flatCoordinates, offset, ends,\n      stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n      opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      minSquaredDistance = ol.geom.flat.closest.getClosestPoint(\n          flatCoordinates, offset, end, stride,\n          maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n      offset = end;\n    }\n    return minSquaredDistance;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @param {number} maxDelta Max delta.\n   * @param {boolean} isRing Is ring.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {Array.<number>} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n   * @return {number} Minimum squared distance.\n   */\n  ol.geom.flat.closest.getssClosestPoint = function(flatCoordinates, offset,\n      endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n      opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      minSquaredDistance = ol.geom.flat.closest.getsClosestPoint(\n          flatCoordinates, offset, ends, stride,\n          maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n      offset = ends[ends.length - 1];\n    }\n    return minSquaredDistance;\n  };\n  \n  goog.provide('ol.geom.flat.deflate');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} stride Stride.\n   * @return {number} offset Offset.\n   */\n  ol.geom.flat.deflate.coordinate = function(flatCoordinates, offset, coordinate, stride) {\n    var i, ii;\n    for (i = 0, ii = coordinate.length; i < ii; ++i) {\n      flatCoordinates[offset++] = coordinate[i];\n    }\n    return offset;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @param {number} stride Stride.\n   * @return {number} offset Offset.\n   */\n  ol.geom.flat.deflate.coordinates = function(flatCoordinates, offset, coordinates, stride) {\n    var i, ii;\n    for (i = 0, ii = coordinates.length; i < ii; ++i) {\n      var coordinate = coordinates[i];\n      var j;\n      for (j = 0; j < stride; ++j) {\n        flatCoordinates[offset++] = coordinate[j];\n      }\n    }\n    return offset;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<ol.Coordinate>>} coordinatess Coordinatess.\n   * @param {number} stride Stride.\n   * @param {Array.<number>=} opt_ends Ends.\n   * @return {Array.<number>} Ends.\n   */\n  ol.geom.flat.deflate.coordinatess = function(flatCoordinates, offset, coordinatess, stride, opt_ends) {\n    var ends = opt_ends ? opt_ends : [];\n    var i = 0;\n    var j, jj;\n    for (j = 0, jj = coordinatess.length; j < jj; ++j) {\n      var end = ol.geom.flat.deflate.coordinates(\n          flatCoordinates, offset, coordinatess[j], stride);\n      ends[i++] = end;\n      offset = end;\n    }\n    ends.length = i;\n    return ends;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinatesss Coordinatesss.\n   * @param {number} stride Stride.\n   * @param {Array.<Array.<number>>=} opt_endss Endss.\n   * @return {Array.<Array.<number>>} Endss.\n   */\n  ol.geom.flat.deflate.coordinatesss = function(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\n    var endss = opt_endss ? opt_endss : [];\n    var i = 0;\n    var j, jj;\n    for (j = 0, jj = coordinatesss.length; j < jj; ++j) {\n      var ends = ol.geom.flat.deflate.coordinatess(\n          flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\n      endss[i++] = ends;\n      offset = ends[ends.length - 1];\n    }\n    endss.length = i;\n    return endss;\n  };\n  \n  goog.provide('ol.geom.flat.inflate');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {Array.<ol.Coordinate>=} opt_coordinates Coordinates.\n   * @return {Array.<ol.Coordinate>} Coordinates.\n   */\n  ol.geom.flat.inflate.coordinates = function(flatCoordinates, offset, end, stride, opt_coordinates) {\n    var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n    var i = 0;\n    var j;\n    for (j = offset; j < end; j += stride) {\n      coordinates[i++] = flatCoordinates.slice(j, j + stride);\n    }\n    coordinates.length = i;\n    return coordinates;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array.<Array.<ol.Coordinate>>=} opt_coordinatess Coordinatess.\n   * @return {Array.<Array.<ol.Coordinate>>} Coordinatess.\n   */\n  ol.geom.flat.inflate.coordinatess = function(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n    var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n    var i = 0;\n    var j, jj;\n    for (j = 0, jj = ends.length; j < jj; ++j) {\n      var end = ends[j];\n      coordinatess[i++] = ol.geom.flat.inflate.coordinates(\n          flatCoordinates, offset, end, stride, coordinatess[i]);\n      offset = end;\n    }\n    coordinatess.length = i;\n    return coordinatess;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @param {Array.<Array.<Array.<ol.Coordinate>>>=} opt_coordinatesss\n   *     Coordinatesss.\n   * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinatesss.\n   */\n  ol.geom.flat.inflate.coordinatesss = function(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n    var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n    var i = 0;\n    var j, jj;\n    for (j = 0, jj = endss.length; j < jj; ++j) {\n      var ends = endss[j];\n      coordinatesss[i++] = ol.geom.flat.inflate.coordinatess(\n          flatCoordinates, offset, ends, stride, coordinatesss[i]);\n      offset = ends[ends.length - 1];\n    }\n    coordinatesss.length = i;\n    return coordinatesss;\n  };\n  \n  // Based on simplify-js https://github.com/mourner/simplify-js\n  // Copyright (c) 2012, Vladimir Agafonkin\n  // All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions are met:\n  //\n  //    1. Redistributions of source code must retain the above copyright notice,\n  //       this list of conditions and the following disclaimer.\n  //\n  //    2. Redistributions in binary form must reproduce the above copyright\n  //       notice, this list of conditions and the following disclaimer in the\n  //       documentation and/or other materials provided with the distribution.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n  // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n  // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n  // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n  // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  // POSSIBILITY OF SUCH DAMAGE.\n  \n  goog.provide('ol.geom.flat.simplify');\n  \n  goog.require('ol.math');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {boolean} highQuality Highest quality.\n   * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat\n   *     coordinates.\n   * @return {Array.<number>} Simplified line string.\n   */\n  ol.geom.flat.simplify.lineString = function(flatCoordinates, offset, end,\n      stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n    var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?\n      opt_simplifiedFlatCoordinates : [];\n    if (!highQuality) {\n      end = ol.geom.flat.simplify.radialDistance(flatCoordinates, offset, end,\n          stride, squaredTolerance,\n          simplifiedFlatCoordinates, 0);\n      flatCoordinates = simplifiedFlatCoordinates;\n      offset = 0;\n      stride = 2;\n    }\n    simplifiedFlatCoordinates.length = ol.geom.flat.simplify.douglasPeucker(\n        flatCoordinates, offset, end, stride, squaredTolerance,\n        simplifiedFlatCoordinates, 0);\n    return simplifiedFlatCoordinates;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n   *     coordinates.\n   * @param {number} simplifiedOffset Simplified offset.\n   * @return {number} Simplified offset.\n   */\n  ol.geom.flat.simplify.douglasPeucker = function(flatCoordinates, offset, end,\n      stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    var n = (end - offset) / stride;\n    if (n < 3) {\n      for (; offset < end; offset += stride) {\n        simplifiedFlatCoordinates[simplifiedOffset++] =\n            flatCoordinates[offset];\n        simplifiedFlatCoordinates[simplifiedOffset++] =\n            flatCoordinates[offset + 1];\n      }\n      return simplifiedOffset;\n    }\n    /** @type {Array.<number>} */\n    var markers = new Array(n);\n    markers[0] = 1;\n    markers[n - 1] = 1;\n    /** @type {Array.<number>} */\n    var stack = [offset, end - stride];\n    var index = 0;\n    var i;\n    while (stack.length > 0) {\n      var last = stack.pop();\n      var first = stack.pop();\n      var maxSquaredDistance = 0;\n      var x1 = flatCoordinates[first];\n      var y1 = flatCoordinates[first + 1];\n      var x2 = flatCoordinates[last];\n      var y2 = flatCoordinates[last + 1];\n      for (i = first + stride; i < last; i += stride) {\n        var x = flatCoordinates[i];\n        var y = flatCoordinates[i + 1];\n        var squaredDistance = ol.math.squaredSegmentDistance(\n            x, y, x1, y1, x2, y2);\n        if (squaredDistance > maxSquaredDistance) {\n          index = i;\n          maxSquaredDistance = squaredDistance;\n        }\n      }\n      if (maxSquaredDistance > squaredTolerance) {\n        markers[(index - offset) / stride] = 1;\n        if (first + stride < index) {\n          stack.push(first, index);\n        }\n        if (index + stride < last) {\n          stack.push(index, last);\n        }\n      }\n    }\n    for (i = 0; i < n; ++i) {\n      if (markers[i]) {\n        simplifiedFlatCoordinates[simplifiedOffset++] =\n            flatCoordinates[offset + i * stride];\n        simplifiedFlatCoordinates[simplifiedOffset++] =\n            flatCoordinates[offset + i * stride + 1];\n      }\n    }\n    return simplifiedOffset;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n   *     coordinates.\n   * @param {number} simplifiedOffset Simplified offset.\n   * @param {Array.<number>} simplifiedEnds Simplified ends.\n   * @return {number} Simplified offset.\n   */\n  ol.geom.flat.simplify.douglasPeuckers = function(flatCoordinates, offset,\n      ends, stride, squaredTolerance, simplifiedFlatCoordinates,\n      simplifiedOffset, simplifiedEnds) {\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      simplifiedOffset = ol.geom.flat.simplify.douglasPeucker(\n          flatCoordinates, offset, end, stride, squaredTolerance,\n          simplifiedFlatCoordinates, simplifiedOffset);\n      simplifiedEnds.push(simplifiedOffset);\n      offset = end;\n    }\n    return simplifiedOffset;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n   *     coordinates.\n   * @param {number} simplifiedOffset Simplified offset.\n   * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\n   * @return {number} Simplified offset.\n   */\n  ol.geom.flat.simplify.douglasPeuckerss = function(\n      flatCoordinates, offset, endss, stride, squaredTolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      var simplifiedEnds = [];\n      simplifiedOffset = ol.geom.flat.simplify.douglasPeuckers(\n          flatCoordinates, offset, ends, stride, squaredTolerance,\n          simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n      simplifiedEndss.push(simplifiedEnds);\n      offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n   *     coordinates.\n   * @param {number} simplifiedOffset Simplified offset.\n   * @return {number} Simplified offset.\n   */\n  ol.geom.flat.simplify.radialDistance = function(flatCoordinates, offset, end,\n      stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    if (end <= offset + stride) {\n      // zero or one point, no simplification possible, so copy and return\n      for (; offset < end; offset += stride) {\n        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n        simplifiedFlatCoordinates[simplifiedOffset++] =\n            flatCoordinates[offset + 1];\n      }\n      return simplifiedOffset;\n    }\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    // copy first point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    var x2 = x1;\n    var y2 = y1;\n    for (offset += stride; offset < end; offset += stride) {\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      if (ol.math.squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n        // copy point at offset\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n        x1 = x2;\n        y1 = y2;\n      }\n    }\n    if (x2 != x1 || y2 != y1) {\n      // copy last point\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    }\n    return simplifiedOffset;\n  };\n  \n  \n  /**\n   * @param {number} value Value.\n   * @param {number} tolerance Tolerance.\n   * @return {number} Rounded value.\n   */\n  ol.geom.flat.simplify.snap = function(value, tolerance) {\n    return tolerance * Math.round(value / tolerance);\n  };\n  \n  \n  /**\n   * Simplifies a line string using an algorithm designed by Tim Schaub.\n   * Coordinates are snapped to the nearest value in a virtual grid and\n   * consecutive duplicate coordinates are discarded.  This effectively preserves\n   * topology as the simplification of any subsection of a line string is\n   * independent of the rest of the line string.  This means that, for examples,\n   * the common edge between two polygons will be simplified to the same line\n   * string independently in both polygons.  This implementation uses a single\n   * pass over the coordinates and eliminates intermediate collinear points.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} tolerance Tolerance.\n   * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n   *     coordinates.\n   * @param {number} simplifiedOffset Simplified offset.\n   * @return {number} Simplified offset.\n   */\n  ol.geom.flat.simplify.quantize = function(flatCoordinates, offset, end, stride,\n      tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    // do nothing if the line is empty\n    if (offset == end) {\n      return simplifiedOffset;\n    }\n    // snap the first coordinate (P1)\n    var x1 = ol.geom.flat.simplify.snap(flatCoordinates[offset], tolerance);\n    var y1 = ol.geom.flat.simplify.snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // add the first coordinate to the output\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    // find the next coordinate that does not snap to the same value as the first\n    // coordinate (P2)\n    var x2, y2;\n    do {\n      x2 = ol.geom.flat.simplify.snap(flatCoordinates[offset], tolerance);\n      y2 = ol.geom.flat.simplify.snap(flatCoordinates[offset + 1], tolerance);\n      offset += stride;\n      if (offset == end) {\n        // all coordinates snap to the same value, the line collapses to a point\n        // push the last snapped value anyway to ensure that the output contains\n        // at least two points\n        // FIXME should we really return at least two points anyway?\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n        return simplifiedOffset;\n      }\n    } while (x2 == x1 && y2 == y1);\n    while (offset < end) {\n      var x3, y3;\n      // snap the next coordinate (P3)\n      x3 = ol.geom.flat.simplify.snap(flatCoordinates[offset], tolerance);\n      y3 = ol.geom.flat.simplify.snap(flatCoordinates[offset + 1], tolerance);\n      offset += stride;\n      // skip P3 if it is equal to P2\n      if (x3 == x2 && y3 == y2) {\n        continue;\n      }\n      // calculate the delta between P1 and P2\n      var dx1 = x2 - x1;\n      var dy1 = y2 - y1;\n      // calculate the delta between P3 and P1\n      var dx2 = x3 - x1;\n      var dy2 = y3 - y1;\n      // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n      // P1 in the same direction then P2 is on the straight line between P1 and\n      // P3\n      if ((dx1 * dy2 == dy1 * dx2) &&\n          ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n          ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n        // discard P2 and set P2 = P3\n        x2 = x3;\n        y2 = y3;\n        continue;\n      }\n      // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n      // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n      // and continue with P1 = P2 and P2 = P3\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n      x2 = x3;\n      y2 = y3;\n    }\n    // add the last point (P2)\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    return simplifiedOffset;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {number} tolerance Tolerance.\n   * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n   *     coordinates.\n   * @param {number} simplifiedOffset Simplified offset.\n   * @param {Array.<number>} simplifiedEnds Simplified ends.\n   * @return {number} Simplified offset.\n   */\n  ol.geom.flat.simplify.quantizes = function(\n      flatCoordinates, offset, ends, stride,\n      tolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      simplifiedOffset = ol.geom.flat.simplify.quantize(\n          flatCoordinates, offset, end, stride,\n          tolerance,\n          simplifiedFlatCoordinates, simplifiedOffset);\n      simplifiedEnds.push(simplifiedOffset);\n      offset = end;\n    }\n    return simplifiedOffset;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @param {number} tolerance Tolerance.\n   * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n   *     coordinates.\n   * @param {number} simplifiedOffset Simplified offset.\n   * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\n   * @return {number} Simplified offset.\n   */\n  ol.geom.flat.simplify.quantizess = function(\n      flatCoordinates, offset, endss, stride,\n      tolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      var simplifiedEnds = [];\n      simplifiedOffset = ol.geom.flat.simplify.quantizes(\n          flatCoordinates, offset, ends, stride,\n          tolerance,\n          simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n      simplifiedEndss.push(simplifiedEnds);\n      offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n  };\n  \n  goog.provide('ol.geom.LinearRing');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.area');\n  goog.require('ol.geom.flat.closest');\n  goog.require('ol.geom.flat.deflate');\n  goog.require('ol.geom.flat.inflate');\n  goog.require('ol.geom.flat.simplify');\n  \n  \n  /**\n   * @classdesc\n   * Linear ring geometry. Only used as part of polygon; cannot be rendered\n   * on its own.\n   *\n   * @constructor\n   * @extends {ol.geom.SimpleGeometry}\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.LinearRing = function(coordinates, opt_layout) {\n  \n    ol.geom.SimpleGeometry.call(this);\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n  \n    this.setCoordinates(coordinates, opt_layout);\n  \n  };\n  ol.inherits(ol.geom.LinearRing, ol.geom.SimpleGeometry);\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.LinearRing} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.LinearRing.prototype.clone = function() {\n    var linearRing = new ol.geom.LinearRing(null);\n    linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n    return linearRing;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.LinearRing.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance <\n        ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getMaxSquaredDelta(\n          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return ol.geom.flat.closest.getClosestPoint(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n        this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  \n  \n  /**\n   * Return the area of the linear ring on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  ol.geom.LinearRing.prototype.getArea = function() {\n    return ol.geom.flat.area.linearRing(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  \n  \n  /**\n   * Return the coordinates of the linear ring.\n   * @return {Array.<ol.Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  ol.geom.LinearRing.prototype.getCoordinates = function() {\n    return ol.geom.flat.inflate.coordinates(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.LinearRing.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = ol.geom.flat.simplify.douglasPeucker(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n        squaredTolerance, simplifiedFlatCoordinates, 0);\n    var simplifiedLinearRing = new ol.geom.LinearRing(null);\n    simplifiedLinearRing.setFlatCoordinates(\n        ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates);\n    return simplifiedLinearRing;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.LinearRing.prototype.getType = function() {\n    return ol.geom.GeometryType.LINEAR_RING;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.LinearRing.prototype.intersectsExtent = function(extent) {};\n  \n  \n  /**\n   * Set the coordinates of the linear ring.\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  ol.geom.LinearRing.prototype.setCoordinates = function(coordinates, opt_layout) {\n    if (!coordinates) {\n      this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);\n    } else {\n      this.setLayout(opt_layout, coordinates, 1);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      this.flatCoordinates.length = ol.geom.flat.deflate.coordinates(\n          this.flatCoordinates, 0, coordinates, this.stride);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   */\n  ol.geom.LinearRing.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n    this.setFlatCoordinatesInternal(layout, flatCoordinates);\n    this.changed();\n  };\n  \n  goog.provide('ol.geom.Point');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.deflate');\n  goog.require('ol.math');\n  \n  \n  /**\n   * @classdesc\n   * Point geometry.\n   *\n   * @constructor\n   * @extends {ol.geom.SimpleGeometry}\n   * @param {ol.Coordinate} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.Point = function(coordinates, opt_layout) {\n    ol.geom.SimpleGeometry.call(this);\n    this.setCoordinates(coordinates, opt_layout);\n  };\n  ol.inherits(ol.geom.Point, ol.geom.SimpleGeometry);\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.Point} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.Point.prototype.clone = function() {\n    var point = new ol.geom.Point(null);\n    point.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n    return point;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Point.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var squaredDistance = ol.math.squaredDistance(\n        x, y, flatCoordinates[0], flatCoordinates[1]);\n    if (squaredDistance < minSquaredDistance) {\n      var stride = this.stride;\n      var i;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  \n  \n  /**\n   * Return the coordinate of the point.\n   * @return {ol.Coordinate} Coordinates.\n   * @override\n   * @api\n   */\n  ol.geom.Point.prototype.getCoordinates = function() {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Point.prototype.computeExtent = function(extent) {\n    return ol.extent.createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.Point.prototype.getType = function() {\n    return ol.geom.GeometryType.POINT;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.Point.prototype.intersectsExtent = function(extent) {\n    return ol.extent.containsXY(extent,\n        this.flatCoordinates[0], this.flatCoordinates[1]);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.Point.prototype.setCoordinates = function(coordinates, opt_layout) {\n    if (!coordinates) {\n      this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);\n    } else {\n      this.setLayout(opt_layout, coordinates, 0);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      this.flatCoordinates.length = ol.geom.flat.deflate.coordinate(\n          this.flatCoordinates, 0, coordinates, this.stride);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   */\n  ol.geom.Point.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n    this.setFlatCoordinatesInternal(layout, flatCoordinates);\n    this.changed();\n  };\n  \n  goog.provide('ol.geom.flat.contains');\n  \n  goog.require('ol.extent');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {ol.Extent} extent Extent.\n   * @return {boolean} Contains extent.\n   */\n  ol.geom.flat.contains.linearRingContainsExtent = function(flatCoordinates, offset, end, stride, extent) {\n    var outside = ol.extent.forEachCorner(extent,\n        /**\n         * @param {ol.Coordinate} coordinate Coordinate.\n         * @return {boolean} Contains (x, y).\n         */\n        function(coordinate) {\n          return !ol.geom.flat.contains.linearRingContainsXY(flatCoordinates,\n              offset, end, stride, coordinate[0], coordinate[1]);\n        });\n    return !outside;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  ol.geom.flat.contains.linearRingContainsXY = function(flatCoordinates, offset, end, stride, x, y) {\n    // http://geomalgorithms.com/a03-_inclusion.html\n    // Copyright 2000 softSurfer, 2012 Dan Sunday\n    // This code may be freely used and modified for any purpose\n    // providing that this copyright notice is included with it.\n    // SoftSurfer makes no warranty for this code, and cannot be held\n    // liable for any real or imagined damage resulting from its use.\n    // Users of this code must verify correctness for their application.\n    var wn = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n      var x2 = flatCoordinates[offset];\n      var y2 = flatCoordinates[offset + 1];\n      if (y1 <= y) {\n        if (y2 > y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) > 0) {\n          wn++;\n        }\n      } else if (y2 <= y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) < 0) {\n        wn--;\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n    return wn !== 0;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  ol.geom.flat.contains.linearRingsContainsXY = function(flatCoordinates, offset, ends, stride, x, y) {\n    if (ends.length === 0) {\n      return false;\n    }\n    if (!ol.geom.flat.contains.linearRingContainsXY(\n        flatCoordinates, offset, ends[0], stride, x, y)) {\n      return false;\n    }\n    var i, ii;\n    for (i = 1, ii = ends.length; i < ii; ++i) {\n      if (ol.geom.flat.contains.linearRingContainsXY(\n          flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  ol.geom.flat.contains.linearRingssContainsXY = function(flatCoordinates, offset, endss, stride, x, y) {\n    if (endss.length === 0) {\n      return false;\n    }\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      if (ol.geom.flat.contains.linearRingsContainsXY(\n          flatCoordinates, offset, ends, stride, x, y)) {\n        return true;\n      }\n      offset = ends[ends.length - 1];\n    }\n    return false;\n  };\n  \n  goog.provide('ol.geom.flat.interiorpoint');\n  \n  goog.require('ol.array');\n  goog.require('ol.geom.flat.contains');\n  \n  \n  /**\n   * Calculates a point that is likely to lie in the interior of the linear rings.\n   * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array.<number>} flatCenters Flat centers.\n   * @param {number} flatCentersOffset Flat center offset.\n   * @param {Array.<number>=} opt_dest Destination.\n   * @return {Array.<number>} Destination point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   */\n  ol.geom.flat.interiorpoint.linearRings = function(flatCoordinates, offset,\n      ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n    var i, ii, x, x1, x2, y1, y2;\n    var y = flatCenters[flatCentersOffset + 1];\n    /** @type {Array.<number>} */\n    var intersections = [];\n    // Calculate intersections with the horizontal line\n    for (var r = 0, rr = ends.length; r < rr; ++r) {\n      var end = ends[r];\n      x1 = flatCoordinates[end - stride];\n      y1 = flatCoordinates[end - stride + 1];\n      for (i = offset; i < end; i += stride) {\n        x2 = flatCoordinates[i];\n        y2 = flatCoordinates[i + 1];\n        if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n          x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;\n          intersections.push(x);\n        }\n        x1 = x2;\n        y1 = y2;\n      }\n    }\n    // Find the longest segment of the horizontal line that has its center point\n    // inside the linear ring.\n    var pointX = NaN;\n    var maxSegmentLength = -Infinity;\n    intersections.sort(ol.array.numberSafeCompareFunction);\n    x1 = intersections[0];\n    for (i = 1, ii = intersections.length; i < ii; ++i) {\n      x2 = intersections[i];\n      var segmentLength = Math.abs(x2 - x1);\n      if (segmentLength > maxSegmentLength) {\n        x = (x1 + x2) / 2;\n        if (ol.geom.flat.contains.linearRingsContainsXY(\n            flatCoordinates, offset, ends, stride, x, y)) {\n          pointX = x;\n          maxSegmentLength = segmentLength;\n        }\n      }\n      x1 = x2;\n    }\n    if (isNaN(pointX)) {\n      // There is no horizontal line that has its center point inside the linear\n      // ring.  Use the center of the the linear ring's extent.\n      pointX = flatCenters[flatCentersOffset];\n    }\n    if (opt_dest) {\n      opt_dest.push(pointX, y, maxSegmentLength);\n      return opt_dest;\n    } else {\n      return [pointX, y, maxSegmentLength];\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @param {Array.<number>} flatCenters Flat centers.\n   * @return {Array.<number>} Interior points as XYM coordinates, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   */\n  ol.geom.flat.interiorpoint.linearRingss = function(flatCoordinates, offset, endss, stride, flatCenters) {\n    var interiorPoints = [];\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      interiorPoints = ol.geom.flat.interiorpoint.linearRings(flatCoordinates,\n          offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n      offset = ends[ends.length - 1];\n    }\n    return interiorPoints;\n  };\n  \n  goog.provide('ol.geom.flat.segments');\n  \n  \n  /**\n   * This function calls `callback` for each segment of the flat coordinates\n   * array. If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function\n   *     called for each segment.\n   * @param {S=} opt_this The object to be used as the value of 'this'\n   *     within callback.\n   * @return {T|boolean} Value.\n   * @template T,S\n   */\n  ol.geom.flat.segments.forEach = function(flatCoordinates, offset, end, stride, callback, opt_this) {\n    var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    var point2 = [];\n    var ret;\n    for (; (offset + stride) < end; offset += stride) {\n      point2[0] = flatCoordinates[offset + stride];\n      point2[1] = flatCoordinates[offset + stride + 1];\n      ret = callback.call(opt_this, point1, point2);\n      if (ret) {\n        return ret;\n      }\n      point1[0] = point2[0];\n      point1[1] = point2[1];\n    }\n    return false;\n  };\n  \n  goog.provide('ol.geom.flat.intersectsextent');\n  \n  goog.require('ol.extent');\n  goog.require('ol.geom.flat.contains');\n  goog.require('ol.geom.flat.segments');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {ol.Extent} extent Extent.\n   * @return {boolean} True if the geometry and the extent intersect.\n   */\n  ol.geom.flat.intersectsextent.lineString = function(flatCoordinates, offset, end, stride, extent) {\n    var coordinatesExtent = ol.extent.extendFlatCoordinates(\n        ol.extent.createEmpty(), flatCoordinates, offset, end, stride);\n    if (!ol.extent.intersects(extent, coordinatesExtent)) {\n      return false;\n    }\n    if (ol.extent.containsExtent(extent, coordinatesExtent)) {\n      return true;\n    }\n    if (coordinatesExtent[0] >= extent[0] &&\n        coordinatesExtent[2] <= extent[2]) {\n      return true;\n    }\n    if (coordinatesExtent[1] >= extent[1] &&\n        coordinatesExtent[3] <= extent[3]) {\n      return true;\n    }\n    return ol.geom.flat.segments.forEach(flatCoordinates, offset, end, stride,\n        /**\n         * @param {ol.Coordinate} point1 Start point.\n         * @param {ol.Coordinate} point2 End point.\n         * @return {boolean} `true` if the segment and the extent intersect,\n         *     `false` otherwise.\n         */\n        function(point1, point2) {\n          return ol.extent.intersectsSegment(extent, point1, point2);\n        });\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {ol.Extent} extent Extent.\n   * @return {boolean} True if the geometry and the extent intersect.\n   */\n  ol.geom.flat.intersectsextent.lineStrings = function(flatCoordinates, offset, ends, stride, extent) {\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      if (ol.geom.flat.intersectsextent.lineString(\n          flatCoordinates, offset, ends[i], stride, extent)) {\n        return true;\n      }\n      offset = ends[i];\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {ol.Extent} extent Extent.\n   * @return {boolean} True if the geometry and the extent intersect.\n   */\n  ol.geom.flat.intersectsextent.linearRing = function(flatCoordinates, offset, end, stride, extent) {\n    if (ol.geom.flat.intersectsextent.lineString(\n        flatCoordinates, offset, end, stride, extent)) {\n      return true;\n    }\n    if (ol.geom.flat.contains.linearRingContainsXY(\n        flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n      return true;\n    }\n    if (ol.geom.flat.contains.linearRingContainsXY(\n        flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n      return true;\n    }\n    if (ol.geom.flat.contains.linearRingContainsXY(\n        flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n      return true;\n    }\n    if (ol.geom.flat.contains.linearRingContainsXY(\n        flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n      return true;\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {ol.Extent} extent Extent.\n   * @return {boolean} True if the geometry and the extent intersect.\n   */\n  ol.geom.flat.intersectsextent.linearRings = function(flatCoordinates, offset, ends, stride, extent) {\n    if (!ol.geom.flat.intersectsextent.linearRing(\n        flatCoordinates, offset, ends[0], stride, extent)) {\n      return false;\n    }\n    if (ends.length === 1) {\n      return true;\n    }\n    var i, ii;\n    for (i = 1, ii = ends.length; i < ii; ++i) {\n      if (ol.geom.flat.contains.linearRingContainsExtent(\n          flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @param {ol.Extent} extent Extent.\n   * @return {boolean} True if the geometry and the extent intersect.\n   */\n  ol.geom.flat.intersectsextent.linearRingss = function(flatCoordinates, offset, endss, stride, extent) {\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      if (ol.geom.flat.intersectsextent.linearRings(\n          flatCoordinates, offset, ends, stride, extent)) {\n        return true;\n      }\n      offset = ends[ends.length - 1];\n    }\n    return false;\n  };\n  \n  goog.provide('ol.geom.flat.reverse');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   */\n  ol.geom.flat.reverse.coordinates = function(flatCoordinates, offset, end, stride) {\n    while (offset < end - stride) {\n      var i;\n      for (i = 0; i < stride; ++i) {\n        var tmp = flatCoordinates[offset + i];\n        flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n        flatCoordinates[end - stride + i] = tmp;\n      }\n      offset += stride;\n      end -= stride;\n    }\n  };\n  \n  goog.provide('ol.geom.flat.orient');\n  \n  goog.require('ol.geom.flat.reverse');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {boolean} Is clockwise.\n   */\n  ol.geom.flat.orient.linearRingIsClockwise = function(flatCoordinates, offset, end, stride) {\n    // http://tinyurl.com/clockwise-method\n    // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n    var edge = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n      var x2 = flatCoordinates[offset];\n      var y2 = flatCoordinates[offset + 1];\n      edge += (x2 - x1) * (y2 + y1);\n      x1 = x2;\n      y1 = y2;\n    }\n    return edge > 0;\n  };\n  \n  \n  /**\n   * Determines if linear rings are oriented.  By default, left-hand orientation\n   * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n   * To test for right-hand orientation, use the `opt_right` argument.\n   *\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Array of end indexes.\n   * @param {number} stride Stride.\n   * @param {boolean=} opt_right Test for right-hand orientation\n   *     (counter-clockwise exterior ring and clockwise interior rings).\n   * @return {boolean} Rings are correctly oriented.\n   */\n  ol.geom.flat.orient.linearRingsAreOriented = function(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var isClockwise = ol.geom.flat.orient.linearRingIsClockwise(\n          flatCoordinates, offset, end, stride);\n      if (i === 0) {\n        if ((right && isClockwise) || (!right && !isClockwise)) {\n          return false;\n        }\n      } else {\n        if ((right && !isClockwise) || (!right && isClockwise)) {\n          return false;\n        }\n      }\n      offset = end;\n    }\n    return true;\n  };\n  \n  \n  /**\n   * Determines if linear rings are oriented.  By default, left-hand orientation\n   * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n   * To test for right-hand orientation, use the `opt_right` argument.\n   *\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n   * @param {number} stride Stride.\n   * @param {boolean=} opt_right Test for right-hand orientation\n   *     (counter-clockwise exterior ring and clockwise interior rings).\n   * @return {boolean} Rings are correctly oriented.\n   */\n  ol.geom.flat.orient.linearRingssAreOriented = function(flatCoordinates, offset, endss, stride, opt_right) {\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      if (!ol.geom.flat.orient.linearRingsAreOriented(\n          flatCoordinates, offset, endss[i], stride, opt_right)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  \n  \n  /**\n   * Orient coordinates in a flat array of linear rings.  By default, rings\n   * are oriented following the left-hand rule (clockwise for exterior and\n   * counter-clockwise for interior rings).  To orient according to the\n   * right-hand rule, use the `opt_right` argument.\n   *\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n   * @return {number} End.\n   */\n  ol.geom.flat.orient.orientLinearRings = function(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var isClockwise = ol.geom.flat.orient.linearRingIsClockwise(\n          flatCoordinates, offset, end, stride);\n      var reverse = i === 0 ?\n        (right && isClockwise) || (!right && !isClockwise) :\n        (right && !isClockwise) || (!right && isClockwise);\n      if (reverse) {\n        ol.geom.flat.reverse.coordinates(flatCoordinates, offset, end, stride);\n      }\n      offset = end;\n    }\n    return offset;\n  };\n  \n  \n  /**\n   * Orient coordinates in a flat array of linear rings.  By default, rings\n   * are oriented following the left-hand rule (clockwise for exterior and\n   * counter-clockwise for interior rings).  To orient according to the\n   * right-hand rule, use the `opt_right` argument.\n   *\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n   * @param {number} stride Stride.\n   * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n   * @return {number} End.\n   */\n  ol.geom.flat.orient.orientLinearRingss = function(flatCoordinates, offset, endss, stride, opt_right) {\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      offset = ol.geom.flat.orient.orientLinearRings(\n          flatCoordinates, offset, endss[i], stride, opt_right);\n    }\n    return offset;\n  };\n  \n  goog.provide('ol.geom.Polygon');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.LinearRing');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.area');\n  goog.require('ol.geom.flat.closest');\n  goog.require('ol.geom.flat.contains');\n  goog.require('ol.geom.flat.deflate');\n  goog.require('ol.geom.flat.inflate');\n  goog.require('ol.geom.flat.interiorpoint');\n  goog.require('ol.geom.flat.intersectsextent');\n  goog.require('ol.geom.flat.orient');\n  goog.require('ol.geom.flat.simplify');\n  goog.require('ol.math');\n  \n  \n  /**\n   * @classdesc\n   * Polygon geometry.\n   *\n   * @constructor\n   * @extends {ol.geom.SimpleGeometry}\n   * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear\n   *     rings that define the polygon. The first linear ring of the array\n   *     defines the outer-boundary or surface of the polygon. Each subsequent\n   *     linear ring defines a hole in the surface of the polygon. A linear ring\n   *     is an array of vertices' coordinates where the first coordinate and the\n   *     last are equivalent.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.Polygon = function(coordinates, opt_layout) {\n  \n    ol.geom.SimpleGeometry.call(this);\n  \n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n    this.ends_ = [];\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.flatInteriorPoint_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n  \n    this.setCoordinates(coordinates, opt_layout);\n  \n  };\n  ol.inherits(ol.geom.Polygon, ol.geom.SimpleGeometry);\n  \n  \n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {ol.geom.LinearRing} linearRing Linear ring.\n   * @api\n   */\n  ol.geom.Polygon.prototype.appendLinearRing = function(linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      ol.array.extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.Polygon} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.Polygon.prototype.clone = function() {\n    var polygon = new ol.geom.Polygon(null);\n    polygon.setFlatCoordinates(\n        this.layout, this.flatCoordinates.slice(), this.ends_.slice());\n    return polygon;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Polygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance <\n        ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getsMaxSquaredDelta(\n          this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return ol.geom.flat.closest.getsClosestPoint(\n        this.flatCoordinates, 0, this.ends_, this.stride,\n        this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Polygon.prototype.containsXY = function(x, y) {\n    return ol.geom.flat.contains.linearRingsContainsXY(\n        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n  };\n  \n  \n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  ol.geom.Polygon.prototype.getArea = function() {\n    return ol.geom.flat.area.linearRings(\n        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n  };\n  \n  \n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array.<Array.<ol.Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  ol.geom.Polygon.prototype.getCoordinates = function(opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      ol.geom.flat.orient.orientLinearRings(\n          flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n  \n    return ol.geom.flat.inflate.coordinatess(\n        flatCoordinates, 0, this.ends_, this.stride);\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Ends.\n   */\n  ol.geom.Polygon.prototype.getEnds = function() {\n    return this.ends_;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Interior point.\n   */\n  ol.geom.Polygon.prototype.getFlatInteriorPoint = function() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      var flatCenter = ol.extent.getCenter(this.getExtent());\n      this.flatInteriorPoint_ = ol.geom.flat.interiorpoint.linearRings(\n          this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,\n          flatCenter, 0);\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoint_;\n  };\n  \n  \n  /**\n   * Return an interior point of the polygon.\n   * @return {ol.geom.Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  ol.geom.Polygon.prototype.getInteriorPoint = function() {\n    return new ol.geom.Point(this.getFlatInteriorPoint(), ol.geom.GeometryLayout.XYM);\n  };\n  \n  \n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n  ol.geom.Polygon.prototype.getLinearRingCount = function() {\n    return this.ends_.length;\n  };\n  \n  \n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {ol.geom.LinearRing} Linear ring.\n   * @api\n   */\n  ol.geom.Polygon.prototype.getLinearRing = function(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    var linearRing = new ol.geom.LinearRing(null);\n    linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));\n    return linearRing;\n  };\n  \n  \n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array.<ol.geom.LinearRing>} Linear rings.\n   * @api\n   */\n  ol.geom.Polygon.prototype.getLinearRings = function() {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var linearRings = [];\n    var offset = 0;\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var linearRing = new ol.geom.LinearRing(null);\n      linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));\n      linearRings.push(linearRing);\n      offset = end;\n    }\n    return linearRings;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Oriented flat coordinates.\n   */\n  ol.geom.Polygon.prototype.getOrientedFlatCoordinates = function() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (ol.geom.flat.orient.linearRingsAreOriented(\n          flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            ol.geom.flat.orient.orientLinearRings(\n                this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Polygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = ol.geom.flat.simplify.quantizes(\n        this.flatCoordinates, 0, this.ends_, this.stride,\n        Math.sqrt(squaredTolerance),\n        simplifiedFlatCoordinates, 0, simplifiedEnds);\n    var simplifiedPolygon = new ol.geom.Polygon(null);\n    simplifiedPolygon.setFlatCoordinates(\n        ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEnds);\n    return simplifiedPolygon;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.Polygon.prototype.getType = function() {\n    return ol.geom.GeometryType.POLYGON;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.Polygon.prototype.intersectsExtent = function(extent) {\n    return ol.geom.flat.intersectsextent.linearRings(\n        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n  };\n  \n  \n  /**\n   * Set the coordinates of the polygon.\n   * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  ol.geom.Polygon.prototype.setCoordinates = function(coordinates, opt_layout) {\n    if (!coordinates) {\n      this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null, this.ends_);\n    } else {\n      this.setLayout(opt_layout, coordinates, 2);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      var ends = ol.geom.flat.deflate.coordinatess(\n          this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n      this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {Array.<number>} ends Ends.\n   */\n  ol.geom.Polygon.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {\n    this.setFlatCoordinatesInternal(layout, flatCoordinates);\n    this.ends_ = ends;\n    this.changed();\n  };\n  \n  \n  /**\n   * Create an approximation of a circle on the surface of a sphere.\n   * @param {ol.Sphere} sphere The sphere.\n   * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).\n   * @param {number} radius The great-circle distance from the center to\n   *     the polygon vertices.\n   * @param {number=} opt_n Optional number of vertices for the resulting\n   *     polygon. Default is `32`.\n   * @return {ol.geom.Polygon} The \"circular\" polygon.\n   * @api\n   */\n  ol.geom.Polygon.circular = function(sphere, center, radius, opt_n) {\n    var n = opt_n ? opt_n : 32;\n    /** @type {Array.<number>} */\n    var flatCoordinates = [];\n    var i;\n    for (i = 0; i < n; ++i) {\n      ol.array.extend(\n          flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));\n    }\n    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n    var polygon = new ol.geom.Polygon(null);\n    polygon.setFlatCoordinates(\n        ol.geom.GeometryLayout.XY, flatCoordinates, [flatCoordinates.length]);\n    return polygon;\n  };\n  \n  \n  /**\n   * Create a polygon from an extent. The layout used is `XY`.\n   * @param {ol.Extent} extent The extent.\n   * @return {ol.geom.Polygon} The polygon.\n   * @api\n   */\n  ol.geom.Polygon.fromExtent = function(extent) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var flatCoordinates =\n        [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n    var polygon = new ol.geom.Polygon(null);\n    polygon.setFlatCoordinates(\n        ol.geom.GeometryLayout.XY, flatCoordinates, [flatCoordinates.length]);\n    return polygon;\n  };\n  \n  \n  /**\n   * Create a regular polygon from a circle.\n   * @param {ol.geom.Circle} circle Circle geometry.\n   * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n   * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n   *     radians. Default is 0.\n   * @return {ol.geom.Polygon} Polygon geometry.\n   * @api\n   */\n  ol.geom.Polygon.fromCircle = function(circle, opt_sides, opt_angle) {\n    var sides = opt_sides ? opt_sides : 32;\n    var stride = circle.getStride();\n    var layout = circle.getLayout();\n    var polygon = new ol.geom.Polygon(null, layout);\n    var arrayLength = stride * (sides + 1);\n    var flatCoordinates = new Array(arrayLength);\n    for (var i = 0; i < arrayLength; i++) {\n      flatCoordinates[i] = 0;\n    }\n    var ends = [flatCoordinates.length];\n    polygon.setFlatCoordinates(layout, flatCoordinates, ends);\n    ol.geom.Polygon.makeRegular(\n        polygon, circle.getCenter(), circle.getRadius(), opt_angle);\n    return polygon;\n  };\n  \n  \n  /**\n   * Modify the coordinates of a polygon to make it a regular polygon.\n   * @param {ol.geom.Polygon} polygon Polygon geometry.\n   * @param {ol.Coordinate} center Center of the regular polygon.\n   * @param {number} radius Radius of the regular polygon.\n   * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n   *     radians. Default is 0.\n   */\n  ol.geom.Polygon.makeRegular = function(polygon, center, radius, opt_angle) {\n    var flatCoordinates = polygon.getFlatCoordinates();\n    var layout = polygon.getLayout();\n    var stride = polygon.getStride();\n    var ends = polygon.getEnds();\n    var sides = flatCoordinates.length / stride - 1;\n    var startAngle = opt_angle ? opt_angle : 0;\n    var angle, offset;\n    for (var i = 0; i <= sides; ++i) {\n      offset = i * stride;\n      angle = startAngle + (ol.math.modulo(i, sides) * 2 * Math.PI / sides);\n      flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));\n      flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));\n    }\n    polygon.setFlatCoordinates(layout, flatCoordinates, ends);\n  };\n  \n  goog.provide('ol.View');\n  \n  goog.require('ol');\n  goog.require('ol.CenterConstraint');\n  goog.require('ol.Object');\n  goog.require('ol.ResolutionConstraint');\n  goog.require('ol.RotationConstraint');\n  goog.require('ol.ViewHint');\n  goog.require('ol.ViewProperty');\n  goog.require('ol.array');\n  goog.require('ol.asserts');\n  goog.require('ol.coordinate');\n  goog.require('ol.easing');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.math');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.proj.Units');\n  \n  \n  /**\n   * @classdesc\n   * An ol.View object represents a simple 2D view of the map.\n   *\n   * This is the object to act upon to change the center, resolution,\n   * and rotation of the map.\n   *\n   * ### The view states\n   *\n   * An `ol.View` is determined by three states: `center`, `resolution`,\n   * and `rotation`. Each state has a corresponding getter and setter, e.g.\n   * `getCenter` and `setCenter` for the `center` state.\n   *\n   * An `ol.View` has a `projection`. The projection determines the\n   * coordinate system of the center, and its units determine the units of the\n   * resolution (projection units per pixel). The default projection is\n   * Spherical Mercator (EPSG:3857).\n   *\n   * ### The constraints\n   *\n   * `setCenter`, `setResolution` and `setRotation` can be used to change the\n   * states of the view. Any value can be passed to the setters. And the value\n   * that is passed to a setter will effectively be the value set in the view,\n   * and returned by the corresponding getter.\n   *\n   * But an `ol.View` object also has a *resolution constraint*, a\n   * *rotation constraint* and a *center constraint*.\n   *\n   * As said above, no constraints are applied when the setters are used to set\n   * new states for the view. Applying constraints is done explicitly through\n   * the use of the `constrain*` functions (`constrainResolution` and\n   * `constrainRotation` and `constrainCenter`).\n   *\n   * The main users of the constraints are the interactions and the\n   * controls. For example, double-clicking on the map changes the view to\n   * the \"next\" resolution. And releasing the fingers after pinch-zooming\n   * snaps to the closest resolution (with an animation).\n   *\n   * The *resolution constraint* snaps to specific resolutions. It is\n   * determined by the following options: `resolutions`, `maxResolution`,\n   * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three\n   * options are ignored. See documentation for each option for more\n   * information.\n   *\n   * The *rotation constraint* snaps to specific angles. It is determined\n   * by the following options: `enableRotation` and `constrainRotation`.\n   * By default the rotation value is snapped to zero when approaching the\n   * horizontal.\n   *\n   * The *center constraint* is determined by the `extent` option. By\n   * default the center is not constrained at all.\n   *\n   * @constructor\n   * @extends {ol.Object}\n   * @param {olx.ViewOptions=} opt_options View options.\n   * @api\n   */\n  ol.View = function(opt_options) {\n    ol.Object.call(this);\n  \n    var options = ol.obj.assign({}, opt_options);\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.hints_ = [0, 0];\n  \n    /**\n     * @private\n     * @type {Array.<Array.<ol.ViewAnimation>>}\n     */\n    this.animations_ = [];\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.updateAnimationKey_;\n  \n    this.updateAnimations_ = this.updateAnimations_.bind(this);\n  \n    /**\n     * @private\n     * @const\n     * @type {ol.proj.Projection}\n     */\n    this.projection_ = ol.proj.createProjection(options.projection, 'EPSG:3857');\n  \n    this.applyOptions_(options);\n  };\n  ol.inherits(ol.View, ol.Object);\n  \n  \n  /**\n   * Set up the view with the given options.\n   * @param {olx.ViewOptions} options View options.\n   */\n  ol.View.prototype.applyOptions_ = function(options) {\n  \n    /**\n     * @type {Object.<string, *>}\n     */\n    var properties = {};\n    properties[ol.ViewProperty.CENTER] = options.center !== undefined ?\n      options.center : null;\n  \n    var resolutionConstraintInfo = ol.View.createResolutionConstraint_(\n        options);\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n  \n    /**\n     * @private\n     * @type {Array.<number>|undefined}\n     */\n    this.resolutions_ = options.resolutions;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n  \n    var centerConstraint = ol.View.createCenterConstraint_(options);\n    var resolutionConstraint = resolutionConstraintInfo.constraint;\n    var rotationConstraint = ol.View.createRotationConstraint_(options);\n  \n    /**\n     * @private\n     * @type {ol.Constraints}\n     */\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint\n    };\n  \n    if (options.resolution !== undefined) {\n      properties[ol.ViewProperty.RESOLUTION] = options.resolution;\n    } else if (options.zoom !== undefined) {\n      properties[ol.ViewProperty.RESOLUTION] = this.constrainResolution(\n          this.maxResolution_, options.zoom - this.minZoom_);\n  \n      if (this.resolutions_) { // in case map zoom is out of min/max zoom range\n        properties[ol.ViewProperty.RESOLUTION] = ol.math.clamp(\n            Number(this.getResolution() || properties[ol.ViewProperty.RESOLUTION]),\n            this.minResolution_, this.maxResolution_);\n      }\n    }\n    properties[ol.ViewProperty.ROTATION] =\n        options.rotation !== undefined ? options.rotation : 0;\n    this.setProperties(properties);\n  \n    /**\n     * @private\n     * @type {olx.ViewOptions}\n     */\n    this.options_ = options;\n  \n  };\n  \n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be uesd to apply new min/max zoom or\n   * resolution limits.\n   * @param {olx.ViewOptions} newOptions New options to be applied.\n   * @return {olx.ViewOptions} New options updated with the current view state.\n   */\n  ol.View.prototype.getUpdatedOptions_ = function(newOptions) {\n    var options = ol.obj.assign({}, this.options_);\n  \n    // preserve resolution (or zoom)\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    }\n  \n    // preserve center\n    options.center = this.getCenter();\n  \n    // preserve rotation\n    options.rotation = this.getRotation();\n  \n    return ol.obj.assign({}, options, newOptions);\n  };\n  \n  \n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link ol.easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(olx.AnimationOptions|function(boolean))} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n  ol.View.prototype.animate = function(var_args) {\n    var animationCount = arguments.length;\n    var callback;\n    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n    if (!this.isDef()) {\n      // if view properties are not yet set, shortcut to the final state\n      var state = arguments[animationCount - 1];\n      if (state.center) {\n        this.setCenter(state.center);\n      }\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      }\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n      if (callback) {\n        callback(true);\n      }\n      return;\n    }\n    var start = Date.now();\n    var center = this.getCenter().slice();\n    var resolution = this.getResolution();\n    var rotation = this.getRotation();\n    var series = [];\n    for (var i = 0; i < animationCount; ++i) {\n      var options = /** @type {olx.AnimationOptions} */ (arguments[i]);\n  \n      var animation = /** @type {ol.ViewAnimation} */ ({\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || ol.easing.inAndOut\n      });\n  \n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center;\n        center = animation.targetCenter;\n      }\n  \n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.constrainResolution(\n            this.maxResolution_, options.zoom - this.minZoom_, 0);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n  \n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        var delta = ol.math.modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n  \n      animation.callback = callback;\n  \n      // check if animation is a no-op\n      if (ol.View.isNoopAnimation(animation)) {\n        animation.complete = true;\n        // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n      series.push(animation);\n    }\n    this.animations_.push(series);\n    this.setHint(ol.ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  };\n  \n  \n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n  ol.View.prototype.getAnimating = function() {\n    return this.hints_[ol.ViewHint.ANIMATING] > 0;\n  };\n  \n  \n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n  ol.View.prototype.getInteracting = function() {\n    return this.hints_[ol.ViewHint.INTERACTING] > 0;\n  };\n  \n  \n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n  ol.View.prototype.cancelAnimations = function() {\n    this.setHint(ol.ViewHint.ANIMATING, -this.hints_[ol.ViewHint.ANIMATING]);\n    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {\n      var series = this.animations_[i];\n      if (series[0].callback) {\n        series[0].callback(false);\n      }\n    }\n    this.animations_.length = 0;\n  };\n  \n  /**\n   * Update all animations.\n   */\n  ol.View.prototype.updateAnimations_ = function() {\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n    if (!this.getAnimating()) {\n      return;\n    }\n    var now = Date.now();\n    var more = false;\n    for (var i = this.animations_.length - 1; i >= 0; --i) {\n      var series = this.animations_[i];\n      var seriesComplete = true;\n      for (var j = 0, jj = series.length; j < jj; ++j) {\n        var animation = series[j];\n        if (animation.complete) {\n          continue;\n        }\n        var elapsed = now - animation.start;\n        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n        var progress = animation.easing(fraction);\n        if (animation.sourceCenter) {\n          var x0 = animation.sourceCenter[0];\n          var y0 = animation.sourceCenter[1];\n          var x1 = animation.targetCenter[0];\n          var y1 = animation.targetCenter[1];\n          var x = x0 + progress * (x1 - x0);\n          var y = y0 + progress * (y1 - y0);\n          this.set(ol.ViewProperty.CENTER, [x, y]);\n        }\n        if (animation.sourceResolution && animation.targetResolution) {\n          var resolution = progress === 1 ?\n            animation.targetResolution :\n            animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\n          if (animation.anchor) {\n            this.set(ol.ViewProperty.CENTER,\n                this.calculateCenterZoom(resolution, animation.anchor));\n          }\n          this.set(ol.ViewProperty.RESOLUTION, resolution);\n        }\n        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {\n          var rotation = progress === 1 ?\n            ol.math.modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI :\n            animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\n          if (animation.anchor) {\n            this.set(ol.ViewProperty.CENTER,\n                this.calculateCenterRotate(rotation, animation.anchor));\n          }\n          this.set(ol.ViewProperty.ROTATION, rotation);\n        }\n        more = true;\n        if (!animation.complete) {\n          break;\n        }\n      }\n      if (seriesComplete) {\n        this.animations_[i] = null;\n        this.setHint(ol.ViewHint.ANIMATING, -1);\n        var callback = series[0].callback;\n        if (callback) {\n          callback(true);\n        }\n      }\n    }\n    // prune completed series\n    this.animations_ = this.animations_.filter(Boolean);\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);\n    }\n  };\n  \n  /**\n   * @param {number} rotation Target rotation.\n   * @param {ol.Coordinate} anchor Rotation anchor.\n   * @return {ol.Coordinate|undefined} Center for rotation and anchor.\n   */\n  ol.View.prototype.calculateCenterRotate = function(rotation, anchor) {\n    var center;\n    var currentCenter = this.getCenter();\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      ol.coordinate.rotate(center, rotation - this.getRotation());\n      ol.coordinate.add(center, anchor);\n    }\n    return center;\n  };\n  \n  \n  /**\n   * @param {number} resolution Target resolution.\n   * @param {ol.Coordinate} anchor Zoom anchor.\n   * @return {ol.Coordinate|undefined} Center for resolution and anchor.\n   */\n  ol.View.prototype.calculateCenterZoom = function(resolution, anchor) {\n    var center;\n    var currentCenter = this.getCenter();\n    var currentResolution = this.getResolution();\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      var x = anchor[0] -\n          resolution * (anchor[0] - currentCenter[0]) / currentResolution;\n      var y = anchor[1] -\n          resolution * (anchor[1] - currentCenter[1]) / currentResolution;\n      center = [x, y];\n    }\n    return center;\n  };\n  \n  \n  /**\n   * @private\n   * @return {ol.Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n  ol.View.prototype.getSizeFromViewport_ = function() {\n    var size = [100, 100];\n    var selector = '.ol-viewport[data-view=\"' + ol.getUid(this) + '\"]';\n    var element = document.querySelector(selector);\n    if (element) {\n      var metrics = getComputedStyle(element);\n      size[0] = parseInt(metrics.width, 10);\n      size[1] = parseInt(metrics.height, 10);\n    }\n    return size;\n  };\n  \n  \n  /**\n   * Get the constrained center of this view.\n   * @param {ol.Coordinate|undefined} center Center.\n   * @return {ol.Coordinate|undefined} Constrained center.\n   * @api\n   */\n  ol.View.prototype.constrainCenter = function(center) {\n    return this.constraints_.center(center);\n  };\n  \n  \n  /**\n   * Get the constrained resolution of this view.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number=} opt_delta Delta. Default is `0`.\n   * @param {number=} opt_direction Direction. Default is `0`.\n   * @return {number|undefined} Constrained resolution.\n   * @api\n   */\n  ol.View.prototype.constrainResolution = function(\n      resolution, opt_delta, opt_direction) {\n    var delta = opt_delta || 0;\n    var direction = opt_direction || 0;\n    return this.constraints_.resolution(resolution, delta, direction);\n  };\n  \n  \n  /**\n   * Get the constrained rotation of this view.\n   * @param {number|undefined} rotation Rotation.\n   * @param {number=} opt_delta Delta. Default is `0`.\n   * @return {number|undefined} Constrained rotation.\n   * @api\n   */\n  ol.View.prototype.constrainRotation = function(rotation, opt_delta) {\n    var delta = opt_delta || 0;\n    return this.constraints_.rotation(rotation, delta);\n  };\n  \n  \n  /**\n   * Get the view center.\n   * @return {ol.Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n  ol.View.prototype.getCenter = function() {\n    return /** @type {ol.Coordinate|undefined} */ (\n      this.get(ol.ViewProperty.CENTER));\n  };\n  \n  \n  /**\n   * @return {ol.Constraints} Constraints.\n   */\n  ol.View.prototype.getConstraints = function() {\n    return this.constraints_;\n  };\n  \n  \n  /**\n   * @param {Array.<number>=} opt_hints Destination array.\n   * @return {Array.<number>} Hint.\n   */\n  ol.View.prototype.getHints = function(opt_hints) {\n    if (opt_hints !== undefined) {\n      opt_hints[0] = this.hints_[0];\n      opt_hints[1] = this.hints_[1];\n      return opt_hints;\n    } else {\n      return this.hints_.slice();\n    }\n  };\n  \n  \n  /**\n   * Calculate the extent for the current view state and the passed size.\n   * The size is the pixel dimensions of the box into which the calculated extent\n   * should fit. In most cases you want to get the extent of the entire map,\n   * that is `map.getSize()`.\n   * @param {ol.Size=} opt_size Box pixel size. If not provided, the size of the\n   * first map that uses this view will be used.\n   * @return {ol.Extent} Extent.\n   * @api\n   */\n  ol.View.prototype.calculateExtent = function(opt_size) {\n    var size = opt_size || this.getSizeFromViewport_();\n    var center = /** @type {!ol.Coordinate} */ (this.getCenter());\n    ol.asserts.assert(center, 1); // The view center is not defined\n    var resolution = /** @type {!number} */ (this.getResolution());\n    ol.asserts.assert(resolution !== undefined, 2); // The view resolution is not defined\n    var rotation = /** @type {!number} */ (this.getRotation());\n    ol.asserts.assert(rotation !== undefined, 3); // The view rotation is not defined\n  \n    return ol.extent.getForViewAndSize(center, resolution, rotation, size);\n  };\n  \n  \n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n  ol.View.prototype.getMaxResolution = function() {\n    return this.maxResolution_;\n  };\n  \n  \n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n  ol.View.prototype.getMinResolution = function() {\n    return this.minResolution_;\n  };\n  \n  \n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n  ol.View.prototype.getMaxZoom = function() {\n    return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));\n  };\n  \n  \n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n  ol.View.prototype.setMaxZoom = function(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\n  };\n  \n  \n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n  ol.View.prototype.getMinZoom = function() {\n    return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));\n  };\n  \n  \n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n  ol.View.prototype.setMinZoom = function(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\n  };\n  \n  \n  /**\n   * Get the view projection.\n   * @return {ol.proj.Projection} The projection of the view.\n   * @api\n   */\n  ol.View.prototype.getProjection = function() {\n    return this.projection_;\n  };\n  \n  \n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n  ol.View.prototype.getResolution = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.ViewProperty.RESOLUTION));\n  };\n  \n  \n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the {ol.View}, or undefined if none were given.\n   * @return {Array.<number>|undefined} The resolutions of the view.\n   * @api\n   */\n  ol.View.prototype.getResolutions = function() {\n    return this.resolutions_;\n  };\n  \n  \n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Size=} opt_size Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n  ol.View.prototype.getResolutionForExtent = function(extent, opt_size) {\n    var size = opt_size || this.getSizeFromViewport_();\n    var xResolution = ol.extent.getWidth(extent) / size[0];\n    var yResolution = ol.extent.getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  };\n  \n  \n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number=} opt_power Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n  ol.View.prototype.getResolutionForValueFunction = function(opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.maxResolution_;\n    var minResolution = this.minResolution_;\n    var max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function(value) {\n        var resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      });\n  };\n  \n  \n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  ol.View.prototype.getRotation = function() {\n    return /** @type {number} */ (this.get(ol.ViewProperty.ROTATION));\n  };\n  \n  \n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number=} opt_power Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n  ol.View.prototype.getValueForResolutionFunction = function(opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.maxResolution_;\n    var minResolution = this.minResolution_;\n    var max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function(resolution) {\n        var value =\n              (Math.log(maxResolution / resolution) / Math.log(power)) / max;\n        return value;\n      });\n  };\n  \n  \n  /**\n   * @return {olx.ViewState} View state.\n   */\n  ol.View.prototype.getState = function() {\n    var center = /** @type {ol.Coordinate} */ (this.getCenter());\n    var projection = this.getProjection();\n    var resolution = /** @type {number} */ (this.getResolution());\n    var rotation = this.getRotation();\n    return /** @type {olx.ViewState} */ ({\n      center: center.slice(),\n      projection: projection !== undefined ? projection : null,\n      resolution: resolution,\n      rotation: rotation,\n      zoom: this.getZoom()\n    });\n  };\n  \n  \n  /**\n   * Get the current zoom level.  If you configured your view with a resolutions\n   * array (this is rare), this method may return non-integer zoom levels (so\n   * the zoom level is not safe to use as an index into a resolutions array).\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n  ol.View.prototype.getZoom = function() {\n    var zoom;\n    var resolution = this.getResolution();\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n    return zoom;\n  };\n  \n  \n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n  ol.View.prototype.getZoomForResolution = function(resolution) {\n    var offset = this.minZoom_ || 0;\n    var max, zoomFactor;\n    if (this.resolutions_) {\n      var nearest = ol.array.linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  };\n  \n  \n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n  ol.View.prototype.getResolutionForZoom = function(zoom) {\n    return /** @type {number} */ (this.constrainResolution(\n        this.maxResolution_, zoom - this.minZoom_, 0));\n  };\n  \n  \n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {ol.geom.SimpleGeometry|ol.Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {olx.view.FitOptions=} opt_options Options.\n   * @api\n   */\n  ol.View.prototype.fit = function(geometryOrExtent, opt_options) {\n    var options = opt_options || {};\n    var size = options.size;\n    if (!size) {\n      size = this.getSizeFromViewport_();\n    }\n    /** @type {ol.geom.SimpleGeometry} */\n    var geometry;\n    if (!(geometryOrExtent instanceof ol.geom.SimpleGeometry)) {\n      ol.asserts.assert(Array.isArray(geometryOrExtent),\n          24); // Invalid extent or geometry provided as `geometry`\n      ol.asserts.assert(!ol.extent.isEmpty(geometryOrExtent),\n          25); // Cannot fit empty extent provided as `geometry`\n      geometry = ol.geom.Polygon.fromExtent(geometryOrExtent);\n    } else if (geometryOrExtent.getType() === ol.geom.GeometryType.CIRCLE) {\n      geometryOrExtent = geometryOrExtent.getExtent();\n      geometry = ol.geom.Polygon.fromExtent(geometryOrExtent);\n      geometry.rotate(this.getRotation(), ol.extent.getCenter(geometryOrExtent));\n    } else {\n      geometry = geometryOrExtent;\n    }\n  \n    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    var constrainResolution = options.constrainResolution !== undefined ?\n      options.constrainResolution : true;\n    var nearest = options.nearest !== undefined ? options.nearest : false;\n    var minResolution;\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.constrainResolution(\n          this.maxResolution_, options.maxZoom - this.minZoom_, 0);\n    } else {\n      minResolution = 0;\n    }\n    var coords = geometry.getFlatCoordinates();\n  \n    // calculate rotated extent\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var minRotX = +Infinity;\n    var minRotY = +Infinity;\n    var maxRotX = -Infinity;\n    var maxRotY = -Infinity;\n    var stride = geometry.getStride();\n    for (var i = 0, ii = coords.length; i < ii; i += stride) {\n      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n  \n    // calculate resolution\n    var resolution = this.getResolutionForExtent(\n        [minRotX, minRotY, maxRotX, maxRotY],\n        [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);\n    resolution = isNaN(resolution) ? minResolution :\n      Math.max(resolution, minResolution);\n    if (constrainResolution) {\n      var constrainedResolution = this.constrainResolution(resolution, 0, 0);\n      if (!nearest && constrainedResolution < resolution) {\n        constrainedResolution = this.constrainResolution(\n            constrainedResolution, -1, 0);\n      }\n      resolution = constrainedResolution;\n    }\n  \n    // calculate center\n    sinAngle = -sinAngle; // go back to original rotation\n    var centerRotX = (minRotX + maxRotX) / 2;\n    var centerRotY = (minRotY + maxRotY) / 2;\n    centerRotX += (padding[1] - padding[3]) / 2 * resolution;\n    centerRotY += (padding[0] - padding[2]) / 2 * resolution;\n    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;\n    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;\n    var center = [centerX, centerY];\n    var callback = options.callback ? options.callback : ol.nullFunction;\n  \n    if (options.duration !== undefined) {\n      this.animate({\n        resolution: resolution,\n        center: center,\n        duration: options.duration,\n        easing: options.easing\n      }, callback);\n    } else {\n      this.setResolution(resolution);\n      this.setCenter(center);\n      setTimeout(callback.bind(undefined, true), 0);\n    }\n  };\n  \n  \n  /**\n   * Center on coordinate and view position.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {ol.Size} size Box pixel size.\n   * @param {ol.Pixel} position Position on the view to center on.\n   * @api\n   */\n  ol.View.prototype.centerOn = function(coordinate, size, position) {\n    // calculate rotated position\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    var resolution = this.getResolution();\n    rotX += (size[0] / 2 - position[0]) * resolution;\n    rotY += (position[1] - size[1] / 2) * resolution;\n  \n    // go back to original angle\n    sinAngle = -sinAngle; // go back to original rotation\n    var centerX = rotX * cosAngle - rotY * sinAngle;\n    var centerY = rotY * cosAngle + rotX * sinAngle;\n  \n    this.setCenter([centerX, centerY]);\n  };\n  \n  \n  /**\n   * @return {boolean} Is defined.\n   */\n  ol.View.prototype.isDef = function() {\n    return !!this.getCenter() && this.getResolution() !== undefined;\n  };\n  \n  \n  /**\n   * Rotate the view around a given coordinate.\n   * @param {number} rotation New rotation value for the view.\n   * @param {ol.Coordinate=} opt_anchor The rotation center.\n   * @api\n   */\n  ol.View.prototype.rotate = function(rotation, opt_anchor) {\n    if (opt_anchor !== undefined) {\n      var center = this.calculateCenterRotate(rotation, opt_anchor);\n      this.setCenter(center);\n    }\n    this.setRotation(rotation);\n  };\n  \n  \n  /**\n   * Set the center of the current view.\n   * @param {ol.Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n  ol.View.prototype.setCenter = function(center) {\n    this.set(ol.ViewProperty.CENTER, center);\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.ViewHint} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n  ol.View.prototype.setHint = function(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  };\n  \n  \n  /**\n   * Set the resolution for this view.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n  ol.View.prototype.setResolution = function(resolution) {\n    this.set(ol.ViewProperty.RESOLUTION, resolution);\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  \n  \n  /**\n   * Set the rotation for this view.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  ol.View.prototype.setRotation = function(rotation) {\n    this.set(ol.ViewProperty.ROTATION, rotation);\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  \n  \n  /**\n   * Zoom to a specific zoom level.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n  ol.View.prototype.setZoom = function(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  };\n  \n  \n  /**\n   * @param {olx.ViewOptions} options View options.\n   * @private\n   * @return {ol.CenterConstraintType} The constraint.\n   */\n  ol.View.createCenterConstraint_ = function(options) {\n    if (options.extent !== undefined) {\n      return ol.CenterConstraint.createExtent(options.extent);\n    } else {\n      return ol.CenterConstraint.none;\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {olx.ViewOptions} options View options.\n   * @return {{constraint: ol.ResolutionConstraintType, maxResolution: number,\n   *     minResolution: number, zoomFactor: number}} The constraint.\n   */\n  ol.View.createResolutionConstraint_ = function(options) {\n    var resolutionConstraint;\n    var maxResolution;\n    var minResolution;\n  \n    // TODO: move these to be ol constants\n    // see https://github.com/openlayers/openlayers/issues/2076\n    var defaultMaxZoom = 28;\n    var defaultZoomFactor = 2;\n  \n    var minZoom = options.minZoom !== undefined ?\n      options.minZoom : ol.DEFAULT_MIN_ZOOM;\n  \n    var maxZoom = options.maxZoom !== undefined ?\n      options.maxZoom : defaultMaxZoom;\n  \n    var zoomFactor = options.zoomFactor !== undefined ?\n      options.zoomFactor : defaultZoomFactor;\n  \n    if (options.resolutions !== undefined) {\n      var resolutions = options.resolutions;\n      maxResolution = resolutions[minZoom];\n      minResolution = resolutions[maxZoom] !== undefined ?\n        resolutions[maxZoom] : resolutions[resolutions.length - 1];\n      resolutionConstraint = ol.ResolutionConstraint.createSnapToResolutions(\n          resolutions);\n    } else {\n      // calculate the default min and max resolution\n      var projection = ol.proj.createProjection(options.projection, 'EPSG:3857');\n      var extent = projection.getExtent();\n      var size = !extent ?\n        // use an extent that can fit the whole world if need be\n        360 * ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES] /\n              projection.getMetersPerUnit() :\n        Math.max(ol.extent.getWidth(extent), ol.extent.getHeight(extent));\n  \n      var defaultMaxResolution = size / ol.DEFAULT_TILE_SIZE / Math.pow(\n          defaultZoomFactor, ol.DEFAULT_MIN_ZOOM);\n  \n      var defaultMinResolution = defaultMaxResolution / Math.pow(\n          defaultZoomFactor, defaultMaxZoom - ol.DEFAULT_MIN_ZOOM);\n  \n      // user provided maxResolution takes precedence\n      maxResolution = options.maxResolution;\n      if (maxResolution !== undefined) {\n        minZoom = 0;\n      } else {\n        maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n      }\n  \n      // user provided minResolution takes precedence\n      minResolution = options.minResolution;\n      if (minResolution === undefined) {\n        if (options.maxZoom !== undefined) {\n          if (options.maxResolution !== undefined) {\n            minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n          } else {\n            minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n          }\n        } else {\n          minResolution = defaultMinResolution;\n        }\n      }\n  \n      // given discrete zoom levels, minResolution may be different than provided\n      maxZoom = minZoom + Math.floor(\n          Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\n      minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n  \n      resolutionConstraint = ol.ResolutionConstraint.createSnapToPower(\n          zoomFactor, maxResolution, maxZoom - minZoom);\n    }\n    return {constraint: resolutionConstraint, maxResolution: maxResolution,\n      minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor};\n  };\n  \n  \n  /**\n   * @private\n   * @param {olx.ViewOptions} options View options.\n   * @return {ol.RotationConstraintType} Rotation constraint.\n   */\n  ol.View.createRotationConstraint_ = function(options) {\n    var enableRotation = options.enableRotation !== undefined ?\n      options.enableRotation : true;\n    if (enableRotation) {\n      var constrainRotation = options.constrainRotation;\n      if (constrainRotation === undefined || constrainRotation === true) {\n        return ol.RotationConstraint.createSnapToZero();\n      } else if (constrainRotation === false) {\n        return ol.RotationConstraint.none;\n      } else if (typeof constrainRotation === 'number') {\n        return ol.RotationConstraint.createSnapToN(constrainRotation);\n      } else {\n        return ol.RotationConstraint.none;\n      }\n    } else {\n      return ol.RotationConstraint.disable;\n    }\n  };\n  \n  \n  /**\n   * Determine if an animation involves no view change.\n   * @param {ol.ViewAnimation} animation The animation.\n   * @return {boolean} The animation involves no view change.\n   */\n  ol.View.isNoopAnimation = function(animation) {\n    if (animation.sourceCenter && animation.targetCenter) {\n      if (!ol.coordinate.equals(animation.sourceCenter, animation.targetCenter)) {\n        return false;\n      }\n    }\n    if (animation.sourceResolution !== animation.targetResolution) {\n      return false;\n    }\n    if (animation.sourceRotation !== animation.targetRotation) {\n      return false;\n    }\n    return true;\n  };\n  \n  goog.provide('ol.dom');\n  \n  \n  /**\n   * Create an html canvas element and returns its 2d context.\n   * @param {number=} opt_width Canvas width.\n   * @param {number=} opt_height Canvas height.\n   * @return {CanvasRenderingContext2D} The context.\n   */\n  ol.dom.createCanvasContext2D = function(opt_width, opt_height) {\n    var canvas = document.createElement('CANVAS');\n    if (opt_width) {\n      canvas.width = opt_width;\n    }\n    if (opt_height) {\n      canvas.height = opt_height;\n    }\n    return canvas.getContext('2d');\n  };\n  \n  \n  /**\n   * Get the current computed width for the given element including margin,\n   * padding and border.\n   * Equivalent to jQuery's `$(el).outerWidth(true)`.\n   * @param {!Element} element Element.\n   * @return {number} The width.\n   */\n  ol.dom.outerWidth = function(element) {\n    var width = element.offsetWidth;\n    var style = getComputedStyle(element);\n    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n  \n    return width;\n  };\n  \n  \n  /**\n   * Get the current computed height for the given element including margin,\n   * padding and border.\n   * Equivalent to jQuery's `$(el).outerHeight(true)`.\n   * @param {!Element} element Element.\n   * @return {number} The height.\n   */\n  ol.dom.outerHeight = function(element) {\n    var height = element.offsetHeight;\n    var style = getComputedStyle(element);\n    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n  \n    return height;\n  };\n  \n  /**\n   * @param {Node} newNode Node to replace old node\n   * @param {Node} oldNode The node to be replaced\n   */\n  ol.dom.replaceNode = function(newNode, oldNode) {\n    var parent = oldNode.parentNode;\n    if (parent) {\n      parent.replaceChild(newNode, oldNode);\n    }\n  };\n  \n  /**\n   * @param {Node} node The node to remove.\n   * @returns {Node} The node that was removed or null.\n   */\n  ol.dom.removeNode = function(node) {\n    return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n  };\n  \n  /**\n   * @param {Node} node The node to remove the children from.\n   */\n  ol.dom.removeChildren = function(node) {\n    while (node.lastChild) {\n      node.removeChild(node.lastChild);\n    }\n  };\n  \n  goog.provide('ol.layer.Property');\n  \n  /**\n   * @enum {string}\n   */\n  ol.layer.Property = {\n    OPACITY: 'opacity',\n    VISIBLE: 'visible',\n    EXTENT: 'extent',\n    Z_INDEX: 'zIndex',\n    MAX_RESOLUTION: 'maxResolution',\n    MIN_RESOLUTION: 'minResolution',\n    SOURCE: 'source'\n  };\n  \n  goog.provide('ol.layer.Base');\n  \n  goog.require('ol');\n  goog.require('ol.Object');\n  goog.require('ol.layer.Property');\n  goog.require('ol.math');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Note that with `ol.layer.Base` and all its subclasses, any property set in\n   * the options is set as a {@link ol.Object} property on the layer object, so\n   * is observable, and has get/set accessors.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.Object}\n   * @param {olx.layer.BaseOptions} options Layer options.\n   * @api\n   */\n  ol.layer.Base = function(options) {\n  \n    ol.Object.call(this);\n  \n    /**\n     * @type {Object.<string, *>}\n     */\n    var properties = ol.obj.assign({}, options);\n    properties[ol.layer.Property.OPACITY] =\n        options.opacity !== undefined ? options.opacity : 1;\n    properties[ol.layer.Property.VISIBLE] =\n        options.visible !== undefined ? options.visible : true;\n    properties[ol.layer.Property.Z_INDEX] =\n        options.zIndex !== undefined ? options.zIndex : 0;\n    properties[ol.layer.Property.MAX_RESOLUTION] =\n        options.maxResolution !== undefined ? options.maxResolution : Infinity;\n    properties[ol.layer.Property.MIN_RESOLUTION] =\n        options.minResolution !== undefined ? options.minResolution : 0;\n  \n    this.setProperties(properties);\n  \n    /**\n     * @type {ol.LayerState}\n     * @private\n     */\n    this.state_ = /** @type {ol.LayerState} */ ({\n      layer: /** @type {ol.layer.Layer} */ (this),\n      managed: true\n    });\n  \n    /**\n     * The layer type.\n     * @type {ol.LayerType}\n     * @protected;\n     */\n    this.type;\n  \n  };\n  ol.inherits(ol.layer.Base, ol.Object);\n  \n  \n  /**\n   * Get the layer type (used when creating a layer renderer).\n   * @return {ol.LayerType} The layer type.\n   */\n  ol.layer.Base.prototype.getType = function() {\n    return this.type;\n  };\n  \n  \n  /**\n   * @return {ol.LayerState} Layer state.\n   */\n  ol.layer.Base.prototype.getLayerState = function() {\n    this.state_.opacity = ol.math.clamp(this.getOpacity(), 0, 1);\n    this.state_.sourceState = this.getSourceState();\n    this.state_.visible = this.getVisible();\n    this.state_.extent = this.getExtent();\n    this.state_.zIndex = this.getZIndex();\n    this.state_.maxResolution = this.getMaxResolution();\n    this.state_.minResolution = Math.max(this.getMinResolution(), 0);\n  \n    return this.state_;\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Array.<ol.layer.Layer>=} opt_array Array of layers (to be\n   *     modified in place).\n   * @return {Array.<ol.layer.Layer>} Array of layers.\n   */\n  ol.layer.Base.prototype.getLayersArray = function(opt_array) {};\n  \n  \n  /**\n   * @abstract\n   * @param {Array.<ol.LayerState>=} opt_states Optional list of layer\n   *     states (to be modified in place).\n   * @return {Array.<ol.LayerState>} List of layer states.\n   */\n  ol.layer.Base.prototype.getLayerStatesArray = function(opt_states) {};\n  \n  \n  /**\n   * Return the {@link ol.Extent extent} of the layer or `undefined` if it\n   * will be visible regardless of extent.\n   * @return {ol.Extent|undefined} The layer extent.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.getExtent = function() {\n    return /** @type {ol.Extent|undefined} */ (\n      this.get(ol.layer.Property.EXTENT));\n  };\n  \n  \n  /**\n   * Return the maximum resolution of the layer.\n   * @return {number} The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.getMaxResolution = function() {\n    return /** @type {number} */ (\n      this.get(ol.layer.Property.MAX_RESOLUTION));\n  };\n  \n  \n  /**\n   * Return the minimum resolution of the layer.\n   * @return {number} The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.getMinResolution = function() {\n    return /** @type {number} */ (\n      this.get(ol.layer.Property.MIN_RESOLUTION));\n  };\n  \n  \n  /**\n   * Return the opacity of the layer (between 0 and 1).\n   * @return {number} The opacity of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.getOpacity = function() {\n    return /** @type {number} */ (this.get(ol.layer.Property.OPACITY));\n  };\n  \n  \n  /**\n   * @abstract\n   * @return {ol.source.State} Source state.\n   */\n  ol.layer.Base.prototype.getSourceState = function() {};\n  \n  \n  /**\n   * Return the visibility of the layer (`true` or `false`).\n   * @return {boolean} The visibility of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.getVisible = function() {\n    return /** @type {boolean} */ (this.get(ol.layer.Property.VISIBLE));\n  };\n  \n  \n  /**\n   * Return the Z-index of the layer, which is used to order layers before\n   * rendering. The default Z-index is 0.\n   * @return {number} The Z-index of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.getZIndex = function() {\n    return /** @type {number} */ (this.get(ol.layer.Property.Z_INDEX));\n  };\n  \n  \n  /**\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\n   * will be visible at all extents.\n   * @param {ol.Extent|undefined} extent The extent of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.setExtent = function(extent) {\n    this.set(ol.layer.Property.EXTENT, extent);\n  };\n  \n  \n  /**\n   * Set the maximum resolution at which the layer is visible.\n   * @param {number} maxResolution The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.setMaxResolution = function(maxResolution) {\n    this.set(ol.layer.Property.MAX_RESOLUTION, maxResolution);\n  };\n  \n  \n  /**\n   * Set the minimum resolution at which the layer is visible.\n   * @param {number} minResolution The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.setMinResolution = function(minResolution) {\n    this.set(ol.layer.Property.MIN_RESOLUTION, minResolution);\n  };\n  \n  \n  /**\n   * Set the opacity of the layer, allowed values range from 0 to 1.\n   * @param {number} opacity The opacity of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.setOpacity = function(opacity) {\n    this.set(ol.layer.Property.OPACITY, opacity);\n  };\n  \n  \n  /**\n   * Set the visibility of the layer (`true` or `false`).\n   * @param {boolean} visible The visibility of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.setVisible = function(visible) {\n    this.set(ol.layer.Property.VISIBLE, visible);\n  };\n  \n  \n  /**\n   * Set Z-index of the layer, which is used to order layers before rendering.\n   * The default Z-index is 0.\n   * @param {number} zindex The z-index of the layer.\n   * @observable\n   * @api\n   */\n  ol.layer.Base.prototype.setZIndex = function(zindex) {\n    this.set(ol.layer.Property.Z_INDEX, zindex);\n  };\n  \n  goog.provide('ol.source.State');\n  \n  \n  /**\n   * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n   * @enum {string}\n   */\n  ol.source.State = {\n    UNDEFINED: 'undefined',\n    LOADING: 'loading',\n    READY: 'ready',\n    ERROR: 'error'\n  };\n  \n  \n  goog.provide('ol.layer.Group');\n  \n  goog.require('ol');\n  goog.require('ol.Collection');\n  goog.require('ol.CollectionEventType');\n  goog.require('ol.Object');\n  goog.require('ol.ObjectEventType');\n  goog.require('ol.asserts');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.layer.Base');\n  goog.require('ol.obj');\n  goog.require('ol.source.State');\n  \n  \n  /**\n   * @classdesc\n   * A {@link ol.Collection} of layers that are handled together.\n   *\n   * A generic `change` event is triggered when the group/Collection changes.\n   *\n   * @constructor\n   * @extends {ol.layer.Base}\n   * @param {olx.layer.GroupOptions=} opt_options Layer options.\n   * @api\n   */\n  ol.layer.Group = function(opt_options) {\n  \n    var options = opt_options || {};\n    var baseOptions = /** @type {olx.layer.GroupOptions} */\n        (ol.obj.assign({}, options));\n    delete baseOptions.layers;\n  \n    var layers = options.layers;\n  \n    ol.layer.Base.call(this, baseOptions);\n  \n    /**\n     * @private\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.layersListenerKeys_ = [];\n  \n    /**\n     * @private\n     * @type {Object.<string, Array.<ol.EventsKey>>}\n     */\n    this.listenerKeys_ = {};\n  \n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.layer.Group.Property_.LAYERS),\n        this.handleLayersChanged_, this);\n  \n    if (layers) {\n      if (Array.isArray(layers)) {\n        layers = new ol.Collection(layers.slice(), {unique: true});\n      } else {\n        ol.asserts.assert(layers instanceof ol.Collection,\n            43); // Expected `layers` to be an array or an `ol.Collection`\n        layers = layers;\n      }\n    } else {\n      layers = new ol.Collection(undefined, {unique: true});\n    }\n  \n    this.setLayers(layers);\n  \n  };\n  ol.inherits(ol.layer.Group, ol.layer.Base);\n  \n  \n  /**\n   * @private\n   */\n  ol.layer.Group.prototype.handleLayerChange_ = function() {\n    this.changed();\n  };\n  \n  \n  /**\n   * @param {ol.events.Event} event Event.\n   * @private\n   */\n  ol.layer.Group.prototype.handleLayersChanged_ = function(event) {\n    this.layersListenerKeys_.forEach(ol.events.unlistenByKey);\n    this.layersListenerKeys_.length = 0;\n  \n    var layers = this.getLayers();\n    this.layersListenerKeys_.push(\n        ol.events.listen(layers, ol.CollectionEventType.ADD,\n            this.handleLayersAdd_, this),\n        ol.events.listen(layers, ol.CollectionEventType.REMOVE,\n            this.handleLayersRemove_, this));\n  \n    for (var id in this.listenerKeys_) {\n      this.listenerKeys_[id].forEach(ol.events.unlistenByKey);\n    }\n    ol.obj.clear(this.listenerKeys_);\n  \n    var layersArray = layers.getArray();\n    var i, ii, layer;\n    for (i = 0, ii = layersArray.length; i < ii; i++) {\n      layer = layersArray[i];\n      this.listenerKeys_[ol.getUid(layer).toString()] = [\n        ol.events.listen(layer, ol.ObjectEventType.PROPERTYCHANGE,\n            this.handleLayerChange_, this),\n        ol.events.listen(layer, ol.events.EventType.CHANGE,\n            this.handleLayerChange_, this)\n      ];\n    }\n  \n    this.changed();\n  };\n  \n  \n  /**\n   * @param {ol.Collection.Event} collectionEvent Collection event.\n   * @private\n   */\n  ol.layer.Group.prototype.handleLayersAdd_ = function(collectionEvent) {\n    var layer = /** @type {ol.layer.Base} */ (collectionEvent.element);\n    var key = ol.getUid(layer).toString();\n    this.listenerKeys_[key] = [\n      ol.events.listen(layer, ol.ObjectEventType.PROPERTYCHANGE,\n          this.handleLayerChange_, this),\n      ol.events.listen(layer, ol.events.EventType.CHANGE,\n          this.handleLayerChange_, this)\n    ];\n    this.changed();\n  };\n  \n  \n  /**\n   * @param {ol.Collection.Event} collectionEvent Collection event.\n   * @private\n   */\n  ol.layer.Group.prototype.handleLayersRemove_ = function(collectionEvent) {\n    var layer = /** @type {ol.layer.Base} */ (collectionEvent.element);\n    var key = ol.getUid(layer).toString();\n    this.listenerKeys_[key].forEach(ol.events.unlistenByKey);\n    delete this.listenerKeys_[key];\n    this.changed();\n  };\n  \n  \n  /**\n   * Returns the {@link ol.Collection collection} of {@link ol.layer.Layer layers}\n   * in this group.\n   * @return {!ol.Collection.<ol.layer.Base>} Collection of\n   *   {@link ol.layer.Base layers} that are part of this group.\n   * @observable\n   * @api\n   */\n  ol.layer.Group.prototype.getLayers = function() {\n    return /** @type {!ol.Collection.<ol.layer.Base>} */ (this.get(\n        ol.layer.Group.Property_.LAYERS));\n  };\n  \n  \n  /**\n   * Set the {@link ol.Collection collection} of {@link ol.layer.Layer layers}\n   * in this group.\n   * @param {!ol.Collection.<ol.layer.Base>} layers Collection of\n   *   {@link ol.layer.Base layers} that are part of this group.\n   * @observable\n   * @api\n   */\n  ol.layer.Group.prototype.setLayers = function(layers) {\n    this.set(ol.layer.Group.Property_.LAYERS, layers);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.layer.Group.prototype.getLayersArray = function(opt_array) {\n    var array = opt_array !== undefined ? opt_array : [];\n    this.getLayers().forEach(function(layer) {\n      layer.getLayersArray(array);\n    });\n    return array;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.layer.Group.prototype.getLayerStatesArray = function(opt_states) {\n    var states = opt_states !== undefined ? opt_states : [];\n  \n    var pos = states.length;\n  \n    this.getLayers().forEach(function(layer) {\n      layer.getLayerStatesArray(states);\n    });\n  \n    var ownLayerState = this.getLayerState();\n    var i, ii, layerState;\n    for (i = pos, ii = states.length; i < ii; i++) {\n      layerState = states[i];\n      layerState.opacity *= ownLayerState.opacity;\n      layerState.visible = layerState.visible && ownLayerState.visible;\n      layerState.maxResolution = Math.min(\n          layerState.maxResolution, ownLayerState.maxResolution);\n      layerState.minResolution = Math.max(\n          layerState.minResolution, ownLayerState.minResolution);\n      if (ownLayerState.extent !== undefined) {\n        if (layerState.extent !== undefined) {\n          layerState.extent = ol.extent.getIntersection(\n              layerState.extent, ownLayerState.extent);\n        } else {\n          layerState.extent = ownLayerState.extent;\n        }\n      }\n    }\n  \n    return states;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.layer.Group.prototype.getSourceState = function() {\n    return ol.source.State.READY;\n  };\n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.layer.Group.Property_ = {\n    LAYERS: 'layers'\n  };\n  \n  goog.provide('ol.PluginType');\n  \n  /**\n   * A plugin type used when registering a plugin.  The supported plugin types are\n   * 'MAP_RENDERER', and 'LAYER_RENDERER'.\n   * @enum {string}\n   */\n  ol.PluginType = {\n    MAP_RENDERER: 'MAP_RENDERER',\n    LAYER_RENDERER: 'LAYER_RENDERER'\n  };\n  \n  goog.provide('ol.plugins');\n  \n  goog.require('ol.PluginType');\n  \n  /**\n   * The registry of map renderer plugins.\n   * @type {Array<olx.MapRendererPlugin>}\n   * @private\n   */\n  ol.plugins.mapRendererPlugins_ = [];\n  \n  \n  /**\n   * Get all registered map renderer plugins.\n   * @return {Array<olx.MapRendererPlugin>} The registered map renderer plugins.\n   */\n  ol.plugins.getMapRendererPlugins = function() {\n    return ol.plugins.mapRendererPlugins_;\n  };\n  \n  \n  /**\n   * The registry of layer renderer plugins.\n   * @type {Array<olx.LayerRendererPlugin>}\n   * @private\n   */\n  ol.plugins.layerRendererPlugins_ = [];\n  \n  \n  /**\n   * Get all registered layer renderer plugins.\n   * @return {Array<olx.LayerRendererPlugin>} The registered layer renderer plugins.\n   */\n  ol.plugins.getLayerRendererPlugins = function() {\n    return ol.plugins.layerRendererPlugins_;\n  };\n  \n  \n  /**\n   * Register a plugin.\n   * @param {ol.PluginType} type The plugin type.\n   * @param {*} plugin The plugin.\n   */\n  ol.plugins.register = function(type, plugin) {\n    var plugins;\n    switch (type) {\n      case ol.PluginType.MAP_RENDERER: {\n        plugins = ol.plugins.mapRendererPlugins_;\n        plugins.push(/** @type {olx.MapRendererPlugin} */ (plugin));\n        break;\n      }\n      case ol.PluginType.LAYER_RENDERER: {\n        plugins = ol.plugins.layerRendererPlugins_;\n        plugins.push(/** @type {olx.LayerRendererPlugin} */ (plugin));\n        break;\n      }\n      default: {\n        throw new Error('Unsupported plugin type: ' + type);\n      }\n    }\n  };\n  \n  \n  /**\n   * Register multiple plugins.\n   * @param {ol.PluginType} type The plugin type.\n   * @param {Array} plugins The plugins.\n   */\n  ol.plugins.registerMultiple = function(type, plugins) {\n    for (var i = 0, ii = plugins.length; i < ii; ++i) {\n      ol.plugins.register(type, plugins[i]);\n    }\n  };\n  \n  goog.provide('ol.renderer.Type');\n  \n  \n  /**\n   * Available renderers: `'canvas'` or `'webgl'`.\n   * @enum {string}\n   */\n  ol.renderer.Type = {\n    CANVAS: 'canvas',\n    WEBGL: 'webgl'\n  };\n  \n  goog.provide('ol.PluggableMap');\n  \n  goog.require('ol');\n  goog.require('ol.Collection');\n  goog.require('ol.CollectionEventType');\n  goog.require('ol.MapBrowserEvent');\n  goog.require('ol.MapBrowserEventHandler');\n  goog.require('ol.MapBrowserEventType');\n  goog.require('ol.MapEvent');\n  goog.require('ol.MapEventType');\n  goog.require('ol.MapProperty');\n  goog.require('ol.Object');\n  goog.require('ol.ObjectEventType');\n  goog.require('ol.TileQueue');\n  goog.require('ol.View');\n  goog.require('ol.ViewHint');\n  goog.require('ol.asserts');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.functions');\n  goog.require('ol.has');\n  goog.require('ol.layer.Group');\n  goog.require('ol.obj');\n  goog.require('ol.plugins');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.size');\n  goog.require('ol.structs.PriorityQueue');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.Object}\n   * @param {olx.MapOptions} options Map options.\n   * @fires ol.MapBrowserEvent\n   * @fires ol.MapEvent\n   * @fires ol.render.Event#postcompose\n   * @fires ol.render.Event#precompose\n   * @api\n   */\n  ol.PluggableMap = function(options) {\n  \n    ol.Object.call(this);\n  \n    var optionsInternal = ol.PluggableMap.createOptionsInternal(options);\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.loadTilesWhileAnimating_ =\n        options.loadTilesWhileAnimating !== undefined ?\n          options.loadTilesWhileAnimating : false;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.loadTilesWhileInteracting_ =\n        options.loadTilesWhileInteracting !== undefined ?\n          options.loadTilesWhileInteracting : false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio !== undefined ?\n      options.pixelRatio : ol.has.DEVICE_PIXEL_RATIO;\n  \n    /**\n     * @private\n     * @type {Object.<string, string>}\n     */\n    this.logos_ = optionsInternal.logos;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.animationDelayKey_;\n  \n    /**\n     * @private\n     */\n    this.animationDelay_ = function() {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_.call(this, Date.now());\n    }.bind(this);\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.coordinateToPixelTransform_ = ol.transform.create();\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.pixelToCoordinateTransform_ = ol.transform.create();\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.frameIndex_ = 0;\n  \n    /**\n     * @private\n     * @type {?olx.FrameState}\n     */\n    this.frameState_ = null;\n  \n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {ol.Extent}\n     */\n    this.previousExtent_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.EventsKey}\n     */\n    this.viewPropertyListenerKey_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.EventsKey}\n     */\n    this.viewChangeListenerKey_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.layerGroupPropertyListenerKeys_ = null;\n  \n    /**\n     * @private\n     * @type {Element}\n     */\n    this.viewport_ = document.createElement('DIV');\n    this.viewport_.className = 'ol-viewport' + (ol.has.TOUCH ? ' ol-touch' : '');\n    this.viewport_.style.position = 'relative';\n    this.viewport_.style.overflow = 'hidden';\n    this.viewport_.style.width = '100%';\n    this.viewport_.style.height = '100%';\n    // prevent page zoom on IE >= 10 browsers\n    this.viewport_.style.msTouchAction = 'none';\n    this.viewport_.style.touchAction = 'none';\n  \n    /**\n     * @private\n     * @type {!Element}\n     */\n    this.overlayContainer_ = document.createElement('DIV');\n    this.overlayContainer_.className = 'ol-overlaycontainer';\n    this.viewport_.appendChild(this.overlayContainer_);\n  \n    /**\n     * @private\n     * @type {!Element}\n     */\n    this.overlayContainerStopEvent_ = document.createElement('DIV');\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    var overlayEvents = [\n      ol.events.EventType.CLICK,\n      ol.events.EventType.DBLCLICK,\n      ol.events.EventType.MOUSEDOWN,\n      ol.events.EventType.TOUCHSTART,\n      ol.events.EventType.MSPOINTERDOWN,\n      ol.MapBrowserEventType.POINTERDOWN,\n      ol.events.EventType.MOUSEWHEEL,\n      ol.events.EventType.WHEEL\n    ];\n    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {\n      ol.events.listen(this.overlayContainerStopEvent_, overlayEvents[i],\n          ol.events.Event.stopPropagation);\n    }\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n  \n    /**\n     * @private\n     * @type {ol.MapBrowserEventHandler}\n     */\n    this.mapBrowserEventHandler_ = new ol.MapBrowserEventHandler(this, options.moveTolerance);\n    for (var key in ol.MapBrowserEventType) {\n      ol.events.listen(this.mapBrowserEventHandler_, ol.MapBrowserEventType[key],\n          this.handleMapBrowserEvent, this);\n    }\n  \n    /**\n     * @private\n     * @type {Element|Document}\n     */\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n  \n    /**\n     * @private\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.keyHandlerKeys_ = null;\n  \n    ol.events.listen(this.viewport_, ol.events.EventType.WHEEL,\n        this.handleBrowserEvent, this);\n    ol.events.listen(this.viewport_, ol.events.EventType.MOUSEWHEEL,\n        this.handleBrowserEvent, this);\n  \n    /**\n     * @type {ol.Collection.<ol.control.Control>}\n     * @protected\n     */\n    this.controls = optionsInternal.controls || new ol.Collection();\n  \n    /**\n     * @type {ol.Collection.<ol.interaction.Interaction>}\n     * @protected\n     */\n    this.interactions = optionsInternal.interactions || new ol.Collection();\n  \n    /**\n     * @type {ol.Collection.<ol.Overlay>}\n     * @private\n     */\n    this.overlays_ = optionsInternal.overlays;\n  \n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object.<string, ol.Overlay>}\n     */\n    this.overlayIdIndex_ = {};\n  \n    /**\n     * @type {ol.renderer.Map}\n     * @private\n     */\n    this.renderer_ = optionsInternal.mapRendererPlugin['create'](this.viewport_, this);\n  \n    /**\n     * @type {function(Event)|undefined}\n     * @private\n     */\n    this.handleResize_;\n  \n    /**\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.focus_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<ol.PostRenderFunction>}\n     */\n    this.postRenderFunctions_ = [];\n  \n    /**\n     * @private\n     * @type {ol.TileQueue}\n     */\n    this.tileQueue_ = new ol.TileQueue(\n        this.getTilePriority.bind(this),\n        this.handleTileChange_.bind(this));\n  \n    /**\n     * Uids of features to skip at rendering time.\n     * @type {Object.<string, boolean>}\n     * @private\n     */\n    this.skippedFeatureUids_ = {};\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.MapProperty.LAYERGROUP),\n        this.handleLayerGroupChanged_, this);\n    ol.events.listen(this, ol.Object.getChangeEventType(ol.MapProperty.VIEW),\n        this.handleViewChanged_, this);\n    ol.events.listen(this, ol.Object.getChangeEventType(ol.MapProperty.SIZE),\n        this.handleSizeChanged_, this);\n    ol.events.listen(this, ol.Object.getChangeEventType(ol.MapProperty.TARGET),\n        this.handleTargetChanged_, this);\n  \n    // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n    this.setProperties(optionsInternal.values);\n  \n    this.controls.forEach(\n        /**\n         * @param {ol.control.Control} control Control.\n         * @this {ol.PluggableMap}\n         */\n        function(control) {\n          control.setMap(this);\n        }, this);\n  \n    ol.events.listen(this.controls, ol.CollectionEventType.ADD,\n        /**\n         * @param {ol.Collection.Event} event Collection event.\n         */\n        function(event) {\n          event.element.setMap(this);\n        }, this);\n  \n    ol.events.listen(this.controls, ol.CollectionEventType.REMOVE,\n        /**\n         * @param {ol.Collection.Event} event Collection event.\n         */\n        function(event) {\n          event.element.setMap(null);\n        }, this);\n  \n    this.interactions.forEach(\n        /**\n         * @param {ol.interaction.Interaction} interaction Interaction.\n         * @this {ol.PluggableMap}\n         */\n        function(interaction) {\n          interaction.setMap(this);\n        }, this);\n  \n    ol.events.listen(this.interactions, ol.CollectionEventType.ADD,\n        /**\n         * @param {ol.Collection.Event} event Collection event.\n         */\n        function(event) {\n          event.element.setMap(this);\n        }, this);\n  \n    ol.events.listen(this.interactions, ol.CollectionEventType.REMOVE,\n        /**\n         * @param {ol.Collection.Event} event Collection event.\n         */\n        function(event) {\n          event.element.setMap(null);\n        }, this);\n  \n    this.overlays_.forEach(this.addOverlayInternal_, this);\n  \n    ol.events.listen(this.overlays_, ol.CollectionEventType.ADD,\n        /**\n         * @param {ol.Collection.Event} event Collection event.\n         */\n        function(event) {\n          this.addOverlayInternal_(/** @type {ol.Overlay} */ (event.element));\n        }, this);\n  \n    ol.events.listen(this.overlays_, ol.CollectionEventType.REMOVE,\n        /**\n         * @param {ol.Collection.Event} event Collection event.\n         */\n        function(event) {\n          var overlay = /** @type {ol.Overlay} */ (event.element);\n          var id = overlay.getId();\n          if (id !== undefined) {\n            delete this.overlayIdIndex_[id.toString()];\n          }\n          event.element.setMap(null);\n        }, this);\n  \n  };\n  ol.inherits(ol.PluggableMap, ol.Object);\n  \n  \n  /**\n   * Add the given control to the map.\n   * @param {ol.control.Control} control Control.\n   * @api\n   */\n  ol.PluggableMap.prototype.addControl = function(control) {\n    this.getControls().push(control);\n  };\n  \n  \n  /**\n   * Add the given interaction to the map.\n   * @param {ol.interaction.Interaction} interaction Interaction to add.\n   * @api\n   */\n  ol.PluggableMap.prototype.addInteraction = function(interaction) {\n    this.getInteractions().push(interaction);\n  };\n  \n  \n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link ol.Collection}.\n   * @param {ol.layer.Base} layer Layer.\n   * @api\n   */\n  ol.PluggableMap.prototype.addLayer = function(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n  \n  \n  /**\n   * Add the given overlay to the map.\n   * @param {ol.Overlay} overlay Overlay.\n   * @api\n   */\n  ol.PluggableMap.prototype.addOverlay = function(overlay) {\n    this.getOverlays().push(overlay);\n  };\n  \n  \n  /**\n   * This deals with map's overlay collection changes.\n   * @param {ol.Overlay} overlay Overlay.\n   * @private\n   */\n  ol.PluggableMap.prototype.addOverlayInternal_ = function(overlay) {\n    var id = overlay.getId();\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n    overlay.setMap(this);\n  };\n  \n  \n  /**\n   *\n   * @inheritDoc\n   */\n  ol.PluggableMap.prototype.disposeInternal = function() {\n    this.mapBrowserEventHandler_.dispose();\n    ol.events.unlisten(this.viewport_, ol.events.EventType.WHEEL,\n        this.handleBrowserEvent, this);\n    ol.events.unlisten(this.viewport_, ol.events.EventType.MOUSEWHEEL,\n        this.handleBrowserEvent, this);\n    if (this.handleResize_ !== undefined) {\n      window.removeEventListener(ol.events.EventType.RESIZE,\n          this.handleResize_, false);\n      this.handleResize_ = undefined;\n    }\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n      this.animationDelayKey_ = undefined;\n    }\n    this.setTarget(null);\n    ol.Object.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `opt_options`.\n   * @param {ol.Pixel} pixel Pixel.\n   * @param {function(this: S, (ol.Feature|ol.render.Feature),\n   *     ol.layer.Layer): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link ol.Feature feature} or\n   *     {@link ol.render.Feature render feature} at the pixel, the second is\n   *     the {@link ol.layer.Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {olx.AtPixelOptions=} opt_options Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n  ol.PluggableMap.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var hitTolerance = opt_options.hitTolerance !== undefined ?\n      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = opt_options.layerFilter !== undefined ?\n      opt_options.layerFilter : ol.functions.TRUE;\n    return this.renderer_.forEachFeatureAtCoordinate(\n        coordinate, this.frameState_, hitTolerance, callback, null,\n        layerFilter, null);\n  };\n  \n  \n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {ol.Pixel} pixel Pixel.\n   * @param {olx.AtPixelOptions=} opt_options Optional options.\n   * @return {Array.<ol.Feature|ol.render.Feature>} The detected features or\n   * `null` if none were found.\n   * @api\n   */\n  ol.PluggableMap.prototype.getFeaturesAtPixel = function(pixel, opt_options) {\n    var features = null;\n    this.forEachFeatureAtPixel(pixel, function(feature) {\n      if (!features) {\n        features = [];\n      }\n      features.push(feature);\n    }, opt_options);\n    return features;\n  };\n  \n  /**\n   * Detect layers that have a color value at a pixel on the viewport, and\n   * execute a callback with each matching layer. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {ol.Pixel} pixel Pixel.\n   * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback\n   *     Layer callback. This callback will receive two arguments: first is the\n   *     {@link ol.layer.Layer layer}, second argument is an array representing\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n   *     that do not currently support this argument. To stop detection, callback\n   *     functions can return a truthy value.\n   * @param {S=} opt_this Value to use as `this` when executing `callback`.\n   * @param {(function(this: U, ol.layer.Layer): boolean)=} opt_layerFilter Layer\n   *     filter function. The filter function will receive one argument, the\n   *     {@link ol.layer.Layer layer-candidate} and it should return a boolean\n   *     value. Only layers which are visible and for which this function returns\n   *     `true` will be tested for features. By default, all visible layers will\n   *     be tested.\n   * @param {U=} opt_this2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T,U\n   * @api\n   */\n  ol.PluggableMap.prototype.forEachLayerAtPixel = function(pixel, callback, opt_this, opt_layerFilter, opt_this2) {\n    if (!this.frameState_) {\n      return;\n    }\n    var thisArg = opt_this !== undefined ? opt_this : null;\n    var layerFilter = opt_layerFilter !== undefined ?\n      opt_layerFilter : ol.functions.TRUE;\n    var thisArg2 = opt_this2 !== undefined ? opt_this2 : null;\n    return this.renderer_.forEachLayerAtPixel(\n        pixel, this.frameState_, callback, thisArg,\n        layerFilter, thisArg2);\n  };\n  \n  \n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {ol.Pixel} pixel Pixel.\n   * @param {olx.AtPixelOptions=} opt_options Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @template U\n   * @api\n   */\n  ol.PluggableMap.prototype.hasFeatureAtPixel = function(pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var layerFilter = opt_options.layerFilter !== undefined ?\n      opt_options.layerFilter : ol.functions.TRUE;\n    var hitTolerance = opt_options.hitTolerance !== undefined ?\n      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    return this.renderer_.hasFeatureAtCoordinate(\n        coordinate, this.frameState_, hitTolerance, layerFilter, null);\n  };\n  \n  \n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {Event} event Event.\n   * @return {ol.Coordinate} Coordinate.\n   * @api\n   */\n  ol.PluggableMap.prototype.getEventCoordinate = function(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n  \n  \n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {Event} event Event.\n   * @return {ol.Pixel} Pixel.\n   * @api\n   */\n  ol.PluggableMap.prototype.getEventPixel = function(event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = event.changedTouches ? event.changedTouches[0] : event;\n    return [\n      eventPosition.clientX - viewportPosition.left,\n      eventPosition.clientY - viewportPosition.top\n    ];\n  };\n  \n  \n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {Element|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n  ol.PluggableMap.prototype.getTarget = function() {\n    return /** @type {Element|string|undefined} */ (\n      this.get(ol.MapProperty.TARGET));\n  };\n  \n  \n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {Element} The element that the map is rendered in.\n   * @api\n   */\n  ol.PluggableMap.prototype.getTargetElement = function() {\n    var target = this.getTarget();\n    if (target !== undefined) {\n      return typeof target === 'string' ?\n        document.getElementById(target) :\n        target;\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {ol.Pixel} pixel Pixel position in the map viewport.\n   * @return {ol.Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n  ol.PluggableMap.prototype.getCoordinateFromPixel = function(pixel) {\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return ol.transform.apply(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n  \n  \n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {ol.Collection.<ol.control.Control>} Controls.\n   * @api\n   */\n  ol.PluggableMap.prototype.getControls = function() {\n    return this.controls;\n  };\n  \n  \n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {ol.Collection.<ol.Overlay>} Overlays.\n   * @api\n   */\n  ol.PluggableMap.prototype.getOverlays = function() {\n    return this.overlays_;\n  };\n  \n  \n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {ol.Overlay} Overlay.\n   * @api\n   */\n  ol.PluggableMap.prototype.getOverlayById = function(id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  };\n  \n  \n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {ol.Collection.<ol.interaction.Interaction>} Interactions.\n   * @api\n   */\n  ol.PluggableMap.prototype.getInteractions = function() {\n    return this.interactions;\n  };\n  \n  \n  /**\n   * Get the layergroup associated with this map.\n   * @return {ol.layer.Group} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  ol.PluggableMap.prototype.getLayerGroup = function() {\n    return /** @type {ol.layer.Group} */ (this.get(ol.MapProperty.LAYERGROUP));\n  };\n  \n  \n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!ol.Collection.<ol.layer.Base>} Layers.\n   * @api\n   */\n  ol.PluggableMap.prototype.getLayers = function() {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n  \n  \n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {ol.Coordinate} coordinate A map coordinate.\n   * @return {ol.Pixel} A pixel position in the map viewport.\n   * @api\n   */\n  ol.PluggableMap.prototype.getPixelFromCoordinate = function(coordinate) {\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return ol.transform.apply(frameState.coordinateToPixelTransform,\n          coordinate.slice(0, 2));\n    }\n  };\n  \n  \n  /**\n   * Get the map renderer.\n   * @return {ol.renderer.Map} Renderer\n   */\n  ol.PluggableMap.prototype.getRenderer = function() {\n    return this.renderer_;\n  };\n  \n  \n  /**\n   * Get the size of this map.\n   * @return {ol.Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  ol.PluggableMap.prototype.getSize = function() {\n    return /** @type {ol.Size|undefined} */ (this.get(ol.MapProperty.SIZE));\n  };\n  \n  \n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {ol.View} The view that controls this map.\n   * @observable\n   * @api\n   */\n  ol.PluggableMap.prototype.getView = function() {\n    return /** @type {ol.View} */ (this.get(ol.MapProperty.VIEW));\n  };\n  \n  \n  /**\n   * Get the element that serves as the map viewport.\n   * @return {Element} Viewport.\n   * @api\n   */\n  ol.PluggableMap.prototype.getViewport = function() {\n    return this.viewport_;\n  };\n  \n  \n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link ol.MapBrowserEvent}\n   * events.\n   * @return {!Element} The map's overlay container.\n   */\n  ol.PluggableMap.prototype.getOverlayContainer = function() {\n    return this.overlayContainer_;\n  };\n  \n  \n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link ol.MapBrowserEvent}.\n   * @return {!Element} The map's overlay container that stops events.\n   */\n  ol.PluggableMap.prototype.getOverlayContainerStopEvent = function() {\n    return this.overlayContainerStopEvent_;\n  };\n  \n  \n  /**\n   * @param {ol.Tile} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {ol.Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n  ol.PluggableMap.prototype.getTilePriority = function(tile, tileSourceKey, tileCenter, tileResolution) {\n    // Filter out tiles at higher zoom levels than the current zoom level, or that\n    // are outside the visible extent.\n    var frameState = this.frameState_;\n    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n      return ol.structs.PriorityQueue.DROP;\n    }\n    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n      return ol.structs.PriorityQueue.DROP;\n    }\n    // Prioritize the highest zoom level tiles closest to the focus.\n    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n    // Within a zoom level, tiles are prioritized by the distance in pixels\n    // between the center of the tile and the focus.  The factor of 65536 means\n    // that the prioritization should behave as desired for tiles up to\n    // 65536 * Math.log(2) = 45426 pixels from the focus.\n    var deltaX = tileCenter[0] - frameState.focus[0];\n    var deltaY = tileCenter[1] - frameState.focus[1];\n    return 65536 * Math.log(tileResolution) +\n        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n  };\n  \n  \n  /**\n   * @param {Event} browserEvent Browser event.\n   * @param {string=} opt_type Type.\n   */\n  ol.PluggableMap.prototype.handleBrowserEvent = function(browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new ol.MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n  ol.PluggableMap.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n    this.focus_ = mapBrowserEvent.coordinate;\n    mapBrowserEvent.frameState = this.frameState_;\n    var interactionsArray = this.getInteractions().getArray();\n    var i;\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      for (i = interactionsArray.length - 1; i >= 0; i--) {\n        var interaction = interactionsArray[i];\n        if (!interaction.getActive()) {\n          continue;\n        }\n        var cont = interaction.handleEvent(mapBrowserEvent);\n        if (!cont) {\n          break;\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.PluggableMap.prototype.handlePostRender = function() {\n  \n    var frameState = this.frameState_;\n  \n    // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n    var tileQueue = this.tileQueue_;\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = 16;\n      var maxNewLoads = maxTotalLoading;\n      if (frameState) {\n        var hints = frameState.viewHints;\n        if (hints[ol.ViewHint.ANIMATING]) {\n          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n        if (hints[ol.ViewHint.INTERACTING]) {\n          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n      }\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n  \n    var postRenderFunctions = this.postRenderFunctions_;\n    var i, ii;\n    for (i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n    postRenderFunctions.length = 0;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.PluggableMap.prototype.handleSizeChanged_ = function() {\n    this.render();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.PluggableMap.prototype.handleTargetChanged_ = function() {\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n  \n    var targetElement;\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n  \n    if (this.keyHandlerKeys_) {\n      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        ol.events.unlistenByKey(this.keyHandlerKeys_[i]);\n      }\n      this.keyHandlerKeys_ = null;\n    }\n  \n    if (!targetElement) {\n      this.renderer_.removeLayerRenderers();\n      ol.dom.removeNode(this.viewport_);\n      if (this.handleResize_ !== undefined) {\n        window.removeEventListener(ol.events.EventType.RESIZE,\n            this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n  \n      var keyboardEventTarget = !this.keyboardEventTarget_ ?\n        targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [\n        ol.events.listen(keyboardEventTarget, ol.events.EventType.KEYDOWN,\n            this.handleBrowserEvent, this),\n        ol.events.listen(keyboardEventTarget, ol.events.EventType.KEYPRESS,\n            this.handleBrowserEvent, this)\n      ];\n  \n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        window.addEventListener(ol.events.EventType.RESIZE,\n            this.handleResize_, false);\n      }\n    }\n  \n    this.updateSize();\n    // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.PluggableMap.prototype.handleTileChange_ = function() {\n    this.render();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.PluggableMap.prototype.handleViewPropertyChanged_ = function() {\n    this.render();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.PluggableMap.prototype.handleViewChanged_ = function() {\n    if (this.viewPropertyListenerKey_) {\n      ol.events.unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n    if (this.viewChangeListenerKey_) {\n      ol.events.unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n    var view = this.getView();\n    if (view) {\n      this.viewport_.setAttribute('data-view', ol.getUid(view));\n      this.viewPropertyListenerKey_ = ol.events.listen(\n          view, ol.ObjectEventType.PROPERTYCHANGE,\n          this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = ol.events.listen(\n          view, ol.events.EventType.CHANGE,\n          this.handleViewPropertyChanged_, this);\n    }\n    this.render();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.PluggableMap.prototype.handleLayerGroupChanged_ = function() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(ol.events.unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n    var layerGroup = this.getLayerGroup();\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [\n        ol.events.listen(\n            layerGroup, ol.ObjectEventType.PROPERTYCHANGE,\n            this.render, this),\n        ol.events.listen(\n            layerGroup, ol.events.EventType.CHANGE,\n            this.render, this)\n      ];\n    }\n    this.render();\n  };\n  \n  \n  /**\n   * @return {boolean} Is rendered.\n   */\n  ol.PluggableMap.prototype.isRendered = function() {\n    return !!this.frameState_;\n  };\n  \n  \n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n  ol.PluggableMap.prototype.renderSync = function() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n    this.animationDelay_();\n  };\n  \n  \n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n  ol.PluggableMap.prototype.render = function() {\n    if (this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(\n          this.animationDelay_);\n    }\n  };\n  \n  \n  /**\n   * Remove the given control from the map.\n   * @param {ol.control.Control} control Control.\n   * @return {ol.control.Control|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n  ol.PluggableMap.prototype.removeControl = function(control) {\n    return this.getControls().remove(control);\n  };\n  \n  \n  /**\n   * Remove the given interaction from the map.\n   * @param {ol.interaction.Interaction} interaction Interaction to remove.\n   * @return {ol.interaction.Interaction|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n  ol.PluggableMap.prototype.removeInteraction = function(interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n  \n  \n  /**\n   * Removes the given layer from the map.\n   * @param {ol.layer.Base} layer Layer.\n   * @return {ol.layer.Base|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n  ol.PluggableMap.prototype.removeLayer = function(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n  \n  \n  /**\n   * Remove the given overlay from the map.\n   * @param {ol.Overlay} overlay Overlay.\n   * @return {ol.Overlay|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n  ol.PluggableMap.prototype.removeOverlay = function(overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n  \n  \n  /**\n   * @param {number} time Time.\n   * @private\n   */\n  ol.PluggableMap.prototype.renderFrame_ = function(time) {\n    var i, ii, viewState;\n  \n    var size = this.getSize();\n    var view = this.getView();\n    var extent = ol.extent.createEmpty();\n    var previousFrameState = this.frameState_;\n    /** @type {?olx.FrameState} */\n    var frameState = null;\n    if (size !== undefined && ol.size.hasArea(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n      var layerStates = {};\n      for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n        layerStates[ol.getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\n      }\n      viewState = view.getState();\n      var center = viewState.center;\n      var pixelResolution = viewState.resolution / this.pixelRatio_;\n      center[0] = Math.round(center[0] / pixelResolution) * pixelResolution;\n      center[1] = Math.round(center[1] / pixelResolution) * pixelResolution;\n      frameState = /** @type {olx.FrameState} */ ({\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        extent: extent,\n        focus: !this.focus_ ? center : this.focus_,\n        index: this.frameIndex_++,\n        layerStates: layerStates,\n        layerStatesArray: layerStatesArray,\n        logos: ol.obj.assign({}, this.logos_),\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        skippedFeatureUids: this.skippedFeatureUids_,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      });\n    }\n  \n    if (frameState) {\n      frameState.extent = ol.extent.getForViewAndSize(viewState.center,\n          viewState.resolution, viewState.rotation, frameState.size, extent);\n    }\n  \n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n  \n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n      Array.prototype.push.apply(\n          this.postRenderFunctions_, frameState.postRenderFunctions);\n  \n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ ||\n                    (!ol.extent.isEmpty(this.previousExtent_) &&\n                    !ol.extent.equals(frameState.extent, this.previousExtent_));\n        if (moveStart) {\n          this.dispatchEvent(\n              new ol.MapEvent(ol.MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = ol.extent.createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n  \n      var idle = this.previousExtent_ &&\n          !frameState.viewHints[ol.ViewHint.ANIMATING] &&\n          !frameState.viewHints[ol.ViewHint.INTERACTING] &&\n          !ol.extent.equals(frameState.extent, this.previousExtent_);\n  \n      if (idle) {\n        this.dispatchEvent(\n            new ol.MapEvent(ol.MapEventType.MOVEEND, this, frameState));\n        ol.extent.clone(frameState.extent, this.previousExtent_);\n      }\n    }\n  \n    this.dispatchEvent(\n        new ol.MapEvent(ol.MapEventType.POSTRENDER, this, frameState));\n  \n    setTimeout(this.handlePostRender.bind(this), 0);\n  \n  };\n  \n  \n  /**\n   * Sets the layergroup of this map.\n   * @param {ol.layer.Group} layerGroup A layer group containing the layers in\n   *     this map.\n   * @observable\n   * @api\n   */\n  ol.PluggableMap.prototype.setLayerGroup = function(layerGroup) {\n    this.set(ol.MapProperty.LAYERGROUP, layerGroup);\n  };\n  \n  \n  /**\n   * Set the size of this map.\n   * @param {ol.Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  ol.PluggableMap.prototype.setSize = function(size) {\n    this.set(ol.MapProperty.SIZE, size);\n  };\n  \n  \n  /**\n   * Set the target element to render this map into.\n   * @param {Element|string|undefined} target The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n  ol.PluggableMap.prototype.setTarget = function(target) {\n    this.set(ol.MapProperty.TARGET, target);\n  };\n  \n  \n  /**\n   * Set the view for this map.\n   * @param {ol.View} view The view that controls this map.\n   * @observable\n   * @api\n   */\n  ol.PluggableMap.prototype.setView = function(view) {\n    this.set(ol.MapProperty.VIEW, view);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   */\n  ol.PluggableMap.prototype.skipFeature = function(feature) {\n    var featureUid = ol.getUid(feature).toString();\n    this.skippedFeatureUids_[featureUid] = true;\n    this.render();\n  };\n  \n  \n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n  ol.PluggableMap.prototype.updateSize = function() {\n    var targetElement = this.getTargetElement();\n  \n    if (!targetElement) {\n      this.setSize(undefined);\n    } else {\n      var computedStyle = getComputedStyle(targetElement);\n      this.setSize([\n        targetElement.offsetWidth -\n            parseFloat(computedStyle['borderLeftWidth']) -\n            parseFloat(computedStyle['paddingLeft']) -\n            parseFloat(computedStyle['paddingRight']) -\n            parseFloat(computedStyle['borderRightWidth']),\n        targetElement.offsetHeight -\n            parseFloat(computedStyle['borderTopWidth']) -\n            parseFloat(computedStyle['paddingTop']) -\n            parseFloat(computedStyle['paddingBottom']) -\n            parseFloat(computedStyle['borderBottomWidth'])\n      ]);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   */\n  ol.PluggableMap.prototype.unskipFeature = function(feature) {\n    var featureUid = ol.getUid(feature).toString();\n    delete this.skippedFeatureUids_[featureUid];\n    this.render();\n  };\n  \n  \n  /**\n   * @type {Array.<ol.renderer.Type>}\n   * @const\n   */\n  ol.PluggableMap.DEFAULT_RENDERER_TYPES = [\n    ol.renderer.Type.CANVAS,\n    ol.renderer.Type.WEBGL\n  ];\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.PluggableMap.LOGO_URL = 'data:image/png;base64,' +\n      'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBI' +\n      'WXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAA' +\n      'AhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszW' +\n      'WMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvY' +\n      'asvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvX' +\n      'H1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1Vk' +\n      'bMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW' +\n      '2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLP' +\n      'VcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqT' +\n      'acrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaar' +\n      'ldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+Hi' +\n      'zeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDn' +\n      'BAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSF' +\n      'hYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJ' +\n      'REFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxC' +\n      'Brb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe' +\n      '0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8' +\n      'a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7a' +\n      'hgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCn' +\n      'B3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDg' +\n      'q82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC';\n  \n  \n  /**\n   * @param {olx.MapOptions} options Map options.\n   * @return {ol.MapOptionsInternal} Internal map options.\n   */\n  ol.PluggableMap.createOptionsInternal = function(options) {\n  \n    /**\n     * @type {Element|Document}\n     */\n    var keyboardEventTarget = null;\n    if (options.keyboardEventTarget !== undefined) {\n      keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ?\n        document.getElementById(options.keyboardEventTarget) :\n        options.keyboardEventTarget;\n    }\n  \n    /**\n     * @type {Object.<string, *>}\n     */\n    var values = {};\n  \n    var logos = {};\n    if (options.logo === undefined ||\n        (typeof options.logo === 'boolean' && options.logo)) {\n      logos[ol.PluggableMap.LOGO_URL] = 'https://openlayers.org/';\n    } else {\n      var logo = options.logo;\n      if (typeof logo === 'string') {\n        logos[logo] = '';\n      } else if (logo instanceof HTMLElement) {\n        logos[ol.getUid(logo).toString()] = logo;\n      } else if (logo) {\n        ol.asserts.assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.\n        ol.asserts.assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.\n        logos[logo.src] = logo.href;\n      }\n    }\n  \n    var layerGroup = (options.layers instanceof ol.layer.Group) ?\n      options.layers : new ol.layer.Group({layers: options.layers});\n    values[ol.MapProperty.LAYERGROUP] = layerGroup;\n  \n    values[ol.MapProperty.TARGET] = options.target;\n  \n    values[ol.MapProperty.VIEW] = options.view !== undefined ?\n      options.view : new ol.View();\n  \n    /**\n     * @type {Array.<ol.renderer.Type>}\n     */\n    var rendererTypes;\n  \n    if (options.renderer !== undefined) {\n      if (Array.isArray(options.renderer)) {\n        rendererTypes = options.renderer;\n      } else if (typeof options.renderer === 'string') {\n        rendererTypes = [options.renderer];\n      } else {\n        ol.asserts.assert(false, 46); // Incorrect format for `renderer` option\n      }\n      if (rendererTypes.indexOf(/** @type {ol.renderer.Type} */ ('dom')) >= 0) {\n        rendererTypes = rendererTypes.concat(ol.PluggableMap.DEFAULT_RENDERER_TYPES);\n      }\n    } else {\n      rendererTypes = ol.PluggableMap.DEFAULT_RENDERER_TYPES;\n    }\n  \n    /**\n     * @type {olx.MapRendererPlugin}\n     */\n    var mapRendererPlugin;\n  \n    var mapRendererPlugins = ol.plugins.getMapRendererPlugins();\n    outer: for (var i = 0, ii = rendererTypes.length; i < ii; ++i) {\n      var rendererType = rendererTypes[i];\n      for (var j = 0, jj = mapRendererPlugins.length; j < jj; ++j) {\n        var candidate = mapRendererPlugins[j];\n        if (candidate['handles'](rendererType)) {\n          mapRendererPlugin = candidate;\n          break outer;\n        }\n      }\n    }\n  \n    if (!mapRendererPlugin) {\n      throw new Error('Unable to create a map renderer for types: ' +  rendererTypes.join(', '));\n    }\n  \n    var controls;\n    if (options.controls !== undefined) {\n      if (Array.isArray(options.controls)) {\n        controls = new ol.Collection(options.controls.slice());\n      } else {\n        ol.asserts.assert(options.controls instanceof ol.Collection,\n            47); // Expected `controls` to be an array or an `ol.Collection`\n        controls = options.controls;\n      }\n    }\n  \n    var interactions;\n    if (options.interactions !== undefined) {\n      if (Array.isArray(options.interactions)) {\n        interactions = new ol.Collection(options.interactions.slice());\n      } else {\n        ol.asserts.assert(options.interactions instanceof ol.Collection,\n            48); // Expected `interactions` to be an array or an `ol.Collection`\n        interactions = options.interactions;\n      }\n    }\n  \n    var overlays;\n    if (options.overlays !== undefined) {\n      if (Array.isArray(options.overlays)) {\n        overlays = new ol.Collection(options.overlays.slice());\n      } else {\n        ol.asserts.assert(options.overlays instanceof ol.Collection,\n            49); // Expected `overlays` to be an array or an `ol.Collection`\n        overlays = options.overlays;\n      }\n    } else {\n      overlays = new ol.Collection();\n    }\n  \n    return {\n      controls: controls,\n      interactions: interactions,\n      keyboardEventTarget: keyboardEventTarget,\n      logos: logos,\n      overlays: overlays,\n      mapRendererPlugin: mapRendererPlugin,\n      values: values\n    };\n  \n  };\n  \n  goog.provide('ol.control.Control');\n  \n  goog.require('ol');\n  goog.require('ol.MapEventType');\n  goog.require('ol.Object');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  \n  \n  /**\n   * @classdesc\n   * A control is a visible widget with a DOM element in a fixed position on the\n   * screen. They can involve user input (buttons), or be informational only;\n   * the position is determined using CSS. By default these are placed in the\n   * container with CSS class name `ol-overlaycontainer-stopevent`, but can use\n   * any outside DOM element.\n   *\n   * This is the base class for controls. You can use it for simple custom\n   * controls by creating the element with listeners, creating an instance:\n   * ```js\n   * var myControl = new ol.control.Control({element: myElement});\n   * ```\n   * and then adding this to the map.\n   *\n   * The main advantage of having this as a control rather than a simple separate\n   * DOM element is that preventing propagation is handled for you. Controls\n   * will also be `ol.Object`s in a `ol.Collection`, so you can use their\n   * methods.\n   *\n   * You can also extend this base for your own control class. See\n   * examples/custom-controls for an example of how to do this.\n   *\n   * @constructor\n   * @extends {ol.Object}\n   * @implements {oli.control.Control}\n   * @param {olx.control.ControlOptions} options Control options.\n   * @api\n   */\n  ol.control.Control = function(options) {\n  \n    ol.Object.call(this);\n  \n    /**\n     * @protected\n     * @type {Element}\n     */\n    this.element = options.element ? options.element : null;\n  \n    /**\n     * @private\n     * @type {Element}\n     */\n    this.target_ = null;\n  \n    /**\n     * @private\n     * @type {ol.PluggableMap}\n     */\n    this.map_ = null;\n  \n    /**\n     * @protected\n     * @type {!Array.<ol.EventsKey>}\n     */\n    this.listenerKeys = [];\n  \n    /**\n     * @type {function(ol.MapEvent)}\n     */\n    this.render = options.render ? options.render : ol.nullFunction;\n  \n    if (options.target) {\n      this.setTarget(options.target);\n    }\n  \n  };\n  ol.inherits(ol.control.Control, ol.Object);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.control.Control.prototype.disposeInternal = function() {\n    ol.dom.removeNode(this.element);\n    ol.Object.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * Get the map associated with this control.\n   * @return {ol.PluggableMap} Map.\n   * @api\n   */\n  ol.control.Control.prototype.getMap = function() {\n    return this.map_;\n  };\n  \n  \n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {ol.PluggableMap} map Map.\n   * @override\n   * @api\n   */\n  ol.control.Control.prototype.setMap = function(map) {\n    if (this.map_) {\n      ol.dom.removeNode(this.element);\n    }\n    for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {\n      ol.events.unlistenByKey(this.listenerKeys[i]);\n    }\n    this.listenerKeys.length = 0;\n    this.map_ = map;\n    if (this.map_) {\n      var target = this.target_ ?\n        this.target_ : map.getOverlayContainerStopEvent();\n      target.appendChild(this.element);\n      if (this.render !== ol.nullFunction) {\n        this.listenerKeys.push(ol.events.listen(map,\n            ol.MapEventType.POSTRENDER, this.render, this));\n      }\n      map.render();\n    }\n  };\n  \n  \n  /**\n   * This function is used to set a target element for the control. It has no\n   * effect if it is called after the control has been added to the map (i.e.\n   * after `setMap` is called on the control). If no `target` is set in the\n   * options passed to the control constructor and if `setTarget` is not called\n   * then the control is added to the map's overlay container.\n   * @param {Element|string} target Target.\n   * @api\n   */\n  ol.control.Control.prototype.setTarget = function(target) {\n    this.target_ = typeof target === 'string' ?\n      document.getElementById(target) :\n      target;\n  };\n  \n  goog.provide('ol.css');\n  \n  \n  /**\n   * The CSS class for hidden feature.\n   *\n   * @const\n   * @type {string}\n   */\n  ol.css.CLASS_HIDDEN = 'ol-hidden';\n  \n  \n  /**\n   * The CSS class that we'll give the DOM elements to have them selectable.\n   *\n   * @const\n   * @type {string}\n   */\n  ol.css.CLASS_SELECTABLE = 'ol-selectable';\n  \n  /**\n   * The CSS class that we'll give the DOM elements to have them unselectable.\n   *\n   * @const\n   * @type {string}\n   */\n  ol.css.CLASS_UNSELECTABLE = 'ol-unselectable';\n  \n  \n  /**\n   * The CSS class for unsupported feature.\n   *\n   * @const\n   * @type {string}\n   */\n  ol.css.CLASS_UNSUPPORTED = 'ol-unsupported';\n  \n  \n  /**\n   * The CSS class for controls.\n   *\n   * @const\n   * @type {string}\n   */\n  ol.css.CLASS_CONTROL = 'ol-control';\n  \n  \n  /**\n   * Get the list of font families from a font spec.  Note that this doesn't work\n   * for font families that have commas in them.\n   * @param {string} The CSS font property.\n   * @return {Object.<string>} The font families (or null if the input spec is invalid).\n   */\n  ol.css.getFontFamilies = (function() {\n    var style;\n    var cache = {};\n    return function(font) {\n      if (!style) {\n        style = document.createElement('div').style;\n      }\n      if (!(font in cache)) {\n        style.font = font;\n        var family = style.fontFamily;\n        style.font = '';\n        if (!family) {\n          return null;\n        }\n        cache[font] = family.split(/,\\s?/);\n      }\n      return cache[font];\n    };\n  })();\n  \n  goog.provide('ol.render.EventType');\n  \n  /**\n   * @enum {string}\n   */\n  ol.render.EventType = {\n    /**\n     * @event ol.render.Event#postcompose\n     * @api\n     */\n    POSTCOMPOSE: 'postcompose',\n    /**\n     * @event ol.render.Event#precompose\n     * @api\n     */\n    PRECOMPOSE: 'precompose',\n    /**\n     * @event ol.render.Event#render\n     * @api\n     */\n    RENDER: 'render'\n  };\n  \n  goog.provide('ol.layer.Layer');\n  \n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol');\n  goog.require('ol.Object');\n  goog.require('ol.layer.Base');\n  goog.require('ol.layer.Property');\n  goog.require('ol.obj');\n  goog.require('ol.render.EventType');\n  goog.require('ol.source.State');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * A visual representation of raster or vector map data.\n   * Layers group together those properties that pertain to how the data is to be\n   * displayed, irrespective of the source of that data.\n   *\n   * Layers are usually added to a map with {@link ol.Map#addLayer}. Components\n   * like {@link ol.interaction.Select} use unmanaged layers internally. These\n   * unmanaged layers are associated with the map using\n   * {@link ol.layer.Layer#setMap} instead.\n   *\n   * A generic `change` event is fired when the state of the source changes.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.layer.Base}\n   * @fires ol.render.Event\n   * @param {olx.layer.LayerOptions} options Layer options.\n   * @api\n   */\n  ol.layer.Layer = function(options) {\n  \n    var baseOptions = ol.obj.assign({}, options);\n    delete baseOptions.source;\n  \n    ol.layer.Base.call(this, /** @type {olx.layer.BaseOptions} */ (baseOptions));\n  \n    /**\n     * @private\n     * @type {?ol.EventsKey}\n     */\n    this.mapPrecomposeKey_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.EventsKey}\n     */\n    this.mapRenderKey_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.EventsKey}\n     */\n    this.sourceChangeKey_ = null;\n  \n    if (options.map) {\n      this.setMap(options.map);\n    }\n  \n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.layer.Property.SOURCE),\n        this.handleSourcePropertyChange_, this);\n  \n    var source = options.source ? options.source : null;\n    this.setSource(source);\n  };\n  ol.inherits(ol.layer.Layer, ol.layer.Base);\n  \n  \n  /**\n   * Return `true` if the layer is visible, and if the passed resolution is\n   * between the layer's minResolution and maxResolution. The comparison is\n   * inclusive for `minResolution` and exclusive for `maxResolution`.\n   * @param {ol.LayerState} layerState Layer state.\n   * @param {number} resolution Resolution.\n   * @return {boolean} The layer is visible at the given resolution.\n   */\n  ol.layer.Layer.visibleAtResolution = function(layerState, resolution) {\n    return layerState.visible && resolution >= layerState.minResolution &&\n        resolution < layerState.maxResolution;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.layer.Layer.prototype.getLayersArray = function(opt_array) {\n    var array = opt_array ? opt_array : [];\n    array.push(this);\n    return array;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.layer.Layer.prototype.getLayerStatesArray = function(opt_states) {\n    var states = opt_states ? opt_states : [];\n    states.push(this.getLayerState());\n    return states;\n  };\n  \n  \n  /**\n   * Get the layer source.\n   * @return {ol.source.Source} The layer source (or `null` if not yet set).\n   * @observable\n   * @api\n   */\n  ol.layer.Layer.prototype.getSource = function() {\n    var source = this.get(ol.layer.Property.SOURCE);\n    return /** @type {ol.source.Source} */ (source) || null;\n  };\n  \n  \n  /**\n    * @inheritDoc\n    */\n  ol.layer.Layer.prototype.getSourceState = function() {\n    var source = this.getSource();\n    return !source ? ol.source.State.UNDEFINED : source.getState();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.layer.Layer.prototype.handleSourceChange_ = function() {\n    this.changed();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.layer.Layer.prototype.handleSourcePropertyChange_ = function() {\n    if (this.sourceChangeKey_) {\n      ol.events.unlistenByKey(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n    var source = this.getSource();\n    if (source) {\n      this.sourceChangeKey_ = ol.events.listen(source,\n          ol.events.EventType.CHANGE, this.handleSourceChange_, this);\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * Sets the layer to be rendered on top of other layers on a map. The map will\n   * not manage this layer in its layers collection, and the callback in\n   * {@link ol.Map#forEachLayerAtPixel} will receive `null` as layer. This\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\n   * use `#setMap(null)`.\n   *\n   * To add the layer to a map and have it managed by the map, use\n   * {@link ol.Map#addLayer} instead.\n   * @param {ol.PluggableMap} map Map.\n   * @api\n   */\n  ol.layer.Layer.prototype.setMap = function(map) {\n    if (this.mapPrecomposeKey_) {\n      ol.events.unlistenByKey(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n    if (!map) {\n      this.changed();\n    }\n    if (this.mapRenderKey_) {\n      ol.events.unlistenByKey(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n    if (map) {\n      this.mapPrecomposeKey_ = ol.events.listen(\n          map, ol.render.EventType.PRECOMPOSE, function(evt) {\n            var layerState = this.getLayerState();\n            layerState.managed = false;\n            layerState.zIndex = Infinity;\n            evt.frameState.layerStatesArray.push(layerState);\n            evt.frameState.layerStates[ol.getUid(this)] = layerState;\n          }, this);\n      this.mapRenderKey_ = ol.events.listen(\n          this, ol.events.EventType.CHANGE, map.render, map);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * Set the layer source.\n   * @param {ol.source.Source} source The layer source.\n   * @observable\n   * @api\n   */\n  ol.layer.Layer.prototype.setSource = function(source) {\n    this.set(ol.layer.Property.SOURCE, source);\n  };\n  \n  // FIXME handle date line wrap\n  \n  goog.provide('ol.control.Attribution');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.control.Control');\n  goog.require('ol.css');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.layer.Layer');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * @classdesc\n   * Control to show all the attributions associated with the layer sources\n   * in the map. This control is one of the default controls included in maps.\n   * By default it will show in the bottom right portion of the map, but this can\n   * be changed by using a css selector for `.ol-attribution`.\n   *\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.AttributionOptions=} opt_options Attribution options.\n   * @api\n   */\n  ol.control.Attribution = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {Element}\n     */\n    this.ulElement_ = document.createElement('UL');\n  \n    /**\n     * @private\n     * @type {Element}\n     */\n    this.logoLi_ = document.createElement('LI');\n  \n    this.ulElement_.appendChild(this.logoLi_);\n    this.logoLi_.style.display = 'none';\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.collapsible_ = options.collapsible !== undefined ?\n      options.collapsible : true;\n  \n    if (!this.collapsible_) {\n      this.collapsed_ = false;\n    }\n  \n    var className = options.className !== undefined ? options.className : 'ol-attribution';\n  \n    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';\n  \n    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\\u00BB';\n  \n    if (typeof collapseLabel === 'string') {\n      /**\n       * @private\n       * @type {Node}\n       */\n      this.collapseLabel_ = document.createElement('span');\n      this.collapseLabel_.textContent = collapseLabel;\n    } else {\n      this.collapseLabel_ = collapseLabel;\n    }\n  \n    var label = options.label !== undefined ? options.label : 'i';\n  \n    if (typeof label === 'string') {\n      /**\n       * @private\n       * @type {Node}\n       */\n      this.label_ = document.createElement('span');\n      this.label_.textContent = label;\n    } else {\n      this.label_ = label;\n    }\n  \n  \n    var activeLabel = (this.collapsible_ && !this.collapsed_) ?\n      this.collapseLabel_ : this.label_;\n    var button = document.createElement('button');\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(activeLabel);\n  \n    ol.events.listen(button, ol.events.EventType.CLICK, this.handleClick_, this);\n  \n    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +\n        ol.css.CLASS_CONTROL +\n        (this.collapsed_ && this.collapsible_ ? ' ol-collapsed' : '') +\n        (this.collapsible_ ? '' : ' ol-uncollapsible');\n    var element = document.createElement('div');\n    element.className = cssClasses;\n    element.appendChild(this.ulElement_);\n    element.appendChild(button);\n  \n    var render = options.render ? options.render : ol.control.Attribution.render;\n  \n    ol.control.Control.call(this, {\n      element: element,\n      render: render,\n      target: options.target\n    });\n  \n    /**\n     * A list of currently rendered resolutions.\n     * @type {Array.<string>}\n     * @private\n     */\n    this.renderedAttributions_ = [];\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n  \n    /**\n     * @private\n     * @type {Object.<string, Element>}\n     */\n    this.logoElements_ = {};\n  \n  };\n  ol.inherits(ol.control.Attribution, ol.control.Control);\n  \n  \n  /**\n   * Get a list of visible attributions.\n   * @param {olx.FrameState} frameState Frame state.\n   * @return {Array.<string>} Attributions.\n   * @private\n   */\n  ol.control.Attribution.prototype.getSourceAttributions_ = function(frameState) {\n    /**\n     * Used to determine if an attribution already exists.\n     * @type {Object.<string, boolean>}\n     */\n    var lookup = {};\n  \n    /**\n     * A list of visible attributions.\n     * @type {Array.<string>}\n     */\n    var visibleAttributions = [];\n  \n    var layerStatesArray = frameState.layerStatesArray;\n    var resolution = frameState.viewState.resolution;\n    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      var layerState = layerStatesArray[i];\n      if (!ol.layer.Layer.visibleAtResolution(layerState, resolution)) {\n        continue;\n      }\n  \n      var source = layerState.layer.getSource();\n      if (!source) {\n        continue;\n      }\n  \n      var attributionGetter = source.getAttributions2();\n      if (!attributionGetter) {\n        continue;\n      }\n  \n      var attributions = attributionGetter(frameState);\n      if (!attributions) {\n        continue;\n      }\n  \n      if (Array.isArray(attributions)) {\n        for (var j = 0, jj = attributions.length; j < jj; ++j) {\n          if (!(attributions[j] in lookup)) {\n            visibleAttributions.push(attributions[j]);\n            lookup[attributions[j]] = true;\n          }\n        }\n      } else {\n        if (!(attributions in lookup)) {\n          visibleAttributions.push(attributions);\n          lookup[attributions] = true;\n        }\n      }\n    }\n    return visibleAttributions;\n  };\n  \n  \n  /**\n   * Update the attribution element.\n   * @param {ol.MapEvent} mapEvent Map event.\n   * @this {ol.control.Attribution}\n   * @api\n   */\n  ol.control.Attribution.render = function(mapEvent) {\n    this.updateElement_(mapEvent.frameState);\n  };\n  \n  \n  /**\n   * @private\n   * @param {?olx.FrameState} frameState Frame state.\n   */\n  ol.control.Attribution.prototype.updateElement_ = function(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n  \n    var attributions = this.getSourceAttributions_(frameState);\n    if (ol.array.equals(attributions, this.renderedAttributions_)) {\n      return;\n    }\n  \n    // remove everything but the logo\n    while (this.ulElement_.lastChild !== this.logoLi_) {\n      this.ulElement_.removeChild(this.ulElement_.lastChild);\n    }\n  \n    // append the attributions\n    for (var i = 0, ii = attributions.length; i < ii; ++i) {\n      var element = document.createElement('LI');\n      element.innerHTML = attributions[i];\n      this.ulElement_.appendChild(element);\n    }\n  \n  \n    if (attributions.length === 0 && this.renderedAttributions_.length > 0) {\n      this.element.classList.add('ol-logo-only');\n    } else if (this.renderedAttributions_.length === 0 && attributions.length > 0) {\n      this.element.classList.remove('ol-logo-only');\n    }\n  \n    var visible = attributions.length > 0 || !ol.obj.isEmpty(frameState.logos);\n    if (this.renderedVisible_ != visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.renderedVisible_ = visible;\n    }\n  \n    this.renderedAttributions_ = attributions;\n    this.insertLogos_(frameState);\n  };\n  \n  \n  /**\n   * @param {?olx.FrameState} frameState Frame state.\n   * @private\n   */\n  ol.control.Attribution.prototype.insertLogos_ = function(frameState) {\n  \n    var logo;\n    var logos = frameState.logos;\n    var logoElements = this.logoElements_;\n  \n    for (logo in logoElements) {\n      if (!(logo in logos)) {\n        ol.dom.removeNode(logoElements[logo]);\n        delete logoElements[logo];\n      }\n    }\n  \n    var image, logoElement, logoKey;\n    for (logoKey in logos) {\n      var logoValue = logos[logoKey];\n      if (logoValue instanceof HTMLElement) {\n        this.logoLi_.appendChild(logoValue);\n        logoElements[logoKey] = logoValue;\n      }\n      if (!(logoKey in logoElements)) {\n        image = new Image();\n        image.src = logoKey;\n        if (logoValue === '') {\n          logoElement = image;\n        } else {\n          logoElement = document.createElement('a');\n          logoElement.href = logoValue;\n          logoElement.appendChild(image);\n        }\n        this.logoLi_.appendChild(logoElement);\n        logoElements[logoKey] = logoElement;\n      }\n    }\n  \n    this.logoLi_.style.display = !ol.obj.isEmpty(logos) ? '' : 'none';\n  \n  };\n  \n  \n  /**\n   * @param {Event} event The event to handle\n   * @private\n   */\n  ol.control.Attribution.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    this.handleToggle_();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.control.Attribution.prototype.handleToggle_ = function() {\n    this.element.classList.toggle('ol-collapsed');\n    if (this.collapsed_) {\n      ol.dom.replaceNode(this.collapseLabel_, this.label_);\n    } else {\n      ol.dom.replaceNode(this.label_, this.collapseLabel_);\n    }\n    this.collapsed_ = !this.collapsed_;\n  };\n  \n  \n  /**\n   * Return `true` if the attribution is collapsible, `false` otherwise.\n   * @return {boolean} True if the widget is collapsible.\n   * @api\n   */\n  ol.control.Attribution.prototype.getCollapsible = function() {\n    return this.collapsible_;\n  };\n  \n  \n  /**\n   * Set whether the attribution should be collapsible.\n   * @param {boolean} collapsible True if the widget is collapsible.\n   * @api\n   */\n  ol.control.Attribution.prototype.setCollapsible = function(collapsible) {\n    if (this.collapsible_ === collapsible) {\n      return;\n    }\n    this.collapsible_ = collapsible;\n    this.element.classList.toggle('ol-uncollapsible');\n    if (!collapsible && this.collapsed_) {\n      this.handleToggle_();\n    }\n  };\n  \n  \n  /**\n   * Collapse or expand the attribution according to the passed parameter. Will\n   * not do anything if the attribution isn't collapsible or if the current\n   * collapsed state is already the one requested.\n   * @param {boolean} collapsed True if the widget is collapsed.\n   * @api\n   */\n  ol.control.Attribution.prototype.setCollapsed = function(collapsed) {\n    if (!this.collapsible_ || this.collapsed_ === collapsed) {\n      return;\n    }\n    this.handleToggle_();\n  };\n  \n  \n  /**\n   * Return `true` when the attribution is currently collapsed or `false`\n   * otherwise.\n   * @return {boolean} True if the widget is collapsed.\n   * @api\n   */\n  ol.control.Attribution.prototype.getCollapsed = function() {\n    return this.collapsed_;\n  };\n  \n  goog.provide('ol.control.Rotate');\n  \n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol');\n  goog.require('ol.control.Control');\n  goog.require('ol.css');\n  goog.require('ol.easing');\n  \n  \n  /**\n   * @classdesc\n   * A button control to reset rotation to 0.\n   * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css\n   * selector is added to the button when the rotation is 0.\n   *\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.RotateOptions=} opt_options Rotate options.\n   * @api\n   */\n  ol.control.Rotate = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    var className = options.className !== undefined ? options.className : 'ol-rotate';\n  \n    var label = options.label !== undefined ? options.label : '\\u21E7';\n  \n    /**\n     * @type {Element}\n     * @private\n     */\n    this.label_ = null;\n  \n    if (typeof label === 'string') {\n      this.label_ = document.createElement('span');\n      this.label_.className = 'ol-compass';\n      this.label_.textContent = label;\n    } else {\n      this.label_ = label;\n      this.label_.classList.add('ol-compass');\n    }\n  \n    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';\n  \n    var button = document.createElement('button');\n    button.className = className + '-reset';\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(this.label_);\n  \n    ol.events.listen(button, ol.events.EventType.CLICK,\n        ol.control.Rotate.prototype.handleClick_, this);\n  \n    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +\n        ol.css.CLASS_CONTROL;\n    var element = document.createElement('div');\n    element.className = cssClasses;\n    element.appendChild(button);\n  \n    var render = options.render ? options.render : ol.control.Rotate.render;\n  \n    this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;\n  \n    ol.control.Control.call(this, {\n      element: element,\n      render: render,\n      target: options.target\n    });\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.rotation_ = undefined;\n  \n    if (this.autoHide_) {\n      this.element.classList.add(ol.css.CLASS_HIDDEN);\n    }\n  \n  };\n  ol.inherits(ol.control.Rotate, ol.control.Control);\n  \n  \n  /**\n   * @param {Event} event The event to handle\n   * @private\n   */\n  ol.control.Rotate.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    if (this.callResetNorth_ !== undefined) {\n      this.callResetNorth_();\n    } else {\n      this.resetNorth_();\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.control.Rotate.prototype.resetNorth_ = function() {\n    var map = this.getMap();\n    var view = map.getView();\n    if (!view) {\n      // the map does not have a view, so we can't act\n      // upon it\n      return;\n    }\n    if (view.getRotation() !== undefined) {\n      if (this.duration_ > 0) {\n        view.animate({\n          rotation: 0,\n          duration: this.duration_,\n          easing: ol.easing.easeOut\n        });\n      } else {\n        view.setRotation(0);\n      }\n    }\n  };\n  \n  \n  /**\n   * Update the rotate control element.\n   * @param {ol.MapEvent} mapEvent Map event.\n   * @this {ol.control.Rotate}\n   * @api\n   */\n  ol.control.Rotate.render = function(mapEvent) {\n    var frameState = mapEvent.frameState;\n    if (!frameState) {\n      return;\n    }\n    var rotation = frameState.viewState.rotation;\n    if (rotation != this.rotation_) {\n      var transform = 'rotate(' + rotation + 'rad)';\n      if (this.autoHide_) {\n        var contains = this.element.classList.contains(ol.css.CLASS_HIDDEN);\n        if (!contains && rotation === 0) {\n          this.element.classList.add(ol.css.CLASS_HIDDEN);\n        } else if (contains && rotation !== 0) {\n          this.element.classList.remove(ol.css.CLASS_HIDDEN);\n        }\n      }\n      this.label_.style.msTransform = transform;\n      this.label_.style.webkitTransform = transform;\n      this.label_.style.transform = transform;\n    }\n    this.rotation_ = rotation;\n  };\n  \n  goog.provide('ol.control.Zoom');\n  \n  goog.require('ol');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.control.Control');\n  goog.require('ol.css');\n  goog.require('ol.easing');\n  \n  \n  /**\n   * @classdesc\n   * A control with 2 buttons, one for zoom in and one for zoom out.\n   * This control is one of the default controls of a map. To style this control\n   * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.\n   *\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.ZoomOptions=} opt_options Zoom options.\n   * @api\n   */\n  ol.control.Zoom = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    var className = options.className !== undefined ? options.className : 'ol-zoom';\n  \n    var delta = options.delta !== undefined ? options.delta : 1;\n  \n    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';\n    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\\u2212';\n  \n    var zoomInTipLabel = options.zoomInTipLabel !== undefined ?\n      options.zoomInTipLabel : 'Zoom in';\n    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ?\n      options.zoomOutTipLabel : 'Zoom out';\n  \n    var inElement = document.createElement('button');\n    inElement.className = className + '-in';\n    inElement.setAttribute('type', 'button');\n    inElement.title = zoomInTipLabel;\n    inElement.appendChild(\n        typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel\n    );\n  \n    ol.events.listen(inElement, ol.events.EventType.CLICK,\n        ol.control.Zoom.prototype.handleClick_.bind(this, delta));\n  \n    var outElement = document.createElement('button');\n    outElement.className = className + '-out';\n    outElement.setAttribute('type', 'button');\n    outElement.title = zoomOutTipLabel;\n    outElement.appendChild(\n        typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel\n    );\n  \n    ol.events.listen(outElement, ol.events.EventType.CLICK,\n        ol.control.Zoom.prototype.handleClick_.bind(this, -delta));\n  \n    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +\n        ol.css.CLASS_CONTROL;\n    var element = document.createElement('div');\n    element.className = cssClasses;\n    element.appendChild(inElement);\n    element.appendChild(outElement);\n  \n    ol.control.Control.call(this, {\n      element: element,\n      target: options.target\n    });\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  \n  };\n  ol.inherits(ol.control.Zoom, ol.control.Control);\n  \n  \n  /**\n   * @param {number} delta Zoom delta.\n   * @param {Event} event The event to handle\n   * @private\n   */\n  ol.control.Zoom.prototype.handleClick_ = function(delta, event) {\n    event.preventDefault();\n    this.zoomByDelta_(delta);\n  };\n  \n  \n  /**\n   * @param {number} delta Zoom delta.\n   * @private\n   */\n  ol.control.Zoom.prototype.zoomByDelta_ = function(delta) {\n    var map = this.getMap();\n    var view = map.getView();\n    if (!view) {\n      // the map does not have a view, so we can't act\n      // upon it\n      return;\n    }\n    var currentResolution = view.getResolution();\n    if (currentResolution) {\n      var newResolution = view.constrainResolution(currentResolution, delta);\n      if (this.duration_ > 0) {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.animate({\n          resolution: newResolution,\n          duration: this.duration_,\n          easing: ol.easing.easeOut\n        });\n      } else {\n        view.setResolution(newResolution);\n      }\n    }\n  };\n  \n  goog.provide('ol.control');\n  \n  goog.require('ol.Collection');\n  goog.require('ol.control.Attribution');\n  goog.require('ol.control.Rotate');\n  goog.require('ol.control.Zoom');\n  \n  \n  /**\n   * Set of controls included in maps by default. Unless configured otherwise,\n   * this returns a collection containing an instance of each of the following\n   * controls:\n   * * {@link ol.control.Zoom}\n   * * {@link ol.control.Rotate}\n   * * {@link ol.control.Attribution}\n   *\n   * @param {olx.control.DefaultsOptions=} opt_options Defaults options.\n   * @return {ol.Collection.<ol.control.Control>} Controls.\n   * @api\n   */\n  ol.control.defaults = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    var controls = new ol.Collection();\n  \n    var zoomControl = options.zoom !== undefined ? options.zoom : true;\n    if (zoomControl) {\n      controls.push(new ol.control.Zoom(options.zoomOptions));\n    }\n  \n    var rotateControl = options.rotate !== undefined ? options.rotate : true;\n    if (rotateControl) {\n      controls.push(new ol.control.Rotate(options.rotateOptions));\n    }\n  \n    var attributionControl = options.attribution !== undefined ?\n      options.attribution : true;\n    if (attributionControl) {\n      controls.push(new ol.control.Attribution(options.attributionOptions));\n    }\n  \n    return controls;\n  \n  };\n  \n  goog.provide('ol.Kinetic');\n  \n  \n  /**\n   * @classdesc\n   * Implementation of inertial deceleration for map movement.\n   *\n   * @constructor\n   * @param {number} decay Rate of decay (must be negative).\n   * @param {number} minVelocity Minimum velocity (pixels/millisecond).\n   * @param {number} delay Delay to consider to calculate the kinetic\n   *     initial values (milliseconds).\n   * @struct\n   * @api\n   */\n  ol.Kinetic = function(decay, minVelocity, delay) {\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.decay_ = decay;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.minVelocity_ = minVelocity;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.delay_ = delay;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.points_ = [];\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.initialVelocity_ = 0;\n  };\n  \n  \n  /**\n   * FIXME empty description for jsdoc\n   */\n  ol.Kinetic.prototype.begin = function() {\n    this.points_.length = 0;\n    this.angle_ = 0;\n    this.initialVelocity_ = 0;\n  };\n  \n  \n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   */\n  ol.Kinetic.prototype.update = function(x, y) {\n    this.points_.push(x, y, Date.now());\n  };\n  \n  \n  /**\n   * @return {boolean} Whether we should do kinetic animation.\n   */\n  ol.Kinetic.prototype.end = function() {\n    if (this.points_.length < 6) {\n      // at least 2 points are required (i.e. there must be at least 6 elements\n      // in the array)\n      return false;\n    }\n    var delay = Date.now() - this.delay_;\n    var lastIndex = this.points_.length - 3;\n    if (this.points_[lastIndex + 2] < delay) {\n      // the last tracked point is too old, which means that the user stopped\n      // panning before releasing the map\n      return false;\n    }\n  \n    // get the first point which still falls into the delay time\n    var firstIndex = lastIndex - 3;\n    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {\n      firstIndex -= 3;\n    }\n  \n    var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];\n    // we don't want a duration of 0 (divide by zero)\n    // we also make sure the user panned for a duration of at least one frame\n    // (1/60s) to compute sane displacement values\n    if (duration < 1000 / 60) {\n      return false;\n    }\n  \n    var dx = this.points_[lastIndex] - this.points_[firstIndex];\n    var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];\n    this.angle_ = Math.atan2(dy, dx);\n    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;\n    return this.initialVelocity_ > this.minVelocity_;\n  };\n  \n  \n  /**\n   * @return {number} Total distance travelled (pixels).\n   */\n  ol.Kinetic.prototype.getDistance = function() {\n    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;\n  };\n  \n  \n  /**\n   * @return {number} Angle of the kinetic panning animation (radians).\n   */\n  ol.Kinetic.prototype.getAngle = function() {\n    return this.angle_;\n  };\n  \n  goog.provide('ol.interaction.Property');\n  \n  /**\n   * @enum {string}\n   */\n  ol.interaction.Property = {\n    ACTIVE: 'active'\n  };\n  \n  // FIXME factor out key precondition (shift et. al)\n  \n  goog.provide('ol.interaction.Interaction');\n  \n  goog.require('ol');\n  goog.require('ol.Object');\n  goog.require('ol.easing');\n  goog.require('ol.interaction.Property');\n  goog.require('ol.math');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * User actions that change the state of the map. Some are similar to controls,\n   * but are not associated with a DOM element.\n   * For example, {@link ol.interaction.KeyboardZoom} is functionally the same as\n   * {@link ol.control.Zoom}, but triggered by a keyboard event not a button\n   * element event.\n   * Although interactions do not have a DOM element, some of them do render\n   * vectors and so are visible on the screen.\n   *\n   * @constructor\n   * @param {olx.interaction.InteractionOptions} options Options.\n   * @extends {ol.Object}\n   * @api\n   */\n  ol.interaction.Interaction = function(options) {\n  \n    ol.Object.call(this);\n  \n    /**\n     * @private\n     * @type {ol.PluggableMap}\n     */\n    this.map_ = null;\n  \n    this.setActive(true);\n  \n    /**\n     * @type {function(ol.MapBrowserEvent):boolean}\n     */\n    this.handleEvent = options.handleEvent;\n  \n  };\n  ol.inherits(ol.interaction.Interaction, ol.Object);\n  \n  \n  /**\n   * Return whether the interaction is currently active.\n   * @return {boolean} `true` if the interaction is active, `false` otherwise.\n   * @observable\n   * @api\n   */\n  ol.interaction.Interaction.prototype.getActive = function() {\n    return /** @type {boolean} */ (\n      this.get(ol.interaction.Property.ACTIVE));\n  };\n  \n  \n  /**\n   * Get the map associated with this interaction.\n   * @return {ol.PluggableMap} Map.\n   * @api\n   */\n  ol.interaction.Interaction.prototype.getMap = function() {\n    return this.map_;\n  };\n  \n  \n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  ol.interaction.Interaction.prototype.setActive = function(active) {\n    this.set(ol.interaction.Property.ACTIVE, active);\n  };\n  \n  \n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {ol.PluggableMap} map Map.\n   */\n  ol.interaction.Interaction.prototype.setMap = function(map) {\n    this.map_ = map;\n  };\n  \n  \n  /**\n   * @param {ol.View} view View.\n   * @param {ol.Coordinate} delta Delta.\n   * @param {number=} opt_duration Duration.\n   */\n  ol.interaction.Interaction.pan = function(view, delta, opt_duration) {\n    var currentCenter = view.getCenter();\n    if (currentCenter) {\n      var center = view.constrainCenter(\n          [currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);\n      if (opt_duration) {\n        view.animate({\n          duration: opt_duration,\n          easing: ol.easing.linear,\n          center: center\n        });\n      } else {\n        view.setCenter(center);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.View} view View.\n   * @param {number|undefined} rotation Rotation.\n   * @param {ol.Coordinate=} opt_anchor Anchor coordinate.\n   * @param {number=} opt_duration Duration.\n   */\n  ol.interaction.Interaction.rotate = function(view, rotation, opt_anchor, opt_duration) {\n    rotation = view.constrainRotation(rotation, 0);\n    ol.interaction.Interaction.rotateWithoutConstraints(\n        view, rotation, opt_anchor, opt_duration);\n  };\n  \n  \n  /**\n   * @param {ol.View} view View.\n   * @param {number|undefined} rotation Rotation.\n   * @param {ol.Coordinate=} opt_anchor Anchor coordinate.\n   * @param {number=} opt_duration Duration.\n   */\n  ol.interaction.Interaction.rotateWithoutConstraints = function(view, rotation, opt_anchor, opt_duration) {\n    if (rotation !== undefined) {\n      var currentRotation = view.getRotation();\n      var currentCenter = view.getCenter();\n      if (currentRotation !== undefined && currentCenter && opt_duration > 0) {\n        view.animate({\n          rotation: rotation,\n          anchor: opt_anchor,\n          duration: opt_duration,\n          easing: ol.easing.easeOut\n        });\n      } else {\n        view.rotate(rotation, opt_anchor);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.View} view View.\n   * @param {number|undefined} resolution Resolution to go to.\n   * @param {ol.Coordinate=} opt_anchor Anchor coordinate.\n   * @param {number=} opt_duration Duration.\n   * @param {number=} opt_direction Zooming direction; > 0 indicates\n   *     zooming out, in which case the constraints system will select\n   *     the largest nearest resolution; < 0 indicates zooming in, in\n   *     which case the constraints system will select the smallest\n   *     nearest resolution; == 0 indicates that the zooming direction\n   *     is unknown/not relevant, in which case the constraints system\n   *     will select the nearest resolution. If not defined 0 is\n   *     assumed.\n   */\n  ol.interaction.Interaction.zoom = function(view, resolution, opt_anchor, opt_duration, opt_direction) {\n    resolution = view.constrainResolution(resolution, 0, opt_direction);\n    ol.interaction.Interaction.zoomWithoutConstraints(\n        view, resolution, opt_anchor, opt_duration);\n  };\n  \n  \n  /**\n   * @param {ol.View} view View.\n   * @param {number} delta Delta from previous zoom level.\n   * @param {ol.Coordinate=} opt_anchor Anchor coordinate.\n   * @param {number=} opt_duration Duration.\n   */\n  ol.interaction.Interaction.zoomByDelta = function(view, delta, opt_anchor, opt_duration) {\n    var currentResolution = view.getResolution();\n    var resolution = view.constrainResolution(currentResolution, delta, 0);\n  \n    if (resolution !== undefined) {\n      var resolutions = view.getResolutions();\n      resolution = ol.math.clamp(\n          resolution,\n          view.getMinResolution() || resolutions[resolutions.length - 1],\n          view.getMaxResolution() || resolutions[0]);\n    }\n  \n    // If we have a constraint on center, we need to change the anchor so that the\n    // new center is within the extent. We first calculate the new center, apply\n    // the constraint to it, and then calculate back the anchor\n    if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {\n      var currentCenter = view.getCenter();\n      var center = view.calculateCenterZoom(resolution, opt_anchor);\n      center = view.constrainCenter(center);\n  \n      opt_anchor = [\n        (resolution * currentCenter[0] - currentResolution * center[0]) /\n            (resolution - currentResolution),\n        (resolution * currentCenter[1] - currentResolution * center[1]) /\n            (resolution - currentResolution)\n      ];\n    }\n  \n    ol.interaction.Interaction.zoomWithoutConstraints(\n        view, resolution, opt_anchor, opt_duration);\n  };\n  \n  \n  /**\n   * @param {ol.View} view View.\n   * @param {number|undefined} resolution Resolution to go to.\n   * @param {ol.Coordinate=} opt_anchor Anchor coordinate.\n   * @param {number=} opt_duration Duration.\n   */\n  ol.interaction.Interaction.zoomWithoutConstraints = function(view, resolution, opt_anchor, opt_duration) {\n    if (resolution) {\n      var currentResolution = view.getResolution();\n      var currentCenter = view.getCenter();\n      if (currentResolution !== undefined && currentCenter &&\n          resolution !== currentResolution && opt_duration) {\n        view.animate({\n          resolution: resolution,\n          anchor: opt_anchor,\n          duration: opt_duration,\n          easing: ol.easing.easeOut\n        });\n      } else {\n        if (opt_anchor) {\n          var center = view.calculateCenterZoom(resolution, opt_anchor);\n          view.setCenter(center);\n        }\n        view.setResolution(resolution);\n      }\n    }\n  };\n  \n  goog.provide('ol.interaction.DoubleClickZoom');\n  \n  goog.require('ol');\n  goog.require('ol.MapBrowserEventType');\n  goog.require('ol.interaction.Interaction');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to zoom by double-clicking on the map.\n   *\n   * @constructor\n   * @extends {ol.interaction.Interaction}\n   * @param {olx.interaction.DoubleClickZoomOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.DoubleClickZoom = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n  \n    ol.interaction.Interaction.call(this, {\n      handleEvent: ol.interaction.DoubleClickZoom.handleEvent\n    });\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  \n  };\n  ol.inherits(ol.interaction.DoubleClickZoom, ol.interaction.Interaction);\n  \n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a\n   * doubleclick) and eventually zooms the map.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {ol.interaction.DoubleClickZoom}\n   * @api\n   */\n  ol.interaction.DoubleClickZoom.handleEvent = function(mapBrowserEvent) {\n    var stopEvent = false;\n    var browserEvent = mapBrowserEvent.originalEvent;\n    if (mapBrowserEvent.type == ol.MapBrowserEventType.DBLCLICK) {\n      var map = mapBrowserEvent.map;\n      var anchor = mapBrowserEvent.coordinate;\n      var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n      var view = map.getView();\n      ol.interaction.Interaction.zoomByDelta(\n          view, delta, anchor, this.duration_);\n      mapBrowserEvent.preventDefault();\n      stopEvent = true;\n    }\n    return !stopEvent;\n  };\n  \n  goog.provide('ol.events.condition');\n  \n  goog.require('ol.MapBrowserEventType');\n  goog.require('ol.asserts');\n  goog.require('ol.functions');\n  goog.require('ol.has');\n  \n  \n  /**\n   * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\n   * additionally the shift-key is pressed).\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if only the alt key is pressed.\n   * @api\n   */\n  ol.events.condition.altKeyOnly = function(mapBrowserEvent) {\n    var originalEvent = mapBrowserEvent.originalEvent;\n    return (\n      originalEvent.altKey &&\n        !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n        !originalEvent.shiftKey);\n  };\n  \n  \n  /**\n   * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\n   * (e.g. when additionally the platform-modifier-key is pressed).\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if only the alt and shift keys are pressed.\n   * @api\n   */\n  ol.events.condition.altShiftKeysOnly = function(mapBrowserEvent) {\n    var originalEvent = mapBrowserEvent.originalEvent;\n    return (\n      originalEvent.altKey &&\n        !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n        originalEvent.shiftKey);\n  };\n  \n  \n  /**\n   * Return always true.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True.\n   * @function\n   * @api\n   */\n  ol.events.condition.always = ol.functions.TRUE;\n  \n  \n  /**\n   * Return `true` if the event is a `click` event, `false` otherwise.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if the event is a map `click` event.\n   * @api\n   */\n  ol.events.condition.click = function(mapBrowserEvent) {\n    return mapBrowserEvent.type == ol.MapBrowserEventType.CLICK;\n  };\n  \n  \n  /**\n   * Return `true` if the event has an \"action\"-producing mouse button.\n   *\n   * By definition, this includes left-click on windows/linux, and left-click\n   * without the ctrl key on Macs.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} The result.\n   */\n  ol.events.condition.mouseActionButton = function(mapBrowserEvent) {\n    var originalEvent = mapBrowserEvent.originalEvent;\n    return originalEvent.button == 0 &&\n        !(ol.has.WEBKIT && ol.has.MAC && originalEvent.ctrlKey);\n  };\n  \n  \n  /**\n   * Return always false.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} False.\n   * @function\n   * @api\n   */\n  ol.events.condition.never = ol.functions.FALSE;\n  \n  \n  /**\n   * Return `true` if the browser event is a `pointermove` event, `false`\n   * otherwise.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if the browser event is a `pointermove` event.\n   * @api\n   */\n  ol.events.condition.pointerMove = function(mapBrowserEvent) {\n    return mapBrowserEvent.type == 'pointermove';\n  };\n  \n  \n  /**\n   * Return `true` if the event is a map `singleclick` event, `false` otherwise.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if the event is a map `singleclick` event.\n   * @api\n   */\n  ol.events.condition.singleClick = function(mapBrowserEvent) {\n    return mapBrowserEvent.type == ol.MapBrowserEventType.SINGLECLICK;\n  };\n  \n  \n  /**\n   * Return `true` if the event is a map `dblclick` event, `false` otherwise.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if the event is a map `dblclick` event.\n   * @api\n   */\n  ol.events.condition.doubleClick = function(mapBrowserEvent) {\n    return mapBrowserEvent.type == ol.MapBrowserEventType.DBLCLICK;\n  };\n  \n  \n  /**\n   * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\n   * pressed.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True only if there no modifier keys are pressed.\n   * @api\n   */\n  ol.events.condition.noModifierKeys = function(mapBrowserEvent) {\n    var originalEvent = mapBrowserEvent.originalEvent;\n    return (\n      !originalEvent.altKey &&\n        !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n        !originalEvent.shiftKey);\n  };\n  \n  \n  /**\n   * Return `true` if only the platform-modifier-key (the meta-key on Mac,\n   * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally\n   * the shift-key is pressed).\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if only the platform modifier key is pressed.\n   * @api\n   */\n  ol.events.condition.platformModifierKeyOnly = function(mapBrowserEvent) {\n    var originalEvent = mapBrowserEvent.originalEvent;\n    return (\n      !originalEvent.altKey &&\n        (ol.has.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&\n        !originalEvent.shiftKey);\n  };\n  \n  \n  /**\n   * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\n   * additionally the alt-key is pressed).\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if only the shift key is pressed.\n   * @api\n   */\n  ol.events.condition.shiftKeyOnly = function(mapBrowserEvent) {\n    var originalEvent = mapBrowserEvent.originalEvent;\n    return (\n      !originalEvent.altKey &&\n        !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n        originalEvent.shiftKey);\n  };\n  \n  \n  /**\n   * Return `true` if the target element is not editable, i.e. not a `<input>`-,\n   * `<select>`- or `<textarea>`-element, `false` otherwise.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True only if the target element is not editable.\n   * @api\n   */\n  ol.events.condition.targetNotEditable = function(mapBrowserEvent) {\n    var target = mapBrowserEvent.originalEvent.target;\n    var tagName = target.tagName;\n    return (\n      tagName !== 'INPUT' &&\n        tagName !== 'SELECT' &&\n        tagName !== 'TEXTAREA');\n  };\n  \n  \n  /**\n   * Return `true` if the event originates from a mouse device.\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if the event originates from a mouse device.\n   * @api\n   */\n  ol.events.condition.mouseOnly = function(mapBrowserEvent) {\n    ol.asserts.assert(mapBrowserEvent.pointerEvent, 56); // mapBrowserEvent must originate from a pointer event\n    // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n    return /** @type {ol.MapBrowserEvent} */ (mapBrowserEvent).pointerEvent.pointerType == 'mouse';\n  };\n  \n  \n  /**\n   * Return `true` if the event originates from a primary pointer in\n   * contact with the surface or if the left mouse button is pressed.\n   * @see http://www.w3.org/TR/pointerevents/#button-states\n   *\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} True if the event originates from a primary pointer.\n   * @api\n   */\n  ol.events.condition.primaryAction = function(mapBrowserEvent) {\n    var pointerEvent = mapBrowserEvent.pointerEvent;\n    return pointerEvent.isPrimary && pointerEvent.button === 0;\n  };\n  \n  goog.provide('ol.interaction.Pointer');\n  \n  goog.require('ol');\n  goog.require('ol.functions');\n  goog.require('ol.MapBrowserEventType');\n  goog.require('ol.MapBrowserPointerEvent');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * @classdesc\n   * Base class that calls user-defined functions on `down`, `move` and `up`\n   * events. This class also manages \"drag sequences\".\n   *\n   * When the `handleDownEvent` user function returns `true` a drag sequence is\n   * started. During a drag sequence the `handleDragEvent` user function is\n   * called on `move` events. The drag sequence ends when the `handleUpEvent`\n   * user function is called and returns `false`.\n   *\n   * @constructor\n   * @param {olx.interaction.PointerOptions=} opt_options Options.\n   * @extends {ol.interaction.Interaction}\n   * @api\n   */\n  ol.interaction.Pointer = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    var handleEvent = options.handleEvent ?\n      options.handleEvent : ol.interaction.Pointer.handleEvent;\n  \n    ol.interaction.Interaction.call(this, {\n      handleEvent: handleEvent\n    });\n  \n    /**\n     * @type {function(ol.MapBrowserPointerEvent):boolean}\n     * @private\n     */\n    this.handleDownEvent_ = options.handleDownEvent ?\n      options.handleDownEvent : ol.interaction.Pointer.handleDownEvent;\n  \n    /**\n     * @type {function(ol.MapBrowserPointerEvent)}\n     * @private\n     */\n    this.handleDragEvent_ = options.handleDragEvent ?\n      options.handleDragEvent : ol.interaction.Pointer.handleDragEvent;\n  \n    /**\n     * @type {function(ol.MapBrowserPointerEvent)}\n     * @private\n     */\n    this.handleMoveEvent_ = options.handleMoveEvent ?\n      options.handleMoveEvent : ol.interaction.Pointer.handleMoveEvent;\n  \n    /**\n     * @type {function(ol.MapBrowserPointerEvent):boolean}\n     * @private\n     */\n    this.handleUpEvent_ = options.handleUpEvent ?\n      options.handleUpEvent : ol.interaction.Pointer.handleUpEvent;\n  \n    /**\n     * @type {boolean}\n     * @protected\n     */\n    this.handlingDownUpSequence = false;\n  \n    /**\n     * @type {Object.<string, ol.pointer.PointerEvent>}\n     * @private\n     */\n    this.trackedPointers_ = {};\n  \n    /**\n     * @type {Array.<ol.pointer.PointerEvent>}\n     * @protected\n     */\n    this.targetPointers = [];\n  \n  };\n  ol.inherits(ol.interaction.Pointer, ol.interaction.Interaction);\n  \n  \n  /**\n   * @param {Array.<ol.pointer.PointerEvent>} pointerEvents List of events.\n   * @return {ol.Pixel} Centroid pixel.\n   */\n  ol.interaction.Pointer.centroid = function(pointerEvents) {\n    var length = pointerEvents.length;\n    var clientX = 0;\n    var clientY = 0;\n    for (var i = 0; i < length; i++) {\n      clientX += pointerEvents[i].clientX;\n      clientY += pointerEvents[i].clientY;\n    }\n    return [clientX / length, clientY / length];\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Whether the event is a pointerdown, pointerdrag\n   *     or pointerup event.\n   * @private\n   */\n  ol.interaction.Pointer.prototype.isPointerDraggingEvent_ = function(mapBrowserEvent) {\n    var type = mapBrowserEvent.type;\n    return (\n      type === ol.MapBrowserEventType.POINTERDOWN ||\n        type === ol.MapBrowserEventType.POINTERDRAG ||\n        type === ol.MapBrowserEventType.POINTERUP);\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @private\n   */\n  ol.interaction.Pointer.prototype.updateTrackedPointers_ = function(mapBrowserEvent) {\n    if (this.isPointerDraggingEvent_(mapBrowserEvent)) {\n      var event = mapBrowserEvent.pointerEvent;\n  \n      var id = event.pointerId.toString();\n      if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERUP) {\n        delete this.trackedPointers_[id];\n      } else if (mapBrowserEvent.type ==\n          ol.MapBrowserEventType.POINTERDOWN) {\n        this.trackedPointers_[id] = event;\n      } else if (id in this.trackedPointers_) {\n        // update only when there was a pointerdown event for this pointer\n        this.trackedPointers_[id] = event;\n      }\n      this.targetPointers = ol.obj.getValues(this.trackedPointers_);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @this {ol.interaction.Pointer}\n   */\n  ol.interaction.Pointer.handleDragEvent = ol.nullFunction;\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Capture dragging.\n   * @this {ol.interaction.Pointer}\n   */\n  ol.interaction.Pointer.handleUpEvent = ol.functions.FALSE;\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Capture dragging.\n   * @this {ol.interaction.Pointer}\n   */\n  ol.interaction.Pointer.handleDownEvent = ol.functions.FALSE;\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @this {ol.interaction.Pointer}\n   */\n  ol.interaction.Pointer.handleMoveEvent = ol.nullFunction;\n  \n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} and may call into\n   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\n   * detected.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {ol.interaction.Pointer}\n   * @api\n   */\n  ol.interaction.Pointer.handleEvent = function(mapBrowserEvent) {\n    if (!(mapBrowserEvent instanceof ol.MapBrowserPointerEvent)) {\n      return true;\n    }\n  \n    var stopEvent = false;\n    this.updateTrackedPointers_(mapBrowserEvent);\n    if (this.handlingDownUpSequence) {\n      if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERDRAG) {\n        this.handleDragEvent_(mapBrowserEvent);\n      } else if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERUP) {\n        var handledUp = this.handleUpEvent_(mapBrowserEvent);\n        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;\n      }\n    } else {\n      if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERDOWN) {\n        var handled = this.handleDownEvent_(mapBrowserEvent);\n        this.handlingDownUpSequence = handled;\n        stopEvent = this.shouldStopEvent(handled);\n      } else if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERMOVE) {\n        this.handleMoveEvent_(mapBrowserEvent);\n      }\n    }\n    return !stopEvent;\n  };\n  \n  \n  /**\n   * This method is used to determine if \"down\" events should be propagated to\n   * other interactions or should be stopped.\n   *\n   * The method receives the return code of the \"handleDownEvent\" function.\n   *\n   * By default this function is the \"identity\" function. It's overidden in\n   * child classes.\n   *\n   * @param {boolean} handled Was the event handled by the interaction?\n   * @return {boolean} Should the event be stopped?\n   * @protected\n   */\n  ol.interaction.Pointer.prototype.shouldStopEvent = function(handled) {\n    return handled;\n  };\n  \n  goog.provide('ol.interaction.DragPan');\n  \n  goog.require('ol');\n  goog.require('ol.ViewHint');\n  goog.require('ol.coordinate');\n  goog.require('ol.easing');\n  goog.require('ol.events.condition');\n  goog.require('ol.functions');\n  goog.require('ol.interaction.Pointer');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to pan the map by dragging the map.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @param {olx.interaction.DragPanOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.DragPan = function(opt_options) {\n  \n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.DragPan.handleDownEvent_,\n      handleDragEvent: ol.interaction.DragPan.handleDragEvent_,\n      handleUpEvent: ol.interaction.DragPan.handleUpEvent_\n    });\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {ol.Kinetic|undefined}\n     */\n    this.kinetic_ = options.kinetic;\n  \n    /**\n     * @type {ol.Pixel}\n     */\n    this.lastCentroid = null;\n  \n    /**\n     * @type {number}\n     */\n    this.lastPointersCount_;\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition ?\n      options.condition : ol.events.condition.noModifierKeys;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.noKinetic_ = false;\n  \n  };\n  ol.inherits(ol.interaction.DragPan, ol.interaction.Pointer);\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @this {ol.interaction.DragPan}\n   * @private\n   */\n  ol.interaction.DragPan.handleDragEvent_ = function(mapBrowserEvent) {\n    var targetPointers = this.targetPointers;\n    var centroid =\n        ol.interaction.Pointer.centroid(targetPointers);\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid[0], centroid[1]);\n      }\n      if (this.lastCentroid) {\n        var deltaX = this.lastCentroid[0] - centroid[0];\n        var deltaY = centroid[1] - this.lastCentroid[1];\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        var viewState = view.getState();\n        var center = [deltaX, deltaY];\n        ol.coordinate.scale(center, viewState.resolution);\n        ol.coordinate.rotate(center, viewState.rotation);\n        ol.coordinate.add(center, viewState.center);\n        center = view.constrainCenter(center);\n        view.setCenter(center);\n      }\n    } else if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger down, tiny drag, second finger down\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = centroid;\n    this.lastPointersCount_ = targetPointers.length;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.DragPan}\n   * @private\n   */\n  ol.interaction.DragPan.handleUpEvent_ = function(mapBrowserEvent) {\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        var distance = this.kinetic_.getDistance();\n        var angle = this.kinetic_.getAngle();\n        var center = /** @type {!ol.Coordinate} */ (view.getCenter());\n        var centerpx = map.getPixelFromCoordinate(center);\n        var dest = map.getCoordinateFromPixel([\n          centerpx[0] - distance * Math.cos(angle),\n          centerpx[1] - distance * Math.sin(angle)\n        ]);\n        view.animate({\n          center: view.constrainCenter(dest),\n          duration: 500,\n          easing: ol.easing.easeOut\n        });\n      }\n      view.setHint(ol.ViewHint.INTERACTING, -1);\n      return false;\n    } else {\n      if (this.kinetic_) {\n        // reset so we don't overestimate the kinetic energy after\n        // after one finger up, tiny drag, second finger up\n        this.kinetic_.begin();\n      }\n      this.lastCentroid = null;\n      return true;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.DragPan}\n   * @private\n   */\n  ol.interaction.DragPan.handleDownEvent_ = function(mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      this.lastCentroid = null;\n      if (!this.handlingDownUpSequence) {\n        view.setHint(ol.ViewHint.INTERACTING, 1);\n      }\n      // stop any current animation\n      if (view.getAnimating()) {\n        view.setCenter(mapBrowserEvent.frameState.viewState.center);\n      }\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      // No kinetic as soon as more than one pointer on the screen is\n      // detected. This is to prevent nasty pans after pinch.\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.DragPan.prototype.shouldStopEvent = ol.functions.FALSE;\n  \n  goog.provide('ol.interaction.DragRotate');\n  \n  goog.require('ol');\n  goog.require('ol.RotationConstraint');\n  goog.require('ol.ViewHint');\n  goog.require('ol.events.condition');\n  goog.require('ol.functions');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.interaction.Pointer');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to rotate the map by clicking and dragging on the map,\n   * normally combined with an {@link ol.events.condition} that limits\n   * it to when the alt and shift keys are held down.\n   *\n   * This interaction is only supported for mouse devices.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @param {olx.interaction.DragRotateOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.DragRotate = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.DragRotate.handleDownEvent_,\n      handleDragEvent: ol.interaction.DragRotate.handleDragEvent_,\n      handleUpEvent: ol.interaction.DragRotate.handleUpEvent_\n    });\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition ?\n      options.condition : ol.events.condition.altShiftKeysOnly;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  };\n  ol.inherits(ol.interaction.DragRotate, ol.interaction.Pointer);\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @this {ol.interaction.DragRotate}\n   * @private\n   */\n  ol.interaction.DragRotate.handleDragEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n  \n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    if (view.getConstraints().rotation === ol.RotationConstraint.disable) {\n      return;\n    }\n    var size = map.getSize();\n    var offset = mapBrowserEvent.pixel;\n    var theta =\n        Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);\n    if (this.lastAngle_ !== undefined) {\n      var delta = theta - this.lastAngle_;\n      var rotation = view.getRotation();\n      ol.interaction.Interaction.rotateWithoutConstraints(\n          view, rotation - delta);\n    }\n    this.lastAngle_ = theta;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.DragRotate}\n   * @private\n   */\n  ol.interaction.DragRotate.handleUpEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n  \n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    view.setHint(ol.ViewHint.INTERACTING, -1);\n    var rotation = view.getRotation();\n    ol.interaction.Interaction.rotate(view, rotation,\n        undefined, this.duration_);\n    return false;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.DragRotate}\n   * @private\n   */\n  ol.interaction.DragRotate.handleDownEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n  \n    if (ol.events.condition.mouseActionButton(mapBrowserEvent) &&\n        this.condition_(mapBrowserEvent)) {\n      var map = mapBrowserEvent.map;\n      map.getView().setHint(ol.ViewHint.INTERACTING, 1);\n      this.lastAngle_ = undefined;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.DragRotate.prototype.shouldStopEvent = ol.functions.FALSE;\n  \n  // FIXME add rotation\n  \n  goog.provide('ol.render.Box');\n  \n  goog.require('ol');\n  goog.require('ol.Disposable');\n  goog.require('ol.geom.Polygon');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.Disposable}\n   * @param {string} className CSS class name.\n   */\n  ol.render.Box = function(className) {\n  \n    /**\n     * @type {ol.geom.Polygon}\n     * @private\n     */\n    this.geometry_ = null;\n  \n    /**\n     * @type {HTMLDivElement}\n     * @private\n     */\n    this.element_ = /** @type {HTMLDivElement} */ (document.createElement('div'));\n    this.element_.style.position = 'absolute';\n    this.element_.className = 'ol-box ' + className;\n  \n    /**\n     * @private\n     * @type {ol.PluggableMap}\n     */\n    this.map_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Pixel}\n     */\n    this.startPixel_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Pixel}\n     */\n    this.endPixel_ = null;\n  \n  };\n  ol.inherits(ol.render.Box, ol.Disposable);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.Box.prototype.disposeInternal = function() {\n    this.setMap(null);\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.render.Box.prototype.render_ = function() {\n    var startPixel = this.startPixel_;\n    var endPixel = this.endPixel_;\n    var px = 'px';\n    var style = this.element_.style;\n    style.left = Math.min(startPixel[0], endPixel[0]) + px;\n    style.top = Math.min(startPixel[1], endPixel[1]) + px;\n    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;\n    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;\n  };\n  \n  \n  /**\n   * @param {ol.PluggableMap} map Map.\n   */\n  ol.render.Box.prototype.setMap = function(map) {\n    if (this.map_) {\n      this.map_.getOverlayContainer().removeChild(this.element_);\n      var style = this.element_.style;\n      style.left = style.top = style.width = style.height = 'inherit';\n    }\n    this.map_ = map;\n    if (this.map_) {\n      this.map_.getOverlayContainer().appendChild(this.element_);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Pixel} startPixel Start pixel.\n   * @param {ol.Pixel} endPixel End pixel.\n   */\n  ol.render.Box.prototype.setPixels = function(startPixel, endPixel) {\n    this.startPixel_ = startPixel;\n    this.endPixel_ = endPixel;\n    this.createOrUpdateGeometry();\n    this.render_();\n  };\n  \n  \n  /**\n   * Creates or updates the cached geometry.\n   */\n  ol.render.Box.prototype.createOrUpdateGeometry = function() {\n    var startPixel = this.startPixel_;\n    var endPixel = this.endPixel_;\n    var pixels = [\n      startPixel,\n      [startPixel[0], endPixel[1]],\n      endPixel,\n      [endPixel[0], startPixel[1]]\n    ];\n    var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);\n    // close the polygon\n    coordinates[4] = coordinates[0].slice();\n    if (!this.geometry_) {\n      this.geometry_ = new ol.geom.Polygon([coordinates]);\n    } else {\n      this.geometry_.setCoordinates([coordinates]);\n    }\n  };\n  \n  \n  /**\n   * @return {ol.geom.Polygon} Geometry.\n   */\n  ol.render.Box.prototype.getGeometry = function() {\n    return this.geometry_;\n  };\n  \n  // FIXME draw drag box\n  goog.provide('ol.interaction.DragBox');\n  \n  goog.require('ol.events.Event');\n  goog.require('ol');\n  goog.require('ol.events.condition');\n  goog.require('ol.interaction.Pointer');\n  goog.require('ol.render.Box');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to draw a vector box by clicking and dragging on the map,\n   * normally combined with an {@link ol.events.condition} that limits\n   * it to when the shift or other key is held down. This is used, for example,\n   * for zooming to a specific area of the map\n   * (see {@link ol.interaction.DragZoom} and\n   * {@link ol.interaction.DragRotateAndZoom}).\n   *\n   * This interaction is only supported for mouse devices.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @fires ol.interaction.DragBox.Event\n   * @param {olx.interaction.DragBoxOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.DragBox = function(opt_options) {\n  \n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.DragBox.handleDownEvent_,\n      handleDragEvent: ol.interaction.DragBox.handleDragEvent_,\n      handleUpEvent: ol.interaction.DragBox.handleUpEvent_\n    });\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @type {ol.render.Box}\n     * @private\n     */\n    this.box_ = new ol.render.Box(options.className || 'ol-dragbox');\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n  \n    /**\n     * @type {ol.Pixel}\n     * @private\n     */\n    this.startPixel_ = null;\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition ?\n      options.condition : ol.events.condition.always;\n  \n    /**\n     * @private\n     * @type {ol.DragBoxEndConditionType}\n     */\n    this.boxEndCondition_ = options.boxEndCondition ?\n      options.boxEndCondition : ol.interaction.DragBox.defaultBoxEndCondition;\n  };\n  ol.inherits(ol.interaction.DragBox, ol.interaction.Pointer);\n  \n  \n  /**\n   * The default condition for determining whether the boxend event\n   * should fire.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent\n   *     leading to the box end.\n   * @param {ol.Pixel} startPixel The starting pixel of the box.\n   * @param {ol.Pixel} endPixel The end pixel of the box.\n   * @return {boolean} Whether or not the boxend condition should be fired.\n   * @this {ol.interaction.DragBox}\n   */\n  ol.interaction.DragBox.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {\n    var width = endPixel[0] - startPixel[0];\n    var height = endPixel[1] - startPixel[1];\n    return width * width + height * height >= this.minArea_;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @this {ol.interaction.DragBox}\n   * @private\n   */\n  ol.interaction.DragBox.handleDragEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n  \n    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n  \n    this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXDRAG,\n        mapBrowserEvent.coordinate, mapBrowserEvent));\n  };\n  \n  \n  /**\n   * Returns geometry of last drawn box.\n   * @return {ol.geom.Polygon} Geometry.\n   * @api\n   */\n  ol.interaction.DragBox.prototype.getGeometry = function() {\n    return this.box_.getGeometry();\n  };\n  \n  \n  /**\n   * To be overridden by child classes.\n   * FIXME: use constructor option instead of relying on overriding.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @protected\n   */\n  ol.interaction.DragBox.prototype.onBoxEnd = ol.nullFunction;\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.DragBox}\n   * @private\n   */\n  ol.interaction.DragBox.handleUpEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n  \n    this.box_.setMap(null);\n  \n    if (this.boxEndCondition_(mapBrowserEvent,\n        this.startPixel_, mapBrowserEvent.pixel)) {\n      this.onBoxEnd(mapBrowserEvent);\n      this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXEND,\n          mapBrowserEvent.coordinate, mapBrowserEvent));\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.DragBox}\n   * @private\n   */\n  ol.interaction.DragBox.handleDownEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n  \n    if (ol.events.condition.mouseActionButton(mapBrowserEvent) &&\n        this.condition_(mapBrowserEvent)) {\n      this.startPixel_ = mapBrowserEvent.pixel;\n      this.box_.setMap(mapBrowserEvent.map);\n      this.box_.setPixels(this.startPixel_, this.startPixel_);\n      this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXSTART,\n          mapBrowserEvent.coordinate, mapBrowserEvent));\n      return true;\n    } else {\n      return false;\n    }\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.interaction.DragBox.EventType_ = {\n    /**\n     * Triggered upon drag box start.\n     * @event ol.interaction.DragBox.Event#boxstart\n     * @api\n     */\n    BOXSTART: 'boxstart',\n  \n    /**\n     * Triggered on drag when box is active.\n     * @event ol.interaction.DragBox.Event#boxdrag\n     * @api\n     */\n    BOXDRAG: 'boxdrag',\n  \n    /**\n     * Triggered upon drag box end.\n     * @event ol.interaction.DragBox.Event#boxend\n     * @api\n     */\n    BOXEND: 'boxend'\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.interaction.DragBox} instances are instances of\n   * this type.\n   *\n   * @param {string} type The event type.\n   * @param {ol.Coordinate} coordinate The event coordinate.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Originating event.\n   * @extends {ol.events.Event}\n   * @constructor\n   * @implements {oli.DragBoxEvent}\n   */\n  ol.interaction.DragBox.Event = function(type, coordinate, mapBrowserEvent) {\n    ol.events.Event.call(this, type);\n  \n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {ol.Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n  \n    /**\n     * @const\n     * @type {ol.MapBrowserEvent}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  \n  };\n  ol.inherits(ol.interaction.DragBox.Event, ol.events.Event);\n  \n  goog.provide('ol.interaction.DragZoom');\n  \n  goog.require('ol');\n  goog.require('ol.easing');\n  goog.require('ol.events.condition');\n  goog.require('ol.extent');\n  goog.require('ol.interaction.DragBox');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to zoom the map by clicking and dragging on the map,\n   * normally combined with an {@link ol.events.condition} that limits\n   * it to when a key, shift by default, is held down.\n   *\n   * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\n   * your custom one configured with `className`.\n   *\n   * @constructor\n   * @extends {ol.interaction.DragBox}\n   * @param {olx.interaction.DragZoomOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.DragZoom = function(opt_options) {\n    var options = opt_options ? opt_options : {};\n  \n    var condition = options.condition ?\n      options.condition : ol.events.condition.shiftKeyOnly;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.out_ = options.out !== undefined ? options.out : false;\n  \n    ol.interaction.DragBox.call(this, {\n      condition: condition,\n      className: options.className || 'ol-dragzoom'\n    });\n  \n  };\n  ol.inherits(ol.interaction.DragZoom, ol.interaction.DragBox);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.DragZoom.prototype.onBoxEnd = function() {\n    var map = this.getMap();\n  \n    var view = /** @type {!ol.View} */ (map.getView());\n  \n    var size = /** @type {!ol.Size} */ (map.getSize());\n  \n    var extent = this.getGeometry().getExtent();\n  \n    if (this.out_) {\n      var mapExtent = view.calculateExtent(size);\n      var boxPixelExtent = ol.extent.createOrUpdateFromCoordinates([\n        map.getPixelFromCoordinate(ol.extent.getBottomLeft(extent)),\n        map.getPixelFromCoordinate(ol.extent.getTopRight(extent))]);\n      var factor = view.getResolutionForExtent(boxPixelExtent, size);\n  \n      ol.extent.scaleFromCenter(mapExtent, 1 / factor);\n      extent = mapExtent;\n    }\n  \n    var resolution = view.constrainResolution(\n        view.getResolutionForExtent(extent, size));\n  \n    var center = ol.extent.getCenter(extent);\n    center = view.constrainCenter(center);\n  \n    view.animate({\n      resolution: resolution,\n      center: center,\n      duration: this.duration_,\n      easing: ol.easing.easeOut\n    });\n  \n  };\n  \n  goog.provide('ol.events.KeyCode');\n  \n  /**\n   * @enum {number}\n   * @const\n   */\n  ol.events.KeyCode = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40\n  };\n  \n  goog.provide('ol.interaction.KeyboardPan');\n  \n  goog.require('ol');\n  goog.require('ol.coordinate');\n  goog.require('ol.events.EventType');\n  goog.require('ol.events.KeyCode');\n  goog.require('ol.events.condition');\n  goog.require('ol.interaction.Interaction');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to pan the map using keyboard arrows.\n   * Note that, although this interaction is by default included in maps,\n   * the keys can only be used when browser focus is on the element to which\n   * the keyboard events are attached. By default, this is the map div,\n   * though you can change this with the `keyboardEventTarget` in\n   * {@link ol.Map}. `document` never loses focus but, for any other element,\n   * focus will have to be on, and returned to, this element if the keys are to\n   * function.\n   * See also {@link ol.interaction.KeyboardZoom}.\n   *\n   * @constructor\n   * @extends {ol.interaction.Interaction}\n   * @param {olx.interaction.KeyboardPanOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.KeyboardPan = function(opt_options) {\n  \n    ol.interaction.Interaction.call(this, {\n      handleEvent: ol.interaction.KeyboardPan.handleEvent\n    });\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultCondition_ = function(mapBrowserEvent) {\n      return ol.events.condition.noModifierKeys(mapBrowserEvent) &&\n        ol.events.condition.targetNotEditable(mapBrowserEvent);\n    };\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition !== undefined ?\n      options.condition : this.defaultCondition_;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelDelta_ = options.pixelDelta !== undefined ?\n      options.pixelDelta : 128;\n  \n  };\n  ol.inherits(ol.interaction.KeyboardPan, ol.interaction.Interaction);\n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides the direction to pan to (if an arrow key was\n   * pressed).\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {ol.interaction.KeyboardPan}\n   * @api\n   */\n  ol.interaction.KeyboardPan.handleEvent = function(mapBrowserEvent) {\n    var stopEvent = false;\n    if (mapBrowserEvent.type == ol.events.EventType.KEYDOWN) {\n      var keyEvent = mapBrowserEvent.originalEvent;\n      var keyCode = keyEvent.keyCode;\n      if (this.condition_(mapBrowserEvent) &&\n          (keyCode == ol.events.KeyCode.DOWN ||\n          keyCode == ol.events.KeyCode.LEFT ||\n          keyCode == ol.events.KeyCode.RIGHT ||\n          keyCode == ol.events.KeyCode.UP)) {\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        var mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n        var deltaX = 0, deltaY = 0;\n        if (keyCode == ol.events.KeyCode.DOWN) {\n          deltaY = -mapUnitsDelta;\n        } else if (keyCode == ol.events.KeyCode.LEFT) {\n          deltaX = -mapUnitsDelta;\n        } else if (keyCode == ol.events.KeyCode.RIGHT) {\n          deltaX = mapUnitsDelta;\n        } else {\n          deltaY = mapUnitsDelta;\n        }\n        var delta = [deltaX, deltaY];\n        ol.coordinate.rotate(delta, view.getRotation());\n        ol.interaction.Interaction.pan(view, delta, this.duration_);\n        mapBrowserEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  };\n  \n  goog.provide('ol.interaction.KeyboardZoom');\n  \n  goog.require('ol');\n  goog.require('ol.events.EventType');\n  goog.require('ol.events.condition');\n  goog.require('ol.interaction.Interaction');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to zoom the map using keyboard + and -.\n   * Note that, although this interaction is by default included in maps,\n   * the keys can only be used when browser focus is on the element to which\n   * the keyboard events are attached. By default, this is the map div,\n   * though you can change this with the `keyboardEventTarget` in\n   * {@link ol.Map}. `document` never loses focus but, for any other element,\n   * focus will have to be on, and returned to, this element if the keys are to\n   * function.\n   * See also {@link ol.interaction.KeyboardPan}.\n   *\n   * @constructor\n   * @param {olx.interaction.KeyboardZoomOptions=} opt_options Options.\n   * @extends {ol.interaction.Interaction}\n   * @api\n   */\n  ol.interaction.KeyboardZoom = function(opt_options) {\n  \n    ol.interaction.Interaction.call(this, {\n      handleEvent: ol.interaction.KeyboardZoom.handleEvent\n    });\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition ? options.condition :\n      ol.events.condition.targetNotEditable;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n  \n  };\n  ol.inherits(ol.interaction.KeyboardZoom, ol.interaction.Interaction);\n  \n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\n   * key pressed was '+' or '-').\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {ol.interaction.KeyboardZoom}\n   * @api\n   */\n  ol.interaction.KeyboardZoom.handleEvent = function(mapBrowserEvent) {\n    var stopEvent = false;\n    if (mapBrowserEvent.type == ol.events.EventType.KEYDOWN ||\n        mapBrowserEvent.type == ol.events.EventType.KEYPRESS) {\n      var keyEvent = mapBrowserEvent.originalEvent;\n      var charCode = keyEvent.charCode;\n      if (this.condition_(mapBrowserEvent) &&\n          (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {\n        var map = mapBrowserEvent.map;\n        var delta = (charCode == '+'.charCodeAt(0)) ? this.delta_ : -this.delta_;\n        var view = map.getView();\n        ol.interaction.Interaction.zoomByDelta(\n            view, delta, undefined, this.duration_);\n        mapBrowserEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  };\n  \n  goog.provide('ol.interaction.MouseWheelZoom');\n  \n  goog.require('ol');\n  goog.require('ol.ViewHint');\n  goog.require('ol.easing');\n  goog.require('ol.events.EventType');\n  goog.require('ol.has');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.math');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to zoom the map by scrolling the mouse wheel.\n   *\n   * @constructor\n   * @extends {ol.interaction.Interaction}\n   * @param {olx.interaction.MouseWheelZoomOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.MouseWheelZoom = function(opt_options) {\n  \n    ol.interaction.Interaction.call(this, {\n      handleEvent: ol.interaction.MouseWheelZoom.handleEvent\n    });\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.constrainResolution_ = options.constrainResolution || false;\n  \n    /**\n     * @private\n     * @type {?ol.Coordinate}\n     */\n    this.lastAnchor_ = null;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.startTime_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.timeoutId_ = undefined;\n  \n    /**\n     * @private\n     * @type {ol.interaction.MouseWheelZoom.Mode_|undefined}\n     */\n    this.mode_ = undefined;\n  \n    /**\n     * Trackpad events separated by this delay will be considered separate\n     * interactions.\n     * @type {number}\n     */\n    this.trackpadEventGap_ = 400;\n  \n    /**\n     * @type {number|undefined}\n     */\n    this.trackpadTimeoutId_ = undefined;\n  \n    /**\n     * The number of delta values per zoom level\n     * @private\n     * @type {number}\n     */\n    this.trackpadDeltaPerZoom_ = 300;\n  \n    /**\n     * The zoom factor by which scroll zooming is allowed to exceed the limits.\n     * @private\n     * @type {number}\n     */\n    this.trackpadZoomBuffer_ = 1.5;\n  \n  };\n  ol.inherits(ol.interaction.MouseWheelZoom, ol.interaction.Interaction);\n  \n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a\n   * mousewheel-event) and eventually zooms the map.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} Allow event propagation.\n   * @this {ol.interaction.MouseWheelZoom}\n   * @api\n   */\n  ol.interaction.MouseWheelZoom.handleEvent = function(mapBrowserEvent) {\n    var type = mapBrowserEvent.type;\n    if (type !== ol.events.EventType.WHEEL && type !== ol.events.EventType.MOUSEWHEEL) {\n      return true;\n    }\n  \n    mapBrowserEvent.preventDefault();\n  \n    var map = mapBrowserEvent.map;\n    var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);\n  \n    if (this.useAnchor_) {\n      this.lastAnchor_ = mapBrowserEvent.coordinate;\n    }\n  \n    // Delta normalisation inspired by\n    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\n    var delta;\n    if (mapBrowserEvent.type == ol.events.EventType.WHEEL) {\n      delta = wheelEvent.deltaY;\n      if (ol.has.FIREFOX &&\n          wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n        delta /= ol.has.DEVICE_PIXEL_RATIO;\n      }\n      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        delta *= 40;\n      }\n    } else if (mapBrowserEvent.type == ol.events.EventType.MOUSEWHEEL) {\n      delta = -wheelEvent.wheelDeltaY;\n      if (ol.has.SAFARI) {\n        delta /= 3;\n      }\n    }\n  \n    if (delta === 0) {\n      return false;\n    }\n  \n    var now = Date.now();\n  \n    if (this.startTime_ === undefined) {\n      this.startTime_ = now;\n    }\n  \n    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\n      this.mode_ = Math.abs(delta) < 4 ?\n        ol.interaction.MouseWheelZoom.Mode_.TRACKPAD :\n        ol.interaction.MouseWheelZoom.Mode_.WHEEL;\n    }\n  \n    if (this.mode_ === ol.interaction.MouseWheelZoom.Mode_.TRACKPAD) {\n      var view = map.getView();\n      if (this.trackpadTimeoutId_) {\n        clearTimeout(this.trackpadTimeoutId_);\n      } else {\n        view.setHint(ol.ViewHint.INTERACTING, 1);\n      }\n      this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);\n      var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);\n      var minResolution = view.getMinResolution();\n      var maxResolution = view.getMaxResolution();\n      var rebound = 0;\n      if (resolution < minResolution) {\n        resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);\n        rebound = 1;\n      } else if (resolution > maxResolution) {\n        resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);\n        rebound = -1;\n      }\n      if (this.lastAnchor_) {\n        var center = view.calculateCenterZoom(resolution, this.lastAnchor_);\n        view.setCenter(view.constrainCenter(center));\n      }\n      view.setResolution(resolution);\n  \n      if (rebound === 0 && this.constrainResolution_) {\n        view.animate({\n          resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),\n          easing: ol.easing.easeOut,\n          anchor: this.lastAnchor_,\n          duration: this.duration_\n        });\n      }\n  \n      if (rebound > 0) {\n        view.animate({\n          resolution: minResolution,\n          easing: ol.easing.easeOut,\n          anchor: this.lastAnchor_,\n          duration: 500\n        });\n      } else if (rebound < 0) {\n        view.animate({\n          resolution: maxResolution,\n          easing: ol.easing.easeOut,\n          anchor: this.lastAnchor_,\n          duration: 500\n        });\n      }\n      this.startTime_ = now;\n      return false;\n    }\n  \n    this.delta_ += delta;\n  \n    var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\n  \n    clearTimeout(this.timeoutId_);\n    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);\n  \n    return false;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.interaction.MouseWheelZoom.prototype.decrementInteractingHint_ = function() {\n    this.trackpadTimeoutId_ = undefined;\n    var view = this.getMap().getView();\n    view.setHint(ol.ViewHint.INTERACTING, -1);\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.PluggableMap} map Map.\n   */\n  ol.interaction.MouseWheelZoom.prototype.handleWheelZoom_ = function(map) {\n    var view = map.getView();\n    if (view.getAnimating()) {\n      view.cancelAnimations();\n    }\n    var maxDelta = ol.MOUSEWHEELZOOM_MAXDELTA;\n    var delta = ol.math.clamp(this.delta_, -maxDelta, maxDelta);\n    ol.interaction.Interaction.zoomByDelta(view, -delta, this.lastAnchor_,\n        this.duration_);\n    this.mode_ = undefined;\n    this.delta_ = 0;\n    this.lastAnchor_ = null;\n    this.startTime_ = undefined;\n    this.timeoutId_ = undefined;\n  };\n  \n  \n  /**\n   * Enable or disable using the mouse's location as an anchor when zooming\n   * @param {boolean} useAnchor true to zoom to the mouse's location, false\n   * to zoom to the center of the map\n   * @api\n   */\n  ol.interaction.MouseWheelZoom.prototype.setMouseAnchor = function(useAnchor) {\n    this.useAnchor_ = useAnchor;\n    if (!useAnchor) {\n      this.lastAnchor_ = null;\n    }\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.interaction.MouseWheelZoom.Mode_ = {\n    TRACKPAD: 'trackpad',\n    WHEEL: 'wheel'\n  };\n  \n  goog.provide('ol.interaction.PinchRotate');\n  \n  goog.require('ol');\n  goog.require('ol.ViewHint');\n  goog.require('ol.functions');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.interaction.Pointer');\n  goog.require('ol.RotationConstraint');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to rotate the map by twisting with two fingers\n   * on a touch screen.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @param {olx.interaction.PinchRotateOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.PinchRotate = function(opt_options) {\n  \n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.PinchRotate.handleDownEvent_,\n      handleDragEvent: ol.interaction.PinchRotate.handleDragEvent_,\n      handleUpEvent: ol.interaction.PinchRotate.handleUpEvent_\n    });\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.anchor_ = null;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotating_ = false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.rotationDelta_ = 0.0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  \n  };\n  ol.inherits(ol.interaction.PinchRotate, ol.interaction.Pointer);\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @this {ol.interaction.PinchRotate}\n   * @private\n   */\n  ol.interaction.PinchRotate.handleDragEvent_ = function(mapBrowserEvent) {\n    var rotationDelta = 0.0;\n  \n    var touch0 = this.targetPointers[0];\n    var touch1 = this.targetPointers[1];\n  \n    // angle between touches\n    var angle = Math.atan2(\n        touch1.clientY - touch0.clientY,\n        touch1.clientX - touch0.clientX);\n  \n    if (this.lastAngle_ !== undefined) {\n      var delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n      if (!this.rotating_ &&\n          Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n      rotationDelta = delta;\n    }\n    this.lastAngle_ = angle;\n  \n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    if (view.getConstraints().rotation === ol.RotationConstraint.disable) {\n      return;\n    }\n  \n    // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n    var viewportPosition = map.getViewport().getBoundingClientRect();\n    var centroid = ol.interaction.Pointer.centroid(this.targetPointers);\n    centroid[0] -= viewportPosition.left;\n    centroid[1] -= viewportPosition.top;\n    this.anchor_ = map.getCoordinateFromPixel(centroid);\n  \n    // rotate\n    if (this.rotating_) {\n      var rotation = view.getRotation();\n      map.render();\n      ol.interaction.Interaction.rotateWithoutConstraints(view,\n          rotation + rotationDelta, this.anchor_);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.PinchRotate}\n   * @private\n   */\n  ol.interaction.PinchRotate.handleUpEvent_ = function(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      view.setHint(ol.ViewHint.INTERACTING, -1);\n      if (this.rotating_) {\n        var rotation = view.getRotation();\n        ol.interaction.Interaction.rotate(\n            view, rotation, this.anchor_, this.duration_);\n      }\n      return false;\n    } else {\n      return true;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.PinchRotate}\n   * @private\n   */\n  ol.interaction.PinchRotate.handleDownEvent_ = function(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      var map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n      if (!this.handlingDownUpSequence) {\n        map.getView().setHint(ol.ViewHint.INTERACTING, 1);\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.PinchRotate.prototype.shouldStopEvent = ol.functions.FALSE;\n  \n  goog.provide('ol.interaction.PinchZoom');\n  \n  goog.require('ol');\n  goog.require('ol.ViewHint');\n  goog.require('ol.functions');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.interaction.Pointer');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to zoom the map by pinching with two fingers\n   * on a touch screen.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @param {olx.interaction.PinchZoomOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.PinchZoom = function(opt_options) {\n  \n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.PinchZoom.handleDownEvent_,\n      handleDragEvent: ol.interaction.PinchZoom.handleDragEvent_,\n      handleUpEvent: ol.interaction.PinchZoom.handleUpEvent_\n    });\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.constrainResolution_ = options.constrainResolution || false;\n  \n    /**\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.anchor_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastDistance_ = undefined;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastScaleDelta_ = 1;\n  \n  };\n  ol.inherits(ol.interaction.PinchZoom, ol.interaction.Pointer);\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @this {ol.interaction.PinchZoom}\n   * @private\n   */\n  ol.interaction.PinchZoom.handleDragEvent_ = function(mapBrowserEvent) {\n    var scaleDelta = 1.0;\n  \n    var touch0 = this.targetPointers[0];\n    var touch1 = this.targetPointers[1];\n    var dx = touch0.clientX - touch1.clientX;\n    var dy = touch0.clientY - touch1.clientY;\n  \n    // distance between touches\n    var distance = Math.sqrt(dx * dx + dy * dy);\n  \n    if (this.lastDistance_ !== undefined) {\n      scaleDelta = this.lastDistance_ / distance;\n    }\n    this.lastDistance_ = distance;\n  \n  \n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    var resolution = view.getResolution();\n    var maxResolution = view.getMaxResolution();\n    var minResolution = view.getMinResolution();\n    var newResolution = resolution * scaleDelta;\n    if (newResolution > maxResolution) {\n      scaleDelta = maxResolution / resolution;\n      newResolution = maxResolution;\n    } else if (newResolution < minResolution) {\n      scaleDelta = minResolution / resolution;\n      newResolution = minResolution;\n    }\n  \n    if (scaleDelta != 1.0) {\n      this.lastScaleDelta_ = scaleDelta;\n    }\n  \n    // scale anchor point.\n    var viewportPosition = map.getViewport().getBoundingClientRect();\n    var centroid = ol.interaction.Pointer.centroid(this.targetPointers);\n    centroid[0] -= viewportPosition.left;\n    centroid[1] -= viewportPosition.top;\n    this.anchor_ = map.getCoordinateFromPixel(centroid);\n  \n    // scale, bypass the resolution constraint\n    map.render();\n    ol.interaction.Interaction.zoomWithoutConstraints(view, newResolution, this.anchor_);\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.PinchZoom}\n   * @private\n   */\n  ol.interaction.PinchZoom.handleUpEvent_ = function(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      view.setHint(ol.ViewHint.INTERACTING, -1);\n      var resolution = view.getResolution();\n      if (this.constrainResolution_ ||\n          resolution < view.getMinResolution() ||\n          resolution > view.getMaxResolution()) {\n        // Zoom to final resolution, with an animation, and provide a\n        // direction not to zoom out/in if user was pinching in/out.\n        // Direction is > 0 if pinching out, and < 0 if pinching in.\n        var direction = this.lastScaleDelta_ - 1;\n        ol.interaction.Interaction.zoom(view, resolution,\n            this.anchor_, this.duration_, direction);\n      }\n      return false;\n    } else {\n      return true;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.PinchZoom}\n   * @private\n   */\n  ol.interaction.PinchZoom.handleDownEvent_ = function(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      var map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastDistance_ = undefined;\n      this.lastScaleDelta_ = 1;\n      if (!this.handlingDownUpSequence) {\n        map.getView().setHint(ol.ViewHint.INTERACTING, 1);\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.PinchZoom.prototype.shouldStopEvent = ol.functions.FALSE;\n  \n  goog.provide('ol.interaction');\n  \n  goog.require('ol.Collection');\n  goog.require('ol.Kinetic');\n  goog.require('ol.interaction.DoubleClickZoom');\n  goog.require('ol.interaction.DragPan');\n  goog.require('ol.interaction.DragRotate');\n  goog.require('ol.interaction.DragZoom');\n  goog.require('ol.interaction.KeyboardPan');\n  goog.require('ol.interaction.KeyboardZoom');\n  goog.require('ol.interaction.MouseWheelZoom');\n  goog.require('ol.interaction.PinchRotate');\n  goog.require('ol.interaction.PinchZoom');\n  \n  \n  /**\n   * Set of interactions included in maps by default. Specific interactions can be\n   * excluded by setting the appropriate option to false in the constructor\n   * options, but the order of the interactions is fixed.  If you want to specify\n   * a different order for interactions, you will need to create your own\n   * {@link ol.interaction.Interaction} instances and insert them into a\n   * {@link ol.Collection} in the order you want before creating your\n   * {@link ol.Map} instance. The default set of interactions, in sequence, is:\n   * * {@link ol.interaction.DragRotate}\n   * * {@link ol.interaction.DoubleClickZoom}\n   * * {@link ol.interaction.DragPan}\n   * * {@link ol.interaction.PinchRotate}\n   * * {@link ol.interaction.PinchZoom}\n   * * {@link ol.interaction.KeyboardPan}\n   * * {@link ol.interaction.KeyboardZoom}\n   * * {@link ol.interaction.MouseWheelZoom}\n   * * {@link ol.interaction.DragZoom}\n   *\n   * @param {olx.interaction.DefaultsOptions=} opt_options Defaults options.\n   * @return {ol.Collection.<ol.interaction.Interaction>} A collection of\n   * interactions to be used with the ol.Map constructor's interactions option.\n   * @api\n   */\n  ol.interaction.defaults = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    var interactions = new ol.Collection();\n  \n    var kinetic = new ol.Kinetic(-0.005, 0.05, 100);\n  \n    var altShiftDragRotate = options.altShiftDragRotate !== undefined ?\n      options.altShiftDragRotate : true;\n    if (altShiftDragRotate) {\n      interactions.push(new ol.interaction.DragRotate());\n    }\n  \n    var doubleClickZoom = options.doubleClickZoom !== undefined ?\n      options.doubleClickZoom : true;\n    if (doubleClickZoom) {\n      interactions.push(new ol.interaction.DoubleClickZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration\n      }));\n    }\n  \n    var dragPan = options.dragPan !== undefined ? options.dragPan : true;\n    if (dragPan) {\n      interactions.push(new ol.interaction.DragPan({\n        kinetic: kinetic\n      }));\n    }\n  \n    var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate :\n      true;\n    if (pinchRotate) {\n      interactions.push(new ol.interaction.PinchRotate());\n    }\n  \n    var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;\n    if (pinchZoom) {\n      interactions.push(new ol.interaction.PinchZoom({\n        constrainResolution: options.constrainResolution,\n        duration: options.zoomDuration\n      }));\n    }\n  \n    var keyboard = options.keyboard !== undefined ? options.keyboard : true;\n    if (keyboard) {\n      interactions.push(new ol.interaction.KeyboardPan());\n      interactions.push(new ol.interaction.KeyboardZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration\n      }));\n    }\n  \n    var mouseWheelZoom = options.mouseWheelZoom !== undefined ?\n      options.mouseWheelZoom : true;\n    if (mouseWheelZoom) {\n      interactions.push(new ol.interaction.MouseWheelZoom({\n        constrainResolution: options.constrainResolution,\n        duration: options.zoomDuration\n      }));\n    }\n  \n    var shiftDragZoom = options.shiftDragZoom !== undefined ?\n      options.shiftDragZoom : true;\n    if (shiftDragZoom) {\n      interactions.push(new ol.interaction.DragZoom({\n        duration: options.zoomDuration\n      }));\n    }\n  \n    return interactions;\n  \n  };\n  \n  goog.provide('ol.ImageBase');\n  \n  goog.require('ol');\n  goog.require('ol.events.EventTarget');\n  goog.require('ol.events.EventType');\n  \n  \n  /**\n   * @constructor\n   * @abstract\n   * @extends {ol.events.EventTarget}\n   * @param {ol.Extent} extent Extent.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.ImageState} state State.\n   */\n  ol.ImageBase = function(extent, resolution, pixelRatio, state) {\n  \n    ol.events.EventTarget.call(this);\n  \n    /**\n     * @protected\n     * @type {ol.Extent}\n     */\n    this.extent = extent;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n  \n    /**\n     * @protected\n     * @type {number|undefined}\n     */\n    this.resolution = resolution;\n  \n    /**\n     * @protected\n     * @type {ol.ImageState}\n     */\n    this.state = state;\n  \n  };\n  ol.inherits(ol.ImageBase, ol.events.EventTarget);\n  \n  \n  /**\n   * @protected\n   */\n  ol.ImageBase.prototype.changed = function() {\n    this.dispatchEvent(ol.events.EventType.CHANGE);\n  };\n  \n  \n  /**\n   * @return {ol.Extent} Extent.\n   */\n  ol.ImageBase.prototype.getExtent = function() {\n    return this.extent;\n  };\n  \n  \n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|Image|HTMLVideoElement} Image.\n   */\n  ol.ImageBase.prototype.getImage = function() {};\n  \n  \n  /**\n   * @return {number} PixelRatio.\n   */\n  ol.ImageBase.prototype.getPixelRatio = function() {\n    return this.pixelRatio_;\n  };\n  \n  \n  /**\n   * @return {number} Resolution.\n   */\n  ol.ImageBase.prototype.getResolution = function() {\n    return /** @type {number} */ (this.resolution);\n  };\n  \n  \n  /**\n   * @return {ol.ImageState} State.\n   */\n  ol.ImageBase.prototype.getState = function() {\n    return this.state;\n  };\n  \n  \n  /**\n   * Load not yet loaded URI.\n   * @abstract\n   */\n  ol.ImageBase.prototype.load = function() {};\n  \n  goog.provide('ol.ImageState');\n  \n  /**\n   * @enum {number}\n   */\n  ol.ImageState = {\n    IDLE: 0,\n    LOADING: 1,\n    LOADED: 2,\n    ERROR: 3\n  };\n  \n  goog.provide('ol.ImageCanvas');\n  \n  goog.require('ol');\n  goog.require('ol.ImageBase');\n  goog.require('ol.ImageState');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.ImageBase}\n   * @param {ol.Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {ol.ImageCanvasLoader=} opt_loader Optional loader function to\n   *     support asynchronous canvas drawing.\n   */\n  ol.ImageCanvas = function(extent, resolution, pixelRatio, canvas, opt_loader) {\n  \n    /**\n     * Optional canvas loader function.\n     * @type {?ol.ImageCanvasLoader}\n     * @private\n     */\n    this.loader_ = opt_loader !== undefined ? opt_loader : null;\n  \n    var state = opt_loader !== undefined ?\n      ol.ImageState.IDLE : ol.ImageState.LOADED;\n  \n    ol.ImageBase.call(this, extent, resolution, pixelRatio, state);\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = canvas;\n  \n    /**\n     * @private\n     * @type {Error}\n     */\n    this.error_ = null;\n  \n  };\n  ol.inherits(ol.ImageCanvas, ol.ImageBase);\n  \n  \n  /**\n   * Get any error associated with asynchronous rendering.\n   * @return {Error} Any error that occurred during rendering.\n   */\n  ol.ImageCanvas.prototype.getError = function() {\n    return this.error_;\n  };\n  \n  \n  /**\n   * Handle async drawing complete.\n   * @param {Error} err Any error during drawing.\n   * @private\n   */\n  ol.ImageCanvas.prototype.handleLoad_ = function(err) {\n    if (err) {\n      this.error_ = err;\n      this.state = ol.ImageState.ERROR;\n    } else {\n      this.state = ol.ImageState.LOADED;\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.ImageCanvas.prototype.load = function() {\n    if (this.state == ol.ImageState.IDLE) {\n      this.state = ol.ImageState.LOADING;\n      this.changed();\n      this.loader_(this.handleLoad_.bind(this));\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.ImageCanvas.prototype.getImage = function() {\n    return this.canvas_;\n  };\n  \n  goog.provide('ol.LayerType');\n  \n  /**\n   * A layer type used when creating layer renderers.\n   * @enum {string}\n   */\n  ol.LayerType = {\n    IMAGE: 'IMAGE',\n    TILE: 'TILE',\n    VECTOR_TILE: 'VECTOR_TILE',\n    VECTOR: 'VECTOR'\n  };\n  \n  goog.provide('ol.layer.VectorRenderType');\n  \n  /**\n   * @enum {string}\n   * Render mode for vector layers:\n   *  * `'image'`: Vector layers are rendered as images. Great performance, but\n   *    point symbols and texts are always rotated with the view and pixels are\n   *    scaled during zoom animations.\n   *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering\n   *    even during animations, but slower performance.\n   * @api\n   */\n  ol.layer.VectorRenderType = {\n    IMAGE: 'image',\n    VECTOR: 'vector'\n  };\n  \n  goog.provide('ol.render.Event');\n  \n  goog.require('ol');\n  goog.require('ol.events.Event');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.render.Event}\n   * @param {ol.render.EventType} type Type.\n   * @param {ol.render.VectorContext=} opt_vectorContext Vector context.\n   * @param {olx.FrameState=} opt_frameState Frame state.\n   * @param {?CanvasRenderingContext2D=} opt_context Context.\n   * @param {?ol.webgl.Context=} opt_glContext WebGL Context.\n   */\n  ol.render.Event = function(\n      type, opt_vectorContext, opt_frameState, opt_context,\n      opt_glContext) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * For canvas, this is an instance of {@link ol.render.canvas.Immediate}.\n     * @type {ol.render.VectorContext|undefined}\n     * @api\n     */\n    this.vectorContext = opt_vectorContext;\n  \n    /**\n     * An object representing the current render frame state.\n     * @type {olx.FrameState|undefined}\n     * @api\n     */\n    this.frameState = opt_frameState;\n  \n    /**\n     * Canvas context. Only available when a Canvas renderer is used, null\n     * otherwise.\n     * @type {CanvasRenderingContext2D|null|undefined}\n     * @api\n     */\n    this.context = opt_context;\n  \n    /**\n     * WebGL context. Only available when a WebGL renderer is used, null\n     * otherwise.\n     * @type {ol.webgl.Context|null|undefined}\n     * @api\n     */\n    this.glContext = opt_glContext;\n  \n  };\n  ol.inherits(ol.render.Event, ol.events.Event);\n  \n  goog.provide('ol.structs.LRUCache');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.events.EventTarget');\n  goog.require('ol.events.EventType');\n  \n  \n  /**\n   * Implements a Least-Recently-Used cache where the keys do not conflict with\n   * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n   * items from the cache is the responsibility of the user.\n   * @constructor\n   * @extends {ol.events.EventTarget}\n   * @fires ol.events.Event\n   * @struct\n   * @template T\n   * @param {number=} opt_highWaterMark High water mark.\n   */\n  ol.structs.LRUCache = function(opt_highWaterMark) {\n  \n    ol.events.EventTarget.call(this);\n  \n    /**\n     * @type {number}\n     */\n    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n  \n    /**\n     * @private\n     * @type {!Object.<string, ol.LRUCacheEntry>}\n     */\n    this.entries_ = {};\n  \n    /**\n     * @private\n     * @type {?ol.LRUCacheEntry}\n     */\n    this.oldest_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.LRUCacheEntry}\n     */\n    this.newest_ = null;\n  \n  };\n  \n  ol.inherits(ol.structs.LRUCache, ol.events.EventTarget);\n  \n  \n  /**\n   * @return {boolean} Can expire cache.\n   */\n  ol.structs.LRUCache.prototype.canExpireCache = function() {\n    return this.getCount() > this.highWaterMark;\n  };\n  \n  \n  /**\n   * FIXME empty description for jsdoc\n   */\n  ol.structs.LRUCache.prototype.clear = function() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n    this.dispatchEvent(ol.events.EventType.CLEAR);\n  };\n  \n  \n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  ol.structs.LRUCache.prototype.containsKey = function(key) {\n    return this.entries_.hasOwnProperty(key);\n  };\n  \n  \n  /**\n   * @param {function(this: S, T, string, ol.structs.LRUCache): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   * @param {S=} opt_this The object to use as `this` in `f`.\n   * @template S\n   */\n  ol.structs.LRUCache.prototype.forEach = function(f, opt_this) {\n    var entry = this.oldest_;\n    while (entry) {\n      f.call(opt_this, entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  };\n  \n  \n  /**\n   * @param {string} key Key.\n   * @return {T} Value.\n   */\n  ol.structs.LRUCache.prototype.get = function(key) {\n    var entry = this.entries_[key];\n    ol.asserts.assert(entry !== undefined,\n        15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      return entry.value_;\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {ol.LRUCacheEntry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  };\n  \n  \n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  ol.structs.LRUCache.prototype.remove = function(key) {\n    var entry = this.entries_[key];\n    ol.asserts.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {ol.LRUCacheEntry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {ol.LRUCacheEntry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  };\n  \n  \n  /**\n   * @return {number} Count.\n   */\n  ol.structs.LRUCache.prototype.getCount = function() {\n    return this.count_;\n  };\n  \n  \n  /**\n   * @return {Array.<string>} Keys.\n   */\n  ol.structs.LRUCache.prototype.getKeys = function() {\n    var keys = new Array(this.count_);\n    var i = 0;\n    var entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  };\n  \n  \n  /**\n   * @return {Array.<T>} Values.\n   */\n  ol.structs.LRUCache.prototype.getValues = function() {\n    var values = new Array(this.count_);\n    var i = 0;\n    var entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  };\n  \n  \n  /**\n   * @return {T} Last value.\n   */\n  ol.structs.LRUCache.prototype.peekLast = function() {\n    return this.oldest_.value_;\n  };\n  \n  \n  /**\n   * @return {string} Last key.\n   */\n  ol.structs.LRUCache.prototype.peekLastKey = function() {\n    return this.oldest_.key_;\n  };\n  \n  \n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  ol.structs.LRUCache.prototype.peekFirstKey = function() {\n    return this.newest_.key_;\n  };\n  \n  \n  /**\n   * @return {T} value Value.\n   */\n  ol.structs.LRUCache.prototype.pop = function() {\n    var entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {ol.LRUCacheEntry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  };\n  \n  \n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  ol.structs.LRUCache.prototype.replace = function(key, value) {\n    this.get(key);  // update `newest_`\n    this.entries_[key].value_ = value;\n  };\n  \n  \n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  ol.structs.LRUCache.prototype.set = function(key, value) {\n    ol.asserts.assert(!(key in this.entries_),\n        16); // Tried to set a value for a key that is used already\n    var entry = /** @type {ol.LRUCacheEntry} */ ({\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value\n    });\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  };\n  \n  \n  /**\n   * Prune the cache.\n   */\n  ol.structs.LRUCache.prototype.prune = function() {\n    while (this.canExpireCache()) {\n      this.pop();\n    }\n  };\n  \n  goog.provide('ol.render.canvas');\n  \n  \n  goog.require('ol.css');\n  goog.require('ol.dom');\n  goog.require('ol.obj');\n  goog.require('ol.structs.LRUCache');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.render.canvas.defaultFont = '10px sans-serif';\n  \n  \n  /**\n   * @const\n   * @type {ol.Color}\n   */\n  ol.render.canvas.defaultFillStyle = [0, 0, 0, 1];\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.render.canvas.defaultLineCap = 'round';\n  \n  \n  /**\n   * @const\n   * @type {Array.<number>}\n   */\n  ol.render.canvas.defaultLineDash = [];\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.canvas.defaultLineDashOffset = 0;\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.render.canvas.defaultLineJoin = 'round';\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.canvas.defaultMiterLimit = 10;\n  \n  \n  /**\n   * @const\n   * @type {ol.Color}\n   */\n  ol.render.canvas.defaultStrokeStyle = [0, 0, 0, 1];\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.render.canvas.defaultTextAlign = 'center';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.render.canvas.defaultTextBaseline = 'middle';\n  \n  \n  /**\n   * @const\n   * @type {Array.<number>}\n   */\n  ol.render.canvas.defaultPadding = [0, 0, 0, 0];\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.canvas.defaultLineWidth = 1;\n  \n  \n  /**\n   * @type {ol.structs.LRUCache.<HTMLCanvasElement>}\n   */\n  ol.render.canvas.labelCache = new ol.structs.LRUCache();\n  \n  \n  /**\n   * @type {!Object.<string, number>}\n   */\n  ol.render.canvas.checkedFonts_ = {};\n  \n  \n  /**\n   * @type {CanvasRenderingContext2D}\n   */\n  ol.render.canvas.measureContext_ = null;\n  \n  \n  /**\n   * @type {!Object.<string, number>}\n   */\n  ol.render.canvas.textHeights_ = {};\n  \n  \n  /**\n   * Clears the label cache when a font becomes available.\n   * @param {string} fontSpec CSS font spec.\n   */\n  ol.render.canvas.checkFont = (function() {\n    var retries = 60;\n    var checked = ol.render.canvas.checkedFonts_;\n    var labelCache = ol.render.canvas.labelCache;\n    var font = '32px monospace';\n    var text = 'wmytzilWMYTZIL@#/&?$%10';\n    var interval, referenceWidth;\n  \n    function isAvailable(fontFamily) {\n      var context = ol.render.canvas.getMeasureContext();\n      context.font = font;\n      referenceWidth = context.measureText(text).width;\n      var available = true;\n      if (fontFamily != 'monospace') {\n        context.font = '32px ' + fontFamily + ',monospace';\n        var width = context.measureText(text).width;\n        // If width and referenceWidth are the same, then the 'monospace'\n        // fallback was used instead of the font we wanted, so the font is not\n        // available.\n        available = width != referenceWidth;\n      }\n      return available;\n    }\n  \n    function check() {\n      var done = true;\n      for (var font in checked) {\n        if (checked[font] < retries) {\n          if (isAvailable(font)) {\n            checked[font] = retries;\n            ol.obj.clear(ol.render.canvas.textHeights_);\n            // Make sure that loaded fonts are picked up by Safari\n            ol.render.canvas.measureContext_ = null;\n            labelCache.clear();\n          } else {\n            ++checked[font];\n            done = false;\n          }\n        }\n      }\n      if (done) {\n        window.clearInterval(interval);\n        interval = undefined;\n      }\n    }\n  \n    return function(fontSpec) {\n      var fontFamilies = ol.css.getFontFamilies(fontSpec);\n      if (!fontFamilies) {\n        return;\n      }\n      for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {\n        var fontFamily = fontFamilies[i];\n        if (!(fontFamily in checked)) {\n          checked[fontFamily] = retries;\n          if (!isAvailable(fontFamily)) {\n            checked[fontFamily] = 0;\n            if (interval === undefined) {\n              interval = window.setInterval(check, 32);\n            }\n          }\n        }\n      }\n    };\n  })();\n  \n  \n  /**\n   * @return {CanvasRenderingContext2D} Measure context.\n   */\n  ol.render.canvas.getMeasureContext = function() {\n    var context = ol.render.canvas.measureContext_;\n    if (!context) {\n      context = ol.render.canvas.measureContext_ = ol.dom.createCanvasContext2D(1, 1);\n    }\n    return context;\n  };\n  \n  \n  /**\n   * @param {string} font Font to use for measuring.\n   * @return {ol.Size} Measurement.\n   */\n  ol.render.canvas.measureTextHeight = (function() {\n    var span;\n    var heights = ol.render.canvas.textHeights_;\n    return function(font) {\n      var height = heights[font];\n      if (height == undefined) {\n        if (!span) {\n          span = document.createElement('span');\n          span.textContent = 'M';\n          span.style.margin = span.style.padding = '0 !important';\n          span.style.position = 'absolute !important';\n          span.style.left = '-99999px !important';\n        }\n        span.style.font = font;\n        document.body.appendChild(span);\n        height = heights[font] = span.offsetHeight;\n        document.body.removeChild(span);\n      }\n      return height;\n    };\n  })();\n  \n  \n  /**\n   * @param {string} font Font.\n   * @param {string} text Text.\n   * @return {number} Width.\n   */\n  ol.render.canvas.measureTextWidth = function(font, text) {\n    var measureContext = ol.render.canvas.getMeasureContext();\n    if (font != measureContext.font) {\n      measureContext.font = font;\n    }\n    return measureContext.measureText(text).width;\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} rotation Rotation.\n   * @param {number} offsetX X offset.\n   * @param {number} offsetY Y offset.\n   */\n  ol.render.canvas.rotateAtOffset = function(context, rotation, offsetX, offsetY) {\n    if (rotation !== 0) {\n      context.translate(offsetX, offsetY);\n      context.rotate(rotation);\n      context.translate(-offsetX, -offsetY);\n    }\n  };\n  \n  \n  ol.render.canvas.resetTransform_ = ol.transform.create();\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {ol.Transform|null} transform Transform.\n   * @param {number} opacity Opacity.\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} w Width.\n   * @param {number} h Height.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} scale Scale.\n   */\n  ol.render.canvas.drawImage = function(context,\n      transform, opacity, image, originX, originY, w, h, x, y, scale) {\n    var alpha;\n    if (opacity != 1) {\n      alpha = context.globalAlpha;\n      context.globalAlpha = alpha * opacity;\n    }\n    if (transform) {\n      context.setTransform.apply(context, transform);\n    }\n  \n    context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);\n  \n    if (alpha) {\n      context.globalAlpha = alpha;\n    }\n    if (transform) {\n      context.setTransform.apply(context, ol.render.canvas.resetTransform_);\n    }\n  };\n  \n  goog.provide('ol.color');\n  \n  goog.require('ol.asserts');\n  goog.require('ol.math');\n  \n  \n  /**\n   * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n   * @const\n   * @type {RegExp}\n   * @private\n   */\n  ol.color.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3,4}){1,2}$/i;\n  \n  \n  /**\n   * Regular expression for matching potential named color style strings.\n   * @const\n   * @type {RegExp}\n   * @private\n   */\n  ol.color.NAMED_COLOR_RE_ = /^([a-z]*)$/i;\n  \n  \n  /**\n   * Return the color as an array. This function maintains a cache of calculated\n   * arrays which means the result should not be modified.\n   * @param {ol.Color|string} color Color.\n   * @return {ol.Color} Color.\n   * @api\n   */\n  ol.color.asArray = function(color) {\n    if (Array.isArray(color)) {\n      return color;\n    } else {\n      return ol.color.fromString(/** @type {string} */ (color));\n    }\n  };\n  \n  \n  /**\n   * Return the color as an rgba string.\n   * @param {ol.Color|string} color Color.\n   * @return {string} Rgba string.\n   * @api\n   */\n  ol.color.asString = function(color) {\n    if (typeof color === 'string') {\n      return color;\n    } else {\n      return ol.color.toString(color);\n    }\n  };\n  \n  /**\n   * Return named color as an rgba string.\n   * @param {string} color Named color.\n   * @return {string} Rgb string.\n   */\n  ol.color.fromNamed = function(color) {\n    var el = document.createElement('div');\n    el.style.color = color;\n    document.body.appendChild(el);\n    var rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  };\n  \n  \n  /**\n   * @param {string} s String.\n   * @return {ol.Color} Color.\n   */\n  ol.color.fromString = (\n    function() {\n  \n      // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n      // semantics, whenever the cache grows too large we simply delete an\n      // arbitrary 25% of the entries.\n  \n      /**\n       * @const\n       * @type {number}\n       */\n      var MAX_CACHE_SIZE = 1024;\n  \n      /**\n       * @type {Object.<string, ol.Color>}\n       */\n      var cache = {};\n  \n      /**\n       * @type {number}\n       */\n      var cacheSize = 0;\n  \n      return (\n        /**\n         * @param {string} s String.\n         * @return {ol.Color} Color.\n         */\n        function(s) {\n          var color;\n          if (cache.hasOwnProperty(s)) {\n            color = cache[s];\n          } else {\n            if (cacheSize >= MAX_CACHE_SIZE) {\n              var i = 0;\n              var key;\n              for (key in cache) {\n                if ((i++ & 3) === 0) {\n                  delete cache[key];\n                  --cacheSize;\n                }\n              }\n            }\n            color = ol.color.fromStringInternal_(s);\n            cache[s] = color;\n            ++cacheSize;\n          }\n          return color;\n        });\n  \n    })();\n  \n  \n  /**\n   * @param {string} s String.\n   * @private\n   * @return {ol.Color} Color.\n   */\n  ol.color.fromStringInternal_ = function(s) {\n    var r, g, b, a, color, parts;\n  \n    if (ol.color.NAMED_COLOR_RE_.exec(s)) {\n      s = ol.color.fromNamed(s);\n    }\n  \n    if (ol.color.HEX_COLOR_RE_.exec(s)) { // hex\n      var n = s.length - 1; // number of hex digits\n      var d; // number of digits per channel\n      if (n <= 4) {\n        d = 1;\n      } else {\n        d = 2;\n      }\n      var hasAlpha = n === 4 || n === 8;\n      r = parseInt(s.substr(1 + 0 * d, d), 16);\n      g = parseInt(s.substr(1 + 1 * d, d), 16);\n      b = parseInt(s.substr(1 + 2 * d, d), 16);\n      if (hasAlpha) {\n        a = parseInt(s.substr(1 + 3 * d, d), 16);\n      } else {\n        a = 255;\n      }\n      if (d == 1) {\n        r = (r << 4) + r;\n        g = (g << 4) + g;\n        b = (b << 4) + b;\n        if (hasAlpha) {\n          a = (a << 4) + a;\n        }\n      }\n      color = [r, g, b, a / 255];\n    } else if (s.indexOf('rgba(') == 0) { // rgba()\n      parts = s.slice(5, -1).split(',').map(Number);\n      color = ol.color.normalize(parts);\n    } else if (s.indexOf('rgb(') == 0) { // rgb()\n      parts = s.slice(4, -1).split(',').map(Number);\n      parts.push(1);\n      color = ol.color.normalize(parts);\n    } else {\n      ol.asserts.assert(false, 14); // Invalid color\n    }\n    return /** @type {ol.Color} */ (color);\n  };\n  \n  \n  /**\n   * @param {ol.Color} color Color.\n   * @param {ol.Color=} opt_color Color.\n   * @return {ol.Color} Clamped color.\n   */\n  ol.color.normalize = function(color, opt_color) {\n    var result = opt_color || [];\n    result[0] = ol.math.clamp((color[0] + 0.5) | 0, 0, 255);\n    result[1] = ol.math.clamp((color[1] + 0.5) | 0, 0, 255);\n    result[2] = ol.math.clamp((color[2] + 0.5) | 0, 0, 255);\n    result[3] = ol.math.clamp(color[3], 0, 1);\n    return result;\n  };\n  \n  \n  /**\n   * @param {ol.Color} color Color.\n   * @return {string} String.\n   */\n  ol.color.toString = function(color) {\n    var r = color[0];\n    if (r != (r | 0)) {\n      r = (r + 0.5) | 0;\n    }\n    var g = color[1];\n    if (g != (g | 0)) {\n      g = (g + 0.5) | 0;\n    }\n    var b = color[2];\n    if (b != (b | 0)) {\n      b = (b + 0.5) | 0;\n    }\n    var a = color[3] === undefined ? 1 : color[3];\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n  };\n  \n  goog.provide('ol.colorlike');\n  \n  goog.require('ol.color');\n  \n  \n  /**\n   * @param {ol.Color|ol.ColorLike} color Color.\n   * @return {ol.ColorLike} The color as an ol.ColorLike\n   * @api\n   */\n  ol.colorlike.asColorLike = function(color) {\n    if (ol.colorlike.isColorLike(color)) {\n      return /** @type {string|CanvasPattern|CanvasGradient} */ (color);\n    } else {\n      return ol.color.asString(/** @type {ol.Color} */ (color));\n    }\n  };\n  \n  \n  /**\n   * @param {?} color The value that is potentially an ol.ColorLike\n   * @return {boolean} Whether the color is an ol.ColorLike\n   */\n  ol.colorlike.isColorLike = function(color) {\n    return (\n      typeof color === 'string' ||\n      color instanceof CanvasPattern ||\n      color instanceof CanvasGradient\n    );\n  };\n  \n  goog.provide('ol.render.VectorContext');\n  \n  \n  /**\n   * Context for drawing geometries.  A vector context is available on render\n   * events and does not need to be constructed directly.\n   * @constructor\n   * @abstract\n   * @struct\n   * @api\n   */\n  ol.render.VectorContext = function() {\n  };\n  \n  \n  /**\n   * Render a geometry with a custom renderer.\n   *\n   * @param {ol.geom.SimpleGeometry} geometry Geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @param {Function} renderer Renderer.\n   */\n  ol.render.VectorContext.prototype.drawCustom = function(geometry, feature, renderer) {};\n  \n  \n  /**\n   * Render a geometry.\n   *\n   * @param {ol.geom.Geometry} geometry The geometry to render.\n   */\n  ol.render.VectorContext.prototype.drawGeometry = function(geometry) {};\n  \n  \n  /**\n   * Set the rendering style.\n   *\n   * @param {ol.style.Style} style The rendering style.\n   */\n  ol.render.VectorContext.prototype.setStyle = function(style) {};\n  \n  \n  /**\n   * @param {ol.geom.Circle} circleGeometry Circle geometry.\n   * @param {ol.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawCircle = function(circleGeometry, feature) {};\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @param {ol.style.Style} style Style.\n   */\n  ol.render.VectorContext.prototype.drawFeature = function(feature, style) {};\n  \n  \n  /**\n   * @param {ol.geom.GeometryCollection} geometryCollectionGeometry Geometry\n   *     collection.\n   * @param {ol.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature) {};\n  \n  \n  /**\n   * @param {ol.geom.LineString|ol.render.Feature} lineStringGeometry Line\n   *     string geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawLineString = function(lineStringGeometry, feature) {};\n  \n  \n  /**\n   * @param {ol.geom.MultiLineString|ol.render.Feature} multiLineStringGeometry\n   *     MultiLineString geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {};\n  \n  \n  /**\n   * @param {ol.geom.MultiPoint|ol.render.Feature} multiPointGeometry MultiPoint\n   *     geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawMultiPoint = function(multiPointGeometry, feature) {};\n  \n  \n  /**\n   * @param {ol.geom.MultiPolygon} multiPolygonGeometry MultiPolygon geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {};\n  \n  \n  /**\n   * @param {ol.geom.Point|ol.render.Feature} pointGeometry Point geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawPoint = function(pointGeometry, feature) {};\n  \n  \n  /**\n   * @param {ol.geom.Polygon|ol.render.Feature} polygonGeometry Polygon\n   *     geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawPolygon = function(polygonGeometry, feature) {};\n  \n  \n  /**\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.VectorContext.prototype.drawText = function(geometry, feature) {};\n  \n  \n  /**\n   * @param {ol.style.Fill} fillStyle Fill style.\n   * @param {ol.style.Stroke} strokeStyle Stroke style.\n   */\n  ol.render.VectorContext.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {};\n  \n  \n  /**\n   * @param {ol.style.Image} imageStyle Image style.\n   * @param {ol.DeclutterGroup=} opt_declutterGroup Declutter.\n   */\n  ol.render.VectorContext.prototype.setImageStyle = function(imageStyle, opt_declutterGroup) {};\n  \n  \n  /**\n   * @param {ol.style.Text} textStyle Text style.\n   * @param {ol.DeclutterGroup=} opt_declutterGroup Declutter.\n   */\n  ol.render.VectorContext.prototype.setTextStyle = function(textStyle, opt_declutterGroup) {};\n  \n  // FIXME test, especially polygons with holes and multipolygons\n  // FIXME need to handle large thick features (where pixel size matters)\n  // FIXME add offset and end to ol.geom.flat.transform.transform2D?\n  \n  goog.provide('ol.render.canvas.Immediate');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.colorlike');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.has');\n  goog.require('ol.render.VectorContext');\n  goog.require('ol.render.canvas');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @classdesc\n   * A concrete subclass of {@link ol.render.VectorContext} that implements\n   * direct rendering of features and geometries to an HTML5 Canvas context.\n   * Instances of this class are created internally by the library and\n   * provided to application code as vectorContext member of the\n   * {@link ol.render.Event} object associated with postcompose, precompose and\n   * render events emitted by layers and maps.\n   *\n   * @constructor\n   * @extends {ol.render.VectorContext}\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @struct\n   */\n  ol.render.canvas.Immediate = function(context, pixelRatio, extent, transform, viewRotation) {\n    ol.render.VectorContext.call(this);\n  \n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context_ = context;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.extent_ = extent;\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.transform_ = transform;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = viewRotation;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasFillState}\n     */\n    this.contextFillState_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasStrokeState}\n     */\n    this.contextStrokeState_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasTextState}\n     */\n    this.contextTextState_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasFillState}\n     */\n    this.fillState_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasStrokeState}\n     */\n    this.strokeState_ = null;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLVideoElement|Image}\n     */\n    this.image_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageAnchorX_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageAnchorY_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageHeight_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageOpacity_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageOriginX_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageOriginY_ = 0;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.imageRotateWithView_ = false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageRotation_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageScale_ = 0;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.imageSnapToPixel_ = false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.imageWidth_ = 0;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.text_ = '';\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetX_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetY_ = 0;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.textRotateWithView_ = false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.textRotation_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.textScale_ = 0;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasFillState}\n     */\n    this.textFillState_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasStrokeState}\n     */\n    this.textStrokeState_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasTextState}\n     */\n    this.textState_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.pixelCoordinates_ = [];\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.tmpLocalTransform_ = ol.transform.create();\n  \n  };\n  ol.inherits(ol.render.canvas.Immediate, ol.render.VectorContext);\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   */\n  ol.render.canvas.Immediate.prototype.drawImages_ = function(flatCoordinates, offset, end, stride) {\n    if (!this.image_) {\n      return;\n    }\n    var pixelCoordinates = ol.geom.flat.transform.transform2D(\n        flatCoordinates, offset, end, 2, this.transform_,\n        this.pixelCoordinates_);\n    var context = this.context_;\n    var localTransform = this.tmpLocalTransform_;\n    var alpha = context.globalAlpha;\n    if (this.imageOpacity_ != 1) {\n      context.globalAlpha = alpha * this.imageOpacity_;\n    }\n    var rotation = this.imageRotation_;\n    if (this.imageRotateWithView_) {\n      rotation += this.viewRotation_;\n    }\n    var i, ii;\n    for (i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {\n      var x = pixelCoordinates[i] - this.imageAnchorX_;\n      var y = pixelCoordinates[i + 1] - this.imageAnchorY_;\n      if (this.imageSnapToPixel_) {\n        x = Math.round(x);\n        y = Math.round(y);\n      }\n      if (rotation !== 0 || this.imageScale_ != 1) {\n        var centerX = x + this.imageAnchorX_;\n        var centerY = y + this.imageAnchorY_;\n        ol.transform.compose(localTransform,\n            centerX, centerY,\n            this.imageScale_, this.imageScale_,\n            rotation,\n            -centerX, -centerY);\n        context.setTransform.apply(context, localTransform);\n      }\n      context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_,\n          this.imageWidth_, this.imageHeight_, x, y,\n          this.imageWidth_, this.imageHeight_);\n    }\n    if (rotation !== 0 || this.imageScale_ != 1) {\n      context.setTransform(1, 0, 0, 1, 0, 0);\n    }\n    if (this.imageOpacity_ != 1) {\n      context.globalAlpha = alpha;\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   */\n  ol.render.canvas.Immediate.prototype.drawText_ = function(flatCoordinates, offset, end, stride) {\n    if (!this.textState_ || this.text_ === '') {\n      return;\n    }\n    if (this.textFillState_) {\n      this.setContextFillState_(this.textFillState_);\n    }\n    if (this.textStrokeState_) {\n      this.setContextStrokeState_(this.textStrokeState_);\n    }\n    this.setContextTextState_(this.textState_);\n    var pixelCoordinates = ol.geom.flat.transform.transform2D(\n        flatCoordinates, offset, end, stride, this.transform_,\n        this.pixelCoordinates_);\n    var context = this.context_;\n    var rotation = this.textRotation_;\n    if (this.textRotateWithView_) {\n      rotation += this.viewRotation_;\n    }\n    for (; offset < end; offset += stride) {\n      var x = pixelCoordinates[offset] + this.textOffsetX_;\n      var y = pixelCoordinates[offset + 1] + this.textOffsetY_;\n      if (rotation !== 0 || this.textScale_ != 1) {\n        var localTransform = ol.transform.compose(this.tmpLocalTransform_,\n            x, y,\n            this.textScale_, this.textScale_,\n            rotation,\n            -x, -y);\n        context.setTransform.apply(context, localTransform);\n      }\n      if (this.textStrokeState_) {\n        context.strokeText(this.text_, x, y);\n      }\n      if (this.textFillState_) {\n        context.fillText(this.text_, x, y);\n      }\n    }\n    if (rotation !== 0 || this.textScale_ != 1) {\n      context.setTransform(1, 0, 0, 1, 0, 0);\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} close Close.\n   * @private\n   * @return {number} end End.\n   */\n  ol.render.canvas.Immediate.prototype.moveToLineTo_ = function(flatCoordinates, offset, end, stride, close) {\n    var context = this.context_;\n    var pixelCoordinates = ol.geom.flat.transform.transform2D(\n        flatCoordinates, offset, end, stride, this.transform_,\n        this.pixelCoordinates_);\n    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);\n    var length = pixelCoordinates.length;\n    if (close) {\n      length -= 2;\n    }\n    for (var i = 2; i < length; i += 2) {\n      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);\n    }\n    if (close) {\n      context.closePath();\n    }\n    return end;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  ol.render.canvas.Immediate.prototype.drawRings_ = function(flatCoordinates, offset, ends, stride) {\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      offset = this.moveToLineTo_(\n          flatCoordinates, offset, ends[i], stride, true);\n    }\n    return offset;\n  };\n  \n  \n  /**\n   * Render a circle geometry into the canvas.  Rendering is immediate and uses\n   * the current fill and stroke styles.\n   *\n   * @param {ol.geom.Circle} geometry Circle geometry.\n   * @override\n   * @api\n   */\n  ol.render.canvas.Immediate.prototype.drawCircle = function(geometry) {\n    if (!ol.extent.intersects(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    if (this.fillState_ || this.strokeState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n      var pixelCoordinates = ol.geom.SimpleGeometry.transform2D(\n          geometry, this.transform_, this.pixelCoordinates_);\n      var dx = pixelCoordinates[2] - pixelCoordinates[0];\n      var dy = pixelCoordinates[3] - pixelCoordinates[1];\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      var context = this.context_;\n      context.beginPath();\n      context.arc(\n          pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);\n      if (this.fillState_) {\n        context.fill();\n      }\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n    if (this.text_ !== '') {\n      this.drawText_(geometry.getCenter(), 0, 2, 2);\n    }\n  };\n  \n  \n  /**\n   * Set the rendering style.  Note that since this is an immediate rendering API,\n   * any `zIndex` on the provided style will be ignored.\n   *\n   * @param {ol.style.Style} style The rendering style.\n   * @override\n   * @api\n   */\n  ol.render.canvas.Immediate.prototype.setStyle = function(style) {\n    this.setFillStrokeStyle(style.getFill(), style.getStroke());\n    this.setImageStyle(style.getImage());\n    this.setTextStyle(style.getText());\n  };\n  \n  \n  /**\n   * Render a geometry into the canvas.  Call\n   * {@link ol.render.canvas.Immediate#setStyle} first to set the rendering style.\n   *\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.\n   * @override\n   * @api\n   */\n  ol.render.canvas.Immediate.prototype.drawGeometry = function(geometry) {\n    var type = geometry.getType();\n    switch (type) {\n      case ol.geom.GeometryType.POINT:\n        this.drawPoint(/** @type {ol.geom.Point} */ (geometry));\n        break;\n      case ol.geom.GeometryType.LINE_STRING:\n        this.drawLineString(/** @type {ol.geom.LineString} */ (geometry));\n        break;\n      case ol.geom.GeometryType.POLYGON:\n        this.drawPolygon(/** @type {ol.geom.Polygon} */ (geometry));\n        break;\n      case ol.geom.GeometryType.MULTI_POINT:\n        this.drawMultiPoint(/** @type {ol.geom.MultiPoint} */ (geometry));\n        break;\n      case ol.geom.GeometryType.MULTI_LINE_STRING:\n        this.drawMultiLineString(/** @type {ol.geom.MultiLineString} */ (geometry));\n        break;\n      case ol.geom.GeometryType.MULTI_POLYGON:\n        this.drawMultiPolygon(/** @type {ol.geom.MultiPolygon} */ (geometry));\n        break;\n      case ol.geom.GeometryType.GEOMETRY_COLLECTION:\n        this.drawGeometryCollection(/** @type {ol.geom.GeometryCollection} */ (geometry));\n        break;\n      case ol.geom.GeometryType.CIRCLE:\n        this.drawCircle(/** @type {ol.geom.Circle} */ (geometry));\n        break;\n      default:\n    }\n  };\n  \n  \n  /**\n   * Render a feature into the canvas.  Note that any `zIndex` on the provided\n   * style will be ignored - features are rendered immediately in the order that\n   * this method is called.  If you need `zIndex` support, you should be using an\n   * {@link ol.layer.Vector} instead.\n   *\n   * @param {ol.Feature} feature Feature.\n   * @param {ol.style.Style} style Style.\n   * @override\n   * @api\n   */\n  ol.render.canvas.Immediate.prototype.drawFeature = function(feature, style) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry ||\n        !ol.extent.intersects(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    this.setStyle(style);\n    this.drawGeometry(geometry);\n  };\n  \n  \n  /**\n   * Render a GeometryCollection to the canvas.  Rendering is immediate and\n   * uses the current styles appropriate for each geometry in the collection.\n   *\n   * @param {ol.geom.GeometryCollection} geometry Geometry collection.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.drawGeometryCollection = function(geometry) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      this.drawGeometry(geometries[i]);\n    }\n  };\n  \n  \n  /**\n   * Render a Point geometry into the canvas.  Rendering is immediate and uses\n   * the current style.\n   *\n   * @param {ol.geom.Point|ol.render.Feature} geometry Point geometry.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.drawPoint = function(geometry) {\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n    if (this.image_) {\n      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n    if (this.text_ !== '') {\n      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n  };\n  \n  \n  /**\n   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and\n   * uses the current style.\n   *\n   * @param {ol.geom.MultiPoint|ol.render.Feature} geometry MultiPoint geometry.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.drawMultiPoint = function(geometry) {\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n    if (this.image_) {\n      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n    if (this.text_ !== '') {\n      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n  };\n  \n  \n  /**\n   * Render a LineString into the canvas.  Rendering is immediate and uses\n   * the current style.\n   *\n   * @param {ol.geom.LineString|ol.render.Feature} geometry LineString geometry.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.drawLineString = function(geometry) {\n    if (!ol.extent.intersects(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    if (this.strokeState_) {\n      this.setContextStrokeState_(this.strokeState_);\n      var context = this.context_;\n      var flatCoordinates = geometry.getFlatCoordinates();\n      context.beginPath();\n      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length,\n          geometry.getStride(), false);\n      context.stroke();\n    }\n    if (this.text_ !== '') {\n      var flatMidpoint = geometry.getFlatMidpoint();\n      this.drawText_(flatMidpoint, 0, 2, 2);\n    }\n  };\n  \n  \n  /**\n   * Render a MultiLineString geometry into the canvas.  Rendering is immediate\n   * and uses the current style.\n   *\n   * @param {ol.geom.MultiLineString|ol.render.Feature} geometry MultiLineString\n   *     geometry.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.drawMultiLineString = function(geometry) {\n    var geometryExtent = geometry.getExtent();\n    if (!ol.extent.intersects(this.extent_, geometryExtent)) {\n      return;\n    }\n    if (this.strokeState_) {\n      this.setContextStrokeState_(this.strokeState_);\n      var context = this.context_;\n      var flatCoordinates = geometry.getFlatCoordinates();\n      var offset = 0;\n      var ends = geometry.getEnds();\n      var stride = geometry.getStride();\n      context.beginPath();\n      var i, ii;\n      for (i = 0, ii = ends.length; i < ii; ++i) {\n        offset = this.moveToLineTo_(\n            flatCoordinates, offset, ends[i], stride, false);\n      }\n      context.stroke();\n    }\n    if (this.text_ !== '') {\n      var flatMidpoints = geometry.getFlatMidpoints();\n      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);\n    }\n  };\n  \n  \n  /**\n   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses\n   * the current style.\n   *\n   * @param {ol.geom.Polygon|ol.render.Feature} geometry Polygon geometry.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.drawPolygon = function(geometry) {\n    if (!ol.extent.intersects(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    if (this.strokeState_ || this.fillState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n      var context = this.context_;\n      context.beginPath();\n      this.drawRings_(geometry.getOrientedFlatCoordinates(),\n          0, geometry.getEnds(), geometry.getStride());\n      if (this.fillState_) {\n        context.fill();\n      }\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n    if (this.text_ !== '') {\n      var flatInteriorPoint = geometry.getFlatInteriorPoint();\n      this.drawText_(flatInteriorPoint, 0, 2, 2);\n    }\n  };\n  \n  \n  /**\n   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and\n   * uses the current style.\n   * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.drawMultiPolygon = function(geometry) {\n    if (!ol.extent.intersects(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    if (this.strokeState_ || this.fillState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n      var context = this.context_;\n      var flatCoordinates = geometry.getOrientedFlatCoordinates();\n      var offset = 0;\n      var endss = geometry.getEndss();\n      var stride = geometry.getStride();\n      var i, ii;\n      context.beginPath();\n      for (i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        offset = this.drawRings_(flatCoordinates, offset, ends, stride);\n      }\n      if (this.fillState_) {\n        context.fill();\n      }\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n    if (this.text_ !== '') {\n      var flatInteriorPoints = geometry.getFlatInteriorPoints();\n      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.CanvasFillState} fillState Fill state.\n   * @private\n   */\n  ol.render.canvas.Immediate.prototype.setContextFillState_ = function(fillState) {\n    var context = this.context_;\n    var contextFillState = this.contextFillState_;\n    if (!contextFillState) {\n      context.fillStyle = fillState.fillStyle;\n      this.contextFillState_ = {\n        fillStyle: fillState.fillStyle\n      };\n    } else {\n      if (contextFillState.fillStyle != fillState.fillStyle) {\n        contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.CanvasStrokeState} strokeState Stroke state.\n   * @private\n   */\n  ol.render.canvas.Immediate.prototype.setContextStrokeState_ = function(strokeState) {\n    var context = this.context_;\n    var contextStrokeState = this.contextStrokeState_;\n    if (!contextStrokeState) {\n      context.lineCap = strokeState.lineCap;\n      if (ol.has.CANVAS_LINE_DASH) {\n        context.setLineDash(strokeState.lineDash);\n        context.lineDashOffset = strokeState.lineDashOffset;\n      }\n      context.lineJoin = strokeState.lineJoin;\n      context.lineWidth = strokeState.lineWidth;\n      context.miterLimit = strokeState.miterLimit;\n      context.strokeStyle = strokeState.strokeStyle;\n      this.contextStrokeState_ = {\n        lineCap: strokeState.lineCap,\n        lineDash: strokeState.lineDash,\n        lineDashOffset: strokeState.lineDashOffset,\n        lineJoin: strokeState.lineJoin,\n        lineWidth: strokeState.lineWidth,\n        miterLimit: strokeState.miterLimit,\n        strokeStyle: strokeState.strokeStyle\n      };\n    } else {\n      if (contextStrokeState.lineCap != strokeState.lineCap) {\n        contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;\n      }\n      if (ol.has.CANVAS_LINE_DASH) {\n        if (!ol.array.equals(\n            contextStrokeState.lineDash, strokeState.lineDash)) {\n          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);\n        }\n        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {\n          contextStrokeState.lineDashOffset = context.lineDashOffset =\n              strokeState.lineDashOffset;\n        }\n      }\n      if (contextStrokeState.lineJoin != strokeState.lineJoin) {\n        contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;\n      }\n      if (contextStrokeState.lineWidth != strokeState.lineWidth) {\n        contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;\n      }\n      if (contextStrokeState.miterLimit != strokeState.miterLimit) {\n        contextStrokeState.miterLimit = context.miterLimit =\n            strokeState.miterLimit;\n      }\n      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {\n        contextStrokeState.strokeStyle = context.strokeStyle =\n            strokeState.strokeStyle;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.CanvasTextState} textState Text state.\n   * @private\n   */\n  ol.render.canvas.Immediate.prototype.setContextTextState_ = function(textState) {\n    var context = this.context_;\n    var contextTextState = this.contextTextState_;\n    var textAlign = textState.textAlign ?\n      textState.textAlign : ol.render.canvas.defaultTextAlign;\n    if (!contextTextState) {\n      context.font = textState.font;\n      context.textAlign = textAlign;\n      context.textBaseline = textState.textBaseline;\n      this.contextTextState_ = {\n        font: textState.font,\n        textAlign: textAlign,\n        textBaseline: textState.textBaseline\n      };\n    } else {\n      if (contextTextState.font != textState.font) {\n        contextTextState.font = context.font = textState.font;\n      }\n      if (contextTextState.textAlign != textAlign) {\n        contextTextState.textAlign = textAlign;\n      }\n      if (contextTextState.textBaseline != textState.textBaseline) {\n        contextTextState.textBaseline = context.textBaseline =\n            textState.textBaseline;\n      }\n    }\n  };\n  \n  \n  /**\n   * Set the fill and stroke style for subsequent draw operations.  To clear\n   * either fill or stroke styles, pass null for the appropriate parameter.\n   *\n   * @param {ol.style.Fill} fillStyle Fill style.\n   * @param {ol.style.Stroke} strokeStyle Stroke style.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n    if (!fillStyle) {\n      this.fillState_ = null;\n    } else {\n      var fillStyleColor = fillStyle.getColor();\n      this.fillState_ = {\n        fillStyle: ol.colorlike.asColorLike(fillStyleColor ?\n          fillStyleColor : ol.render.canvas.defaultFillStyle)\n      };\n    }\n    if (!strokeStyle) {\n      this.strokeState_ = null;\n    } else {\n      var strokeStyleColor = strokeStyle.getColor();\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      var strokeStyleWidth = strokeStyle.getWidth();\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      this.strokeState_ = {\n        lineCap: strokeStyleLineCap !== undefined ?\n          strokeStyleLineCap : ol.render.canvas.defaultLineCap,\n        lineDash: strokeStyleLineDash ?\n          strokeStyleLineDash : ol.render.canvas.defaultLineDash,\n        lineDashOffset: strokeStyleLineDashOffset ?\n          strokeStyleLineDashOffset : ol.render.canvas.defaultLineDashOffset,\n        lineJoin: strokeStyleLineJoin !== undefined ?\n          strokeStyleLineJoin : ol.render.canvas.defaultLineJoin,\n        lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ?\n          strokeStyleWidth : ol.render.canvas.defaultLineWidth),\n        miterLimit: strokeStyleMiterLimit !== undefined ?\n          strokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit,\n        strokeStyle: ol.colorlike.asColorLike(strokeStyleColor ?\n          strokeStyleColor : ol.render.canvas.defaultStrokeStyle)\n      };\n    }\n  };\n  \n  \n  /**\n   * Set the image style for subsequent draw operations.  Pass null to remove\n   * the image style.\n   *\n   * @param {ol.style.Image} imageStyle Image style.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.setImageStyle = function(imageStyle) {\n    if (!imageStyle) {\n      this.image_ = null;\n    } else {\n      var imageAnchor = imageStyle.getAnchor();\n      // FIXME pixel ratio\n      var imageImage = imageStyle.getImage(1);\n      var imageOrigin = imageStyle.getOrigin();\n      var imageSize = imageStyle.getSize();\n      this.imageAnchorX_ = imageAnchor[0];\n      this.imageAnchorY_ = imageAnchor[1];\n      this.imageHeight_ = imageSize[1];\n      this.image_ = imageImage;\n      this.imageOpacity_ = imageStyle.getOpacity();\n      this.imageOriginX_ = imageOrigin[0];\n      this.imageOriginY_ = imageOrigin[1];\n      this.imageRotateWithView_ = imageStyle.getRotateWithView();\n      this.imageRotation_ = imageStyle.getRotation();\n      this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;\n      this.imageSnapToPixel_ = imageStyle.getSnapToPixel();\n      this.imageWidth_ = imageSize[0];\n    }\n  };\n  \n  \n  /**\n   * Set the text style for subsequent draw operations.  Pass null to\n   * remove the text style.\n   *\n   * @param {ol.style.Text} textStyle Text style.\n   * @override\n   */\n  ol.render.canvas.Immediate.prototype.setTextStyle = function(textStyle) {\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      var textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        this.textFillState_ = null;\n      } else {\n        var textFillStyleColor = textFillStyle.getColor();\n        this.textFillState_ = {\n          fillStyle: ol.colorlike.asColorLike(textFillStyleColor ?\n            textFillStyleColor : ol.render.canvas.defaultFillStyle)\n        };\n      }\n      var textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        this.textStrokeState_ = null;\n      } else {\n        var textStrokeStyleColor = textStrokeStyle.getColor();\n        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();\n        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();\n        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();\n        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();\n        var textStrokeStyleWidth = textStrokeStyle.getWidth();\n        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();\n        this.textStrokeState_ = {\n          lineCap: textStrokeStyleLineCap !== undefined ?\n            textStrokeStyleLineCap : ol.render.canvas.defaultLineCap,\n          lineDash: textStrokeStyleLineDash ?\n            textStrokeStyleLineDash : ol.render.canvas.defaultLineDash,\n          lineDashOffset: textStrokeStyleLineDashOffset ?\n            textStrokeStyleLineDashOffset : ol.render.canvas.defaultLineDashOffset,\n          lineJoin: textStrokeStyleLineJoin !== undefined ?\n            textStrokeStyleLineJoin : ol.render.canvas.defaultLineJoin,\n          lineWidth: textStrokeStyleWidth !== undefined ?\n            textStrokeStyleWidth : ol.render.canvas.defaultLineWidth,\n          miterLimit: textStrokeStyleMiterLimit !== undefined ?\n            textStrokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit,\n          strokeStyle: ol.colorlike.asColorLike(textStrokeStyleColor ?\n            textStrokeStyleColor : ol.render.canvas.defaultStrokeStyle)\n        };\n      }\n      var textFont = textStyle.getFont();\n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      var textScale = textStyle.getScale();\n      var textText = textStyle.getText();\n      var textTextAlign = textStyle.getTextAlign();\n      var textTextBaseline = textStyle.getTextBaseline();\n      this.textState_ = {\n        font: textFont !== undefined ?\n          textFont : ol.render.canvas.defaultFont,\n        textAlign: textTextAlign !== undefined ?\n          textTextAlign : ol.render.canvas.defaultTextAlign,\n        textBaseline: textTextBaseline !== undefined ?\n          textTextBaseline : ol.render.canvas.defaultTextBaseline\n      };\n      this.text_ = textText !== undefined ? textText : '';\n      this.textOffsetX_ =\n          textOffsetX !== undefined ? (this.pixelRatio_ * textOffsetX) : 0;\n      this.textOffsetY_ =\n          textOffsetY !== undefined ? (this.pixelRatio_ * textOffsetY) : 0;\n      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;\n      this.textRotation_ = textRotation !== undefined ? textRotation : 0;\n      this.textScale_ = this.pixelRatio_ * (textScale !== undefined ?\n        textScale : 1);\n    }\n  };\n  \n  goog.provide('ol.renderer.Layer');\n  \n  goog.require('ol');\n  goog.require('ol.ImageState');\n  goog.require('ol.Observable');\n  goog.require('ol.TileState');\n  goog.require('ol.asserts');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.functions');\n  goog.require('ol.source.State');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.Observable}\n   * @param {ol.layer.Layer} layer Layer.\n   * @struct\n   */\n  ol.renderer.Layer = function(layer) {\n  \n    ol.Observable.call(this);\n  \n    /**\n     * @private\n     * @type {ol.layer.Layer}\n     */\n    this.layer_ = layer;\n  \n  \n  };\n  ol.inherits(ol.renderer.Layer, ol.Observable);\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(this: S, (ol.Feature|ol.render.Feature), ol.layer.Layer): T}\n   *     callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @return {T|undefined} Callback result.\n   * @template S,T\n   */\n  ol.renderer.Layer.prototype.forEachFeatureAtCoordinate = ol.nullFunction;\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {olx.FrameState} frameState Frame state.\n   * @return {boolean} Is there a feature at the given coordinate?\n   */\n  ol.renderer.Layer.prototype.hasFeatureAtCoordinate = ol.functions.FALSE;\n  \n  \n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {ol.source.Tile} source Tile source.\n   * @param {ol.proj.Projection} projection Projection of the tiles.\n   * @param {Object.<number, Object.<string, ol.Tile>>} tiles Lookup of loaded\n   *     tiles by zoom level.\n   * @return {function(number, ol.TileRange):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the\n   *     lookup.\n   * @protected\n   */\n  ol.renderer.Layer.prototype.createLoadedTileFinder = function(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {ol.TileRange} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      function(zoom, tileRange) {\n        function callback(tile) {\n          if (!tiles[zoom]) {\n            tiles[zoom] = {};\n          }\n          tiles[zoom][tile.tileCoord.toString()] = tile;\n        }\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      });\n  };\n  \n  \n  /**\n   * @return {ol.layer.Layer} Layer.\n   */\n  ol.renderer.Layer.prototype.getLayer = function() {\n    return this.layer_;\n  };\n  \n  \n  /**\n   * Handle changes in image state.\n   * @param {ol.events.Event} event Image change event.\n   * @private\n   */\n  ol.renderer.Layer.prototype.handleImageChange_ = function(event) {\n    var image = /** @type {ol.Image} */ (event.target);\n    if (image.getState() === ol.ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n  \n  \n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {ol.ImageBase} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false`\n   *     otherwise.\n   * @protected\n   */\n  ol.renderer.Layer.prototype.loadImage = function(image) {\n    var imageState = image.getState();\n    if (imageState != ol.ImageState.LOADED &&\n        imageState != ol.ImageState.ERROR) {\n      ol.events.listen(image, ol.events.EventType.CHANGE,\n          this.handleImageChange_, this);\n    }\n    if (imageState == ol.ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ol.ImageState.LOADED;\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.renderer.Layer.prototype.renderIfReadyAndVisible = function() {\n    var layer = this.getLayer();\n    if (layer.getVisible() && layer.getSourceState() == ol.source.State.READY) {\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.source.Tile} tileSource Tile source.\n   * @protected\n   */\n  ol.renderer.Layer.prototype.scheduleExpireCache = function(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {ol.source.Tile} tileSource Tile source.\n       * @param {ol.PluggableMap} map Map.\n       * @param {olx.FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function(tileSource, map, frameState) {\n        var tileSourceKey = ol.getUid(tileSource).toString();\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection,\n              frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n  \n      frameState.postRenderFunctions.push(\n          /** @type {ol.PostRenderFunction} */ (postRenderFunction)\n      );\n    }\n  };\n  \n  \n  /**\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.source.Source} source Source.\n   * @protected\n   */\n  ol.renderer.Layer.prototype.updateLogos = function(frameState, source) {\n    var logo = source.getLogo();\n    if (logo !== undefined) {\n      if (typeof logo === 'string') {\n        frameState.logos[logo] = '';\n      } else if (logo) {\n        ol.asserts.assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.\n        ol.asserts.assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.\n        frameState.logos[logo.src] = logo.href;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {Object.<string, Object.<string, ol.TileRange>>} usedTiles Used tiles.\n   * @param {ol.source.Tile} tileSource Tile source.\n   * @param {number} z Z.\n   * @param {ol.TileRange} tileRange Tile range.\n   * @protected\n   */\n  ol.renderer.Layer.prototype.updateUsedTiles = function(usedTiles, tileSource, z, tileRange) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = ol.getUid(tileSource).toString();\n    var zKey = z.toString();\n    if (tileSourceKey in usedTiles) {\n      if (zKey in usedTiles[tileSourceKey]) {\n        usedTiles[tileSourceKey][zKey].extend(tileRange);\n      } else {\n        usedTiles[tileSourceKey][zKey] = tileRange;\n      }\n    } else {\n      usedTiles[tileSourceKey] = {};\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  };\n  \n  \n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.source.Tile} tileSource Tile source.\n   * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(this: T, ol.Tile)=} opt_tileCallback Tile callback.\n   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n   * @protected\n   * @template T\n   */\n  ol.renderer.Layer.prototype.manageTilePyramid = function(\n      frameState, tileSource, tileGrid, pixelRatio, projection, extent,\n      currentZ, preload, opt_tileCallback, opt_this) {\n    var tileSourceKey = ol.getUid(tileSource).toString();\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == ol.TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback.call(opt_this, tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n  };\n  \n  goog.provide('ol.renderer.canvas.Layer');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.functions');\n  goog.require('ol.render.Event');\n  goog.require('ol.render.EventType');\n  goog.require('ol.render.canvas');\n  goog.require('ol.render.canvas.Immediate');\n  goog.require('ol.renderer.Layer');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @abstract\n   * @extends {ol.renderer.Layer}\n   * @param {ol.layer.Layer} layer Layer.\n   */\n  ol.renderer.canvas.Layer = function(layer) {\n  \n    ol.renderer.Layer.call(this, layer);\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.transform_ = ol.transform.create();\n  \n  };\n  ol.inherits(ol.renderer.canvas.Layer, ol.renderer.Layer);\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.Extent} extent Clip extent.\n   * @protected\n   */\n  ol.renderer.canvas.Layer.prototype.clip = function(context, frameState, extent) {\n    var pixelRatio = frameState.pixelRatio;\n    var width = frameState.size[0] * pixelRatio;\n    var height = frameState.size[1] * pixelRatio;\n    var rotation = frameState.viewState.rotation;\n    var topLeft = ol.extent.getTopLeft(/** @type {ol.Extent} */ (extent));\n    var topRight = ol.extent.getTopRight(/** @type {ol.Extent} */ (extent));\n    var bottomRight = ol.extent.getBottomRight(/** @type {ol.Extent} */ (extent));\n    var bottomLeft = ol.extent.getBottomLeft(/** @type {ol.Extent} */ (extent));\n  \n    ol.transform.apply(frameState.coordinateToPixelTransform, topLeft);\n    ol.transform.apply(frameState.coordinateToPixelTransform, topRight);\n    ol.transform.apply(frameState.coordinateToPixelTransform, bottomRight);\n    ol.transform.apply(frameState.coordinateToPixelTransform, bottomLeft);\n  \n    context.save();\n    ol.render.canvas.rotateAtOffset(context, -rotation, width / 2, height / 2);\n    context.beginPath();\n    context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);\n    context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);\n    context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);\n    context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);\n    context.clip();\n    ol.render.canvas.rotateAtOffset(context, rotation, width / 2, height / 2);\n  };\n  \n  \n  /**\n   * @param {ol.render.EventType} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.Transform=} opt_transform Transform.\n   * @private\n   */\n  ol.renderer.canvas.Layer.prototype.dispatchComposeEvent_ = function(type, context, frameState, opt_transform) {\n    var layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      var width = frameState.size[0] * frameState.pixelRatio;\n      var height = frameState.size[1] * frameState.pixelRatio;\n      var rotation = frameState.viewState.rotation;\n      ol.render.canvas.rotateAtOffset(context, -rotation, width / 2, height / 2);\n      var transform = opt_transform !== undefined ?\n        opt_transform : this.getTransform(frameState, 0);\n      var render = new ol.render.canvas.Immediate(\n          context, frameState.pixelRatio, frameState.extent, transform,\n          frameState.viewState.rotation);\n      var composeEvent = new ol.render.Event(type, render, frameState,\n          context, null);\n      layer.dispatchEvent(composeEvent);\n      ol.render.canvas.rotateAtOffset(context, rotation, width / 2, height / 2);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {olx.FrameState} frameState FrameState.\n   * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n   *     callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  ol.renderer.canvas.Layer.prototype.forEachLayerAtCoordinate = function(coordinate, frameState, callback, thisArg) {\n    var hasFeature = this.forEachFeatureAtCoordinate(\n        coordinate, frameState, 0, ol.functions.TRUE, this);\n  \n    if (hasFeature) {\n      return callback.call(thisArg, this.getLayer(), null);\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.LayerState} layerState Layer state.\n   * @param {ol.Transform=} opt_transform Transform.\n   * @protected\n   */\n  ol.renderer.canvas.Layer.prototype.postCompose = function(context, frameState, layerState, opt_transform) {\n    this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE, context,\n        frameState, opt_transform);\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.Transform=} opt_transform Transform.\n   * @protected\n   */\n  ol.renderer.canvas.Layer.prototype.preCompose = function(context, frameState, opt_transform) {\n    this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE, context,\n        frameState, opt_transform);\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.Transform=} opt_transform Transform.\n   * @protected\n   */\n  ol.renderer.canvas.Layer.prototype.dispatchRenderEvent = function(context, frameState, opt_transform) {\n    this.dispatchComposeEvent_(ol.render.EventType.RENDER, context,\n        frameState, opt_transform);\n  };\n  \n  \n  /**\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!ol.Transform} Transform.\n   */\n  ol.renderer.canvas.Layer.prototype.getTransform = function(frameState, offsetX) {\n    var viewState = frameState.viewState;\n    var pixelRatio = frameState.pixelRatio;\n    var dx1 = pixelRatio * frameState.size[0] / 2;\n    var dy1 = pixelRatio * frameState.size[1] / 2;\n    var sx = pixelRatio / viewState.resolution;\n    var sy = -sx;\n    var angle = -viewState.rotation;\n    var dx2 = -viewState.center[0] + offsetX;\n    var dy2 = -viewState.center[1];\n    return ol.transform.compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.LayerState} layerState Layer state.\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  ol.renderer.canvas.Layer.prototype.composeFrame = function(frameState, layerState, context) {};\n  \n  /**\n   * @abstract\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.LayerState} layerState Layer state.\n   * @return {boolean} whether composeFrame should be called.\n   */\n  ol.renderer.canvas.Layer.prototype.prepareFrame = function(frameState, layerState) {};\n  \n  goog.provide('ol.renderer.canvas.IntermediateCanvas');\n  \n  goog.require('ol');\n  goog.require('ol.coordinate');\n  goog.require('ol.dom');\n  goog.require('ol.extent');\n  goog.require('ol.renderer.canvas.Layer');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @abstract\n   * @extends {ol.renderer.canvas.Layer}\n   * @param {ol.layer.Layer} layer Layer.\n   */\n  ol.renderer.canvas.IntermediateCanvas = function(layer) {\n  \n    ol.renderer.canvas.Layer.call(this, layer);\n  \n    /**\n     * @protected\n     * @type {ol.Transform}\n     */\n    this.coordinateToCanvasPixelTransform = ol.transform.create();\n  \n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitCanvasContext_ = null;\n  \n  };\n  ol.inherits(ol.renderer.canvas.IntermediateCanvas, ol.renderer.canvas.Layer);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.IntermediateCanvas.prototype.composeFrame = function(frameState, layerState, context) {\n  \n    this.preCompose(context, frameState);\n  \n    var image = this.getImage();\n    if (image) {\n  \n      // clipped rendering if layer extent is set\n      var extent = layerState.extent;\n      var clipped = extent !== undefined &&\n          !ol.extent.containsExtent(extent, frameState.extent) &&\n          ol.extent.intersects(extent, frameState.extent);\n      if (clipped) {\n        this.clip(context, frameState, /** @type {ol.Extent} */ (extent));\n      }\n  \n      var imageTransform = this.getImageTransform();\n      // for performance reasons, context.save / context.restore is not used\n      // to save and restore the transformation matrix and the opacity.\n      // see http://jsperf.com/context-save-restore-versus-variable\n      var alpha = context.globalAlpha;\n      context.globalAlpha = layerState.opacity;\n  \n      // for performance reasons, context.setTransform is only used\n      // when the view is rotated. see http://jsperf.com/canvas-transform\n      var dx = imageTransform[4];\n      var dy = imageTransform[5];\n      var dw = image.width * imageTransform[0];\n      var dh = image.height * imageTransform[3];\n      context.drawImage(image, 0, 0, +image.width, +image.height,\n          Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      context.globalAlpha = alpha;\n  \n      if (clipped) {\n        context.restore();\n      }\n    }\n  \n    this.postCompose(context, frameState, layerState);\n  };\n  \n  \n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|Image} Canvas.\n   */\n  ol.renderer.canvas.IntermediateCanvas.prototype.getImage = function() {};\n  \n  \n  /**\n   * @abstract\n   * @return {!ol.Transform} Image transform.\n   */\n  ol.renderer.canvas.IntermediateCanvas.prototype.getImageTransform = function() {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.IntermediateCanvas.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\n    var layer = this.getLayer();\n    var source = layer.getSource();\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    var skippedFeatureUids = frameState.skippedFeatureUids;\n    return source.forEachFeatureAtCoordinate(\n        coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,\n        /**\n         * @param {ol.Feature|ol.render.Feature} feature Feature.\n         * @return {?} Callback result.\n         */\n        function(feature) {\n          return callback.call(thisArg, feature, layer);\n        });\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.IntermediateCanvas.prototype.forEachLayerAtCoordinate = function(coordinate, frameState, callback, thisArg) {\n    if (!this.getImage()) {\n      return undefined;\n    }\n  \n    if (this.getLayer().getSource().forEachFeatureAtCoordinate !== ol.nullFunction) {\n      // for ImageCanvas sources use the original hit-detection logic,\n      // so that for example also transparent polygons are detected\n      return ol.renderer.canvas.Layer.prototype.forEachLayerAtCoordinate.apply(this, arguments);\n    } else {\n      var pixel = ol.transform.apply(this.coordinateToCanvasPixelTransform, coordinate.slice());\n      ol.coordinate.scale(pixel, frameState.viewState.resolution / this.renderedResolution);\n  \n      if (!this.hitCanvasContext_) {\n        this.hitCanvasContext_ = ol.dom.createCanvasContext2D(1, 1);\n      }\n  \n      this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n      this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n  \n      var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n      if (imageData[3] > 0) {\n        return callback.call(thisArg, this.getLayer(),  imageData);\n      } else {\n        return undefined;\n      }\n    }\n  };\n  \n  goog.provide('ol.renderer.canvas.ImageLayer');\n  \n  goog.require('ol');\n  goog.require('ol.ImageCanvas');\n  goog.require('ol.LayerType');\n  goog.require('ol.ViewHint');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.layer.VectorRenderType');\n  goog.require('ol.obj');\n  goog.require('ol.plugins');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.renderer.canvas.IntermediateCanvas');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.canvas.IntermediateCanvas}\n   * @param {ol.layer.Image} imageLayer Single image layer.\n   * @api\n   */\n  ol.renderer.canvas.ImageLayer = function(imageLayer) {\n  \n    ol.renderer.canvas.IntermediateCanvas.call(this, imageLayer);\n  \n    /**\n     * @private\n     * @type {?ol.ImageBase}\n     */\n    this.image_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.imageTransform_ = ol.transform.create();\n  \n    /**\n     * @type {!Array.<string>}\n     */\n    this.skippedFeatures_ = [];\n  \n    /**\n     * @private\n     * @type {ol.renderer.canvas.VectorLayer}\n     */\n    this.vectorRenderer_ = null;\n  \n  };\n  ol.inherits(ol.renderer.canvas.ImageLayer, ol.renderer.canvas.IntermediateCanvas);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @param {ol.layer.Layer} layer The candidate layer.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.canvas.ImageLayer['handles'] = function(type, layer) {\n    return type === ol.renderer.Type.CANVAS && (layer.getType() === ol.LayerType.IMAGE ||\n        layer.getType() === ol.LayerType.VECTOR &&\n        /** @type {ol.layer.Vector} */ (layer).getRenderMode() === ol.layer.VectorRenderType.IMAGE);\n  };\n  \n  \n  /**\n   * Create a layer renderer.\n   * @param {ol.renderer.Map} mapRenderer The map renderer.\n   * @param {ol.layer.Layer} layer The layer to be rendererd.\n   * @return {ol.renderer.canvas.ImageLayer} The layer renderer.\n   */\n  ol.renderer.canvas.ImageLayer['create'] = function(mapRenderer, layer) {\n    var renderer = new ol.renderer.canvas.ImageLayer(/** @type {ol.layer.Image} */ (layer));\n    if (layer.getType() === ol.LayerType.VECTOR) {\n      var candidates = ol.plugins.getLayerRendererPlugins();\n      for (var i = 0, ii = candidates.length; i < ii; ++i) {\n        var candidate = /** @type {Object.<string, Function>} */ (candidates[i]);\n        if (candidate !== ol.renderer.canvas.ImageLayer && candidate['handles'](ol.renderer.Type.CANVAS, layer)) {\n          renderer.setVectorRenderer(candidate['create'](mapRenderer, layer));\n        }\n      }\n    }\n    return renderer;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.ImageLayer.prototype.getImage = function() {\n    return !this.image_ ? null : this.image_.getImage();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.ImageLayer.prototype.getImageTransform = function() {\n    return this.imageTransform_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.ImageLayer.prototype.prepareFrame = function(frameState, layerState) {\n  \n    var pixelRatio = frameState.pixelRatio;\n    var size = frameState.size;\n    var viewState = frameState.viewState;\n    var viewCenter = viewState.center;\n    var viewResolution = viewState.resolution;\n  \n    var image;\n    var imageLayer = /** @type {ol.layer.Image} */ (this.getLayer());\n    var imageSource = imageLayer.getSource();\n  \n    var hints = frameState.viewHints;\n  \n    var renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = ol.extent.getIntersection(\n          renderedExtent, layerState.extent);\n    }\n  \n    if (!hints[ol.ViewHint.ANIMATING] && !hints[ol.ViewHint.INTERACTING] &&\n        !ol.extent.isEmpty(renderedExtent)) {\n      var projection = viewState.projection;\n      if (!ol.ENABLE_RASTER_REPROJECTION) {\n        var sourceProjection = imageSource.getProjection();\n        if (sourceProjection) {\n          projection = sourceProjection;\n        }\n      }\n      var vectorRenderer = this.vectorRenderer_;\n      if (vectorRenderer) {\n        var context = vectorRenderer.context;\n        var imageFrameState = /** @type {olx.FrameState} */ (ol.obj.assign({}, frameState, {\n          size: [\n            ol.extent.getWidth(renderedExtent) / viewResolution,\n            ol.extent.getHeight(renderedExtent) / viewResolution\n          ],\n          viewState: /** @type {olx.ViewState} */ (ol.obj.assign({}, frameState.viewState, {\n            rotation: 0\n          }))\n        }));\n        var skippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();\n        if (vectorRenderer.prepareFrame(imageFrameState, layerState) &&\n            (vectorRenderer.replayGroupChanged ||\n            !ol.array.equals(skippedFeatures, this.skippedFeatures_))) {\n          context.canvas.width = imageFrameState.size[0] * pixelRatio;\n          context.canvas.height = imageFrameState.size[1] * pixelRatio;\n          vectorRenderer.composeFrame(imageFrameState, layerState, context);\n          this.image_ = new ol.ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas);\n          this.skippedFeatures_ = skippedFeatures;\n        }\n      } else {\n        image = imageSource.getImage(\n            renderedExtent, viewResolution, pixelRatio, projection);\n        if (image) {\n          var loaded = this.loadImage(image);\n          if (loaded) {\n            this.image_ = image;\n          }\n        }\n      }\n    }\n  \n    if (this.image_) {\n      image = this.image_;\n      var imageExtent = image.getExtent();\n      var imageResolution = image.getResolution();\n      var imagePixelRatio = image.getPixelRatio();\n      var scale = pixelRatio * imageResolution /\n          (viewResolution * imagePixelRatio);\n      var transform = ol.transform.compose(this.imageTransform_,\n          pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\n          scale, scale,\n          0,\n          imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution,\n          imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\n      ol.transform.compose(this.coordinateToCanvasPixelTransform,\n          pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\n          pixelRatio / viewResolution, -pixelRatio / viewResolution,\n          0,\n          -viewCenter[0], -viewCenter[1]);\n  \n      this.updateLogos(frameState, imageSource);\n      this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\n    }\n  \n    return !!this.image_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.ImageLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (this.vectorRenderer_) {\n      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);\n    } else {\n      return ol.renderer.canvas.IntermediateCanvas.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.renderer.canvas.VectorLayer} renderer Vector renderer.\n   */\n  ol.renderer.canvas.ImageLayer.prototype.setVectorRenderer = function(renderer) {\n    this.vectorRenderer_ = renderer;\n  };\n  \n  goog.provide('ol.style.IconImageCache');\n  \n  goog.require('ol.color');\n  \n  \n  /**\n   * Singleton class. Available through {@link ol.style.iconImageCache}.\n   * @constructor\n   */\n  ol.style.IconImageCache = function() {\n  \n    /**\n     * @type {Object.<string, ol.style.IconImage>}\n     * @private\n     */\n    this.cache_ = {};\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.cacheSize_ = 0;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxCacheSize_ = 32;\n  };\n  \n  \n  /**\n   * @param {string} src Src.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {ol.Color} color Color.\n   * @return {string} Cache key.\n   */\n  ol.style.IconImageCache.getKey = function(src, crossOrigin, color) {\n    var colorString = color ? ol.color.asString(color) : 'null';\n    return crossOrigin + ':' + src + ':' + colorString;\n  };\n  \n  \n  /**\n   * FIXME empty description for jsdoc\n   */\n  ol.style.IconImageCache.prototype.clear = function() {\n    this.cache_ = {};\n    this.cacheSize_ = 0;\n  };\n  \n  \n  /**\n   * FIXME empty description for jsdoc\n   */\n  ol.style.IconImageCache.prototype.expire = function() {\n    if (this.cacheSize_ > this.maxCacheSize_) {\n      var i = 0;\n      var key, iconImage;\n      for (key in this.cache_) {\n        iconImage = this.cache_[key];\n        if ((i++ & 3) === 0 && !iconImage.hasListener()) {\n          delete this.cache_[key];\n          --this.cacheSize_;\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {string} src Src.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {ol.Color} color Color.\n   * @return {ol.style.IconImage} Icon image.\n   */\n  ol.style.IconImageCache.prototype.get = function(src, crossOrigin, color) {\n    var key = ol.style.IconImageCache.getKey(src, crossOrigin, color);\n    return key in this.cache_ ? this.cache_[key] : null;\n  };\n  \n  \n  /**\n   * @param {string} src Src.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {ol.Color} color Color.\n   * @param {ol.style.IconImage} iconImage Icon image.\n   */\n  ol.style.IconImageCache.prototype.set = function(src, crossOrigin, color, iconImage) {\n    var key = ol.style.IconImageCache.getKey(src, crossOrigin, color);\n    this.cache_[key] = iconImage;\n    ++this.cacheSize_;\n  };\n  \n  \n  /**\n   * Set the cache size of the icon cache. Default is `32`. Change this value when\n   * your map uses more than 32 different icon images and you are not caching icon\n   * styles on the application level.\n   * @param {number} maxCacheSize Cache max size.\n   * @api\n   */\n  ol.style.IconImageCache.prototype.setSize = function(maxCacheSize) {\n    this.maxCacheSize_ = maxCacheSize;\n    this.expire();\n  };\n  \n  goog.provide('ol.style');\n  \n  goog.require('ol.style.IconImageCache');\n  \n  /**\n   * The {@link ol.style.IconImageCache} for {@link ol.style.Icon} images.\n   * @api\n   */\n  ol.style.iconImageCache = new ol.style.IconImageCache();\n  \n  goog.provide('ol.renderer.Map');\n  \n  goog.require('ol');\n  goog.require('ol.Disposable');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.functions');\n  goog.require('ol.layer.Layer');\n  goog.require('ol.plugins');\n  goog.require('ol.style');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @abstract\n   * @extends {ol.Disposable}\n   * @param {Element} container Container.\n   * @param {ol.PluggableMap} map Map.\n   * @struct\n   */\n  ol.renderer.Map = function(container, map) {\n  \n    ol.Disposable.call(this);\n  \n  \n    /**\n     * @private\n     * @type {ol.PluggableMap}\n     */\n    this.map_ = map;\n  \n    /**\n     * @private\n     * @type {Object.<string, ol.renderer.Layer>}\n     */\n    this.layerRenderers_ = {};\n  \n    /**\n     * @private\n     * @type {Object.<string, ol.EventsKey>}\n     */\n    this.layerRendererListeners_ = {};\n  \n  };\n  ol.inherits(ol.renderer.Map, ol.Disposable);\n  \n  \n  /**\n   * @param {olx.FrameState} frameState FrameState.\n   * @protected\n   */\n  ol.renderer.Map.prototype.calculateMatrices2D = function(frameState) {\n    var viewState = frameState.viewState;\n    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n  \n    ol.transform.compose(coordinateToPixelTransform,\n        frameState.size[0] / 2, frameState.size[1] / 2,\n        1 / viewState.resolution, -1 / viewState.resolution,\n        -viewState.rotation,\n        -viewState.center[0], -viewState.center[1]);\n  \n    ol.transform.invert(\n        ol.transform.setFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));\n  };\n  \n  \n  /**\n   * Removes all layer renderers.\n   */\n  ol.renderer.Map.prototype.removeLayerRenderers = function() {\n    for (var key in this.layerRenderers_) {\n      this.removeLayerRendererByKey_(key).dispose();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.PluggableMap} map Map.\n   * @param {olx.FrameState} frameState Frame state.\n   * @private\n   */\n  ol.renderer.Map.expireIconCache_ = function(map, frameState) {\n    var cache = ol.style.iconImageCache;\n    cache.expire();\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {olx.FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(this: S, (ol.Feature|ol.render.Feature),\n   *     ol.layer.Layer): T} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  ol.renderer.Map.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg,\n      layerFilter, thisArg2) {\n    var result;\n    var viewState = frameState.viewState;\n    var viewResolution = viewState.resolution;\n  \n    /**\n     * @param {ol.Feature|ol.render.Feature} feature Feature.\n     * @param {ol.layer.Layer} layer Layer.\n     * @return {?} Callback result.\n     */\n    function forEachFeatureAtCoordinate(feature, layer) {\n      var key = ol.getUid(feature).toString();\n      var managed = frameState.layerStates[ol.getUid(layer)].managed;\n      if (!(key in frameState.skippedFeatureUids && !managed)) {\n        return callback.call(thisArg, feature, managed ? layer : null);\n      }\n    }\n  \n    var projection = viewState.projection;\n  \n    var translatedCoordinate = coordinate;\n    if (projection.canWrapX()) {\n      var projectionExtent = projection.getExtent();\n      var worldWidth = ol.extent.getWidth(projectionExtent);\n      var x = coordinate[0];\n      if (x < projectionExtent[0] || x > projectionExtent[2]) {\n        var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);\n        translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];\n      }\n    }\n  \n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var i;\n    for (i = numLayers - 1; i >= 0; --i) {\n      var layerState = layerStates[i];\n      var layer = layerState.layer;\n      if (ol.layer.Layer.visibleAtResolution(layerState, viewResolution) &&\n          layerFilter.call(thisArg2, layer)) {\n        var layerRenderer = this.getLayerRenderer(layer);\n        if (layer.getSource()) {\n          result = layerRenderer.forEachFeatureAtCoordinate(\n              layer.getSource().getWrapX() ? translatedCoordinate : coordinate,\n              frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);\n        }\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {ol.Pixel} pixel Pixel.\n   * @param {olx.FrameState} frameState FrameState.\n   * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n   *     callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  ol.renderer.Map.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg,\n      layerFilter, thisArg2) {};\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {olx.FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n  ol.renderer.Map.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, layerFilter, thisArg) {\n    var hasFeature = this.forEachFeatureAtCoordinate(\n        coordinate, frameState, hitTolerance, ol.functions.TRUE, this, layerFilter, thisArg);\n  \n    return hasFeature !== undefined;\n  };\n  \n  \n  /**\n   * @param {ol.layer.Layer} layer Layer.\n   * @protected\n   * @return {ol.renderer.Layer} Layer renderer.\n   */\n  ol.renderer.Map.prototype.getLayerRenderer = function(layer) {\n    var layerKey = ol.getUid(layer).toString();\n    if (layerKey in this.layerRenderers_) {\n      return this.layerRenderers_[layerKey];\n    } else {\n      var layerRendererPlugins = ol.plugins.getLayerRendererPlugins();\n      var renderer;\n      var type = this.getType();\n      for (var i = 0, ii = layerRendererPlugins.length; i < ii; ++i) {\n        var plugin = layerRendererPlugins[i];\n        if (plugin['handles'](type, layer)) {\n          renderer = plugin['create'](this, layer);\n          break;\n        }\n      }\n      if (renderer) {\n        this.layerRenderers_[layerKey] = renderer;\n        this.layerRendererListeners_[layerKey] = ol.events.listen(renderer,\n            ol.events.EventType.CHANGE, this.handleLayerRendererChange_, this);\n      } else {\n        throw new Error('Unable to create renderer for layer: ' + layer.getType());\n      }\n      return renderer;\n    }\n  };\n  \n  \n  /**\n   * @param {string} layerKey Layer key.\n   * @protected\n   * @return {ol.renderer.Layer} Layer renderer.\n   */\n  ol.renderer.Map.prototype.getLayerRendererByKey = function(layerKey) {\n    return this.layerRenderers_[layerKey];\n  };\n  \n  \n  /**\n   * @protected\n   * @return {Object.<string, ol.renderer.Layer>} Layer renderers.\n   */\n  ol.renderer.Map.prototype.getLayerRenderers = function() {\n    return this.layerRenderers_;\n  };\n  \n  \n  /**\n   * @return {ol.PluggableMap} Map.\n   */\n  ol.renderer.Map.prototype.getMap = function() {\n    return this.map_;\n  };\n  \n  \n  /**\n   * @abstract\n   * @return {ol.renderer.Type} Type\n   */\n  ol.renderer.Map.prototype.getType = function() {};\n  \n  \n  /**\n   * Handle changes in a layer renderer.\n   * @private\n   */\n  ol.renderer.Map.prototype.handleLayerRendererChange_ = function() {\n    this.map_.render();\n  };\n  \n  \n  /**\n   * @param {string} layerKey Layer key.\n   * @return {ol.renderer.Layer} Layer renderer.\n   * @private\n   */\n  ol.renderer.Map.prototype.removeLayerRendererByKey_ = function(layerKey) {\n    var layerRenderer = this.layerRenderers_[layerKey];\n    delete this.layerRenderers_[layerKey];\n  \n    ol.events.unlistenByKey(this.layerRendererListeners_[layerKey]);\n    delete this.layerRendererListeners_[layerKey];\n  \n    return layerRenderer;\n  };\n  \n  \n  /**\n   * Render.\n   * @param {?olx.FrameState} frameState Frame state.\n   */\n  ol.renderer.Map.prototype.renderFrame = ol.nullFunction;\n  \n  \n  /**\n   * @param {ol.PluggableMap} map Map.\n   * @param {olx.FrameState} frameState Frame state.\n   * @private\n   */\n  ol.renderer.Map.prototype.removeUnusedLayerRenderers_ = function(map, frameState) {\n    var layerKey;\n    for (layerKey in this.layerRenderers_) {\n      if (!frameState || !(layerKey in frameState.layerStates)) {\n        this.removeLayerRendererByKey_(layerKey).dispose();\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {olx.FrameState} frameState Frame state.\n   * @protected\n   */\n  ol.renderer.Map.prototype.scheduleExpireIconCache = function(frameState) {\n    frameState.postRenderFunctions.push(\n        /** @type {ol.PostRenderFunction} */ (ol.renderer.Map.expireIconCache_)\n    );\n  };\n  \n  \n  /**\n   * @param {!olx.FrameState} frameState Frame state.\n   * @protected\n   */\n  ol.renderer.Map.prototype.scheduleRemoveUnusedLayerRenderers = function(frameState) {\n    var layerKey;\n    for (layerKey in this.layerRenderers_) {\n      if (!(layerKey in frameState.layerStates)) {\n        frameState.postRenderFunctions.push(\n            /** @type {ol.PostRenderFunction} */ (this.removeUnusedLayerRenderers_.bind(this))\n        );\n        return;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.LayerState} state1 First layer state.\n   * @param {ol.LayerState} state2 Second layer state.\n   * @return {number} The zIndex difference.\n   */\n  ol.renderer.Map.sortByZIndex = function(state1, state2) {\n    return state1.zIndex - state2.zIndex;\n  };\n  \n  // FIXME offset panning\n  \n  goog.provide('ol.renderer.canvas.Map');\n  \n  goog.require('ol.transform');\n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.css');\n  goog.require('ol.dom');\n  goog.require('ol.layer.Layer');\n  goog.require('ol.render.Event');\n  goog.require('ol.render.EventType');\n  goog.require('ol.render.canvas');\n  goog.require('ol.render.canvas.Immediate');\n  goog.require('ol.renderer.Map');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.source.State');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.Map}\n   * @param {Element} container Container.\n   * @param {ol.PluggableMap} map Map.\n   * @api\n   */\n  ol.renderer.canvas.Map = function(container, map) {\n  \n    ol.renderer.Map.call(this, container, map);\n  \n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context_ = ol.dom.createCanvasContext2D();\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = this.context_.canvas;\n  \n    this.canvas_.style.width = '100%';\n    this.canvas_.style.height = '100%';\n    this.canvas_.style.display = 'block';\n    this.canvas_.className = ol.css.CLASS_UNSELECTABLE;\n    container.insertBefore(this.canvas_, container.childNodes[0] || null);\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.transform_ = ol.transform.create();\n  \n  };\n  ol.inherits(ol.renderer.canvas.Map, ol.renderer.Map);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.canvas.Map['handles'] = function(type) {\n    return type === ol.renderer.Type.CANVAS;\n  };\n  \n  \n  /**\n   * Create the map renderer.\n   * @param {Element} container Container.\n   * @param {ol.PluggableMap} map Map.\n   * @return {ol.renderer.canvas.Map} The map renderer.\n   */\n  ol.renderer.canvas.Map['create'] = function(container, map) {\n    return new ol.renderer.canvas.Map(container, map);\n  };\n  \n  \n  /**\n   * @param {ol.render.EventType} type Event type.\n   * @param {olx.FrameState} frameState Frame state.\n   * @private\n   */\n  ol.renderer.canvas.Map.prototype.dispatchComposeEvent_ = function(type, frameState) {\n    var map = this.getMap();\n    var context = this.context_;\n    if (map.hasListener(type)) {\n      var extent = frameState.extent;\n      var pixelRatio = frameState.pixelRatio;\n      var viewState = frameState.viewState;\n      var rotation = viewState.rotation;\n  \n      var transform = this.getTransform(frameState);\n  \n      var vectorContext = new ol.render.canvas.Immediate(context, pixelRatio,\n          extent, transform, rotation);\n      var composeEvent = new ol.render.Event(type, vectorContext,\n          frameState, context, null);\n      map.dispatchEvent(composeEvent);\n    }\n  };\n  \n  \n  /**\n   * @param {olx.FrameState} frameState Frame state.\n   * @protected\n   * @return {!ol.Transform} Transform.\n   */\n  ol.renderer.canvas.Map.prototype.getTransform = function(frameState) {\n    var viewState = frameState.viewState;\n    var dx1 = this.canvas_.width / 2;\n    var dy1 = this.canvas_.height / 2;\n    var sx = frameState.pixelRatio / viewState.resolution;\n    var sy = -sx;\n    var angle = -viewState.rotation;\n    var dx2 = -viewState.center[0];\n    var dy2 = -viewState.center[1];\n    return ol.transform.compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.Map.prototype.getType = function() {\n    return ol.renderer.Type.CANVAS;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.Map.prototype.renderFrame = function(frameState) {\n  \n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.canvas_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n  \n    var context = this.context_;\n    var pixelRatio = frameState.pixelRatio;\n    var width = Math.round(frameState.size[0] * pixelRatio);\n    var height = Math.round(frameState.size[1] * pixelRatio);\n    if (this.canvas_.width != width || this.canvas_.height != height) {\n      this.canvas_.width = width;\n      this.canvas_.height = height;\n    } else {\n      context.clearRect(0, 0, width, height);\n    }\n  \n    var rotation = frameState.viewState.rotation;\n  \n    this.calculateMatrices2D(frameState);\n  \n    this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE, frameState);\n  \n    var layerStatesArray = frameState.layerStatesArray;\n    ol.array.stableSort(layerStatesArray, ol.renderer.Map.sortByZIndex);\n  \n    if (rotation) {\n      context.save();\n      ol.render.canvas.rotateAtOffset(context, rotation, width / 2, height / 2);\n    }\n  \n    var viewResolution = frameState.viewState.resolution;\n    var i, ii, layer, layerRenderer, layerState;\n    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      layerState = layerStatesArray[i];\n      layer = layerState.layer;\n      layerRenderer = /** @type {ol.renderer.canvas.Layer} */ (this.getLayerRenderer(layer));\n      if (!ol.layer.Layer.visibleAtResolution(layerState, viewResolution) ||\n          layerState.sourceState != ol.source.State.READY) {\n        continue;\n      }\n      if (layerRenderer.prepareFrame(frameState, layerState)) {\n        layerRenderer.composeFrame(frameState, layerState, context);\n      }\n    }\n  \n    if (rotation) {\n      context.restore();\n    }\n  \n    this.dispatchComposeEvent_(\n        ol.render.EventType.POSTCOMPOSE, frameState);\n  \n    if (!this.renderedVisible_) {\n      this.canvas_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n  \n    this.scheduleRemoveUnusedLayerRenderers(frameState);\n    this.scheduleExpireIconCache(frameState);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.Map.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg,\n      layerFilter, thisArg2) {\n    var result;\n    var viewState = frameState.viewState;\n    var viewResolution = viewState.resolution;\n  \n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n  \n    var coordinate = ol.transform.apply(\n        frameState.pixelToCoordinateTransform, pixel.slice());\n  \n    var i;\n    for (i = numLayers - 1; i >= 0; --i) {\n      var layerState = layerStates[i];\n      var layer = layerState.layer;\n      if (ol.layer.Layer.visibleAtResolution(layerState, viewResolution) &&\n          layerFilter.call(thisArg2, layer)) {\n        var layerRenderer = /** @type {ol.renderer.canvas.Layer} */ (this.getLayerRenderer(layer));\n        result = layerRenderer.forEachLayerAtCoordinate(\n            coordinate, frameState, callback, thisArg);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return undefined;\n  };\n  \n  goog.provide('ol.renderer.canvas.TileLayer');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.TileRange');\n  goog.require('ol.TileState');\n  goog.require('ol.ViewHint');\n  goog.require('ol.dom');\n  goog.require('ol.extent');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.renderer.canvas.IntermediateCanvas');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.canvas.IntermediateCanvas}\n   * @param {ol.layer.Tile|ol.layer.VectorTile} tileLayer Tile layer.\n   * @api\n   */\n  ol.renderer.canvas.TileLayer = function(tileLayer) {\n  \n    ol.renderer.canvas.IntermediateCanvas.call(this, tileLayer);\n  \n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = this.context === null ? null :  ol.dom.createCanvasContext2D();\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.oversampling_;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.renderedExtent_ = null;\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n  \n    /**\n     * @protected\n     * @type {!Array.<ol.Tile>}\n     */\n    this.renderedTiles = [];\n  \n    /**\n     * @protected\n     * @type {ol.Extent}\n     */\n    this.tmpExtent = ol.extent.createEmpty();\n  \n    /**\n     * @private\n     * @type {ol.TileRange}\n     */\n    this.tmpTileRange_ = new ol.TileRange(0, 0, 0, 0);\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.imageTransform_ = ol.transform.create();\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.zDirection = 0;\n  \n  };\n  ol.inherits(ol.renderer.canvas.TileLayer, ol.renderer.canvas.IntermediateCanvas);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @param {ol.layer.Layer} layer The candidate layer.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.canvas.TileLayer['handles'] = function(type, layer) {\n    return type === ol.renderer.Type.CANVAS && layer.getType() === ol.LayerType.TILE;\n  };\n  \n  \n  /**\n   * Create a layer renderer.\n   * @param {ol.renderer.Map} mapRenderer The map renderer.\n   * @param {ol.layer.Layer} layer The layer to be rendererd.\n   * @return {ol.renderer.canvas.TileLayer} The layer renderer.\n   */\n  ol.renderer.canvas.TileLayer['create'] = function(mapRenderer, layer) {\n    return new ol.renderer.canvas.TileLayer(/** @type {ol.layer.Tile} */ (layer));\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.Tile} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  ol.renderer.canvas.TileLayer.prototype.isDrawableTile_ = function(tile) {\n    var tileState = tile.getState();\n    var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();\n    return tileState == ol.TileState.LOADED ||\n        tileState == ol.TileState.EMPTY ||\n        tileState == ol.TileState.ERROR && !useInterimTilesOnError;\n  };\n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.TileLayer.prototype.prepareFrame = function(frameState, layerState) {\n  \n    var pixelRatio = frameState.pixelRatio;\n    var size = frameState.size;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n  \n    var tileLayer = this.getLayer();\n    var tileSource = /** @type {ol.source.Tile} */ (tileLayer.getSource());\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var oversampling = Math.round(viewResolution / tileResolution) || 1;\n    var extent = frameState.extent;\n  \n    if (layerState.extent !== undefined) {\n      extent = ol.extent.getIntersection(extent, layerState.extent);\n    }\n    if (ol.extent.isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n  \n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n  \n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n  \n    /**\n     * @type {Object.<number, Object.<string, ol.Tile>>}\n     */\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n  \n    var findLoadedTiles = this.createLoadedTileFinder(\n        tileSource, projection, tilesToDrawByZ);\n  \n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    var newTiles = false;\n    var tile, x, y;\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n        if (tile.getState() == ol.TileState.ERROR) {\n          if (!tileLayer.getUseInterimTilesOnError()) {\n            // When useInterimTilesOnError is false, we consider the error tile as loaded.\n            tile.setState(ol.TileState.LOADED);\n          } else if (tileLayer.getPreload() > 0) {\n            // Preloaded tiles for lower resolutions might have finished loading.\n            newTiles = true;\n          }\n        }\n        if (!this.isDrawableTile_(tile)) {\n          tile = tile.getInterimTile();\n        }\n        if (this.isDrawableTile_(tile)) {\n          var uid = ol.getUid(this);\n          if (tile.getState() == ol.TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n            if (!newTiles && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              newTiles = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n  \n        var childTileRange = tileGrid.getTileCoordChildTileRange(\n            tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n              tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n  \n      }\n    }\n  \n    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    var hints = frameState.viewHints;\n    var animatingOrInteracting = hints[ol.ViewHint.ANIMATING] || hints[ol.ViewHint.INTERACTING];\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (\n      newTiles ||\n          !(this.renderedExtent_ && ol.extent.containsExtent(this.renderedExtent_, extent)) ||\n          this.renderedRevision != sourceRevision ||\n          oversampling != this.oversampling_ ||\n          !animatingOrInteracting && renderedResolution != this.renderedResolution\n    )) {\n  \n      var context = this.context;\n      if (context) {\n        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        var canvas = context.canvas;\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if (this.renderedExtent_ && !ol.extent.equals(imageExtent, this.renderedExtent_)) {\n            context.clearRect(0, 0, width, height);\n          }\n          oversampling = this.oversampling_;\n        }\n      }\n  \n      this.renderedTiles.length = 0;\n      /** @type {Array.<number>} */\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function(a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      var tileExtent, tileGutter, tilesToDraw, w, h;\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutter(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n        for (var tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this.renderedTiles.push(tile);\n        }\n      }\n  \n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n  \n    var scale = this.renderedResolution / viewResolution;\n    var transform = ol.transform.compose(this.imageTransform_,\n        pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\n        scale, scale,\n        0,\n        (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,\n        (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    ol.transform.compose(this.coordinateToCanvasPixelTransform,\n        pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\n        pixelRatio / viewResolution, -pixelRatio / viewResolution,\n        0,\n        -viewCenter[0], -viewCenter[1]);\n  \n  \n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,\n        projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.updateLogos(frameState, tileSource);\n  \n    return this.renderedTiles.length > 0;\n  };\n  \n  \n  /**\n   * @param {ol.Tile} tile Tile.\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.LayerState} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  ol.renderer.canvas.TileLayer.prototype.drawTileImage = function(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    var image = tile.getImage(this.getLayer());\n    if (!image) {\n      return;\n    }\n    var uid = ol.getUid(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n    var alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter,\n        image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n  \n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.TileLayer.prototype.getImage = function() {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  \n  \n  /**\n   * @function\n   * @return {ol.layer.Tile|ol.layer.VectorTile}\n   */\n  ol.renderer.canvas.TileLayer.prototype.getLayer;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.TileLayer.prototype.getImageTransform = function() {\n    return this.imageTransform_;\n  };\n  \n  \n  /**\n   * @fileoverview\n   * @suppress {accessControls, ambiguousFunctionDecl, checkDebuggerStatement, checkRegExp, checkTypes, checkVars, const, constantProperty, deprecated, duplicate, es5Strict, fileoverviewTags, missingProperties, nonStandardJsDocs, strictModuleDepCheck, suspiciousCode, undefinedNames, undefinedVars, unknownDefines, unusedLocalVariables, uselessCode, visibility}\n   */\n  goog.provide('ol.ext.rbush');\n  \n  /** @typedef {function(*)} */\n  ol.ext.rbush = function() {};\n  \n  (function() {(function (exports) {\n  'use strict';\n  \n  var quickselect_1 = quickselect;\n  var default_1 = quickselect;\n  function quickselect(arr, k, left, right, compare) {\n      quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n  }\n  function quickselectStep(arr, k, left, right, compare) {\n      while (right > left) {\n          if (right - left > 600) {\n              var n = right - left + 1;\n              var m = k - left + 1;\n              var z = Math.log(n);\n              var s = 0.5 * Math.exp(2 * z / 3);\n              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n              quickselectStep(arr, k, newLeft, newRight, compare);\n          }\n          var t = arr[k];\n          var i = left;\n          var j = right;\n          swap(arr, left, k);\n          if (compare(arr[right], t) > 0) swap(arr, left, right);\n          while (i < j) {\n              swap(arr, i, j);\n              i++;\n              j--;\n              while (compare(arr[i], t) < 0) i++;\n              while (compare(arr[j], t) > 0) j--;\n          }\n          if (compare(arr[left], t) === 0) swap(arr, left, j);\n          else {\n              j++;\n              swap(arr, j, right);\n          }\n          if (j <= k) left = j + 1;\n          if (k <= j) right = j - 1;\n      }\n  }\n  function swap(arr, i, j) {\n      var tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n  }\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n  quickselect_1.default = default_1;\n  \n  var rbush_1 = rbush;\n  function rbush(maxEntries, format) {\n      if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n      this._maxEntries = Math.max(4, maxEntries || 9);\n      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n      if (format) {\n          this._initFormat(format);\n      }\n      this.clear();\n  }\n  rbush.prototype = {\n      all: function () {\n          return this._all(this.data, []);\n      },\n      search: function (bbox) {\n          var node = this.data,\n              result = [],\n              toBBox = this.toBBox;\n          if (!intersects(bbox, node)) return result;\n          var nodesToSearch = [],\n              i, len, child, childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects(bbox, childBBox)) {\n                      if (node.leaf) result.push(child);\n                      else if (contains(bbox, childBBox)) this._all(child, result);\n                      else nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      collides: function (bbox) {\n          var node = this.data,\n              toBBox = this.toBBox;\n          if (!intersects(bbox, node)) return false;\n          var nodesToSearch = [],\n              i, len, child, childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects(bbox, childBBox)) {\n                      if (node.leaf || contains(bbox, childBBox)) return true;\n                      nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return false;\n      },\n      load: function (data) {\n          if (!(data && data.length)) return this;\n          if (data.length < this._minEntries) {\n              for (var i = 0, len = data.length; i < len; i++) {\n                  this.insert(data[i]);\n              }\n              return this;\n          }\n          var node = this._build(data.slice(), 0, data.length - 1, 0);\n          if (!this.data.children.length) {\n              this.data = node;\n          } else if (this.data.height === node.height) {\n              this._splitRoot(this.data, node);\n          } else {\n              if (this.data.height < node.height) {\n                  var tmpNode = this.data;\n                  this.data = node;\n                  node = tmpNode;\n              }\n              this._insert(node, this.data.height - node.height - 1, true);\n          }\n          return this;\n      },\n      insert: function (item) {\n          if (item) this._insert(item, this.data.height - 1);\n          return this;\n      },\n      clear: function () {\n          this.data = createNode([]);\n          return this;\n      },\n      remove: function (item, equalsFn) {\n          if (!item) return this;\n          var node = this.data,\n              bbox = this.toBBox(item),\n              path = [],\n              indexes = [],\n              i, parent, index, goingUp;\n          while (node || path.length) {\n              if (!node) {\n                  node = path.pop();\n                  parent = path[path.length - 1];\n                  i = indexes.pop();\n                  goingUp = true;\n              }\n              if (node.leaf) {\n                  index = findItem(item, node.children, equalsFn);\n                  if (index !== -1) {\n                      node.children.splice(index, 1);\n                      path.push(node);\n                      this._condense(path);\n                      return this;\n                  }\n              }\n              if (!goingUp && !node.leaf && contains(node, bbox)) {\n                  path.push(node);\n                  indexes.push(i);\n                  i = 0;\n                  parent = node;\n                  node = node.children[0];\n              } else if (parent) {\n                  i++;\n                  node = parent.children[i];\n                  goingUp = false;\n              } else node = null;\n          }\n          return this;\n      },\n      toBBox: function (item) { return item; },\n      compareMinX: compareNodeMinX,\n      compareMinY: compareNodeMinY,\n      toJSON: function () { return this.data; },\n      fromJSON: function (data) {\n          this.data = data;\n          return this;\n      },\n      _all: function (node, result) {\n          var nodesToSearch = [];\n          while (node) {\n              if (node.leaf) result.push.apply(result, node.children);\n              else nodesToSearch.push.apply(nodesToSearch, node.children);\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      _build: function (items, left, right, height) {\n          var N = right - left + 1,\n              M = this._maxEntries,\n              node;\n          if (N <= M) {\n              node = createNode(items.slice(left, right + 1));\n              calcBBox(node, this.toBBox);\n              return node;\n          }\n          if (!height) {\n              height = Math.ceil(Math.log(N) / Math.log(M));\n              M = Math.ceil(N / Math.pow(M, height - 1));\n          }\n          node = createNode([]);\n          node.leaf = false;\n          node.height = height;\n          var N2 = Math.ceil(N / M),\n              N1 = N2 * Math.ceil(Math.sqrt(M)),\n              i, j, right2, right3;\n          multiSelect(items, left, right, N1, this.compareMinX);\n          for (i = left; i <= right; i += N1) {\n              right2 = Math.min(i + N1 - 1, right);\n              multiSelect(items, i, right2, N2, this.compareMinY);\n              for (j = i; j <= right2; j += N2) {\n                  right3 = Math.min(j + N2 - 1, right2);\n                  node.children.push(this._build(items, j, right3, height - 1));\n              }\n          }\n          calcBBox(node, this.toBBox);\n          return node;\n      },\n      _chooseSubtree: function (bbox, node, level, path) {\n          var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n          while (true) {\n              path.push(node);\n              if (node.leaf || path.length - 1 === level) break;\n              minArea = minEnlargement = Infinity;\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  area = bboxArea(child);\n                  enlargement = enlargedArea(bbox, child) - area;\n                  if (enlargement < minEnlargement) {\n                      minEnlargement = enlargement;\n                      minArea = area < minArea ? area : minArea;\n                      targetNode = child;\n                  } else if (enlargement === minEnlargement) {\n                      if (area < minArea) {\n                          minArea = area;\n                          targetNode = child;\n                      }\n                  }\n              }\n              node = targetNode || node.children[0];\n          }\n          return node;\n      },\n      _insert: function (item, level, isNode) {\n          var toBBox = this.toBBox,\n              bbox = isNode ? item : toBBox(item),\n              insertPath = [];\n          var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n          node.children.push(item);\n          extend(node, bbox);\n          while (level >= 0) {\n              if (insertPath[level].children.length > this._maxEntries) {\n                  this._split(insertPath, level);\n                  level--;\n              } else break;\n          }\n          this._adjustParentBBoxes(bbox, insertPath, level);\n      },\n      _split: function (insertPath, level) {\n          var node = insertPath[level],\n              M = node.children.length,\n              m = this._minEntries;\n          this._chooseSplitAxis(node, m, M);\n          var splitIndex = this._chooseSplitIndex(node, m, M);\n          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n          newNode.height = node.height;\n          newNode.leaf = node.leaf;\n          calcBBox(node, this.toBBox);\n          calcBBox(newNode, this.toBBox);\n          if (level) insertPath[level - 1].children.push(newNode);\n          else this._splitRoot(node, newNode);\n      },\n      _splitRoot: function (node, newNode) {\n          this.data = createNode([node, newNode]);\n          this.data.height = node.height + 1;\n          this.data.leaf = false;\n          calcBBox(this.data, this.toBBox);\n      },\n      _chooseSplitIndex: function (node, m, M) {\n          var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n          minOverlap = minArea = Infinity;\n          for (i = m; i <= M - m; i++) {\n              bbox1 = distBBox(node, 0, i, this.toBBox);\n              bbox2 = distBBox(node, i, M, this.toBBox);\n              overlap = intersectionArea(bbox1, bbox2);\n              area = bboxArea(bbox1) + bboxArea(bbox2);\n              if (overlap < minOverlap) {\n                  minOverlap = overlap;\n                  index = i;\n                  minArea = area < minArea ? area : minArea;\n              } else if (overlap === minOverlap) {\n                  if (area < minArea) {\n                      minArea = area;\n                      index = i;\n                  }\n              }\n          }\n          return index;\n      },\n      _chooseSplitAxis: function (node, m, M) {\n          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n              compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n              xMargin = this._allDistMargin(node, m, M, compareMinX),\n              yMargin = this._allDistMargin(node, m, M, compareMinY);\n          if (xMargin < yMargin) node.children.sort(compareMinX);\n      },\n      _allDistMargin: function (node, m, M, compare) {\n          node.children.sort(compare);\n          var toBBox = this.toBBox,\n              leftBBox = distBBox(node, 0, m, toBBox),\n              rightBBox = distBBox(node, M - m, M, toBBox),\n              margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n              i, child;\n          for (i = m; i < M - m; i++) {\n              child = node.children[i];\n              extend(leftBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin(leftBBox);\n          }\n          for (i = M - m - 1; i >= m; i--) {\n              child = node.children[i];\n              extend(rightBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin(rightBBox);\n          }\n          return margin;\n      },\n      _adjustParentBBoxes: function (bbox, path, level) {\n          for (var i = level; i >= 0; i--) {\n              extend(path[i], bbox);\n          }\n      },\n      _condense: function (path) {\n          for (var i = path.length - 1, siblings; i >= 0; i--) {\n              if (path[i].children.length === 0) {\n                  if (i > 0) {\n                      siblings = path[i - 1].children;\n                      siblings.splice(siblings.indexOf(path[i]), 1);\n                  } else this.clear();\n              } else calcBBox(path[i], this.toBBox);\n          }\n      },\n      _initFormat: function (format) {\n          var compareArr = ['return a', ' - b', ';'];\n          this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n          this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n          this.toBBox = new Function('a',\n              'return {minX: a' + format[0] +\n              ', minY: a' + format[1] +\n              ', maxX: a' + format[2] +\n              ', maxY: a' + format[3] + '};');\n      }\n  };\n  function findItem(item, items, equalsFn) {\n      if (!equalsFn) return items.indexOf(item);\n      for (var i = 0; i < items.length; i++) {\n          if (equalsFn(item, items[i])) return i;\n      }\n      return -1;\n  }\n  function calcBBox(node, toBBox) {\n      distBBox(node, 0, node.children.length, toBBox, node);\n  }\n  function distBBox(node, k, p, toBBox, destNode) {\n      if (!destNode) destNode = createNode(null);\n      destNode.minX = Infinity;\n      destNode.minY = Infinity;\n      destNode.maxX = -Infinity;\n      destNode.maxY = -Infinity;\n      for (var i = k, child; i < p; i++) {\n          child = node.children[i];\n          extend(destNode, node.leaf ? toBBox(child) : child);\n      }\n      return destNode;\n  }\n  function extend(a, b) {\n      a.minX = Math.min(a.minX, b.minX);\n      a.minY = Math.min(a.minY, b.minY);\n      a.maxX = Math.max(a.maxX, b.maxX);\n      a.maxY = Math.max(a.maxY, b.maxY);\n      return a;\n  }\n  function compareNodeMinX(a, b) { return a.minX - b.minX; }\n  function compareNodeMinY(a, b) { return a.minY - b.minY; }\n  function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\n  function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n  function enlargedArea(a, b) {\n      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n             (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n  }\n  function intersectionArea(a, b) {\n      var minX = Math.max(a.minX, b.minX),\n          minY = Math.max(a.minY, b.minY),\n          maxX = Math.min(a.maxX, b.maxX),\n          maxY = Math.min(a.maxY, b.maxY);\n      return Math.max(0, maxX - minX) *\n             Math.max(0, maxY - minY);\n  }\n  function contains(a, b) {\n      return a.minX <= b.minX &&\n             a.minY <= b.minY &&\n             b.maxX <= a.maxX &&\n             b.maxY <= a.maxY;\n  }\n  function intersects(a, b) {\n      return b.minX <= a.maxX &&\n             b.minY <= a.maxY &&\n             b.maxX >= a.minX &&\n             b.maxY >= a.minY;\n  }\n  function createNode(children) {\n      return {\n          children: children,\n          height: 1,\n          leaf: true,\n          minX: Infinity,\n          minY: Infinity,\n          maxX: -Infinity,\n          maxY: -Infinity\n      };\n  }\n  function multiSelect(arr, left, right, n, compare) {\n      var stack = [left, right],\n          mid;\n      while (stack.length) {\n          right = stack.pop();\n          left = stack.pop();\n          if (right - left <= n) continue;\n          mid = left + Math.ceil((right - left) / n / 2) * n;\n          quickselect_1(arr, mid, left, right, compare);\n          stack.push(left, mid, mid, right);\n      }\n  }\n  \n  exports['default'] = rbush_1;\n  \n  }((this.rbush = this.rbush || {})));}).call(ol.ext);\n  ol.ext.rbush = ol.ext.rbush.default;\n  \n  goog.provide('ol.render.ReplayGroup');\n  \n  \n  /**\n   * Base class for replay groups.\n   * @constructor\n   * @abstract\n   */\n  ol.render.ReplayGroup = function() {};\n  \n  \n  /**\n   * @abstract\n   * @param {number|undefined} zIndex Z index.\n   * @param {ol.render.ReplayType} replayType Replay type.\n   * @return {ol.render.VectorContext} Replay.\n   */\n  ol.render.ReplayGroup.prototype.getReplay = function(zIndex, replayType) {};\n  \n  \n  /**\n   * @abstract\n   * @return {boolean} Is empty.\n   */\n  ol.render.ReplayGroup.prototype.isEmpty = function() {};\n  \n  goog.provide('ol.render.ReplayType');\n  \n  \n  /**\n   * @enum {string}\n   */\n  ol.render.ReplayType = {\n    CIRCLE: 'Circle',\n    DEFAULT: 'Default',\n    IMAGE: 'Image',\n    LINE_STRING: 'LineString',\n    POLYGON: 'Polygon',\n    TEXT: 'Text'\n  };\n  \n  goog.provide('ol.geom.flat.length');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {number} Length.\n   */\n  ol.geom.flat.length.lineString = function(flatCoordinates, offset, end, stride) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var i;\n    for (i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      x1 = x2;\n      y1 = y2;\n    }\n    return length;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {number} Perimeter.\n   */\n  ol.geom.flat.length.linearRing = function(flatCoordinates, offset, end, stride) {\n    var perimeter =\n        ol.geom.flat.length.lineString(flatCoordinates, offset, end, stride);\n    var dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n    var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n    perimeter += Math.sqrt(dx * dx + dy * dy);\n    return perimeter;\n  };\n  \n  goog.provide('ol.geom.flat.textpath');\n  \n  goog.require('ol.math');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Path to put text on.\n   * @param {number} offset Start offset of the `flatCoordinates`.\n   * @param {number} end End offset of the `flatCoordinates`.\n   * @param {number} stride Stride.\n   * @param {string} text Text to place on the path.\n   * @param {function(string):number} measure Measure function returning the\n   * width of the character passed as 1st argument.\n   * @param {number} startM m along the path where the text starts.\n   * @param {number} maxAngle Max angle between adjacent chars in radians.\n   * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was\n   * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\n   */\n  ol.geom.flat.textpath.lineString = function(\n      flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\n    var result = [];\n  \n    // Keep text upright\n    var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n  \n    var numChars = text.length;\n  \n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    offset += stride;\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var segmentM = 0;\n    var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  \n    var chunk = '';\n    var chunkLength = 0;\n    var data, index, previousAngle;\n    for (var i = 0; i < numChars; ++i) {\n      index = reverse ? numChars - i - 1 : i;\n      var char = text.charAt(index);\n      chunk = reverse ? char + chunk : chunk + char;\n      var charLength = measure(chunk) - chunkLength;\n      chunkLength += charLength;\n      var charM = startM + charLength / 2;\n      while (offset < end - stride && segmentM + segmentLength < charM) {\n        x1 = x2;\n        y1 = y2;\n        offset += stride;\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        segmentM += segmentLength;\n        segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n      }\n      var segmentPos = charM - segmentM;\n      var angle = Math.atan2(y2 - y1, x2 - x1);\n      if (reverse) {\n        angle += angle > 0 ? -Math.PI : Math.PI;\n      }\n      if (previousAngle !== undefined) {\n        var delta = angle - previousAngle;\n        delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;\n        if (Math.abs(delta) > maxAngle) {\n          return null;\n        }\n      }\n      var interpolate = segmentPos / segmentLength;\n      var x = ol.math.lerp(x1, x2, interpolate);\n      var y = ol.math.lerp(y1, y2, interpolate);\n      if (previousAngle == angle) {\n        if (reverse) {\n          data[0] = x;\n          data[1] = y;\n          data[2] = charLength / 2;\n        }\n        data[4] = chunk;\n      } else {\n        chunk = char;\n        chunkLength = charLength;\n        data = [x, y, charLength / 2, angle, chunk];\n        if (reverse) {\n          result.unshift(data);\n        } else {\n          result.push(data);\n        }\n        previousAngle = angle;\n      }\n      startM += charLength;\n    }\n    return result;\n  };\n  \n  goog.provide('ol.render.canvas.Instruction');\n  \n  /**\n   * @enum {number}\n   */\n  ol.render.canvas.Instruction = {\n    BEGIN_GEOMETRY: 0,\n    BEGIN_PATH: 1,\n    CIRCLE: 2,\n    CLOSE_PATH: 3,\n    CUSTOM: 4,\n    DRAW_CHARS: 5,\n    DRAW_IMAGE: 6,\n    END_GEOMETRY: 7,\n    FILL: 8,\n    MOVE_TO_LINE_TO: 9,\n    SET_FILL_STYLE: 10,\n    SET_STROKE_STYLE: 11,\n    STROKE: 12\n  };\n  \n  goog.provide('ol.render.replay');\n  \n  goog.require('ol.render.ReplayType');\n  \n  \n  /**\n   * @const\n   * @type {Array.<ol.render.ReplayType>}\n   */\n  ol.render.replay.ORDER = [\n    ol.render.ReplayType.POLYGON,\n    ol.render.ReplayType.CIRCLE,\n    ol.render.ReplayType.LINE_STRING,\n    ol.render.ReplayType.IMAGE,\n    ol.render.ReplayType.TEXT,\n    ol.render.ReplayType.DEFAULT\n  ];\n  \n  /**\n   * @const\n   * @enum {number}\n   */\n  ol.render.replay.TEXT_ALIGN = {};\n  ol.render.replay.TEXT_ALIGN['left'] = 0;\n  ol.render.replay.TEXT_ALIGN['end'] = 0;\n  ol.render.replay.TEXT_ALIGN['center'] = 0.5;\n  ol.render.replay.TEXT_ALIGN['right'] = 1;\n  ol.render.replay.TEXT_ALIGN['start'] = 1;\n  ol.render.replay.TEXT_ALIGN['top'] = 0;\n  ol.render.replay.TEXT_ALIGN['middle'] = 0.5;\n  ol.render.replay.TEXT_ALIGN['hanging'] = 0.2;\n  ol.render.replay.TEXT_ALIGN['alphabetic'] = 0.8;\n  ol.render.replay.TEXT_ALIGN['ideographic'] = 0.8;\n  ol.render.replay.TEXT_ALIGN['bottom'] = 1;\n  \n  goog.provide('ol.render.canvas.Replay');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.colorlike');\n  goog.require('ol.extent');\n  goog.require('ol.extent.Relationship');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.flat.inflate');\n  goog.require('ol.geom.flat.length');\n  goog.require('ol.geom.flat.textpath');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.has');\n  goog.require('ol.obj');\n  goog.require('ol.render.VectorContext');\n  goog.require('ol.render.canvas');\n  goog.require('ol.render.canvas.Instruction');\n  goog.require('ol.render.replay');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.VectorContext}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   * @struct\n   */\n  ol.render.canvas.Replay = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    ol.render.VectorContext.call(this);\n  \n    /**\n     * @type {?}\n     */\n    this.declutterTree = declutterTree;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.tmpExtent_ = ol.extent.createEmpty();\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n  \n    /**\n     * @protected\n     * @const\n     * @type {ol.Extent}\n     */\n    this.maxExtent = maxExtent;\n  \n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxLineWidth = 0;\n  \n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n  \n    /**\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.fillOrigin_;\n  \n    /**\n     * @private\n     * @type {Array.<*>}\n     */\n    this.beginGeometryInstruction1_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<*>}\n     */\n    this.beginGeometryInstruction2_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.bufferedMaxExtent_ = null;\n  \n    /**\n     * @protected\n     * @type {Array.<*>}\n     */\n    this.instructions = [];\n  \n    /**\n     * @protected\n     * @type {Array.<number>}\n     */\n    this.coordinates = [];\n  \n    /**\n     * @private\n     * @type {Object.<number,ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n  \n    /**\n     * @private\n     * @type {!ol.Transform}\n     */\n    this.renderedTransform_ = ol.transform.create();\n  \n    /**\n     * @protected\n     * @type {Array.<*>}\n     */\n    this.hitDetectionInstructions = [];\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.pixelCoordinates_ = null;\n  \n    /**\n     * @protected\n     * @type {ol.CanvasFillStrokeState}\n     */\n    this.state = /** @type {ol.CanvasFillStrokeState} */ ({});\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n  \n    /**\n     * @private\n     * @type {!ol.Transform}\n     */\n    this.tmpLocalTransform_ = ol.transform.create();\n  \n    /**\n     * @private\n     * @type {!ol.Transform}\n     */\n    this.resetTransform_ = ol.transform.create();\n  };\n  ol.inherits(ol.render.canvas.Replay, ol.render.VectorContext);\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {ol.Coordinate} p1 1st point of the background box.\n   * @param {ol.Coordinate} p2 2nd point of the background box.\n   * @param {ol.Coordinate} p3 3rd point of the background box.\n   * @param {ol.Coordinate} p4 4th point of the background box.\n   * @param {Array.<*>} fillInstruction Fill instruction.\n   * @param {Array.<*>} strokeInstruction Stroke instruction.\n   */\n  ol.render.canvas.Replay.prototype.replayTextBackground_ = function(context, p1, p2, p3, p4,\n      fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.fillOrigin_ = /** @type {Array.<number>} */ (fillInstruction[2]);\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, /** @type {Array.<*>} */ (strokeInstruction));\n      context.stroke();\n    }\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {ol.DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {number} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array.<number>} padding Padding.\n   * @param {Array.<*>} fillInstruction Fill instruction.\n   * @param {Array.<*>} strokeInstruction Stroke instruction.\n   */\n  ol.render.canvas.Replay.prototype.replayImage_ = function(context, x, y, image,\n      anchorX, anchorY, declutterGroup, height, opacity, originX, originY,\n      rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n    var fillStroke = fillInstruction || strokeInstruction;\n    var localTransform = this.tmpLocalTransform_;\n    anchorX *= scale;\n    anchorY *= scale;\n    x -= anchorX;\n    y -= anchorY;\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n  \n    var w = (width + originX > image.width) ? image.width - originX : width;\n    var h = (height + originY > image.height) ? image.height - originY : height;\n    var box = this.tmpExtent_;\n    var boxW = padding[3] + w * scale + padding[1];\n    var boxH = padding[0] + h * scale + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n  \n    /** @type {ol.Coordinate} */\n    var p1;\n    /** @type {ol.Coordinate} */\n    var p2;\n    /** @type {ol.Coordinate} */\n    var p3;\n    /** @type {ol.Coordinate} */\n    var p4;\n    if (fillStroke || rotation !== 0) {\n      p1 = [boxX, boxY];\n      p2 = [boxX + boxW, boxY];\n      p3 = [boxX + boxW, boxY + boxH];\n      p4 = [boxX, boxY + boxH];\n    }\n  \n    var transform = null;\n    if (rotation !== 0) {\n      var centerX = x + anchorX;\n      var centerY = y + anchorY;\n      transform = ol.transform.compose(localTransform,\n          centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n  \n      ol.extent.createOrUpdateEmpty(box);\n      ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p1));\n      ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p2));\n      ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p3));\n      ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p4));\n    } else {\n      ol.extent.createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, box);\n    }\n    var canvas = context.canvas;\n    var intersects = box[0] <= canvas.width && box[2] >= 0 && box[1] <= canvas.height && box[3] >= 0;\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[4] == 1) {\n        return;\n      }\n      ol.extent.extend(declutterGroup, box);\n      var declutterArgs = intersects ?\n        [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :\n        null;\n      if (declutterArgs && fillStroke) {\n        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\n      }\n      declutterGroup.push(declutterArgs);\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4,\n            /** @type {Array.<*>} */ (fillInstruction),\n            /** @type {Array.<*>} */ (strokeInstruction));\n      }\n      ol.render.canvas.drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n    }\n  };\n  \n  \n  /**\n   * @protected\n   * @param {Array.<number>} dashArray Dash array.\n   * @return {Array.<number>} Dash array with pixel ratio applied\n   */\n  ol.render.canvas.Replay.prototype.applyPixelRatio = function(dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {\n      return dash * pixelRatio;\n    });\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  ol.render.canvas.Replay.prototype.appendFlatCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {\n  \n    var myEnd = this.coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    var nextCoord = [NaN, NaN];\n    var skipped = true;\n  \n    var i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = ol.extent.coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this.coordinates[myEnd++] = lastCoord[0];\n          this.coordinates[myEnd++] = lastCoord[1];\n        }\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === ol.extent.Relationship.INTERSECTING) {\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastCoord[0] = nextCoord[0];\n      lastCoord[1] = nextCoord[1];\n      lastRel = nextRel;\n    }\n  \n    // Last coordinate equals first or only one point to append:\n    if ((closed && skipped) || i === offset + stride) {\n      this.coordinates[myEnd++] = lastCoord[0];\n      this.coordinates[myEnd++] = lastCoord[1];\n    }\n    return myEnd;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array.<number>} replayEnds Replay ends.\n   * @return {number} Offset.\n   */\n  ol.render.canvas.Replay.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, replayEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      replayEnds.push(replayEnd);\n      offset = end;\n    }\n    return offset;\n  };\n  \n  \n  /**\n   * @inheritDoc.\n   */\n  ol.render.canvas.Replay.prototype.drawCustom = function(geometry, feature, renderer) {\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var replayBegin = this.coordinates.length;\n    var flatCoordinates, replayEnd, replayEnds, replayEndss;\n    var offset;\n    if (type == ol.geom.GeometryType.MULTI_POLYGON) {\n      geometry = /** @type {ol.geom.MultiPolygon} */ (geometry);\n      flatCoordinates = geometry.getOrientedFlatCoordinates();\n      replayEndss = [];\n      var endss = geometry.getEndss();\n      offset = 0;\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var myEnds = [];\n        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n        replayEndss.push(myEnds);\n      }\n      this.instructions.push([ol.render.canvas.Instruction.CUSTOM,\n        replayBegin, replayEndss, geometry, renderer, ol.geom.flat.inflate.coordinatesss]);\n    } else if (type == ol.geom.GeometryType.POLYGON || type == ol.geom.GeometryType.MULTI_LINE_STRING) {\n      replayEnds = [];\n      flatCoordinates = (type == ol.geom.GeometryType.POLYGON) ?\n        /** @type {ol.geom.Polygon} */ (geometry).getOrientedFlatCoordinates() :\n        geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n          /** @type {ol.geom.Polygon|ol.geom.MultiLineString} */ (geometry).getEnds(),\n          stride, replayEnds);\n      this.instructions.push([ol.render.canvas.Instruction.CUSTOM,\n        replayBegin, replayEnds, geometry, renderer, ol.geom.flat.inflate.coordinatess]);\n    } else if (type == ol.geom.GeometryType.LINE_STRING || type == ol.geom.GeometryType.MULTI_POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      replayEnd = this.appendFlatCoordinates(\n          flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      this.instructions.push([ol.render.canvas.Instruction.CUSTOM,\n        replayBegin, replayEnd, geometry, renderer, ol.geom.flat.inflate.coordinates]);\n    } else if (type == ol.geom.GeometryType.POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      replayEnd = this.coordinates.length;\n      this.instructions.push([ol.render.canvas.Instruction.CUSTOM,\n        replayBegin, replayEnd, geometry, renderer]);\n    }\n    this.endGeometry(geometry, feature);\n  };\n  \n  \n  /**\n   * @protected\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.canvas.Replay.prototype.beginGeometry = function(geometry, feature) {\n    this.beginGeometryInstruction1_ =\n        [ol.render.canvas.Instruction.BEGIN_GEOMETRY, feature, 0];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ =\n        [ol.render.canvas.Instruction.BEGIN_GEOMETRY, feature, 0];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  \n  \n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  ol.render.canvas.Replay.prototype.fill_ = function(context) {\n    if (this.fillOrigin_) {\n      var origin = ol.transform.apply(this.renderedTransform_, this.fillOrigin_.slice());\n      context.translate(origin[0], origin[1]);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.fillOrigin_) {\n      context.setTransform.apply(context, ol.render.canvas.resetTransform_);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array.<*>} instruction Instruction.\n   */\n  ol.render.canvas.Replay.prototype.setStrokeStyle_ = function(context, instruction) {\n    context.strokeStyle = /** @type {ol.ColorLike} */ (instruction[1]);\n    context.lineWidth = /** @type {number} */ (instruction[2]);\n    context.lineCap = /** @type {string} */ (instruction[3]);\n    context.lineJoin = /** @type {string} */ (instruction[4]);\n    context.miterLimit = /** @type {number} */ (instruction[5]);\n    if (ol.has.CANVAS_LINE_DASH) {\n      context.lineDashOffset = /** @type {number} */ (instruction[7]);\n      context.setLineDash(/** @type {Array.<number>} */ (instruction[6]));\n    }\n  };\n  \n  \n  /**\n   * @param {ol.DeclutterGroup} declutterGroup Declutter group.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.canvas.Replay.prototype.renderDeclutter_ = function(declutterGroup, feature) {\n    if (declutterGroup && declutterGroup.length > 5) {\n      var groupCount = declutterGroup[4];\n      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n        /** @type {ol.RBushEntry} */\n        var box = {\n          minX: /** @type {number} */ (declutterGroup[0]),\n          minY: /** @type {number} */ (declutterGroup[1]),\n          maxX: /** @type {number} */ (declutterGroup[2]),\n          maxY: /** @type {number} */ (declutterGroup[3]),\n          value: feature\n        };\n        if (!this.declutterTree.collides(box)) {\n          this.declutterTree.insert(box);\n          var drawImage = ol.render.canvas.drawImage;\n          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\n            var declutterData = /** @type {Array} */ (declutterGroup[j]);\n            if (declutterData) {\n              if (declutterData.length > 11) {\n                this.replayTextBackground_(declutterData[0],\n                    declutterData[13], declutterData[14], declutterData[15], declutterData[16],\n                    declutterData[11], declutterData[12]);\n              }\n              drawImage.apply(undefined, declutterData);\n            }\n          }\n        }\n        declutterGroup.length = 5;\n        ol.extent.createOrUpdateEmpty(declutterGroup);\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {ol.Transform} transform Transform.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {Array.<*>} instructions Instructions array.\n   * @param {function((ol.Feature|ol.render.Feature)): T|undefined}\n   *     featureCallback Feature callback.\n   * @param {ol.Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.canvas.Replay.prototype.replay_ = function(\n      context, transform, skippedFeaturesHash,\n      instructions, featureCallback, opt_hitExtent) {\n    /** @type {Array.<number>} */\n    var pixelCoordinates;\n    if (this.pixelCoordinates_ && ol.array.equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = ol.geom.flat.transform.transform2D(\n          this.coordinates, 0, this.coordinates.length, 2,\n          transform, this.pixelCoordinates_);\n      ol.transform.setFromArray(this.renderedTransform_, transform);\n    }\n    var skipFeatures = !ol.obj.isEmpty(skippedFeaturesHash);\n    var i = 0; // instruction index\n    var ii = instructions.length; // end of instructions\n    var d = 0; // data index\n    var dd; // end of per-instruction data\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n  \n    var state = /** @type {olx.render.State} */ ({\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    });\n  \n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    var batchSize =\n        this.instructions != instructions || this.overlaps ? 0 : 200;\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);\n      var /** @type {ol.Feature|ol.render.Feature} */ feature, x, y;\n      switch (type) {\n        case ol.render.canvas.Instruction.BEGIN_GEOMETRY:\n          feature = /** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);\n          if ((skipFeatures &&\n              skippedFeaturesHash[ol.getUid(feature).toString()]) ||\n              !feature.getGeometry()) {\n            i = /** @type {number} */ (instruction[2]);\n          } else if (opt_hitExtent !== undefined && !ol.extent.intersects(\n              opt_hitExtent, feature.getGeometry().getExtent())) {\n            i = /** @type {number} */ (instruction[2]) + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case ol.render.canvas.Instruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = prevY = NaN;\n          }\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.CIRCLE:\n          d = /** @type {number} */ (instruction[1]);\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.CUSTOM:\n          d = /** @type {number} */ (instruction[1]);\n          dd = instruction[2];\n          var geometry = /** @type {ol.geom.SimpleGeometry} */ (instruction[3]);\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          var coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.DRAW_IMAGE:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          image =  /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */\n              (instruction[3]);\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */ (instruction[4]);\n          anchorY = /** @type {number} */ (instruction[5]);\n          declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */ (instruction[6]);\n          var height = /** @type {number} */ (instruction[7]);\n          var opacity = /** @type {number} */ (instruction[8]);\n          var originX = /** @type {number} */ (instruction[9]);\n          var originY = /** @type {number} */ (instruction[10]);\n          var rotateWithView = /** @type {boolean} */ (instruction[11]);\n          var rotation = /** @type {number} */ (instruction[12]);\n          var scale = /** @type {number} */ (instruction[13]);\n          var snapToPixel = /** @type {boolean} */ (instruction[14]);\n          var width = /** @type {number} */ (instruction[15]);\n  \n          var padding, backgroundFill, backgroundStroke;\n          if (instruction.length > 16) {\n            padding = /** @type {Array.<number>} */ (instruction[16]);\n            backgroundFill = /** @type {boolean} */ (instruction[17]);\n            backgroundStroke = /** @type {boolean} */ (instruction[18]);\n          } else {\n            padding = ol.render.canvas.defaultPadding;\n            backgroundFill = backgroundStroke = false;\n          }\n  \n          if (rotateWithView) {\n            rotation += viewRotation;\n          }\n          for (; d < dd; d += 2) {\n            this.replayImage_(context,\n                pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,\n                declutterGroup, height, opacity, originX, originY, rotation, scale,\n                snapToPixel, width, padding,\n                backgroundFill ? /** @type {Array.<*>} */ (lastFillInstruction) : null,\n                backgroundStroke ? /** @type {Array.<*>} */ (lastStrokeInstruction) : null);\n          }\n          this.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.DRAW_CHARS:\n          var begin = /** @type {number} */ (instruction[1]);\n          var end = /** @type {number} */ (instruction[2]);\n          var baseline = /** @type {number} */ (instruction[3]);\n          declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */ (instruction[4]);\n          var overflow = /** @type {number} */ (instruction[5]);\n          var fillKey = /** @type {string} */ (instruction[6]);\n          var maxAngle = /** @type {number} */ (instruction[7]);\n          var measure = /** @type {function(string):number} */ (instruction[8]);\n          var offsetY = /** @type {number} */ (instruction[9]);\n          var strokeKey = /** @type {string} */ (instruction[10]);\n          var strokeWidth =  /** @type {number} */ (instruction[11]);\n          var text = /** @type {string} */ (instruction[12]);\n          var textKey = /** @type {string} */ (instruction[13]);\n          var textScale = /** @type {number} */ (instruction[14]);\n  \n          var pathLength = ol.geom.flat.length.lineString(pixelCoordinates, begin, end, 2);\n          var textLength = measure(text);\n          if (overflow || textLength <= pathLength) {\n            var textAlign = /** @type {ol.render.canvas.TextReplay} */ (this).textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * ol.render.replay.TEXT_ALIGN[textAlign];\n            var parts = ol.geom.flat.textpath.lineString(\n                pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n            if (parts) {\n              var c, cc, chars, label, part;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, '', strokeKey);\n                  anchorX = /** @type {number} */ (part[2]) + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                  this.replayImage_(context,\n                      /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\n                      anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                      /** @type {number} */ (part[3]), textScale, false, label.width,\n                      ol.render.canvas.defaultPadding, null, null);\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */ (part[2]);\n                  anchorY = baseline * label.height - offsetY;\n                  this.replayImage_(context,\n                      /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\n                      anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                      /** @type {number} */ (part[3]), textScale, false, label.width,\n                      ol.render.canvas.defaultPadding, null, null);\n                }\n              }\n            }\n          }\n          this.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);\n            var result = featureCallback(feature);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = (x + 0.5) | 0;\n          roundY = (y + 0.5) | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = (x + 0.5) | 0;\n            roundY = (y + 0.5) | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.fillOrigin_ = instruction[2];\n  \n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n  \n          context.fillStyle = /** @type {ol.ColorLike} */ (instruction[1]);\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array.<*>} */ (instruction));\n          ++i;\n          break;\n        case ol.render.canvas.Instruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {ol.Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   */\n  ol.render.canvas.Replay.prototype.replay = function(\n      context, transform, viewRotation, skippedFeaturesHash) {\n    this.viewRotation_ = viewRotation;\n    this.replay_(context, transform,\n        skippedFeaturesHash, this.instructions, undefined, undefined);\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {ol.Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {function((ol.Feature|ol.render.Feature)): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {ol.Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.canvas.Replay.prototype.replayHitDetection = function(\n      context, transform, viewRotation, skippedFeaturesHash,\n      opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.replay_(context, transform, skippedFeaturesHash,\n        this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);\n  };\n  \n  \n  /**\n   * Reverse the hit detection instructions.\n   */\n  ol.render.canvas.Replay.prototype.reverseHitDetectionInstructions = function() {\n    var hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);\n      if (type == ol.render.canvas.Instruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == ol.render.canvas.Instruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        ol.array.reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.Replay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n    var state = this.state;\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = ol.colorlike.asColorLike(fillStyleColor ?\n        fillStyleColor : ol.render.canvas.defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = ol.colorlike.asColorLike(strokeStyleColor ?\n        strokeStyleColor : ol.render.canvas.defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ?\n        strokeStyleLineCap : ol.render.canvas.defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ?\n        strokeStyleLineDash.slice() : ol.render.canvas.defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ?\n        strokeStyleLineDashOffset : ol.render.canvas.defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ?\n        strokeStyleLineJoin : ol.render.canvas.defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ?\n        strokeStyleWidth : ol.render.canvas.defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ?\n        strokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit;\n  \n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.CanvasFillStrokeState} state State.\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n   */\n  ol.render.canvas.Replay.prototype.applyFill = function(state, geometry) {\n    var fillStyle = state.fillStyle;\n    var fillInstruction = [ol.render.canvas.Instruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      var fillExtent = geometry.getExtent();\n      fillInstruction.push([fillExtent[0], fillExtent[3]]);\n    }\n    this.instructions.push(fillInstruction);\n  };\n  \n  \n  /**\n   * @param {ol.CanvasFillStrokeState} state State.\n   */\n  ol.render.canvas.Replay.prototype.applyStroke = function(state) {\n    this.instructions.push([\n      ol.render.canvas.Instruction.SET_STROKE_STYLE,\n      state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,\n      state.lineJoin, state.miterLimit,\n      this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio\n    ]);\n  };\n  \n  \n  /**\n   * @param {ol.CanvasFillStrokeState} state State.\n   * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState, (ol.geom.Geometry|ol.render.Feature))} applyFill Apply fill.\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n   */\n  ol.render.canvas.Replay.prototype.updateFillStyle = function(state, applyFill, geometry) {\n    var fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      applyFill.call(this, state, geometry);\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.CanvasFillStrokeState} state State.\n   * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState)} applyStroke Apply stroke.\n   */\n  ol.render.canvas.Replay.prototype.updateStrokeStyle = function(state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n    if (state.currentStrokeStyle != strokeStyle ||\n        state.currentLineCap != lineCap ||\n        (lineDash != state.currentLineDash && !ol.array.equals(state.currentLineDash, lineDash)) ||\n        state.currentLineDashOffset != lineDashOffset ||\n        state.currentLineJoin != lineJoin ||\n        state.currentLineWidth != lineWidth ||\n        state.currentMiterLimit != miterLimit) {\n      applyStroke.call(this, state);\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   */\n  ol.render.canvas.Replay.prototype.endGeometry = function(geometry, feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction =\n        [ol.render.canvas.Instruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  \n  \n  /**\n   * FIXME empty description for jsdoc\n   */\n  ol.render.canvas.Replay.prototype.finish = ol.nullFunction;\n  \n  \n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {ol.Extent} The buffered rendering extent.\n   * @protected\n   */\n  ol.render.canvas.Replay.prototype.getBufferedMaxExtent = function() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = ol.extent.clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        ol.extent.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  };\n  \n  goog.provide('ol.render.canvas.ImageReplay');\n  \n  goog.require('ol');\n  goog.require('ol.render.canvas.Instruction');\n  goog.require('ol.render.canvas.Replay');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.canvas.Replay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   * @struct\n   */\n  ol.render.canvas.ImageReplay = function(\n      tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    ol.render.canvas.Replay.call(this,\n        tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  \n    /**\n     * @private\n     * @type {ol.DeclutterGroup}\n     */\n    this.declutterGroup_ = null;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLVideoElement|Image}\n     */\n    this.hitDetectionImage_ = null;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLVideoElement|Image}\n     */\n    this.image_ = null;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.anchorX_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.anchorY_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.height_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.opacity_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.originX_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.originY_ = undefined;\n  \n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.rotateWithView_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.rotation_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.scale_ = undefined;\n  \n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.snapToPixel_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.width_ = undefined;\n  \n  };\n  ol.inherits(ol.render.canvas.ImageReplay, ol.render.canvas.Replay);\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} My end.\n   */\n  ol.render.canvas.ImageReplay.prototype.drawCoordinates_ = function(flatCoordinates, offset, end, stride) {\n    return this.appendFlatCoordinates(\n        flatCoordinates, offset, end, stride, false, false);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.ImageReplay.prototype.drawPoint = function(pointGeometry, feature) {\n    if (!this.image_) {\n      return;\n    }\n    this.beginGeometry(pointGeometry, feature);\n    var flatCoordinates = pointGeometry.getFlatCoordinates();\n    var stride = pointGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    var myEnd = this.drawCoordinates_(\n        flatCoordinates, 0, flatCoordinates.length, stride);\n    this.instructions.push([\n      ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,\n      // Remaining arguments to DRAW_IMAGE are in alphabetical order\n      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,\n      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,\n      this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_\n    ]);\n    this.hitDetectionInstructions.push([\n      ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd,\n      this.hitDetectionImage_,\n      // Remaining arguments to DRAW_IMAGE are in alphabetical order\n      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,\n      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,\n      this.scale_, this.snapToPixel_, this.width_\n    ]);\n    this.endGeometry(pointGeometry, feature);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.ImageReplay.prototype.drawMultiPoint = function(multiPointGeometry, feature) {\n    if (!this.image_) {\n      return;\n    }\n    this.beginGeometry(multiPointGeometry, feature);\n    var flatCoordinates = multiPointGeometry.getFlatCoordinates();\n    var stride = multiPointGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    var myEnd = this.drawCoordinates_(\n        flatCoordinates, 0, flatCoordinates.length, stride);\n    this.instructions.push([\n      ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,\n      // Remaining arguments to DRAW_IMAGE are in alphabetical order\n      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,\n      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,\n      this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_\n    ]);\n    this.hitDetectionInstructions.push([\n      ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd,\n      this.hitDetectionImage_,\n      // Remaining arguments to DRAW_IMAGE are in alphabetical order\n      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,\n      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,\n      this.scale_, this.snapToPixel_, this.width_\n    ]);\n    this.endGeometry(multiPointGeometry, feature);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.ImageReplay.prototype.finish = function() {\n    this.reverseHitDetectionInstructions();\n    // FIXME this doesn't really protect us against further calls to draw*Geometry\n    this.anchorX_ = undefined;\n    this.anchorY_ = undefined;\n    this.hitDetectionImage_ = null;\n    this.image_ = null;\n    this.height_ = undefined;\n    this.scale_ = undefined;\n    this.opacity_ = undefined;\n    this.originX_ = undefined;\n    this.originY_ = undefined;\n    this.rotateWithView_ = undefined;\n    this.rotation_ = undefined;\n    this.snapToPixel_ = undefined;\n    this.width_ = undefined;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.ImageReplay.prototype.setImageStyle = function(imageStyle, declutterGroup) {\n    var anchor = imageStyle.getAnchor();\n    var size = imageStyle.getSize();\n    var hitDetectionImage = imageStyle.getHitDetectionImage(1);\n    var image = imageStyle.getImage(1);\n    var origin = imageStyle.getOrigin();\n    this.anchorX_ = anchor[0];\n    this.anchorY_ = anchor[1];\n    this.declutterGroup_ = /** @type {ol.DeclutterGroup} */ (declutterGroup);\n    this.hitDetectionImage_ = hitDetectionImage;\n    this.image_ = image;\n    this.height_ = size[1];\n    this.opacity_ = imageStyle.getOpacity();\n    this.originX_ = origin[0];\n    this.originY_ = origin[1];\n    this.rotateWithView_ = imageStyle.getRotateWithView();\n    this.rotation_ = imageStyle.getRotation();\n    this.scale_ = imageStyle.getScale();\n    this.snapToPixel_ = imageStyle.getSnapToPixel();\n    this.width_ = size[0];\n  };\n  \n  goog.provide('ol.render.canvas.LineStringReplay');\n  \n  goog.require('ol');\n  goog.require('ol.render.canvas.Instruction');\n  goog.require('ol.render.canvas.Replay');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.canvas.Replay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   * @struct\n   */\n  ol.render.canvas.LineStringReplay = function(\n      tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    ol.render.canvas.Replay.call(this,\n        tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  };\n  ol.inherits(ol.render.canvas.LineStringReplay, ol.render.canvas.Replay);\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} end.\n   */\n  ol.render.canvas.LineStringReplay.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset, end, stride) {\n    var myBegin = this.coordinates.length;\n    var myEnd = this.appendFlatCoordinates(\n        flatCoordinates, offset, end, stride, false, false);\n    var moveToLineToInstruction =\n        [ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n    return end;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.LineStringReplay.prototype.drawLineString = function(lineStringGeometry, feature) {\n    var state = this.state;\n    var strokeStyle = state.strokeStyle;\n    var lineWidth = state.lineWidth;\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(lineStringGeometry, feature);\n    this.hitDetectionInstructions.push([\n      ol.render.canvas.Instruction.SET_STROKE_STYLE,\n      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n      state.miterLimit, state.lineDash, state.lineDashOffset\n    ], [\n      ol.render.canvas.Instruction.BEGIN_PATH\n    ]);\n    var flatCoordinates = lineStringGeometry.getFlatCoordinates();\n    var stride = lineStringGeometry.getStride();\n    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n    this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);\n    this.endGeometry(lineStringGeometry, feature);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.LineStringReplay.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {\n    var state = this.state;\n    var strokeStyle = state.strokeStyle;\n    var lineWidth = state.lineWidth;\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(multiLineStringGeometry, feature);\n    this.hitDetectionInstructions.push([\n      ol.render.canvas.Instruction.SET_STROKE_STYLE,\n      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n      state.miterLimit, state.lineDash, state.lineDashOffset\n    ], [\n      ol.render.canvas.Instruction.BEGIN_PATH\n    ]);\n    var ends = multiLineStringGeometry.getEnds();\n    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n    var stride = multiLineStringGeometry.getStride();\n    var offset = 0;\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinates_(\n          flatCoordinates, offset, ends[i], stride);\n    }\n    this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);\n    this.endGeometry(multiLineStringGeometry, feature);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.LineStringReplay.prototype.finish = function() {\n    var state = this.state;\n    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n      this.instructions.push([ol.render.canvas.Instruction.STROKE]);\n    }\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n  };\n  \n  \n  /**\n   * @inheritDoc.\n   */\n  ol.render.canvas.LineStringReplay.prototype.applyStroke = function(state) {\n    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n      this.instructions.push([ol.render.canvas.Instruction.STROKE]);\n      state.lastStroke = this.coordinates.length;\n    }\n    state.lastStroke = 0;\n    ol.render.canvas.Replay.prototype.applyStroke.call(this, state);\n    this.instructions.push([ol.render.canvas.Instruction.BEGIN_PATH]);\n  };\n  \n  goog.provide('ol.render.canvas.PolygonReplay');\n  \n  goog.require('ol');\n  goog.require('ol.color');\n  goog.require('ol.geom.flat.simplify');\n  goog.require('ol.render.canvas');\n  goog.require('ol.render.canvas.Instruction');\n  goog.require('ol.render.canvas.Replay');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.canvas.Replay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   * @struct\n   */\n  ol.render.canvas.PolygonReplay = function(\n      tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    ol.render.canvas.Replay.call(this,\n        tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  };\n  ol.inherits(ol.render.canvas.PolygonReplay, ol.render.canvas.Replay);\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  ol.render.canvas.PolygonReplay.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle != undefined;\n    var numEnds = ends.length;\n    var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatCoordinates(\n          flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction =\n          [ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        var closePathInstruction = [ol.render.canvas.Instruction.CLOSE_PATH];\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    var fillInstruction = [ol.render.canvas.Instruction.FILL];\n    this.hitDetectionInstructions.push(fillInstruction);\n    if (fill) {\n      this.instructions.push(fillInstruction);\n    }\n    if (stroke) {\n      var strokeInstruction = [ol.render.canvas.Instruction.STROKE];\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.PolygonReplay.prototype.drawCircle = function(circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(circleGeometry);\n    this.beginGeometry(circleGeometry, feature);\n    // always fill the circle for hit detection\n    this.hitDetectionInstructions.push([\n      ol.render.canvas.Instruction.SET_FILL_STYLE,\n      ol.color.asString(ol.render.canvas.defaultFillStyle)\n    ]);\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        ol.render.canvas.Instruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(\n        flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];\n    var circleInstruction = [ol.render.canvas.Instruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    var fillInstruction = [ol.render.canvas.Instruction.FILL];\n    this.hitDetectionInstructions.push(fillInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      var strokeInstruction = [ol.render.canvas.Instruction.STROKE];\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(circleGeometry, feature);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.PolygonReplay.prototype.drawPolygon = function(polygonGeometry, feature) {\n    var state = this.state;\n    this.setFillStrokeStyles_(polygonGeometry);\n    this.beginGeometry(polygonGeometry, feature);\n    // always fill the polygon for hit detection\n    this.hitDetectionInstructions.push([\n      ol.render.canvas.Instruction.SET_FILL_STYLE,\n      ol.color.asString(ol.render.canvas.defaultFillStyle)]\n    );\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        ol.render.canvas.Instruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(polygonGeometry, feature);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.PolygonReplay.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(multiPolygonGeometry);\n    this.beginGeometry(multiPolygonGeometry, feature);\n    // always fill the multi-polygon for hit detection\n    this.hitDetectionInstructions.push([\n      ol.render.canvas.Instruction.SET_FILL_STYLE,\n      ol.color.asString(ol.render.canvas.defaultFillStyle)\n    ]);\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        ol.render.canvas.Instruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n    var i, ii;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(\n          flatCoordinates, offset, endss[i], stride);\n    }\n    this.endGeometry(multiPolygonGeometry, feature);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.PolygonReplay.prototype.finish = function() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    var tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n      var i, ii;\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = ol.geom.flat.simplify.snap(coordinates[i], tolerance);\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n   */\n  ol.render.canvas.PolygonReplay.prototype.setFillStrokeStyles_ = function(geometry) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.applyFill, geometry);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n  \n  goog.provide('ol.geom.flat.straightchunk');\n  \n  \n  /**\n   * @param {number} maxAngle Maximum acceptable angle delta between segments.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {Array.<number>} Start and end of the first suitable chunk of the\n   * given `flatCoordinates`.\n   */\n  ol.geom.flat.straightchunk.lineString = function(maxAngle, flatCoordinates, offset, end, stride) {\n    var chunkStart = offset;\n    var chunkEnd = offset;\n    var chunkM = 0;\n    var m = 0;\n    var start = offset;\n    var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\n    for (i = offset; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      if (x1 !== undefined) {\n        x23 = x2 - x1;\n        y23 = y2 - y1;\n        m23 = Math.sqrt(x23 * x23 + y23 * y23);\n        if (x12 !== undefined) {\n          m += m12;\n          acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n          if (acos > maxAngle) {\n            if (m > chunkM) {\n              chunkM = m;\n              chunkStart = start;\n              chunkEnd = i;\n            }\n            m = 0;\n            start = i - stride;\n          }\n        }\n        m12 = m23;\n        x12 = x23;\n        y12 = y23;\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n    m += m23;\n    return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\n  };\n  \n  goog.provide('ol.style.TextPlacement');\n  \n  \n  /**\n   * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that\n   * `'line'` requires the underlying geometry to be a {@link ol.geom.LineString},\n   * {@link ol.geom.Polygon}, {@link ol.geom.MultiLineString} or\n   * {@link ol.geom.MultiPolygon}.\n   * @enum {string}\n   */\n  ol.style.TextPlacement = {\n    POINT: 'point',\n    LINE: 'line'\n  };\n  \n  goog.provide('ol.render.canvas.TextReplay');\n  \n  goog.require('ol');\n  goog.require('ol.colorlike');\n  goog.require('ol.dom');\n  goog.require('ol.extent');\n  goog.require('ol.geom.flat.straightchunk');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.has');\n  goog.require('ol.render.canvas');\n  goog.require('ol.render.canvas.Instruction');\n  goog.require('ol.render.canvas.Replay');\n  goog.require('ol.render.replay');\n  goog.require('ol.style.TextPlacement');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.canvas.Replay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   * @struct\n   */\n  ol.render.canvas.TextReplay = function(\n      tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    ol.render.canvas.Replay.call(this,\n        tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  \n    /**\n     * @private\n     * @type {ol.DeclutterGroup}\n     */\n    this.declutterGroup_;\n  \n    /**\n     * @private\n     * @type {Array.<HTMLCanvasElement>}\n     */\n    this.labels_ = null;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.text_ = '';\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetX_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetY_ = 0;\n  \n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.textRotateWithView_ = undefined;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.textRotation_ = 0;\n  \n    /**\n     * @private\n     * @type {?ol.CanvasFillState}\n     */\n    this.textFillState_ = null;\n  \n    /**\n     * @type {Object.<string, ol.CanvasFillState>}\n     */\n    this.fillStates = {};\n  \n    /**\n     * @private\n     * @type {?ol.CanvasStrokeState}\n     */\n    this.textStrokeState_ = null;\n  \n    /**\n     * @type {Object.<string, ol.CanvasStrokeState>}\n     */\n    this.strokeStates = {};\n  \n    /**\n     * @private\n     * @type {ol.CanvasTextState}\n     */\n    this.textState_ = /** @type {ol.CanvasTextState} */ ({});\n  \n    /**\n     * @type {Object.<string, ol.CanvasTextState>}\n     */\n    this.textStates = {};\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.textKey_ = '';\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.fillKey_ = '';\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.strokeKey_ = '';\n  \n    /**\n     * @private\n     * @type {Object.<string, Object.<string, number>>}\n     */\n    this.widths_ = {};\n  \n    var labelCache = ol.render.canvas.labelCache;\n    labelCache.prune();\n  \n  };\n  ol.inherits(ol.render.canvas.TextReplay, ol.render.canvas.Replay);\n  \n  \n  /**\n   * @param {string} font Font to use for measuring.\n   * @param {Array.<string>} lines Lines to measure.\n   * @param {Array.<number>} widths Array will be populated with the widths of\n   * each line.\n   * @return {number} Width of the whole text.\n   */\n  ol.render.canvas.TextReplay.measureTextWidths = function(font, lines, widths) {\n    var numLines = lines.length;\n    var width = 0;\n    var currentWidth, i;\n    for (i = 0; i < numLines; ++i) {\n      currentWidth = ol.render.canvas.measureTextWidth(font, lines[i]);\n      width = Math.max(width, currentWidth);\n      widths.push(currentWidth);\n    }\n    return width;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.TextReplay.prototype.drawText = function(geometry, feature) {\n    var fillState = this.textFillState_;\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {\n      return;\n    }\n  \n    var begin = this.coordinates.length;\n  \n    var geometryType = geometry.getType();\n    var flatCoordinates = null;\n    var end = 2;\n    var stride = 2;\n    var i, ii;\n  \n    if (textState.placement === ol.style.TextPlacement.LINE) {\n      if (!ol.extent.intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n      var ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n      stride = geometry.getStride();\n      if (geometryType == ol.geom.GeometryType.LINE_STRING) {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == ol.geom.GeometryType.MULTI_LINE_STRING) {\n        ends = geometry.getEnds();\n      } else if (geometryType == ol.geom.GeometryType.POLYGON) {\n        ends = geometry.getEnds().slice(0, 1);\n      } else if (geometryType == ol.geom.GeometryType.MULTI_POLYGON) {\n        var endss = geometry.getEndss();\n        ends = [];\n        for (i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      var textAlign = textState.textAlign;\n      var flatOffset = 0;\n      var flatEnd;\n      for (var o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          var range = ol.geom.flat.straightchunk.lineString(\n              textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n        for (i = flatOffset; i < flatEnd; i += stride) {\n          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n        end = this.coordinates.length;\n        flatOffset = ends[o];\n        this.drawChars_(begin, end, this.declutterGroup_);\n        begin = end;\n      }\n      this.endGeometry(geometry, feature);\n  \n    } else {\n      var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\n      var width = label.width / this.pixelRatio;\n      switch (geometryType) {\n        case ol.geom.GeometryType.POINT:\n        case ol.geom.GeometryType.MULTI_POINT:\n          flatCoordinates = geometry.getFlatCoordinates();\n          end = flatCoordinates.length;\n          break;\n        case ol.geom.GeometryType.LINE_STRING:\n          flatCoordinates = /** @type {ol.geom.LineString} */ (geometry).getFlatMidpoint();\n          break;\n        case ol.geom.GeometryType.CIRCLE:\n          flatCoordinates = /** @type {ol.geom.Circle} */ (geometry).getCenter();\n          break;\n        case ol.geom.GeometryType.MULTI_LINE_STRING:\n          flatCoordinates = /** @type {ol.geom.MultiLineString} */ (geometry).getFlatMidpoints();\n          end = flatCoordinates.length;\n          break;\n        case ol.geom.GeometryType.POLYGON:\n          flatCoordinates = /** @type {ol.geom.Polygon} */ (geometry).getFlatInteriorPoint();\n          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\n            return;\n          }\n          stride = 3;\n          break;\n        case ol.geom.GeometryType.MULTI_POLYGON:\n          var interiorPoints = /** @type {ol.geom.MultiPolygon} */ (geometry).getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\n              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n            }\n          }\n          end = flatCoordinates.length;\n          if (end == 0) {\n            return;\n          }\n          break;\n        default:\n      }\n      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\n      this.beginGeometry(geometry, feature);\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n        this.updateFillStyle(this.state, this.applyFill, geometry);\n        this.updateStrokeStyle(this.state, this.applyStroke);\n      }\n      this.drawTextImage_(label, begin, end);\n      this.endGeometry(geometry, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {HTMLCanvasElement} Image.\n   */\n  ol.render.canvas.TextReplay.prototype.getImage = function(text, textKey, fillKey, strokeKey) {\n    var label;\n    var key = strokeKey + textKey + text + fillKey + this.pixelRatio;\n  \n    var labelCache = ol.render.canvas.labelCache;\n    if (!labelCache.containsKey(key)) {\n      var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\n      var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\n      var textState = this.textStates[textKey] || this.textState_;\n      var pixelRatio = this.pixelRatio;\n      var scale = textState.scale * pixelRatio;\n      var align =  ol.render.replay.TEXT_ALIGN[textState.textAlign || ol.render.canvas.defaultTextAlign];\n      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n  \n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var widths = [];\n      var width = ol.render.canvas.TextReplay.measureTextWidths(textState.font, lines, widths);\n      var lineHeight = ol.render.canvas.measureTextHeight(textState.font);\n      var height = lineHeight * numLines;\n      var renderWidth = (width + strokeWidth);\n      var context = ol.dom.createCanvasContext2D(\n          Math.ceil(renderWidth * scale),\n          Math.ceil((height + strokeWidth) * scale));\n      label = context.canvas;\n      labelCache.set(key, label);\n      if (scale != 1) {\n        context.scale(scale, scale);\n      }\n      context.font = textState.font;\n      if (strokeKey) {\n        context.strokeStyle = strokeState.strokeStyle;\n        context.lineWidth = strokeWidth * (ol.has.SAFARI ? scale : 1);\n        context.lineCap = strokeState.lineCap;\n        context.lineJoin = strokeState.lineJoin;\n        context.miterLimit = strokeState.miterLimit;\n        if (ol.has.CANVAS_LINE_DASH && strokeState.lineDash.length) {\n          context.setLineDash(strokeState.lineDash);\n          context.lineDashOffset = strokeState.lineDashOffset;\n        }\n      }\n      if (fillKey) {\n        context.fillStyle = fillState.fillStyle;\n      }\n      context.textBaseline = 'middle';\n      context.textAlign = 'center';\n      var leftRight = (0.5 - align);\n      var x = align * label.width / scale + leftRight * strokeWidth;\n      var i;\n      if (strokeKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n      if (fillKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n    }\n    return labelCache.get(key);\n  };\n  \n  \n  /**\n   * @private\n   * @param {HTMLCanvasElement} label Label.\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n  ol.render.canvas.TextReplay.prototype.drawTextImage_ = function(label, begin, end) {\n    var textState = this.textState_;\n    var strokeState = this.textStrokeState_;\n    var pixelRatio = this.pixelRatio;\n    var align = ol.render.replay.TEXT_ALIGN[textState.textAlign || ol.render.canvas.defaultTextAlign];\n    var baseline = ol.render.replay.TEXT_ALIGN[textState.textBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n  \n    var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    this.instructions.push([ol.render.canvas.Instruction.DRAW_IMAGE, begin, end,\n      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,\n      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,\n      1, true, label.width,\n      textState.padding == ol.render.canvas.defaultPadding ?\n        ol.render.canvas.defaultPadding : textState.padding.map(function(p) {\n          return p * pixelRatio;\n        }),\n      !!textState.backgroundFill, !!textState.backgroundStroke\n    ]);\n    this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_IMAGE, begin, end,\n      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,\n      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,\n      1 / pixelRatio, true, label.width, textState.padding,\n      !!textState.backgroundFill, !!textState.backgroundStroke\n    ]);\n  };\n  \n  \n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   * @param {ol.DeclutterGroup} declutterGroup Declutter group.\n   */\n  ol.render.canvas.TextReplay.prototype.drawChars_ = function(begin, end, declutterGroup) {\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    var fillState = this.textFillState_;\n  \n    var strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = /** @type {ol.CanvasStrokeState} */ ({\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        });\n      }\n    }\n    var textKey = this.textKey_;\n    if (!(this.textKey_ in this.textStates)) {\n      this.textStates[this.textKey_] = /** @type {ol.CanvasTextState} */ ({\n        font: textState.font,\n        textAlign: textState.textAlign || ol.render.canvas.defaultTextAlign,\n        scale: textState.scale\n      });\n    }\n    var fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = /** @type {ol.CanvasFillState} */ ({\n          fillStyle: fillState.fillStyle\n        });\n      }\n    }\n  \n    var pixelRatio = this.pixelRatio;\n    var baseline = ol.render.replay.TEXT_ALIGN[textState.textBaseline];\n  \n    var offsetY = this.textOffsetY_ * pixelRatio;\n    var text = this.text_;\n    var font = textState.font;\n    var textScale = textState.scale;\n    var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\n    var widths = this.widths_[font];\n    if (!widths) {\n      this.widths_[font] = widths = {};\n    }\n    this.instructions.push([ol.render.canvas.Instruction.DRAW_CHARS,\n      begin, end, baseline, declutterGroup,\n      textState.overflow, fillKey, textState.maxAngle,\n      function(text) {\n        var width = widths[text];\n        if (!width) {\n          width = widths[text] = ol.render.canvas.measureTextWidth(font, text);\n        }\n        return width * textScale * pixelRatio;\n      },\n      offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1\n    ]);\n    this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_CHARS,\n      begin, end, baseline, declutterGroup,\n      textState.overflow, fillKey, textState.maxAngle,\n      function(text) {\n        var width = widths[text];\n        if (!width) {\n          width = widths[text] = ol.render.canvas.measureTextWidth(font, text);\n        }\n        return width * textScale;\n      },\n      offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio\n    ]);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.TextReplay.prototype.setTextStyle = function(textStyle, declutterGroup) {\n    var textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      this.declutterGroup_ = /** @type {ol.DeclutterGroup} */ (declutterGroup);\n  \n      var textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = this.textFillState_ = null;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = this.textFillState_ = /** @type {ol.CanvasFillState} */ ({});\n        }\n        fillState.fillStyle = ol.colorlike.asColorLike(\n            textFillStyle.getColor() || ol.render.canvas.defaultFillStyle);\n      }\n  \n      var textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = this.textStrokeState_ = null;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = this.textStrokeState_ = /** @type {ol.CanvasStrokeState} */ ({});\n        }\n        var lineDash = textStrokeStyle.getLineDash();\n        var lineDashOffset = textStrokeStyle.getLineDashOffset();\n        var lineWidth = textStrokeStyle.getWidth();\n        var miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || ol.render.canvas.defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : ol.render.canvas.defaultLineDash;\n        strokeState.lineDashOffset =\n            lineDashOffset === undefined ? ol.render.canvas.defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || ol.render.canvas.defaultLineJoin;\n        strokeState.lineWidth =\n            lineWidth === undefined ? ol.render.canvas.defaultLineWidth : lineWidth;\n        strokeState.miterLimit =\n            miterLimit === undefined ? ol.render.canvas.defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = ol.colorlike.asColorLike(\n            textStrokeStyle.getColor() || ol.render.canvas.defaultStrokeStyle);\n      }\n  \n      textState = this.textState_;\n      var font = textStyle.getFont() || ol.render.canvas.defaultFont;\n      ol.render.canvas.checkFont(font);\n      var textScale = textStyle.getScale();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.textBaseline = textStyle.getTextBaseline() || ol.render.canvas.defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || ol.render.canvas.defaultPadding;\n      textState.scale = textScale === undefined ? 1 : textScale;\n  \n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n  \n      this.strokeKey_ = strokeState ?\n        (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : ol.getUid(strokeState.strokeStyle)) +\n        strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +\n        strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :\n        '';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');\n      this.fillKey_ = fillState ?\n        (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + ol.getUid(fillState.fillStyle))) :\n        '';\n    }\n  };\n  \n  goog.provide('ol.render.canvas.ReplayGroup');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.dom');\n  goog.require('ol.extent');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.obj');\n  goog.require('ol.render.ReplayGroup');\n  goog.require('ol.render.ReplayType');\n  goog.require('ol.render.canvas.Replay');\n  goog.require('ol.render.canvas.ImageReplay');\n  goog.require('ol.render.canvas.LineStringReplay');\n  goog.require('ol.render.canvas.PolygonReplay');\n  goog.require('ol.render.canvas.TextReplay');\n  goog.require('ol.render.replay');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.ReplayGroup}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay group can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree\n   * for declutter processing in postrender.\n   * @param {number=} opt_renderBuffer Optional rendering buffer.\n   * @struct\n   */\n  ol.render.canvas.ReplayGroup = function(\n      tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {\n    ol.render.ReplayGroup.call(this);\n  \n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = declutterTree;\n  \n    /**\n     * @type {ol.DeclutterGroup}\n     * @private\n     */\n    this.declutterGroup_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.tolerance_ = tolerance;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.maxExtent_ = maxExtent;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n  \n    /**\n     * @private\n     * @type {!Object.<string,\n     *        Object.<ol.render.ReplayType, ol.render.canvas.Replay>>}\n     */\n    this.replaysByZIndex_ = {};\n  \n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = ol.dom.createCanvasContext2D(1, 1);\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.hitDetectionTransform_ = ol.transform.create();\n  };\n  ol.inherits(ol.render.canvas.ReplayGroup, ol.render.ReplayGroup);\n  \n  \n  /**\n   * This cache is used for storing calculated pixel circles for increasing performance.\n   * It is a static property to allow each Replaygroup to access it.\n   * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}\n   * @private\n   */\n  ol.render.canvas.ReplayGroup.circleArrayCache_ = {\n    0: [[true]]\n  };\n  \n  \n  /**\n   * This method fills a row in the array from the given coordinate to the\n   * middle with `true`.\n   * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.\n   * @param {number} x X coordinate.\n   * @param {number} y Y coordinate.\n   * @private\n   */\n  ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_ = function(array, x, y) {\n    var i;\n    var radius = Math.floor(array.length / 2);\n    if (x >= radius) {\n      for (i = radius; i < x; i++) {\n        array[i][y] = true;\n      }\n    } else if (x < radius) {\n      for (i = x + 1; i < radius; i++) {\n        array[i][y] = true;\n      }\n    }\n  };\n  \n  \n  /**\n   * This methods creates a circle inside a fitting array. Points inside the\n   * circle are marked by true, points on the outside are undefined.\n   * It uses the midpoint circle algorithm.\n   * A cache is used to increase performance.\n   * @param {number} radius Radius.\n   * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.\n   * @private\n   */\n  ol.render.canvas.ReplayGroup.getCircleArray_ = function(radius) {\n    if (ol.render.canvas.ReplayGroup.circleArrayCache_[radius] !== undefined) {\n      return ol.render.canvas.ReplayGroup.circleArrayCache_[radius];\n    }\n  \n    var arraySize = radius * 2 + 1;\n    var arr = new Array(arraySize);\n    for (var i = 0; i < arraySize; i++) {\n      arr[i] = new Array(arraySize);\n    }\n  \n    var x = radius;\n    var y = 0;\n    var error = 0;\n  \n    while (x >= y) {\n      ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius + x, radius + y);\n      ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius + y, radius + x);\n      ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius - y, radius + x);\n      ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius - x, radius + y);\n      ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius - x, radius - y);\n      ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius - y, radius - x);\n      ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius + y, radius - x);\n      ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius + x, radius - y);\n  \n      y++;\n      error += 1 + 2 * y;\n      if (2 * (error - x) + 1 > 0) {\n        x -= 1;\n        error += 1 - 2 * x;\n      }\n    }\n  \n    ol.render.canvas.ReplayGroup.circleArrayCache_[radius] = arr;\n    return arr;\n  };\n  \n  \n  /**\n   * @param {!Object.<string, Array.<*>>} declutterReplays Declutter replays.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} rotation Rotation.\n   */\n  ol.render.canvas.ReplayGroup.replayDeclutter = function(declutterReplays, context, rotation) {\n    var zs = Object.keys(declutterReplays).map(Number).sort(ol.array.numberSafeCompareFunction);\n    var skippedFeatureUids = {};\n    for (var z = 0, zz = zs.length; z < zz; ++z) {\n      var replayData = declutterReplays[zs[z].toString()];\n      for (var i = 0, ii = replayData.length; i < ii;) {\n        var replay = replayData[i++];\n        var transform = replayData[i++];\n        replay.replay(context, transform, rotation, skippedFeatureUids);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {boolean} group Group with previous replay.\n   * @return {ol.DeclutterGroup} Declutter instruction group.\n   */\n  ol.render.canvas.ReplayGroup.prototype.addDeclutter = function(group) {\n    var declutter = null;\n    if (this.declutterTree_) {\n      if (group) {\n        declutter = this.declutterGroup_;\n        /** @type {number} */ (declutter[4])++;\n      } else {\n        declutter = this.declutterGroup_ = ol.extent.createEmpty();\n        declutter.push(1);\n      }\n    }\n    return declutter;\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {ol.Transform} transform Transform.\n   */\n  ol.render.canvas.ReplayGroup.prototype.clip = function(context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  \n  \n  /**\n   * @param {Array.<ol.render.ReplayType>} replays Replays.\n   * @return {boolean} Has replays of the provided types.\n   */\n  ol.render.canvas.ReplayGroup.prototype.hasReplays = function(replays) {\n    for (var zIndex in this.replaysByZIndex_) {\n      var candidates = this.replaysByZIndex_[zIndex];\n      for (var i = 0, ii = replays.length; i < ii; ++i) {\n        if (replays[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  \n  \n  /**\n   * FIXME empty description for jsdoc\n   */\n  ol.render.canvas.ReplayGroup.prototype.finish = function() {\n    var zKey;\n    for (zKey in this.replaysByZIndex_) {\n      var replays = this.replaysByZIndex_[zKey];\n      var replayKey;\n      for (replayKey in replays) {\n        replays[replayKey].finish();\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature\n   *     callback.\n   * @param {Object.<string, ol.DeclutterGroup>} declutterReplays Declutter\n   *     replays.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.canvas.ReplayGroup.prototype.forEachFeatureAtCoordinate = function(\n      coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {\n  \n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = ol.transform.compose(this.hitDetectionTransform_,\n        hitTolerance + 0.5, hitTolerance + 0.5,\n        1 / resolution, -1 / resolution,\n        -rotation,\n        -coordinate[0], -coordinate[1]);\n    var context = this.hitDetectionContext_;\n  \n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n  \n    /**\n     * @type {ol.Extent}\n     */\n    var hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = ol.extent.createEmpty();\n      ol.extent.extendCoordinate(hitExtent, coordinate);\n      ol.extent.buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n  \n    var mask = ol.render.canvas.ReplayGroup.getCircleArray_(hitTolerance);\n    var declutteredFeatures;\n    if (this.declutterTree_) {\n      declutteredFeatures = this.declutterTree_.all().map(function(entry) {\n        return entry.value;\n      });\n    }\n  \n    var replayType;\n  \n    /**\n     * @param {ol.Feature|ol.render.Feature} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (var i = 0; i < contextSize; i++) {\n        for (var j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              var result;\n              if (!(declutteredFeatures && (replayType == ol.render.ReplayType.IMAGE || replayType == ol.render.ReplayType.TEXT)) ||\n                  declutteredFeatures.indexOf(feature) !== -1) {\n                result = callback(feature);\n              }\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n  \n    /** @type {Array.<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(ol.array.numberSafeCompareFunction);\n  \n    var i, j, replays, replay, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = ol.render.replay.ORDER.length - 1; j >= 0; --j) {\n        replayType = ol.render.replay.ORDER[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (declutterReplays &&\n              (replayType == ol.render.ReplayType.IMAGE || replayType == ol.render.ReplayType.TEXT)) {\n            var declutter = declutterReplays[zIndexKey];\n            if (!declutter) {\n              declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            result = replay.replayHitDetection(context, transform, rotation,\n                skippedFeaturesHash, featureCallback, hitExtent);\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @param {ol.Transform} transform Transform.\n   * @return {Array.<number>} Clip coordinates.\n   */\n  ol.render.canvas.ReplayGroup.prototype.getClipCoords = function(transform) {\n    var maxExtent = this.maxExtent_;\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    ol.geom.flat.transform.transform2D(\n        flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.ReplayGroup.prototype.getReplay = function(zIndex, replayType) {\n    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n    var replays = this.replaysByZIndex_[zIndexKey];\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n    var replay = replays[replayType];\n    if (replay === undefined) {\n      var Constructor = ol.render.canvas.ReplayGroup.BATCH_CONSTRUCTORS_[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_,\n          this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n      replays[replayType] = replay;\n    }\n    return replay;\n  };\n  \n  \n  /**\n   * @return {Object.<string, Object.<ol.render.ReplayType, ol.render.canvas.Replay>>} Replays.\n   */\n  ol.render.canvas.ReplayGroup.prototype.getReplays = function() {\n    return this.replaysByZIndex_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.canvas.ReplayGroup.prototype.isEmpty = function() {\n    return ol.obj.isEmpty(this.replaysByZIndex_);\n  };\n  \n  \n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {ol.Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {Array.<ol.render.ReplayType>=} opt_replayTypes Ordered replay types\n   *     to replay. Default is {@link ol.render.replay.ORDER}\n   * @param {Object.<string, ol.DeclutterGroup>=} opt_declutterReplays Declutter\n   *     replays.\n   */\n  ol.render.canvas.ReplayGroup.prototype.replay = function(context,\n      transform, viewRotation, skippedFeaturesHash, opt_replayTypes, opt_declutterReplays) {\n  \n    /** @type {Array.<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(ol.array.numberSafeCompareFunction);\n  \n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    context.save();\n    this.clip(context, transform);\n  \n    var replayTypes = opt_replayTypes ? opt_replayTypes : ol.render.replay.ORDER;\n    var i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n        var replayType = replayTypes[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays &&\n              (replayType == ol.render.ReplayType.IMAGE || replayType == ol.render.ReplayType.TEXT)) {\n            var declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.replay(context, transform, viewRotation, skippedFeaturesHash);\n          }\n        }\n      }\n    }\n  \n    context.restore();\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Object.<ol.render.ReplayType,\n   *                function(new: ol.render.canvas.Replay, number, ol.Extent,\n   *                number, number, boolean, Array.<ol.DeclutterGroup>)>}\n   */\n  ol.render.canvas.ReplayGroup.BATCH_CONSTRUCTORS_ = {\n    'Circle': ol.render.canvas.PolygonReplay,\n    'Default': ol.render.canvas.Replay,\n    'Image': ol.render.canvas.ImageReplay,\n    'LineString': ol.render.canvas.LineStringReplay,\n    'Polygon': ol.render.canvas.PolygonReplay,\n    'Text': ol.render.canvas.TextReplay\n  };\n  \n  goog.provide('ol.renderer.vector');\n  \n  goog.require('ol');\n  goog.require('ol.ImageState');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.render.ReplayType');\n  \n  \n  /**\n   * @param {ol.Feature|ol.render.Feature} feature1 Feature 1.\n   * @param {ol.Feature|ol.render.Feature} feature2 Feature 2.\n   * @return {number} Order.\n   */\n  ol.renderer.vector.defaultOrder = function(feature1, feature2) {\n    return ol.getUid(feature1) - ol.getUid(feature2);\n  };\n  \n  \n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Squared pixel tolerance.\n   */\n  ol.renderer.vector.getSquaredTolerance = function(resolution, pixelRatio) {\n    var tolerance = ol.renderer.vector.getTolerance(resolution, pixelRatio);\n    return tolerance * tolerance;\n  };\n  \n  \n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Pixel tolerance.\n   */\n  ol.renderer.vector.getTolerance = function(resolution, pixelRatio) {\n    return ol.SIMPLIFY_TOLERANCE * resolution / pixelRatio;\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.Circle} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderCircleGeometry_ = function(replayGroup, geometry, style, feature) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n      var circleReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.CIRCLE);\n      circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n      circleReplay.drawCircle(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle) {\n      var textReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.TEXT);\n      textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n      textReplay.drawText(geometry, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @param {ol.style.Style} style Style.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {function(this: T, ol.events.Event)} listener Listener function.\n   * @param {T} thisArg Value to use as `this` when executing `listener`.\n   * @return {boolean} `true` if style is loading.\n   * @template T\n   */\n  ol.renderer.vector.renderFeature = function(\n      replayGroup, feature, style, squaredTolerance, listener, thisArg) {\n    var loading = false;\n    var imageStyle, imageState;\n    imageStyle = style.getImage();\n    if (imageStyle) {\n      imageState = imageStyle.getImageState();\n      if (imageState == ol.ImageState.LOADED ||\n          imageState == ol.ImageState.ERROR) {\n        imageStyle.unlistenImageChange(listener, thisArg);\n      } else {\n        if (imageState == ol.ImageState.IDLE) {\n          imageStyle.load();\n        }\n        imageState = imageStyle.getImageState();\n        imageStyle.listenImageChange(listener, thisArg);\n        loading = true;\n      }\n    }\n    ol.renderer.vector.renderFeature_(replayGroup, feature, style,\n        squaredTolerance);\n  \n    return loading;\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @param {ol.style.Style} style Style.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  ol.renderer.vector.renderFeature_ = function(\n      replayGroup, feature, style, squaredTolerance) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry) {\n      return;\n    }\n    var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n    var renderer = style.getRenderer();\n    if (renderer) {\n      ol.renderer.vector.renderGeometry_(replayGroup, simplifiedGeometry, style, feature);\n    } else {\n      var geometryRenderer =\n          ol.renderer.vector.GEOMETRY_RENDERERS_[simplifiedGeometry.getType()];\n      geometryRenderer(replayGroup, simplifiedGeometry, style, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderGeometry_ = function(replayGroup, geometry, style, feature) {\n    if (geometry.getType() == ol.geom.GeometryType.GEOMETRY_COLLECTION) {\n      var geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();\n      for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        ol.renderer.vector.renderGeometry_(replayGroup, geometries[i], style, feature);\n      }\n      return;\n    }\n    var replay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.DEFAULT);\n    replay.drawCustom(/** @type {ol.geom.SimpleGeometry} */ (geometry), feature, style.getRenderer());\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.GeometryCollection} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderGeometryCollectionGeometry_ = function(replayGroup, geometry, style, feature) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      var geometryRenderer =\n          ol.renderer.vector.GEOMETRY_RENDERERS_[geometries[i].getType()];\n      geometryRenderer(replayGroup, geometries[i], style, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.LineString|ol.render.Feature} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderLineStringGeometry_ = function(replayGroup, geometry, style, feature) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n      var lineStringReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.LINE_STRING);\n      lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n      lineStringReplay.drawLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle) {\n      var textReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.TEXT);\n      textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n      textReplay.drawText(geometry, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.MultiLineString|ol.render.Feature} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderMultiLineStringGeometry_ = function(replayGroup, geometry, style, feature) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n      var lineStringReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.LINE_STRING);\n      lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n      lineStringReplay.drawMultiLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle) {\n      var textReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.TEXT);\n      textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n      textReplay.drawText(geometry, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.MultiPolygon} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderMultiPolygonGeometry_ = function(replayGroup, geometry, style, feature) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (strokeStyle || fillStyle) {\n      var polygonReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.POLYGON);\n      polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n      polygonReplay.drawMultiPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle) {\n      var textReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.TEXT);\n      textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n      textReplay.drawText(geometry, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.Point|ol.render.Feature} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderPointGeometry_ = function(replayGroup, geometry, style, feature) {\n    var imageStyle = style.getImage();\n    if (imageStyle) {\n      if (imageStyle.getImageState() != ol.ImageState.LOADED) {\n        return;\n      }\n      var imageReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.IMAGE);\n      imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));\n      imageReplay.drawPoint(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle) {\n      var textReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.TEXT);\n      textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));\n      textReplay.drawText(geometry, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.MultiPoint|ol.render.Feature} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderMultiPointGeometry_ = function(replayGroup, geometry, style, feature) {\n    var imageStyle = style.getImage();\n    if (imageStyle) {\n      if (imageStyle.getImageState() != ol.ImageState.LOADED) {\n        return;\n      }\n      var imageReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.IMAGE);\n      imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));\n      imageReplay.drawMultiPoint(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle) {\n      var textReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.TEXT);\n      textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));\n      textReplay.drawText(geometry, feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.Polygon|ol.render.Feature} geometry Geometry.\n   * @param {ol.style.Style} style Style.\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @private\n   */\n  ol.renderer.vector.renderPolygonGeometry_ = function(replayGroup, geometry, style, feature) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n      var polygonReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.POLYGON);\n      polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n      polygonReplay.drawPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle) {\n      var textReplay = replayGroup.getReplay(\n          style.getZIndex(), ol.render.ReplayType.TEXT);\n      textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n      textReplay.drawText(geometry, feature);\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Object.<ol.geom.GeometryType,\n   *                function(ol.render.ReplayGroup, ol.geom.Geometry,\n   *                         ol.style.Style, Object)>}\n   */\n  ol.renderer.vector.GEOMETRY_RENDERERS_ = {\n    'Point': ol.renderer.vector.renderPointGeometry_,\n    'LineString': ol.renderer.vector.renderLineStringGeometry_,\n    'Polygon': ol.renderer.vector.renderPolygonGeometry_,\n    'MultiPoint': ol.renderer.vector.renderMultiPointGeometry_,\n    'MultiLineString': ol.renderer.vector.renderMultiLineStringGeometry_,\n    'MultiPolygon': ol.renderer.vector.renderMultiPolygonGeometry_,\n    'GeometryCollection': ol.renderer.vector.renderGeometryCollectionGeometry_,\n    'Circle': ol.renderer.vector.renderCircleGeometry_\n  };\n  \n  goog.provide('ol.renderer.canvas.VectorLayer');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.ViewHint');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.ext.rbush');\n  goog.require('ol.extent');\n  goog.require('ol.render.EventType');\n  goog.require('ol.render.canvas');\n  goog.require('ol.render.canvas.ReplayGroup');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.renderer.canvas.Layer');\n  goog.require('ol.renderer.vector');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.canvas.Layer}\n   * @param {ol.layer.Vector} vectorLayer Vector layer.\n   * @api\n   */\n  ol.renderer.canvas.VectorLayer = function(vectorLayer) {\n  \n    ol.renderer.canvas.Layer.call(this, vectorLayer);\n  \n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = vectorLayer.getDeclutter() ?\n      ol.ext.rbush(9) : null;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.renderedExtent_ = ol.extent.createEmpty();\n  \n    /**\n     * @private\n     * @type {function(ol.Feature, ol.Feature): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n  \n    /**\n     * @private\n     * @type {ol.render.canvas.ReplayGroup}\n     */\n    this.replayGroup_ = null;\n  \n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n  \n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = ol.dom.createCanvasContext2D();\n  \n    ol.events.listen(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);\n  \n  };\n  ol.inherits(ol.renderer.canvas.VectorLayer, ol.renderer.canvas.Layer);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @param {ol.layer.Layer} layer The candidate layer.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.canvas.VectorLayer['handles'] = function(type, layer) {\n    return type === ol.renderer.Type.CANVAS && layer.getType() === ol.LayerType.VECTOR;\n  };\n  \n  \n  /**\n   * Create a layer renderer.\n   * @param {ol.renderer.Map} mapRenderer The map renderer.\n   * @param {ol.layer.Layer} layer The layer to be rendererd.\n   * @return {ol.renderer.canvas.VectorLayer} The layer renderer.\n   */\n  ol.renderer.canvas.VectorLayer['create'] = function(mapRenderer, layer) {\n    return new ol.renderer.canvas.VectorLayer(/** @type {ol.layer.Vector} */ (layer));\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorLayer.prototype.disposeInternal = function() {\n    ol.events.unlisten(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);\n    ol.renderer.canvas.Layer.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorLayer.prototype.composeFrame = function(frameState, layerState, context) {\n  \n    var extent = frameState.extent;\n    var pixelRatio = frameState.pixelRatio;\n    var skippedFeatureUids = layerState.managed ?\n      frameState.skippedFeatureUids : {};\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var rotation = viewState.rotation;\n    var projectionExtent = projection.getExtent();\n    var vectorSource = /** @type {ol.source.Vector} */ (this.getLayer().getSource());\n  \n    var transform = this.getTransform(frameState, 0);\n  \n    this.preCompose(context, frameState, transform);\n  \n    // clipped rendering if layer extent is set\n    var clipExtent = layerState.extent;\n    var clipped = clipExtent !== undefined;\n    if (clipped) {\n      this.clip(context, frameState,  /** @type {ol.Extent} */ (clipExtent));\n    }\n    var replayGroup = this.replayGroup_;\n    if (replayGroup && !replayGroup.isEmpty()) {\n      if (this.declutterTree_) {\n        this.declutterTree_.clear();\n      }\n      var layer = /** @type {ol.layer.Vector} */ (this.getLayer());\n      var drawOffsetX = 0;\n      var drawOffsetY = 0;\n      var replayContext;\n      var transparentLayer = layerState.opacity !== 1;\n      var hasRenderListeners = layer.hasListener(ol.render.EventType.RENDER);\n      if (transparentLayer || hasRenderListeners) {\n        var drawWidth = context.canvas.width;\n        var drawHeight = context.canvas.height;\n        if (rotation) {\n          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n          drawOffsetX = (drawSize - drawWidth) / 2;\n          drawOffsetY = (drawSize - drawHeight) / 2;\n          drawWidth = drawHeight = drawSize;\n        }\n        // resize and clear\n        this.context.canvas.width = drawWidth;\n        this.context.canvas.height = drawHeight;\n        replayContext = this.context;\n      } else {\n        replayContext = context;\n      }\n  \n      var alpha = replayContext.globalAlpha;\n      if (!transparentLayer) {\n        // for performance reasons, context.save / context.restore is not used\n        // to save and restore the transformation matrix and the opacity.\n        // see http://jsperf.com/context-save-restore-versus-variable\n        replayContext.globalAlpha = layerState.opacity;\n      }\n  \n      if (replayContext != context) {\n        replayContext.translate(drawOffsetX, drawOffsetY);\n      }\n  \n      var width = frameState.size[0] * pixelRatio;\n      var height = frameState.size[1] * pixelRatio;\n      ol.render.canvas.rotateAtOffset(replayContext, -rotation,\n          width / 2, height / 2);\n      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n      if (vectorSource.getWrapX() && projection.canWrapX() &&\n          !ol.extent.containsExtent(projectionExtent, extent)) {\n        var startX = extent[0];\n        var worldWidth = ol.extent.getWidth(projectionExtent);\n        var world = 0;\n        var offsetX;\n        while (startX < projectionExtent[0]) {\n          --world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n          startX += worldWidth;\n        }\n        world = 0;\n        startX = extent[2];\n        while (startX > projectionExtent[2]) {\n          ++world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n          startX -= worldWidth;\n        }\n        // restore original transform for render and compose events\n        transform = this.getTransform(frameState, 0);\n      }\n      ol.render.canvas.rotateAtOffset(replayContext, rotation,\n          width / 2, height / 2);\n  \n      if (replayContext != context) {\n        if (hasRenderListeners) {\n          this.dispatchRenderEvent(replayContext, frameState, transform);\n        }\n        if (transparentLayer) {\n          var mainContextAlpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity;\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n          context.globalAlpha = mainContextAlpha;\n        } else {\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n        }\n        replayContext.translate(-drawOffsetX, -drawOffsetY);\n      }\n  \n      if (!transparentLayer) {\n        replayContext.globalAlpha = alpha;\n      }\n    }\n  \n    if (clipped) {\n      context.restore();\n    }\n    this.postCompose(context, frameState, layerState, transform);\n  \n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      var resolution = frameState.viewState.resolution;\n      var rotation = frameState.viewState.rotation;\n      var layer = /** @type {ol.layer.Vector} */ (this.getLayer());\n      /** @type {Object.<string, boolean>} */\n      var features = {};\n      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution,\n          rotation, hitTolerance, {},\n          /**\n           * @param {ol.Feature|ol.render.Feature} feature Feature.\n           * @return {?} Callback result.\n           */\n          function(feature) {\n            var key = ol.getUid(feature).toString();\n            if (!(key in features)) {\n              features[key] = true;\n              return callback.call(thisArg, feature, layer);\n            }\n          }, null);\n      return result;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.events.Event} event Event.\n   */\n  ol.renderer.canvas.VectorLayer.prototype.handleFontsChanged_ = function(event) {\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  };\n  \n  \n  /**\n   * Handle changes in image style state.\n   * @param {ol.events.Event} event Image style change event.\n   * @private\n   */\n  ol.renderer.canvas.VectorLayer.prototype.handleStyleImageChange_ = function(event) {\n    this.renderIfReadyAndVisible();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorLayer.prototype.prepareFrame = function(frameState, layerState) {\n  \n    var vectorLayer = /** @type {ol.layer.Vector} */ (this.getLayer());\n    var vectorSource = vectorLayer.getSource();\n  \n    this.updateLogos(frameState, vectorSource);\n  \n    var animating = frameState.viewHints[ol.ViewHint.ANIMATING];\n    var interacting = frameState.viewHints[ol.ViewHint.INTERACTING];\n    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n  \n    if (!this.dirty_ && (!updateWhileAnimating && animating) ||\n        (!updateWhileInteracting && interacting)) {\n      return true;\n    }\n  \n    var frameStateExtent = frameState.extent;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var vectorLayerRevision = vectorLayer.getRevision();\n    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n  \n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = ol.renderer.vector.defaultOrder;\n    }\n  \n    var extent = ol.extent.buffer(frameStateExtent,\n        vectorLayerRenderBuffer * resolution);\n    var projectionExtent = viewState.projection.getExtent();\n  \n    if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&\n        !ol.extent.containsExtent(projectionExtent, frameState.extent)) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      var worldWidth = ol.extent.getWidth(projectionExtent);\n      var buffer = Math.max(ol.extent.getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - buffer;\n      extent[2] = projectionExtent[2] + buffer;\n    }\n  \n    if (!this.dirty_ &&\n        this.renderedResolution_ == resolution &&\n        this.renderedRevision_ == vectorLayerRevision &&\n        this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n        ol.extent.containsExtent(this.renderedExtent_, extent)) {\n      this.replayGroupChanged = false;\n      return true;\n    }\n  \n    this.replayGroup_ = null;\n  \n    this.dirty_ = false;\n  \n    var replayGroup = new ol.render.canvas.ReplayGroup(\n        ol.renderer.vector.getTolerance(resolution, pixelRatio), extent, resolution,\n        pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {ol.Feature} feature Feature.\n     * @this {ol.renderer.canvas.VectorLayer}\n     */\n    var renderFeature = function(feature) {\n      var styles;\n      var styleFunction = feature.getStyleFunction();\n      if (styleFunction) {\n        styles = styleFunction.call(feature, resolution);\n      } else {\n        styleFunction = vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n      }\n      if (styles) {\n        var dirty = this.renderFeature(\n            feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n    if (vectorLayerRenderOrder) {\n      /** @type {Array.<ol.Feature>} */\n      var features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n          /**\n           * @param {ol.Feature} feature Feature.\n           */\n          function(feature) {\n            features.push(feature);\n          }, this);\n      features.sort(vectorLayerRenderOrder);\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        renderFeature(features[i]);\n      }\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, renderFeature, this);\n    }\n    replayGroup.finish();\n  \n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n  \n    this.replayGroupChanged = true;\n    return true;\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of\n   *     styles.\n   * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  ol.renderer.canvas.VectorLayer.prototype.renderFeature = function(feature, resolution, pixelRatio, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = ol.renderer.vector.renderFeature(\n            replayGroup, feature, styles[i],\n            ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio),\n            this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = ol.renderer.vector.renderFeature(\n          replayGroup, feature, styles,\n          ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio),\n          this.handleStyleImageChange_, this);\n    }\n    return loading;\n  };\n  \n  goog.provide('ol.layer.VectorTileRenderType');\n  \n  /**\n   * @enum {string}\n   * Render mode for vector tiles:\n   *  * `'image'`: Vector tiles are rendered as images. Great performance, but\n   *    point symbols and texts are always rotated with the view and pixels are\n   *    scaled during zoom animations.\n   *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels\n   *    are scaled during zoom animations. Point symbols and texts are accurately\n   *    rendered as vectors and can stay upright on rotated views.\n   *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering\n   *    even during animations, but slower performance than the other options.\n   * @api\n   */\n  ol.layer.VectorTileRenderType = {\n    IMAGE: 'image',\n    HYBRID: 'hybrid',\n    VECTOR: 'vector'\n  };\n  \n  goog.provide('ol.renderer.canvas.VectorTileLayer');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.TileState');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.ext.rbush');\n  goog.require('ol.extent');\n  goog.require('ol.layer.VectorTileRenderType');\n  goog.require('ol.proj');\n  goog.require('ol.proj.Units');\n  goog.require('ol.render.ReplayType');\n  goog.require('ol.render.canvas');\n  goog.require('ol.render.canvas.ReplayGroup');\n  goog.require('ol.render.replay');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.renderer.canvas.TileLayer');\n  goog.require('ol.renderer.vector');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.canvas.TileLayer}\n   * @param {ol.layer.VectorTile} layer VectorTile layer.\n   * @api\n   */\n  ol.renderer.canvas.VectorTileLayer = function(layer) {\n  \n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n  \n    ol.renderer.canvas.TileLayer.call(this, layer);\n  \n    /**\n     * Declutter tree.\n     * @private\n       */\n    this.declutterTree_ = layer.getDeclutter() ? ol.ext.rbush(9) : null;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.tmpTransform_ = ol.transform.create();\n  \n    // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n    this.zDirection =\n        layer.getRenderMode() == ol.layer.VectorTileRenderType.VECTOR ? 1 : 0;\n  \n    ol.events.listen(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);\n  \n  };\n  ol.inherits(ol.renderer.canvas.VectorTileLayer, ol.renderer.canvas.TileLayer);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @param {ol.layer.Layer} layer The candidate layer.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.canvas.VectorTileLayer['handles'] = function(type, layer) {\n    return type === ol.renderer.Type.CANVAS && layer.getType() === ol.LayerType.VECTOR_TILE;\n  };\n  \n  \n  /**\n   * Create a layer renderer.\n   * @param {ol.renderer.Map} mapRenderer The map renderer.\n   * @param {ol.layer.Layer} layer The layer to be rendererd.\n   * @return {ol.renderer.canvas.VectorTileLayer} The layer renderer.\n   */\n  ol.renderer.canvas.VectorTileLayer['create'] = function(mapRenderer, layer) {\n    return new ol.renderer.canvas.VectorTileLayer(/** @type {ol.layer.VectorTile} */ (layer));\n  };\n  \n  \n  /**\n   * @const\n   * @type {!Object.<string, Array.<ol.render.ReplayType>>}\n   */\n  ol.renderer.canvas.VectorTileLayer.IMAGE_REPLAYS = {\n    'image': [ol.render.ReplayType.POLYGON, ol.render.ReplayType.CIRCLE,\n      ol.render.ReplayType.LINE_STRING, ol.render.ReplayType.IMAGE, ol.render.ReplayType.TEXT],\n    'hybrid': [ol.render.ReplayType.POLYGON, ol.render.ReplayType.LINE_STRING]\n  };\n  \n  \n  /**\n   * @const\n   * @type {!Object.<string, Array.<ol.render.ReplayType>>}\n   */\n  ol.renderer.canvas.VectorTileLayer.VECTOR_REPLAYS = {\n    'image': [ol.render.ReplayType.DEFAULT],\n    'hybrid': [ol.render.ReplayType.IMAGE, ol.render.ReplayType.TEXT, ol.render.ReplayType.DEFAULT],\n    'vector': ol.render.replay.ORDER\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.disposeInternal = function() {\n    ol.events.unlisten(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);\n    ol.renderer.canvas.TileLayer.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.prepareFrame = function(frameState, layerState) {\n    var layer = this.getLayer();\n    var layerRevision = layer.getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n      var renderMode = layer.getRenderMode();\n      if (!this.context && renderMode != ol.layer.VectorTileRenderType.VECTOR) {\n        this.context = ol.dom.createCanvasContext2D();\n      }\n      if (this.context && renderMode == ol.layer.VectorTileRenderType.VECTOR) {\n        this.context = null;\n      }\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return ol.renderer.canvas.TileLayer.prototype.prepareFrame.apply(this, arguments);\n  };\n  \n  \n  /**\n   * @param {ol.VectorImageTile} tile Tile.\n   * @param {olx.FrameState} frameState Frame state.\n   * @private\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.createReplayGroup_ = function(\n      tile, frameState) {\n    var layer = this.getLayer();\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var revision = layer.getRevision();\n    var renderOrder = /** @type {ol.RenderOrderFunction} */\n        (layer.getRenderOrder()) || null;\n  \n    var replayState = tile.getReplayState(layer);\n    if (!replayState.dirty && replayState.renderedRevision == revision &&\n        replayState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n  \n    var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var resolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n  \n    var zIndexKeys = {};\n    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n      var sourceTile = tile.getTile(tile.tileKeys[t]);\n      if (sourceTile.getState() == ol.TileState.ERROR) {\n        continue;\n      }\n  \n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = ol.extent.getIntersection(tileExtent, sourceTileExtent);\n      var bufferedExtent = ol.extent.equals(sourceTileExtent, sharedExtent) ? null :\n        ol.extent.buffer(sharedExtent, layer.getRenderBuffer() * resolution);\n      var tileProjection = sourceTile.getProjection();\n      var reproject = false;\n      if (!ol.proj.equivalent(projection, tileProjection)) {\n        reproject = true;\n        sourceTile.setProjection(projection);\n      }\n      replayState.dirty = false;\n      var replayGroup = new ol.render.canvas.ReplayGroup(0, sharedExtent, resolution,\n          pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());\n      var squaredTolerance = ol.renderer.vector.getSquaredTolerance(\n          resolution, pixelRatio);\n  \n      /**\n       * @param {ol.Feature|ol.render.Feature} feature Feature.\n       * @this {ol.renderer.canvas.VectorTileLayer}\n       */\n      var renderFeature = function(feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction.call(/** @type {ol.Feature} */ (feature), resolution);\n        } else {\n          styleFunction = layer.getStyleFunction();\n          if (styleFunction) {\n            styles = styleFunction(feature, resolution);\n          }\n        }\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles,\n              replayGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          replayState.dirty = replayState.dirty || dirty;\n        }\n      };\n  \n      var features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      var feature;\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        feature = features[i];\n        if (reproject) {\n          if (tileProjection.getUnits() == ol.proj.Units.TILE_PIXELS) {\n            // projected tile extent\n            tileProjection.setWorldExtent(sourceTileExtent);\n            // tile extent in tile pixel space\n            tileProjection.setExtent(sourceTile.getExtent());\n          }\n          feature.getGeometry().transform(tileProjection, projection);\n        }\n        if (!bufferedExtent || ol.extent.intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          renderFeature.call(this, feature);\n        }\n      }\n      replayGroup.finish();\n      for (var r in replayGroup.getReplays()) {\n        zIndexKeys[r] = true;\n      }\n      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n    }\n    replayState.renderedRevision = revision;\n    replayState.renderedRenderOrder = renderOrder;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.drawTileImage = function(\n      tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    var vectorImageTile = /** @type {ol.VectorImageTile} */ (tile);\n    this.createReplayGroup_(vectorImageTile, frameState);\n    if (this.context) {\n      this.renderTileImage_(vectorImageTile, frameState, layerState);\n      ol.renderer.canvas.TileLayer.prototype.drawTileImage.apply(this, arguments);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    /** @type {Object.<string, boolean>} */\n    var features = {};\n  \n    /** @type {Array.<ol.VectorImageTile>} */\n    var renderedTiles = this.renderedTiles;\n  \n    var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var bufferedExtent, found;\n    var i, ii, replayGroup;\n    var tile, tileCoord, tileExtent;\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      tile = renderedTiles[i];\n      tileCoord = tile.wrappedTileCoord;\n      tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n      bufferedExtent = ol.extent.buffer(tileExtent, hitTolerance * resolution, bufferedExtent);\n      if (!ol.extent.containsCoordinate(bufferedExtent, coordinate)) {\n        continue;\n      }\n      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        var sourceTile = tile.getTile(tile.tileKeys[t]);\n        if (sourceTile.getState() == ol.TileState.ERROR) {\n          continue;\n        }\n        replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        found = found || replayGroup.forEachFeatureAtCoordinate(\n            coordinate, resolution, rotation, hitTolerance, {},\n            /**\n             * @param {ol.Feature|ol.render.Feature} feature Feature.\n             * @return {?} Callback result.\n             */\n            function(feature) {\n              var key = ol.getUid(feature).toString();\n              if (!(key in features)) {\n                features[key] = true;\n                return callback.call(thisArg, feature, layer);\n              }\n            }, null);\n      }\n    }\n    return found;\n  };\n  \n  \n  /**\n   * @param {ol.VectorTile} tile Tile.\n   * @param {olx.FrameState} frameState Frame state.\n   * @return {ol.Transform} transform Transform.\n   * @private\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.getReplayTransform_ = function(tile, frameState) {\n    var layer = this.getLayer();\n    var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\n    var tileGrid = source.getTileGrid();\n    var tileCoord = tile.tileCoord;\n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var viewState = frameState.viewState;\n    var pixelRatio = frameState.pixelRatio;\n    var renderResolution = viewState.resolution / pixelRatio;\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var center = viewState.center;\n    var origin = ol.extent.getTopLeft(tileExtent);\n    var size = frameState.size;\n    var offsetX = Math.round(pixelRatio * size[0] / 2);\n    var offsetY = Math.round(pixelRatio * size[1] / 2);\n    return ol.transform.compose(this.tmpTransform_,\n        offsetX, offsetY,\n        tileResolution / renderResolution, tileResolution / renderResolution,\n        viewState.rotation,\n        (origin[0] - center[0]) / tileResolution,\n        (center[1] - origin[1]) / tileResolution);\n  };\n  \n  \n  /**\n   * @param {ol.events.Event} event Event.\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.handleFontsChanged_ = function(event) {\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  \n  \n  /**\n   * Handle changes in image style state.\n   * @param {ol.events.Event} event Image style change event.\n   * @private\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.handleStyleImageChange_ = function(event) {\n    this.renderIfReadyAndVisible();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.postCompose = function(context, frameState, layerState) {\n    var layer = this.getLayer();\n    var declutterReplays = layer.getDeclutter() ? {} : null;\n    var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\n    var renderMode = layer.getRenderMode();\n    var replayTypes = ol.renderer.canvas.VectorTileLayer.VECTOR_REPLAYS[renderMode];\n    var pixelRatio = frameState.pixelRatio;\n    var rotation = frameState.viewState.rotation;\n    var size = frameState.size;\n    var offsetX, offsetY;\n    if (rotation) {\n      offsetX = Math.round(pixelRatio * size[0] / 2);\n      offsetY = Math.round(pixelRatio * size[1] / 2);\n      ol.render.canvas.rotateAtOffset(context, -rotation, offsetX, offsetY);\n    }\n    if (declutterReplays) {\n      this.declutterTree_.clear();\n    }\n    var tiles = this.renderedTiles;\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var clips = [];\n    var zs = [];\n    for (var i = tiles.length - 1; i >= 0; --i) {\n      var tile = /** @type {ol.VectorImageTile} */ (tiles[i]);\n      if (tile.getState() == ol.TileState.ABORT) {\n        continue;\n      }\n      var tileCoord = tile.tileCoord;\n      var worldOffset = tileGrid.getTileCoordExtent(tileCoord)[0] -\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord)[0];\n      var transform = undefined;\n      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        var sourceTile = tile.getTile(tile.tileKeys[t]);\n        if (sourceTile.getState() == ol.TileState.ERROR) {\n          continue;\n        }\n        var replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());\n        if (renderMode != ol.layer.VectorTileRenderType.VECTOR && !replayGroup.hasReplays(replayTypes)) {\n          continue;\n        }\n        if (!transform) {\n          transform = this.getTransform(frameState, worldOffset);\n        }\n        var currentZ = sourceTile.tileCoord[0];\n        var currentClip = replayGroup.getClipCoords(transform);\n        context.save();\n        context.globalAlpha = layerState.opacity;\n        // Create a clip mask for regions in this low resolution tile that are\n        // already filled by a higher resolution tile\n        for (var j = 0, jj = clips.length; j < jj; ++j) {\n          var clip = clips[j];\n          if (currentZ < zs[j]) {\n            context.beginPath();\n            // counter-clockwise (outer ring) for current tile\n            context.moveTo(currentClip[0], currentClip[1]);\n            context.lineTo(currentClip[2], currentClip[3]);\n            context.lineTo(currentClip[4], currentClip[5]);\n            context.lineTo(currentClip[6], currentClip[7]);\n            // clockwise (inner ring) for higher resolution tile\n            context.moveTo(clip[6], clip[7]);\n            context.lineTo(clip[4], clip[5]);\n            context.lineTo(clip[2], clip[3]);\n            context.lineTo(clip[0], clip[1]);\n            context.clip();\n          }\n        }\n        replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);\n        context.restore();\n        clips.push(currentClip);\n        zs.push(currentZ);\n      }\n    }\n    if (declutterReplays) {\n      ol.render.canvas.ReplayGroup.replayDeclutter(declutterReplays, context, rotation);\n    }\n    if (rotation) {\n      ol.render.canvas.rotateAtOffset(context, rotation,\n          /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));\n    }\n    ol.renderer.canvas.TileLayer.prototype.postCompose.apply(this, arguments);\n  };\n  \n  \n  /**\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of\n   *     styles.\n   * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.renderFeature = function(feature, squaredTolerance, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = ol.renderer.vector.renderFeature(\n            replayGroup, feature, styles[i], squaredTolerance,\n            this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = ol.renderer.vector.renderFeature(\n          replayGroup, feature, styles, squaredTolerance,\n          this.handleStyleImageChange_, this);\n    }\n    return loading;\n  };\n  \n  \n  /**\n   * @param {ol.VectorImageTile} tile Tile.\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.LayerState} layerState Layer state.\n   * @private\n   */\n  ol.renderer.canvas.VectorTileLayer.prototype.renderTileImage_ = function(\n      tile, frameState, layerState) {\n    var layer = this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var replays = ol.renderer.canvas.VectorTileLayer.IMAGE_REPLAYS[layer.getRenderMode()];\n    if (replays && replayState.renderedTileRevision !== revision) {\n      replayState.renderedTileRevision = revision;\n      var tileCoord = tile.wrappedTileCoord;\n      var z = tileCoord[0];\n      var pixelRatio = frameState.pixelRatio;\n      var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\n      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      var resolution = tileGrid.getResolution(z);\n      var context = tile.getContext(layer);\n      var size = source.getTilePixelSize(z, pixelRatio, frameState.viewState.projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      var tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n      for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n        var sourceTile = tile.getTile(tile.tileKeys[i]);\n        if (sourceTile.getState() == ol.TileState.ERROR) {\n          continue;\n        }\n        var pixelScale = pixelRatio / resolution;\n        var transform = ol.transform.reset(this.tmpTransform_);\n        ol.transform.scale(transform, pixelScale, -pixelScale);\n        ol.transform.translate(transform, -tileExtent[0], -tileExtent[3]);\n        var replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        replayGroup.replay(context, transform, 0, {}, replays);\n      }\n    }\n  };\n  \n  goog.provide('ol.CanvasMap');\n  \n  goog.require('ol');\n  goog.require('ol.PluggableMap');\n  goog.require('ol.PluginType');\n  goog.require('ol.control');\n  goog.require('ol.interaction');\n  goog.require('ol.obj');\n  goog.require('ol.plugins');\n  goog.require('ol.renderer.canvas.ImageLayer');\n  goog.require('ol.renderer.canvas.Map');\n  goog.require('ol.renderer.canvas.TileLayer');\n  goog.require('ol.renderer.canvas.VectorLayer');\n  goog.require('ol.renderer.canvas.VectorTileLayer');\n  \n  \n  ol.plugins.register(ol.PluginType.MAP_RENDERER, ol.renderer.canvas.Map);\n  ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER, [\n    ol.renderer.canvas.ImageLayer,\n    ol.renderer.canvas.TileLayer,\n    ol.renderer.canvas.VectorLayer,\n    ol.renderer.canvas.VectorTileLayer\n  ]);\n  \n  \n  /**\n   * @classdesc\n   * The map is the core component of OpenLayers. For a map to render, a view,\n   * one or more layers, and a target container are needed:\n   *\n   *     var map = new ol.CanvasMap({\n   *       view: new ol.View({\n   *         center: [0, 0],\n   *         zoom: 1\n   *       }),\n   *       layers: [\n   *         new ol.layer.Tile({\n   *           source: new ol.source.OSM()\n   *         })\n   *       ],\n   *       target: 'map'\n   *     });\n   *\n   * The above snippet creates a map using a {@link ol.layer.Tile} to display\n   * {@link ol.source.OSM} OSM data and render it to a DOM element with the\n   * id `map`.\n   *\n   * The constructor places a viewport container (with CSS class name\n   * `ol-viewport`) in the target element (see `getViewport()`), and then two\n   * further elements within the viewport: one with CSS class name\n   * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\n   * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\n   * option of {@link ol.Overlay} for the difference). The map itself is placed in\n   * a further element within the viewport.\n   *\n   * Layers are stored as a `ol.Collection` in layerGroups. A top-level group is\n   * provided by the library. This is what is accessed by `getLayerGroup` and\n   * `setLayerGroup`. Layers entered in the options are added to this group, and\n   * `addLayer` and `removeLayer` change the layer collection in the group.\n   * `getLayers` is a convenience function for `getLayerGroup().getLayers()`.\n   * Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers\n   * entered in the options or added with `addLayer` can be groups, which can\n   * contain further groups, and so on.\n   *\n   * @constructor\n   * @extends {ol.PluggableMap}\n   * @param {olx.MapOptions} options Map options.\n   * @fires ol.MapBrowserEvent\n   * @fires ol.MapEvent\n   * @fires ol.render.Event#postcompose\n   * @fires ol.render.Event#precompose\n   * @api\n   */\n  ol.CanvasMap = function(options) {\n    options = ol.obj.assign({}, options);\n    delete options.renderer;\n    if (!options.controls) {\n      options.controls = ol.control.defaults();\n    }\n    if (!options.interactions) {\n      options.interactions = ol.interaction.defaults();\n    }\n  \n    ol.PluggableMap.call(this, options);\n  };\n  ol.inherits(ol.CanvasMap, ol.PluggableMap);\n  \n  goog.provide('ol.control.FullScreen');\n  \n  goog.require('ol');\n  goog.require('ol.control.Control');\n  goog.require('ol.css');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  \n  \n  /**\n   * @classdesc\n   * Provides a button that when clicked fills up the full screen with the map.\n   * The full screen source element is by default the element containing the map viewport unless\n   * overridden by providing the `source` option. In which case, the dom\n   * element introduced using this parameter will be displayed in full screen.\n   *\n   * When in full screen mode, a close button is shown to exit full screen mode.\n   * The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to\n   * toggle the map in full screen mode.\n   *\n   *\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.FullScreenOptions=} opt_options Options.\n   * @api\n   */\n  ol.control.FullScreen = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.cssClassName_ = options.className !== undefined ? options.className :\n      'ol-full-screen';\n  \n    var label = options.label !== undefined ? options.label : '\\u2922';\n  \n    /**\n     * @private\n     * @type {Node}\n     */\n    this.labelNode_ = typeof label === 'string' ?\n      document.createTextNode(label) : label;\n  \n    var labelActive = options.labelActive !== undefined ? options.labelActive : '\\u00d7';\n  \n    /**\n     * @private\n     * @type {Node}\n     */\n    this.labelActiveNode_ = typeof labelActive === 'string' ?\n      document.createTextNode(labelActive) : labelActive;\n  \n    var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';\n    var button = document.createElement('button');\n    button.className = this.cssClassName_ + '-' + ol.control.FullScreen.isFullScreen();\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(this.labelNode_);\n  \n    ol.events.listen(button, ol.events.EventType.CLICK,\n        this.handleClick_, this);\n  \n    var cssClasses = this.cssClassName_ + ' ' + ol.css.CLASS_UNSELECTABLE +\n        ' ' + ol.css.CLASS_CONTROL + ' ' +\n        (!ol.control.FullScreen.isFullScreenSupported() ? ol.css.CLASS_UNSUPPORTED : '');\n    var element = document.createElement('div');\n    element.className = cssClasses;\n    element.appendChild(button);\n  \n    ol.control.Control.call(this, {\n      element: element,\n      target: options.target\n    });\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.keys_ = options.keys !== undefined ? options.keys : false;\n  \n    /**\n     * @private\n     * @type {Element|string|undefined}\n     */\n    this.source_ = options.source;\n  \n  };\n  ol.inherits(ol.control.FullScreen, ol.control.Control);\n  \n  \n  /**\n   * @param {Event} event The event to handle\n   * @private\n   */\n  ol.control.FullScreen.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    this.handleFullScreen_();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.control.FullScreen.prototype.handleFullScreen_ = function() {\n    if (!ol.control.FullScreen.isFullScreenSupported()) {\n      return;\n    }\n    var map = this.getMap();\n    if (!map) {\n      return;\n    }\n    if (ol.control.FullScreen.isFullScreen()) {\n      ol.control.FullScreen.exitFullScreen();\n    } else {\n      var element;\n      if (this.source_) {\n        element = typeof this.source_ === 'string' ?\n          document.getElementById(this.source_) :\n          this.source_;\n      } else {\n        element = map.getTargetElement();\n      }\n      if (this.keys_) {\n        ol.control.FullScreen.requestFullScreenWithKeys(element);\n  \n      } else {\n        ol.control.FullScreen.requestFullScreen(element);\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.control.FullScreen.prototype.handleFullScreenChange_ = function() {\n    var button = this.element.firstElementChild;\n    var map = this.getMap();\n    if (ol.control.FullScreen.isFullScreen()) {\n      button.className = this.cssClassName_ + '-true';\n      ol.dom.replaceNode(this.labelActiveNode_, this.labelNode_);\n    } else {\n      button.className = this.cssClassName_ + '-false';\n      ol.dom.replaceNode(this.labelNode_, this.labelActiveNode_);\n    }\n    if (map) {\n      map.updateSize();\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.control.FullScreen.prototype.setMap = function(map) {\n    ol.control.Control.prototype.setMap.call(this, map);\n    if (map) {\n      this.listenerKeys.push(ol.events.listen(document,\n          ol.control.FullScreen.getChangeType_(),\n          this.handleFullScreenChange_, this)\n      );\n    }\n  };\n  \n  /**\n   * @return {boolean} Fullscreen is supported by the current platform.\n   */\n  ol.control.FullScreen.isFullScreenSupported = function() {\n    var body = document.body;\n    return !!(\n      body.webkitRequestFullscreen ||\n      (body.mozRequestFullScreen && document.mozFullScreenEnabled) ||\n      (body.msRequestFullscreen && document.msFullscreenEnabled) ||\n      (body.requestFullscreen && document.fullscreenEnabled)\n    );\n  };\n  \n  /**\n   * @return {boolean} Element is currently in fullscreen.\n   */\n  ol.control.FullScreen.isFullScreen = function() {\n    return !!(\n      document.webkitIsFullScreen || document.mozFullScreen ||\n      document.msFullscreenElement || document.fullscreenElement\n    );\n  };\n  \n  /**\n   * Request to fullscreen an element.\n   * @param {Node} element Element to request fullscreen\n   */\n  ol.control.FullScreen.requestFullScreen = function(element) {\n    if (element.requestFullscreen) {\n      element.requestFullscreen();\n    } else if (element.msRequestFullscreen) {\n      element.msRequestFullscreen();\n    } else if (element.mozRequestFullScreen) {\n      element.mozRequestFullScreen();\n    } else if (element.webkitRequestFullscreen) {\n      element.webkitRequestFullscreen();\n    }\n  };\n  \n  /**\n   * Request to fullscreen an element with keyboard input.\n   * @param {Node} element Element to request fullscreen\n   */\n  ol.control.FullScreen.requestFullScreenWithKeys = function(element) {\n    if (element.mozRequestFullScreenWithKeys) {\n      element.mozRequestFullScreenWithKeys();\n    } else if (element.webkitRequestFullscreen) {\n      element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n    } else {\n      ol.control.FullScreen.requestFullScreen(element);\n    }\n  };\n  \n  /**\n   * Exit fullscreen.\n   */\n  ol.control.FullScreen.exitFullScreen = function() {\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    } else if (document.msExitFullscreen) {\n      document.msExitFullscreen();\n    } else if (document.mozCancelFullScreen) {\n      document.mozCancelFullScreen();\n    } else if (document.webkitExitFullscreen) {\n      document.webkitExitFullscreen();\n    }\n  };\n  \n  /**\n   * @return {string} Change type.\n   * @private\n   */\n  ol.control.FullScreen.getChangeType_ = (function() {\n    var changeType;\n    return function() {\n      if (!changeType) {\n        var body = document.body;\n        if (body.webkitRequestFullscreen) {\n          changeType = 'webkitfullscreenchange';\n        } else if (body.mozRequestFullScreen) {\n          changeType = 'mozfullscreenchange';\n        } else if (body.msRequestFullscreen) {\n          changeType = 'MSFullscreenChange';\n        } else if (body.requestFullscreen) {\n          changeType = 'fullscreenchange';\n        }\n      }\n      return changeType;\n    };\n  })();\n  \n  // FIXME should listen on appropriate pane, once it is defined\n  \n  goog.provide('ol.control.MousePosition');\n  \n  goog.require('ol');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.Object');\n  goog.require('ol.control.Control');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * A control to show the 2D coordinates of the mouse cursor. By default, these\n   * are in the view projection, but can be in any supported projection.\n   * By default the control is shown in the top right corner of the map, but this\n   * can be changed by using the css selector `.ol-mouse-position`.\n   *\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.MousePositionOptions=} opt_options Mouse position\n   *     options.\n   * @api\n   */\n  ol.control.MousePosition = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    var element = document.createElement('DIV');\n    element.className = options.className !== undefined ? options.className : 'ol-mouse-position';\n  \n    var render = options.render ?\n      options.render : ol.control.MousePosition.render;\n  \n    ol.control.Control.call(this, {\n      element: element,\n      render: render,\n      target: options.target\n    });\n  \n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.control.MousePosition.Property_.PROJECTION),\n        this.handleProjectionChanged_, this);\n  \n    if (options.coordinateFormat) {\n      this.setCoordinateFormat(options.coordinateFormat);\n    }\n    if (options.projection) {\n      this.setProjection(options.projection);\n    }\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.undefinedHTML_ = options.undefinedHTML !== undefined ? options.undefinedHTML : '';\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedHTML_ = element.innerHTML;\n  \n    /**\n     * @private\n     * @type {ol.proj.Projection}\n     */\n    this.mapProjection_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.TransformFunction}\n     */\n    this.transform_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Pixel}\n     */\n    this.lastMouseMovePixel_ = null;\n  \n  };\n  ol.inherits(ol.control.MousePosition, ol.control.Control);\n  \n  \n  /**\n   * Update the mouseposition element.\n   * @param {ol.MapEvent} mapEvent Map event.\n   * @this {ol.control.MousePosition}\n   * @api\n   */\n  ol.control.MousePosition.render = function(mapEvent) {\n    var frameState = mapEvent.frameState;\n    if (!frameState) {\n      this.mapProjection_ = null;\n    } else {\n      if (this.mapProjection_ != frameState.viewState.projection) {\n        this.mapProjection_ = frameState.viewState.projection;\n        this.transform_ = null;\n      }\n    }\n    this.updateHTML_(this.lastMouseMovePixel_);\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.control.MousePosition.prototype.handleProjectionChanged_ = function() {\n    this.transform_ = null;\n  };\n  \n  \n  /**\n   * Return the coordinate format type used to render the current position or\n   * undefined.\n   * @return {ol.CoordinateFormatType|undefined} The format to render the current\n   *     position in.\n   * @observable\n   * @api\n   */\n  ol.control.MousePosition.prototype.getCoordinateFormat = function() {\n    return /** @type {ol.CoordinateFormatType|undefined} */ (\n      this.get(ol.control.MousePosition.Property_.COORDINATE_FORMAT));\n  };\n  \n  \n  /**\n   * Return the projection that is used to report the mouse position.\n   * @return {ol.proj.Projection|undefined} The projection to report mouse\n   *     position in.\n   * @observable\n   * @api\n   */\n  ol.control.MousePosition.prototype.getProjection = function() {\n    return /** @type {ol.proj.Projection|undefined} */ (\n      this.get(ol.control.MousePosition.Property_.PROJECTION));\n  };\n  \n  \n  /**\n   * @param {Event} event Browser event.\n   * @protected\n   */\n  ol.control.MousePosition.prototype.handleMouseMove = function(event) {\n    var map = this.getMap();\n    this.lastMouseMovePixel_ = map.getEventPixel(event);\n    this.updateHTML_(this.lastMouseMovePixel_);\n  };\n  \n  \n  /**\n   * @param {Event} event Browser event.\n   * @protected\n   */\n  ol.control.MousePosition.prototype.handleMouseOut = function(event) {\n    this.updateHTML_(null);\n    this.lastMouseMovePixel_ = null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.control.MousePosition.prototype.setMap = function(map) {\n    ol.control.Control.prototype.setMap.call(this, map);\n    if (map) {\n      var viewport = map.getViewport();\n      this.listenerKeys.push(\n          ol.events.listen(viewport, ol.events.EventType.MOUSEMOVE,\n              this.handleMouseMove, this),\n          ol.events.listen(viewport, ol.events.EventType.MOUSEOUT,\n              this.handleMouseOut, this)\n      );\n    }\n  };\n  \n  \n  /**\n   * Set the coordinate format type used to render the current position.\n   * @param {ol.CoordinateFormatType} format The format to render the current\n   *     position in.\n   * @observable\n   * @api\n   */\n  ol.control.MousePosition.prototype.setCoordinateFormat = function(format) {\n    this.set(ol.control.MousePosition.Property_.COORDINATE_FORMAT, format);\n  };\n  \n  \n  /**\n   * Set the projection that is used to report the mouse position.\n   * @param {ol.ProjectionLike} projection The projection to report mouse\n   *     position in.\n   * @observable\n   * @api\n   */\n  ol.control.MousePosition.prototype.setProjection = function(projection) {\n    this.set(ol.control.MousePosition.Property_.PROJECTION, ol.proj.get(projection));\n  };\n  \n  \n  /**\n   * @param {?ol.Pixel} pixel Pixel.\n   * @private\n   */\n  ol.control.MousePosition.prototype.updateHTML_ = function(pixel) {\n    var html = this.undefinedHTML_;\n    if (pixel && this.mapProjection_) {\n      if (!this.transform_) {\n        var projection = this.getProjection();\n        if (projection) {\n          this.transform_ = ol.proj.getTransformFromProjections(\n              this.mapProjection_, projection);\n        } else {\n          this.transform_ = ol.proj.identityTransform;\n        }\n      }\n      var map = this.getMap();\n      var coordinate = map.getCoordinateFromPixel(pixel);\n      if (coordinate) {\n        this.transform_(coordinate, coordinate);\n        var coordinateFormat = this.getCoordinateFormat();\n        if (coordinateFormat) {\n          html = coordinateFormat(coordinate);\n        } else {\n          html = coordinate.toString();\n        }\n      }\n    }\n    if (!this.renderedHTML_ || html != this.renderedHTML_) {\n      this.element.innerHTML = html;\n      this.renderedHTML_ = html;\n    }\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.control.MousePosition.Property_ = {\n    PROJECTION: 'projection',\n    COORDINATE_FORMAT: 'coordinateFormat'\n  };\n  \n  goog.provide('ol.OverlayPositioning');\n  \n  /**\n   * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n   * `'top-center'`, `'top-right'`\n   * @enum {string}\n   */\n  ol.OverlayPositioning = {\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_CENTER: 'bottom-center',\n    BOTTOM_RIGHT: 'bottom-right',\n    CENTER_LEFT: 'center-left',\n    CENTER_CENTER: 'center-center',\n    CENTER_RIGHT: 'center-right',\n    TOP_LEFT: 'top-left',\n    TOP_CENTER: 'top-center',\n    TOP_RIGHT: 'top-right'\n  };\n  \n  goog.provide('ol.Overlay');\n  \n  goog.require('ol');\n  goog.require('ol.MapEventType');\n  goog.require('ol.Object');\n  goog.require('ol.OverlayPositioning');\n  goog.require('ol.css');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.extent');\n  \n  \n  /**\n   * @classdesc\n   * An element to be displayed over the map and attached to a single map\n   * location.  Like {@link ol.control.Control}, Overlays are visible widgets.\n   * Unlike Controls, they are not in a fixed position on the screen, but are tied\n   * to a geographical coordinate, so panning the map will move an Overlay but not\n   * a Control.\n   *\n   * Example:\n   *\n   *     var popup = new ol.Overlay({\n   *       element: document.getElementById('popup')\n   *     });\n   *     popup.setPosition(coordinate);\n   *     map.addOverlay(popup);\n   *\n   * @constructor\n   * @extends {ol.Object}\n   * @param {olx.OverlayOptions} options Overlay options.\n   * @api\n   */\n  ol.Overlay = function(options) {\n  \n    ol.Object.call(this);\n  \n    /**\n     * @protected\n     * @type {olx.OverlayOptions}\n     */\n    this.options = options;\n  \n    /**\n     * @protected\n     * @type {number|string|undefined}\n     */\n    this.id = options.id;\n  \n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.insertFirst = options.insertFirst !== undefined ?\n      options.insertFirst : true;\n  \n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n  \n    /**\n     * @protected\n     * @type {Element}\n     */\n    this.element = document.createElement('DIV');\n    this.element.className = options.className !== undefined ?\n      options.className : 'ol-overlay-container ' + ol.css.CLASS_SELECTABLE;\n    this.element.style.position = 'absolute';\n  \n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.autoPan = options.autoPan !== undefined ? options.autoPan : false;\n  \n    /**\n     * @protected\n     * @type {olx.OverlayPanOptions}\n     */\n    this.autoPanAnimation = options.autoPanAnimation ||\n      /** @type {olx.OverlayPanOptions} */ ({});\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.autoPanMargin = options.autoPanMargin !== undefined ?\n      options.autoPanMargin : 20;\n  \n    /**\n     * @protected\n     * @type {{bottom_: string,\n     *         left_: string,\n     *         right_: string,\n     *         top_: string,\n     *         visible: boolean}}\n     */\n    this.rendered = {\n      bottom_: '',\n      left_: '',\n      right_: '',\n      top_: '',\n      visible: true\n    };\n  \n    /**\n     * @protected\n     * @type {?ol.EventsKey}\n     */\n    this.mapPostrenderListenerKey = null;\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.Overlay.Property.ELEMENT),\n        this.handleElementChanged, this);\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.Overlay.Property.MAP),\n        this.handleMapChanged, this);\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.Overlay.Property.OFFSET),\n        this.handleOffsetChanged, this);\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.Overlay.Property.POSITION),\n        this.handlePositionChanged, this);\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.Overlay.Property.POSITIONING),\n        this.handlePositioningChanged, this);\n  \n    if (options.element !== undefined) {\n      this.setElement(options.element);\n    }\n  \n    this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n  \n    this.setPositioning(options.positioning !== undefined ?\n      /** @type {ol.OverlayPositioning} */ (options.positioning) :\n      ol.OverlayPositioning.TOP_LEFT);\n  \n    if (options.position !== undefined) {\n      this.setPosition(options.position);\n    }\n  \n  };\n  ol.inherits(ol.Overlay, ol.Object);\n  \n  \n  /**\n   * Get the DOM element of this overlay.\n   * @return {Element|undefined} The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.getElement = function() {\n    return /** @type {Element|undefined} */ (\n      this.get(ol.Overlay.Property.ELEMENT));\n  };\n  \n  \n  /**\n   * Get the overlay identifier which is set on constructor.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  ol.Overlay.prototype.getId = function() {\n    return this.id;\n  };\n  \n  \n  /**\n   * Get the map associated with this overlay.\n   * @return {ol.PluggableMap|undefined} The map that the overlay is part of.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.getMap = function() {\n    return /** @type {ol.PluggableMap|undefined} */ (\n      this.get(ol.Overlay.Property.MAP));\n  };\n  \n  \n  /**\n   * Get the offset of this overlay.\n   * @return {Array.<number>} The offset.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.getOffset = function() {\n    return /** @type {Array.<number>} */ (\n      this.get(ol.Overlay.Property.OFFSET));\n  };\n  \n  \n  /**\n   * Get the current position of this overlay.\n   * @return {ol.Coordinate|undefined} The spatial point that the overlay is\n   *     anchored at.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.getPosition = function() {\n    return /** @type {ol.Coordinate|undefined} */ (\n      this.get(ol.Overlay.Property.POSITION));\n  };\n  \n  \n  /**\n   * Get the current positioning of this overlay.\n   * @return {ol.OverlayPositioning} How the overlay is positioned\n   *     relative to its point on the map.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.getPositioning = function() {\n    return /** @type {ol.OverlayPositioning} */ (\n      this.get(ol.Overlay.Property.POSITIONING));\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.Overlay.prototype.handleElementChanged = function() {\n    ol.dom.removeChildren(this.element);\n    var element = this.getElement();\n    if (element) {\n      this.element.appendChild(element);\n    }\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.Overlay.prototype.handleMapChanged = function() {\n    if (this.mapPostrenderListenerKey) {\n      ol.dom.removeNode(this.element);\n      ol.events.unlistenByKey(this.mapPostrenderListenerKey);\n      this.mapPostrenderListenerKey = null;\n    }\n    var map = this.getMap();\n    if (map) {\n      this.mapPostrenderListenerKey = ol.events.listen(map,\n          ol.MapEventType.POSTRENDER, this.render, this);\n      this.updatePixelPosition();\n      var container = this.stopEvent ?\n        map.getOverlayContainerStopEvent() : map.getOverlayContainer();\n      if (this.insertFirst) {\n        container.insertBefore(this.element, container.childNodes[0] || null);\n      } else {\n        container.appendChild(this.element);\n      }\n    }\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.Overlay.prototype.render = function() {\n    this.updatePixelPosition();\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.Overlay.prototype.handleOffsetChanged = function() {\n    this.updatePixelPosition();\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.Overlay.prototype.handlePositionChanged = function() {\n    this.updatePixelPosition();\n    if (this.get(ol.Overlay.Property.POSITION) && this.autoPan) {\n      this.panIntoView();\n    }\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.Overlay.prototype.handlePositioningChanged = function() {\n    this.updatePixelPosition();\n  };\n  \n  \n  /**\n   * Set the DOM element to be associated with this overlay.\n   * @param {Element|undefined} element The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.setElement = function(element) {\n    this.set(ol.Overlay.Property.ELEMENT, element);\n  };\n  \n  \n  /**\n   * Set the map to be associated with this overlay.\n   * @param {ol.PluggableMap|undefined} map The map that the overlay is part of.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.setMap = function(map) {\n    this.set(ol.Overlay.Property.MAP, map);\n  };\n  \n  \n  /**\n   * Set the offset for this overlay.\n   * @param {Array.<number>} offset Offset.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.setOffset = function(offset) {\n    this.set(ol.Overlay.Property.OFFSET, offset);\n  };\n  \n  \n  /**\n   * Set the position for this overlay. If the position is `undefined` the\n   * overlay is hidden.\n   * @param {ol.Coordinate|undefined} position The spatial point that the overlay\n   *     is anchored at.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.setPosition = function(position) {\n    this.set(ol.Overlay.Property.POSITION, position);\n  };\n  \n  \n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary).\n   * @protected\n   */\n  ol.Overlay.prototype.panIntoView = function() {\n    var map = this.getMap();\n  \n    if (!map || !map.getTargetElement()) {\n      return;\n    }\n  \n    var mapRect = this.getRect(map.getTargetElement(), map.getSize());\n    var element = /** @type {!Element} */ (this.getElement());\n    var overlayRect = this.getRect(element,\n        [ol.dom.outerWidth(element), ol.dom.outerHeight(element)]);\n  \n    var margin = this.autoPanMargin;\n    if (!ol.extent.containsExtent(mapRect, overlayRect)) {\n      // the overlay is not completely inside the viewport, so pan the map\n      var offsetLeft = overlayRect[0] - mapRect[0];\n      var offsetRight = mapRect[2] - overlayRect[2];\n      var offsetTop = overlayRect[1] - mapRect[1];\n      var offsetBottom = mapRect[3] - overlayRect[3];\n  \n      var delta = [0, 0];\n      if (offsetLeft < 0) {\n        // move map to the left\n        delta[0] = offsetLeft - margin;\n      } else if (offsetRight < 0) {\n        // move map to the right\n        delta[0] = Math.abs(offsetRight) + margin;\n      }\n      if (offsetTop < 0) {\n        // move map up\n        delta[1] = offsetTop - margin;\n      } else if (offsetBottom < 0) {\n        // move map down\n        delta[1] = Math.abs(offsetBottom) + margin;\n      }\n  \n      if (delta[0] !== 0 || delta[1] !== 0) {\n        var center = /** @type {ol.Coordinate} */ (map.getView().getCenter());\n        var centerPx = map.getPixelFromCoordinate(center);\n        var newCenterPx = [\n          centerPx[0] + delta[0],\n          centerPx[1] + delta[1]\n        ];\n  \n        map.getView().animate({\n          center: map.getCoordinateFromPixel(newCenterPx),\n          duration: this.autoPanAnimation.duration,\n          easing: this.autoPanAnimation.easing\n        });\n      }\n    }\n  };\n  \n  \n  /**\n   * Get the extent of an element relative to the document\n   * @param {Element|undefined} element The element.\n   * @param {ol.Size|undefined} size The size of the element.\n   * @return {ol.Extent} The extent.\n   * @protected\n   */\n  ol.Overlay.prototype.getRect = function(element, size) {\n    var box = element.getBoundingClientRect();\n    var offsetX = box.left + window.pageXOffset;\n    var offsetY = box.top + window.pageYOffset;\n    return [\n      offsetX,\n      offsetY,\n      offsetX + size[0],\n      offsetY + size[1]\n    ];\n  };\n  \n  \n  /**\n   * Set the positioning for this overlay.\n   * @param {ol.OverlayPositioning} positioning how the overlay is\n   *     positioned relative to its point on the map.\n   * @observable\n   * @api\n   */\n  ol.Overlay.prototype.setPositioning = function(positioning) {\n    this.set(ol.Overlay.Property.POSITIONING, positioning);\n  };\n  \n  \n  /**\n   * Modify the visibility of the element.\n   * @param {boolean} visible Element visibility.\n   * @protected\n   */\n  ol.Overlay.prototype.setVisible = function(visible) {\n    if (this.rendered.visible !== visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.rendered.visible = visible;\n    }\n  };\n  \n  \n  /**\n   * Update pixel position.\n   * @protected\n   */\n  ol.Overlay.prototype.updatePixelPosition = function() {\n    var map = this.getMap();\n    var position = this.getPosition();\n    if (!map || !map.isRendered() || !position) {\n      this.setVisible(false);\n      return;\n    }\n  \n    var pixel = map.getPixelFromCoordinate(position);\n    var mapSize = map.getSize();\n    this.updateRenderedPosition(pixel, mapSize);\n  };\n  \n  \n  /**\n   * @param {ol.Pixel} pixel The pixel location.\n   * @param {ol.Size|undefined} mapSize The map size.\n   * @protected\n   */\n  ol.Overlay.prototype.updateRenderedPosition = function(pixel, mapSize) {\n    var style = this.element.style;\n    var offset = this.getOffset();\n  \n    var positioning = this.getPositioning();\n  \n    this.setVisible(true);\n  \n    var offsetX = offset[0];\n    var offsetY = offset[1];\n    if (positioning == ol.OverlayPositioning.BOTTOM_RIGHT ||\n        positioning == ol.OverlayPositioning.CENTER_RIGHT ||\n        positioning == ol.OverlayPositioning.TOP_RIGHT) {\n      if (this.rendered.left_ !== '') {\n        this.rendered.left_ = style.left = '';\n      }\n      var right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';\n      if (this.rendered.right_ != right) {\n        this.rendered.right_ = style.right = right;\n      }\n    } else {\n      if (this.rendered.right_ !== '') {\n        this.rendered.right_ = style.right = '';\n      }\n      if (positioning == ol.OverlayPositioning.BOTTOM_CENTER ||\n          positioning == ol.OverlayPositioning.CENTER_CENTER ||\n          positioning == ol.OverlayPositioning.TOP_CENTER) {\n        offsetX -= this.element.offsetWidth / 2;\n      }\n      var left = Math.round(pixel[0] + offsetX) + 'px';\n      if (this.rendered.left_ != left) {\n        this.rendered.left_ = style.left = left;\n      }\n    }\n    if (positioning == ol.OverlayPositioning.BOTTOM_LEFT ||\n        positioning == ol.OverlayPositioning.BOTTOM_CENTER ||\n        positioning == ol.OverlayPositioning.BOTTOM_RIGHT) {\n      if (this.rendered.top_ !== '') {\n        this.rendered.top_ = style.top = '';\n      }\n      var bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';\n      if (this.rendered.bottom_ != bottom) {\n        this.rendered.bottom_ = style.bottom = bottom;\n      }\n    } else {\n      if (this.rendered.bottom_ !== '') {\n        this.rendered.bottom_ = style.bottom = '';\n      }\n      if (positioning == ol.OverlayPositioning.CENTER_LEFT ||\n          positioning == ol.OverlayPositioning.CENTER_CENTER ||\n          positioning == ol.OverlayPositioning.CENTER_RIGHT) {\n        offsetY -= this.element.offsetHeight / 2;\n      }\n      var top = Math.round(pixel[1] + offsetY) + 'px';\n      if (this.rendered.top_ != top) {\n        this.rendered.top_ = style.top = top;\n      }\n    }\n  };\n  \n  \n  /**\n   * returns the options this Overlay has been created with\n   * @public\n   * @return {olx.OverlayOptions} overlay options\n   */\n  ol.Overlay.prototype.getOptions = function() {\n    return this.options;\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @protected\n   */\n  ol.Overlay.Property = {\n    ELEMENT: 'element',\n    MAP: 'map',\n    OFFSET: 'offset',\n    POSITION: 'position',\n    POSITIONING: 'positioning'\n  };\n  \n  goog.provide('ol.control.OverviewMap');\n  \n  goog.require('ol');\n  goog.require('ol.Collection');\n  goog.require('ol.PluggableMap');\n  goog.require('ol.MapEventType');\n  goog.require('ol.MapProperty');\n  goog.require('ol.Object');\n  goog.require('ol.ObjectEventType');\n  goog.require('ol.Overlay');\n  goog.require('ol.OverlayPositioning');\n  goog.require('ol.ViewProperty');\n  goog.require('ol.control.Control');\n  goog.require('ol.coordinate');\n  goog.require('ol.css');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  \n  \n  /**\n   * Create a new control with a map acting as an overview map for an other\n   * defined map.\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.OverviewMapOptions=} opt_options OverviewMap options.\n   * @api\n   */\n  ol.control.OverviewMap = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.collapsible_ = options.collapsible !== undefined ?\n      options.collapsible : true;\n  \n    if (!this.collapsible_) {\n      this.collapsed_ = false;\n    }\n  \n    var className = options.className !== undefined ? options.className : 'ol-overviewmap';\n  \n    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';\n  \n    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\\u00AB';\n  \n    if (typeof collapseLabel === 'string') {\n      /**\n       * @private\n       * @type {Node}\n       */\n      this.collapseLabel_ = document.createElement('span');\n      this.collapseLabel_.textContent = collapseLabel;\n    } else {\n      this.collapseLabel_ = collapseLabel;\n    }\n  \n    var label = options.label !== undefined ? options.label : '\\u00BB';\n  \n  \n    if (typeof label === 'string') {\n      /**\n       * @private\n       * @type {Node}\n       */\n      this.label_ = document.createElement('span');\n      this.label_.textContent = label;\n    } else {\n      this.label_ = label;\n    }\n  \n    var activeLabel = (this.collapsible_ && !this.collapsed_) ?\n      this.collapseLabel_ : this.label_;\n    var button = document.createElement('button');\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(activeLabel);\n  \n    ol.events.listen(button, ol.events.EventType.CLICK,\n        this.handleClick_, this);\n  \n    /**\n     * @type {Element}\n     * @private\n     */\n    this.ovmapDiv_ = document.createElement('DIV');\n    this.ovmapDiv_.className = 'ol-overviewmap-map';\n  \n    /**\n     * @type {ol.PluggableMap}\n     * @private\n     */\n    this.ovmap_ = new ol.PluggableMap({\n      controls: new ol.Collection(),\n      interactions: new ol.Collection(),\n      view: options.view\n    });\n    var ovmap = this.ovmap_;\n  \n    if (options.layers) {\n      options.layers.forEach(\n          /**\n         * @param {ol.layer.Layer} layer Layer.\n         */\n          function(layer) {\n            ovmap.addLayer(layer);\n          }, this);\n    }\n  \n    var box = document.createElement('DIV');\n    box.className = 'ol-overviewmap-box';\n    box.style.boxSizing = 'border-box';\n  \n    /**\n     * @type {ol.Overlay}\n     * @private\n     */\n    this.boxOverlay_ = new ol.Overlay({\n      position: [0, 0],\n      positioning: ol.OverlayPositioning.BOTTOM_LEFT,\n      element: box\n    });\n    this.ovmap_.addOverlay(this.boxOverlay_);\n  \n    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +\n        ol.css.CLASS_CONTROL +\n        (this.collapsed_ && this.collapsible_ ? ' ol-collapsed' : '') +\n        (this.collapsible_ ? '' : ' ol-uncollapsible');\n    var element = document.createElement('div');\n    element.className = cssClasses;\n    element.appendChild(this.ovmapDiv_);\n    element.appendChild(button);\n  \n    var render = options.render ? options.render : ol.control.OverviewMap.render;\n  \n    ol.control.Control.call(this, {\n      element: element,\n      render: render,\n      target: options.target\n    });\n  \n    /* Interactive map */\n  \n    var scope = this;\n  \n    var overlay = this.boxOverlay_;\n    var overlayBox = this.boxOverlay_.getElement();\n  \n    /* Functions definition */\n  \n    var computeDesiredMousePosition = function(mousePosition) {\n      return {\n        clientX: mousePosition.clientX - (overlayBox.offsetWidth / 2),\n        clientY: mousePosition.clientY + (overlayBox.offsetHeight / 2)\n      };\n    };\n  \n    var move = function(event) {\n      var coordinates = ovmap.getEventCoordinate(computeDesiredMousePosition(event));\n  \n      overlay.setPosition(coordinates);\n    };\n  \n    var endMoving = function(event) {\n      var coordinates = ovmap.getEventCoordinate(event);\n  \n      scope.getMap().getView().setCenter(coordinates);\n  \n      window.removeEventListener('mousemove', move);\n      window.removeEventListener('mouseup', endMoving);\n    };\n  \n    /* Binding */\n  \n    overlayBox.addEventListener('mousedown', function() {\n      window.addEventListener('mousemove', move);\n      window.addEventListener('mouseup', endMoving);\n    });\n  };\n  ol.inherits(ol.control.OverviewMap, ol.control.Control);\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.control.OverviewMap.prototype.setMap = function(map) {\n    var oldMap = this.getMap();\n    if (map === oldMap) {\n      return;\n    }\n    if (oldMap) {\n      var oldView = oldMap.getView();\n      if (oldView) {\n        this.unbindView_(oldView);\n      }\n      this.ovmap_.setTarget(null);\n    }\n    ol.control.Control.prototype.setMap.call(this, map);\n  \n    if (map) {\n      this.ovmap_.setTarget(this.ovmapDiv_);\n      this.listenerKeys.push(ol.events.listen(\n          map, ol.ObjectEventType.PROPERTYCHANGE,\n          this.handleMapPropertyChange_, this));\n  \n      // TODO: to really support map switching, this would need to be reworked\n      if (this.ovmap_.getLayers().getLength() === 0) {\n        this.ovmap_.setLayerGroup(map.getLayerGroup());\n      }\n  \n      var view = map.getView();\n      if (view) {\n        this.bindView_(view);\n        if (view.isDef()) {\n          this.ovmap_.updateSize();\n          this.resetExtent_();\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * Handle map property changes.  This only deals with changes to the map's view.\n   * @param {ol.Object.Event} event The propertychange event.\n   * @private\n   */\n  ol.control.OverviewMap.prototype.handleMapPropertyChange_ = function(event) {\n    if (event.key === ol.MapProperty.VIEW) {\n      var oldView = /** @type {ol.View} */ (event.oldValue);\n      if (oldView) {\n        this.unbindView_(oldView);\n      }\n      var newView = this.getMap().getView();\n      this.bindView_(newView);\n    }\n  };\n  \n  \n  /**\n   * Register listeners for view property changes.\n   * @param {ol.View} view The view.\n   * @private\n   */\n  ol.control.OverviewMap.prototype.bindView_ = function(view) {\n    ol.events.listen(view,\n        ol.Object.getChangeEventType(ol.ViewProperty.ROTATION),\n        this.handleRotationChanged_, this);\n  };\n  \n  \n  /**\n   * Unregister listeners for view property changes.\n   * @param {ol.View} view The view.\n   * @private\n   */\n  ol.control.OverviewMap.prototype.unbindView_ = function(view) {\n    ol.events.unlisten(view,\n        ol.Object.getChangeEventType(ol.ViewProperty.ROTATION),\n        this.handleRotationChanged_, this);\n  };\n  \n  \n  /**\n   * Handle rotation changes to the main map.\n   * TODO: This should rotate the extent rectrangle instead of the\n   * overview map's view.\n   * @private\n   */\n  ol.control.OverviewMap.prototype.handleRotationChanged_ = function() {\n    this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());\n  };\n  \n  \n  /**\n   * Update the overview map element.\n   * @param {ol.MapEvent} mapEvent Map event.\n   * @this {ol.control.OverviewMap}\n   * @api\n   */\n  ol.control.OverviewMap.render = function(mapEvent) {\n    this.validateExtent_();\n    this.updateBox_();\n  };\n  \n  \n  /**\n   * Reset the overview map extent if the box size (width or\n   * height) is less than the size of the overview map size times minRatio\n   * or is greater than the size of the overview size times maxRatio.\n   *\n   * If the map extent was not reset, the box size can fits in the defined\n   * ratio sizes. This method then checks if is contained inside the overview\n   * map current extent. If not, recenter the overview map to the current\n   * main map center location.\n   * @private\n   */\n  ol.control.OverviewMap.prototype.validateExtent_ = function() {\n    var map = this.getMap();\n    var ovmap = this.ovmap_;\n  \n    if (!map.isRendered() || !ovmap.isRendered()) {\n      return;\n    }\n  \n    var mapSize = /** @type {ol.Size} */ (map.getSize());\n  \n    var view = map.getView();\n    var extent = view.calculateExtent(mapSize);\n  \n    var ovmapSize = /** @type {ol.Size} */ (ovmap.getSize());\n  \n    var ovview = ovmap.getView();\n    var ovextent = ovview.calculateExtent(ovmapSize);\n  \n    var topLeftPixel =\n        ovmap.getPixelFromCoordinate(ol.extent.getTopLeft(extent));\n    var bottomRightPixel =\n        ovmap.getPixelFromCoordinate(ol.extent.getBottomRight(extent));\n  \n    var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);\n    var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);\n  \n    var ovmapWidth = ovmapSize[0];\n    var ovmapHeight = ovmapSize[1];\n  \n    if (boxWidth < ovmapWidth * ol.OVERVIEWMAP_MIN_RATIO ||\n        boxHeight < ovmapHeight * ol.OVERVIEWMAP_MIN_RATIO ||\n        boxWidth > ovmapWidth * ol.OVERVIEWMAP_MAX_RATIO ||\n        boxHeight > ovmapHeight * ol.OVERVIEWMAP_MAX_RATIO) {\n      this.resetExtent_();\n    } else if (!ol.extent.containsExtent(ovextent, extent)) {\n      this.recenter_();\n    }\n  };\n  \n  \n  /**\n   * Reset the overview map extent to half calculated min and max ratio times\n   * the extent of the main map.\n   * @private\n   */\n  ol.control.OverviewMap.prototype.resetExtent_ = function() {\n    if (ol.OVERVIEWMAP_MAX_RATIO === 0 || ol.OVERVIEWMAP_MIN_RATIO === 0) {\n      return;\n    }\n  \n    var map = this.getMap();\n    var ovmap = this.ovmap_;\n  \n    var mapSize = /** @type {ol.Size} */ (map.getSize());\n  \n    var view = map.getView();\n    var extent = view.calculateExtent(mapSize);\n  \n    var ovview = ovmap.getView();\n  \n    // get how many times the current map overview could hold different\n    // box sizes using the min and max ratio, pick the step in the middle used\n    // to calculate the extent from the main map to set it to the overview map,\n    var steps = Math.log(\n        ol.OVERVIEWMAP_MAX_RATIO / ol.OVERVIEWMAP_MIN_RATIO) / Math.LN2;\n    var ratio = 1 / (Math.pow(2, steps / 2) * ol.OVERVIEWMAP_MIN_RATIO);\n    ol.extent.scaleFromCenter(extent, ratio);\n    ovview.fit(extent);\n  };\n  \n  \n  /**\n   * Set the center of the overview map to the map center without changing its\n   * resolution.\n   * @private\n   */\n  ol.control.OverviewMap.prototype.recenter_ = function() {\n    var map = this.getMap();\n    var ovmap = this.ovmap_;\n  \n    var view = map.getView();\n  \n    var ovview = ovmap.getView();\n  \n    ovview.setCenter(view.getCenter());\n  };\n  \n  \n  /**\n   * Update the box using the main map extent\n   * @private\n   */\n  ol.control.OverviewMap.prototype.updateBox_ = function() {\n    var map = this.getMap();\n    var ovmap = this.ovmap_;\n  \n    if (!map.isRendered() || !ovmap.isRendered()) {\n      return;\n    }\n  \n    var mapSize = /** @type {ol.Size} */ (map.getSize());\n  \n    var view = map.getView();\n  \n    var ovview = ovmap.getView();\n  \n    var rotation = view.getRotation();\n  \n    var overlay = this.boxOverlay_;\n    var box = this.boxOverlay_.getElement();\n    var extent = view.calculateExtent(mapSize);\n    var ovresolution = ovview.getResolution();\n    var bottomLeft = ol.extent.getBottomLeft(extent);\n    var topRight = ol.extent.getTopRight(extent);\n  \n    // set position using bottom left coordinates\n    var rotateBottomLeft = this.calculateCoordinateRotate_(rotation, bottomLeft);\n    overlay.setPosition(rotateBottomLeft);\n  \n    // set box size calculated from map extent size and overview map resolution\n    if (box) {\n      box.style.width = Math.abs((bottomLeft[0] - topRight[0]) / ovresolution) + 'px';\n      box.style.height = Math.abs((topRight[1] - bottomLeft[1]) / ovresolution) + 'px';\n    }\n  };\n  \n  \n  /**\n   * @param {number} rotation Target rotation.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @return {ol.Coordinate|undefined} Coordinate for rotation and center anchor.\n   * @private\n   */\n  ol.control.OverviewMap.prototype.calculateCoordinateRotate_ = function(\n      rotation, coordinate) {\n    var coordinateRotate;\n  \n    var map = this.getMap();\n    var view = map.getView();\n  \n    var currentCenter = view.getCenter();\n  \n    if (currentCenter) {\n      coordinateRotate = [\n        coordinate[0] - currentCenter[0],\n        coordinate[1] - currentCenter[1]\n      ];\n      ol.coordinate.rotate(coordinateRotate, rotation);\n      ol.coordinate.add(coordinateRotate, currentCenter);\n    }\n    return coordinateRotate;\n  };\n  \n  \n  /**\n   * @param {Event} event The event to handle\n   * @private\n   */\n  ol.control.OverviewMap.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    this.handleToggle_();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.control.OverviewMap.prototype.handleToggle_ = function() {\n    this.element.classList.toggle('ol-collapsed');\n    if (this.collapsed_) {\n      ol.dom.replaceNode(this.collapseLabel_, this.label_);\n    } else {\n      ol.dom.replaceNode(this.label_, this.collapseLabel_);\n    }\n    this.collapsed_ = !this.collapsed_;\n  \n    // manage overview map if it had not been rendered before and control\n    // is expanded\n    var ovmap = this.ovmap_;\n    if (!this.collapsed_ && !ovmap.isRendered()) {\n      ovmap.updateSize();\n      this.resetExtent_();\n      ol.events.listenOnce(ovmap, ol.MapEventType.POSTRENDER,\n          function(event) {\n            this.updateBox_();\n          },\n          this);\n    }\n  };\n  \n  \n  /**\n   * Return `true` if the overview map is collapsible, `false` otherwise.\n   * @return {boolean} True if the widget is collapsible.\n   * @api\n   */\n  ol.control.OverviewMap.prototype.getCollapsible = function() {\n    return this.collapsible_;\n  };\n  \n  \n  /**\n   * Set whether the overview map should be collapsible.\n   * @param {boolean} collapsible True if the widget is collapsible.\n   * @api\n   */\n  ol.control.OverviewMap.prototype.setCollapsible = function(collapsible) {\n    if (this.collapsible_ === collapsible) {\n      return;\n    }\n    this.collapsible_ = collapsible;\n    this.element.classList.toggle('ol-uncollapsible');\n    if (!collapsible && this.collapsed_) {\n      this.handleToggle_();\n    }\n  };\n  \n  \n  /**\n   * Collapse or expand the overview map according to the passed parameter. Will\n   * not do anything if the overview map isn't collapsible or if the current\n   * collapsed state is already the one requested.\n   * @param {boolean} collapsed True if the widget is collapsed.\n   * @api\n   */\n  ol.control.OverviewMap.prototype.setCollapsed = function(collapsed) {\n    if (!this.collapsible_ || this.collapsed_ === collapsed) {\n      return;\n    }\n    this.handleToggle_();\n  };\n  \n  \n  /**\n   * Determine if the overview map is collapsed.\n   * @return {boolean} The overview map is collapsed.\n   * @api\n   */\n  ol.control.OverviewMap.prototype.getCollapsed = function() {\n    return this.collapsed_;\n  };\n  \n  \n  /**\n   * Return the overview map.\n   * @return {ol.PluggableMap} Overview map.\n   * @api\n   */\n  ol.control.OverviewMap.prototype.getOverviewMap = function() {\n    return this.ovmap_;\n  };\n  \n  goog.provide('ol.control.ScaleLineUnits');\n  \n  /**\n   * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,\n   * `'nautical'`, `'metric'`, `'us'`.\n   * @enum {string}\n   */\n  ol.control.ScaleLineUnits = {\n    DEGREES: 'degrees',\n    IMPERIAL: 'imperial',\n    NAUTICAL: 'nautical',\n    METRIC: 'metric',\n    US: 'us'\n  };\n  \n  goog.provide('ol.control.ScaleLine');\n  \n  goog.require('ol');\n  goog.require('ol.Object');\n  goog.require('ol.asserts');\n  goog.require('ol.control.Control');\n  goog.require('ol.control.ScaleLineUnits');\n  goog.require('ol.css');\n  goog.require('ol.events');\n  goog.require('ol.proj');\n  goog.require('ol.proj.Units');\n  \n  \n  /**\n   * @classdesc\n   * A control displaying rough y-axis distances, calculated for the center of the\n   * viewport. For conformal projections (e.g. EPSG:3857, the default view\n   * projection in OpenLayers), the scale is valid for all directions.\n   * No scale line will be shown when the y-axis distance of a pixel at the\n   * viewport center cannot be calculated in the view projection.\n   * By default the scale line will show in the bottom left portion of the map,\n   * but this can be changed by using the css selector `.ol-scale-line`.\n   *\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.ScaleLineOptions=} opt_options Scale line options.\n   * @api\n   */\n  ol.control.ScaleLine = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    var className = options.className !== undefined ? options.className : 'ol-scale-line';\n  \n    /**\n     * @private\n     * @type {Element}\n     */\n    this.innerElement_ = document.createElement('DIV');\n    this.innerElement_.className = className + '-inner';\n  \n    /**\n     * @private\n     * @type {Element}\n     */\n    this.element_ = document.createElement('DIV');\n    this.element_.className = className + ' ' + ol.css.CLASS_UNSELECTABLE;\n    this.element_.appendChild(this.innerElement_);\n  \n    /**\n     * @private\n     * @type {?olx.ViewState}\n     */\n    this.viewState_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = false;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderedWidth_ = undefined;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedHTML_ = '';\n  \n    var render = options.render ? options.render : ol.control.ScaleLine.render;\n  \n    ol.control.Control.call(this, {\n      element: this.element_,\n      render: render,\n      target: options.target\n    });\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.control.ScaleLine.Property_.UNITS),\n        this.handleUnitsChanged_, this);\n  \n    this.setUnits(/** @type {ol.control.ScaleLineUnits} */ (options.units) ||\n        ol.control.ScaleLineUnits.METRIC);\n  \n  };\n  ol.inherits(ol.control.ScaleLine, ol.control.Control);\n  \n  \n  /**\n   * @const\n   * @type {Array.<number>}\n   */\n  ol.control.ScaleLine.LEADING_DIGITS = [1, 2, 5];\n  \n  \n  /**\n   * Return the units to use in the scale line.\n   * @return {ol.control.ScaleLineUnits|undefined} The units to use in the scale\n   *     line.\n   * @observable\n   * @api\n   */\n  ol.control.ScaleLine.prototype.getUnits = function() {\n    return /** @type {ol.control.ScaleLineUnits|undefined} */ (\n      this.get(ol.control.ScaleLine.Property_.UNITS));\n  };\n  \n  \n  /**\n   * Update the scale line element.\n   * @param {ol.MapEvent} mapEvent Map event.\n   * @this {ol.control.ScaleLine}\n   * @api\n   */\n  ol.control.ScaleLine.render = function(mapEvent) {\n    var frameState = mapEvent.frameState;\n    if (!frameState) {\n      this.viewState_ = null;\n    } else {\n      this.viewState_ = frameState.viewState;\n    }\n    this.updateElement_();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.control.ScaleLine.prototype.handleUnitsChanged_ = function() {\n    this.updateElement_();\n  };\n  \n  \n  /**\n   * Set the units to use in the scale line.\n   * @param {ol.control.ScaleLineUnits} units The units to use in the scale line.\n   * @observable\n   * @api\n   */\n  ol.control.ScaleLine.prototype.setUnits = function(units) {\n    this.set(ol.control.ScaleLine.Property_.UNITS, units);\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.control.ScaleLine.prototype.updateElement_ = function() {\n    var viewState = this.viewState_;\n  \n    if (!viewState) {\n      if (this.renderedVisible_) {\n        this.element_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n  \n    var center = viewState.center;\n    var projection = viewState.projection;\n    var units = this.getUnits();\n    var pointResolutionUnits = units == ol.control.ScaleLineUnits.DEGREES ?\n      ol.proj.Units.DEGREES :\n      ol.proj.Units.METERS;\n    var pointResolution =\n        ol.proj.getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);\n    if (units != ol.control.ScaleLineUnits.DEGREES) {\n      pointResolution *= projection.getMetersPerUnit();\n    }\n  \n    var nominalCount = this.minWidth_ * pointResolution;\n    var suffix = '';\n    if (units == ol.control.ScaleLineUnits.DEGREES) {\n      var metersPerDegree = ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES];\n      if (projection.getUnits() == ol.proj.Units.DEGREES) {\n        nominalCount *= metersPerDegree;\n      } else {\n        pointResolution /= metersPerDegree;\n      }\n      if (nominalCount < metersPerDegree / 60) {\n        suffix = '\\u2033'; // seconds\n        pointResolution *= 3600;\n      } else if (nominalCount < metersPerDegree) {\n        suffix = '\\u2032'; // minutes\n        pointResolution *= 60;\n      } else {\n        suffix = '\\u00b0'; // degrees\n      }\n    } else if (units == ol.control.ScaleLineUnits.IMPERIAL) {\n      if (nominalCount < 0.9144) {\n        suffix = 'in';\n        pointResolution /= 0.0254;\n      } else if (nominalCount < 1609.344) {\n        suffix = 'ft';\n        pointResolution /= 0.3048;\n      } else {\n        suffix = 'mi';\n        pointResolution /= 1609.344;\n      }\n    } else if (units == ol.control.ScaleLineUnits.NAUTICAL) {\n      pointResolution /= 1852;\n      suffix = 'nm';\n    } else if (units == ol.control.ScaleLineUnits.METRIC) {\n      if (nominalCount < 0.001) {\n        suffix = 'μm';\n        pointResolution *= 1000000;\n      } else if (nominalCount < 1) {\n        suffix = 'mm';\n        pointResolution *= 1000;\n      } else if (nominalCount < 1000) {\n        suffix = 'm';\n      } else {\n        suffix = 'km';\n        pointResolution /= 1000;\n      }\n    } else if (units == ol.control.ScaleLineUnits.US) {\n      if (nominalCount < 0.9144) {\n        suffix = 'in';\n        pointResolution *= 39.37;\n      } else if (nominalCount < 1609.344) {\n        suffix = 'ft';\n        pointResolution /= 0.30480061;\n      } else {\n        suffix = 'mi';\n        pointResolution /= 1609.3472;\n      }\n    } else {\n      ol.asserts.assert(false, 33); // Invalid units\n    }\n  \n    var i = 3 * Math.floor(\n        Math.log(this.minWidth_ * pointResolution) / Math.log(10));\n    var count, width;\n    while (true) {\n      count = ol.control.ScaleLine.LEADING_DIGITS[((i % 3) + 3) % 3] *\n          Math.pow(10, Math.floor(i / 3));\n      width = Math.round(count / pointResolution);\n      if (isNaN(width)) {\n        this.element_.style.display = 'none';\n        this.renderedVisible_ = false;\n        return;\n      } else if (width >= this.minWidth_) {\n        break;\n      }\n      ++i;\n    }\n  \n    var html = count + ' ' + suffix;\n    if (this.renderedHTML_ != html) {\n      this.innerElement_.innerHTML = html;\n      this.renderedHTML_ = html;\n    }\n  \n    if (this.renderedWidth_ != width) {\n      this.innerElement_.style.width = width + 'px';\n      this.renderedWidth_ = width;\n    }\n  \n    if (!this.renderedVisible_) {\n      this.element_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n  \n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.control.ScaleLine.Property_ = {\n    UNITS: 'units'\n  };\n  \n  // FIXME should possibly show tooltip when dragging?\n  \n  goog.provide('ol.control.ZoomSlider');\n  \n  goog.require('ol');\n  goog.require('ol.ViewHint');\n  goog.require('ol.control.Control');\n  goog.require('ol.css');\n  goog.require('ol.easing');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.EventType');\n  goog.require('ol.math');\n  goog.require('ol.pointer.EventType');\n  goog.require('ol.pointer.PointerEventHandler');\n  \n  \n  /**\n   * @classdesc\n   * A slider type of control for zooming.\n   *\n   * Example:\n   *\n   *     map.addControl(new ol.control.ZoomSlider());\n   *\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.ZoomSliderOptions=} opt_options Zoom slider options.\n   * @api\n   */\n  ol.control.ZoomSlider = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * Will hold the current resolution of the view.\n     *\n     * @type {number|undefined}\n     * @private\n     */\n    this.currentResolution_ = undefined;\n  \n    /**\n     * The direction of the slider. Will be determined from actual display of the\n     * container and defaults to ol.control.ZoomSlider.Direction_.VERTICAL.\n     *\n     * @type {ol.control.ZoomSlider.Direction_}\n     * @private\n     */\n    this.direction_ = ol.control.ZoomSlider.Direction_.VERTICAL;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.heightLimit_ = 0;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.widthLimit_ = 0;\n  \n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.previousX_;\n  \n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.previousY_;\n  \n    /**\n     * The calculated thumb size (border box plus margins).  Set when initSlider_\n     * is called.\n     * @type {ol.Size}\n     * @private\n     */\n    this.thumbSize_ = null;\n  \n    /**\n     * Whether the slider is initialized.\n     * @type {boolean}\n     * @private\n     */\n    this.sliderInitialized_ = false;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n  \n    var className = options.className !== undefined ? options.className : 'ol-zoomslider';\n    var thumbElement = document.createElement('button');\n    thumbElement.setAttribute('type', 'button');\n    thumbElement.className = className + '-thumb ' + ol.css.CLASS_UNSELECTABLE;\n    var containerElement = document.createElement('div');\n    containerElement.className = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' + ol.css.CLASS_CONTROL;\n    containerElement.appendChild(thumbElement);\n    /**\n     * @type {ol.pointer.PointerEventHandler}\n     * @private\n     */\n    this.dragger_ = new ol.pointer.PointerEventHandler(containerElement);\n  \n    ol.events.listen(this.dragger_, ol.pointer.EventType.POINTERDOWN,\n        this.handleDraggerStart_, this);\n    ol.events.listen(this.dragger_, ol.pointer.EventType.POINTERMOVE,\n        this.handleDraggerDrag_, this);\n    ol.events.listen(this.dragger_, ol.pointer.EventType.POINTERUP,\n        this.handleDraggerEnd_, this);\n  \n    ol.events.listen(containerElement, ol.events.EventType.CLICK,\n        this.handleContainerClick_, this);\n    ol.events.listen(thumbElement, ol.events.EventType.CLICK,\n        ol.events.Event.stopPropagation);\n  \n    var render = options.render ? options.render : ol.control.ZoomSlider.render;\n  \n    ol.control.Control.call(this, {\n      element: containerElement,\n      render: render\n    });\n  };\n  ol.inherits(ol.control.ZoomSlider, ol.control.Control);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.control.ZoomSlider.prototype.disposeInternal = function() {\n    this.dragger_.dispose();\n    ol.control.Control.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * The enum for available directions.\n   *\n   * @enum {number}\n   * @private\n   */\n  ol.control.ZoomSlider.Direction_ = {\n    VERTICAL: 0,\n    HORIZONTAL: 1\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.control.ZoomSlider.prototype.setMap = function(map) {\n    ol.control.Control.prototype.setMap.call(this, map);\n    if (map) {\n      map.render();\n    }\n  };\n  \n  \n  /**\n   * Initializes the slider element. This will determine and set this controls\n   * direction_ and also constrain the dragging of the thumb to always be within\n   * the bounds of the container.\n   *\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.initSlider_ = function() {\n    var container = this.element;\n    var containerSize = {\n      width: container.offsetWidth, height: container.offsetHeight\n    };\n  \n    var thumb = container.firstElementChild;\n    var computedStyle = getComputedStyle(thumb);\n    var thumbWidth = thumb.offsetWidth +\n        parseFloat(computedStyle['marginRight']) +\n        parseFloat(computedStyle['marginLeft']);\n    var thumbHeight = thumb.offsetHeight +\n        parseFloat(computedStyle['marginTop']) +\n        parseFloat(computedStyle['marginBottom']);\n    this.thumbSize_ = [thumbWidth, thumbHeight];\n  \n    if (containerSize.width > containerSize.height) {\n      this.direction_ = ol.control.ZoomSlider.Direction_.HORIZONTAL;\n      this.widthLimit_ = containerSize.width - thumbWidth;\n    } else {\n      this.direction_ = ol.control.ZoomSlider.Direction_.VERTICAL;\n      this.heightLimit_ = containerSize.height - thumbHeight;\n    }\n    this.sliderInitialized_ = true;\n  };\n  \n  \n  /**\n   * Update the zoomslider element.\n   * @param {ol.MapEvent} mapEvent Map event.\n   * @this {ol.control.ZoomSlider}\n   * @api\n   */\n  ol.control.ZoomSlider.render = function(mapEvent) {\n    if (!mapEvent.frameState) {\n      return;\n    }\n    if (!this.sliderInitialized_) {\n      this.initSlider_();\n    }\n    var res = mapEvent.frameState.viewState.resolution;\n    if (res !== this.currentResolution_) {\n      this.currentResolution_ = res;\n      this.setThumbPosition_(res);\n    }\n  };\n  \n  \n  /**\n   * @param {Event} event The browser event to handle.\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.handleContainerClick_ = function(event) {\n    var view = this.getMap().getView();\n  \n    var relativePosition = this.getRelativePosition_(\n        event.offsetX - this.thumbSize_[0] / 2,\n        event.offsetY - this.thumbSize_[1] / 2);\n  \n    var resolution = this.getResolutionForPosition_(relativePosition);\n  \n    view.animate({\n      resolution: view.constrainResolution(resolution),\n      duration: this.duration_,\n      easing: ol.easing.easeOut\n    });\n  };\n  \n  \n  /**\n   * Handle dragger start events.\n   * @param {ol.pointer.PointerEvent} event The drag event.\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.handleDraggerStart_ = function(event) {\n    if (!this.dragging_ && event.originalEvent.target === this.element.firstElementChild) {\n      this.getMap().getView().setHint(ol.ViewHint.INTERACTING, 1);\n      this.previousX_ = event.clientX;\n      this.previousY_ = event.clientY;\n      this.dragging_ = true;\n    }\n  };\n  \n  \n  /**\n   * Handle dragger drag events.\n   *\n   * @param {ol.pointer.PointerEvent|Event} event The drag event.\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.handleDraggerDrag_ = function(event) {\n    if (this.dragging_) {\n      var element = this.element.firstElementChild;\n      var deltaX = event.clientX - this.previousX_ + parseInt(element.style.left, 10);\n      var deltaY = event.clientY - this.previousY_ + parseInt(element.style.top, 10);\n      var relativePosition = this.getRelativePosition_(deltaX, deltaY);\n      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);\n      this.getMap().getView().setResolution(this.currentResolution_);\n      this.setThumbPosition_(this.currentResolution_);\n      this.previousX_ = event.clientX;\n      this.previousY_ = event.clientY;\n    }\n  };\n  \n  \n  /**\n   * Handle dragger end events.\n   * @param {ol.pointer.PointerEvent|Event} event The drag event.\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.handleDraggerEnd_ = function(event) {\n    if (this.dragging_) {\n      var view = this.getMap().getView();\n      view.setHint(ol.ViewHint.INTERACTING, -1);\n  \n      view.animate({\n        resolution: view.constrainResolution(this.currentResolution_),\n        duration: this.duration_,\n        easing: ol.easing.easeOut\n      });\n  \n      this.dragging_ = false;\n      this.previousX_ = undefined;\n      this.previousY_ = undefined;\n    }\n  };\n  \n  \n  /**\n   * Positions the thumb inside its container according to the given resolution.\n   *\n   * @param {number} res The res.\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.setThumbPosition_ = function(res) {\n    var position = this.getPositionForResolution_(res);\n    var thumb = this.element.firstElementChild;\n  \n    if (this.direction_ == ol.control.ZoomSlider.Direction_.HORIZONTAL) {\n      thumb.style.left = this.widthLimit_ * position + 'px';\n    } else {\n      thumb.style.top = this.heightLimit_ * position + 'px';\n    }\n  };\n  \n  \n  /**\n   * Calculates the relative position of the thumb given x and y offsets.  The\n   * relative position scales from 0 to 1.  The x and y offsets are assumed to be\n   * in pixel units within the dragger limits.\n   *\n   * @param {number} x Pixel position relative to the left of the slider.\n   * @param {number} y Pixel position relative to the top of the slider.\n   * @return {number} The relative position of the thumb.\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.getRelativePosition_ = function(x, y) {\n    var amount;\n    if (this.direction_ === ol.control.ZoomSlider.Direction_.HORIZONTAL) {\n      amount = x / this.widthLimit_;\n    } else {\n      amount = y / this.heightLimit_;\n    }\n    return ol.math.clamp(amount, 0, 1);\n  };\n  \n  \n  /**\n   * Calculates the corresponding resolution of the thumb given its relative\n   * position (where 0 is the minimum and 1 is the maximum).\n   *\n   * @param {number} position The relative position of the thumb.\n   * @return {number} The corresponding resolution.\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.getResolutionForPosition_ = function(position) {\n    var fn = this.getMap().getView().getResolutionForValueFunction();\n    return fn(1 - position);\n  };\n  \n  \n  /**\n   * Determines the relative position of the slider for the given resolution.  A\n   * relative position of 0 corresponds to the minimum view resolution.  A\n   * relative position of 1 corresponds to the maximum view resolution.\n   *\n   * @param {number} res The resolution.\n   * @return {number} The relative position value (between 0 and 1).\n   * @private\n   */\n  ol.control.ZoomSlider.prototype.getPositionForResolution_ = function(res) {\n    var fn = this.getMap().getView().getValueForResolutionFunction();\n    return 1 - fn(res);\n  };\n  \n  goog.provide('ol.control.ZoomToExtent');\n  \n  goog.require('ol');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.control.Control');\n  goog.require('ol.css');\n  \n  \n  /**\n   * @classdesc\n   * A button control which, when pressed, changes the map view to a specific\n   * extent. To style this control use the css selector `.ol-zoom-extent`.\n   *\n   * @constructor\n   * @extends {ol.control.Control}\n   * @param {olx.control.ZoomToExtentOptions=} opt_options Options.\n   * @api\n   */\n  ol.control.ZoomToExtent = function(opt_options) {\n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @type {ol.Extent}\n     * @protected\n     */\n    this.extent = options.extent ? options.extent : null;\n  \n    var className = options.className !== undefined ? options.className :\n      'ol-zoom-extent';\n  \n    var label = options.label !== undefined ? options.label : 'E';\n    var tipLabel = options.tipLabel !== undefined ?\n      options.tipLabel : 'Fit to extent';\n    var button = document.createElement('button');\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(\n        typeof label === 'string' ? document.createTextNode(label) : label\n    );\n  \n    ol.events.listen(button, ol.events.EventType.CLICK,\n        this.handleClick_, this);\n  \n    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +\n        ol.css.CLASS_CONTROL;\n    var element = document.createElement('div');\n    element.className = cssClasses;\n    element.appendChild(button);\n  \n    ol.control.Control.call(this, {\n      element: element,\n      target: options.target\n    });\n  };\n  ol.inherits(ol.control.ZoomToExtent, ol.control.Control);\n  \n  \n  /**\n   * @param {Event} event The event to handle\n   * @private\n   */\n  ol.control.ZoomToExtent.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    this.handleZoomToExtent();\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.control.ZoomToExtent.prototype.handleZoomToExtent = function() {\n    var map = this.getMap();\n    var view = map.getView();\n    var extent = !this.extent ? view.getProjection().getExtent() : this.extent;\n    view.fit(extent);\n  };\n  \n  goog.provide('ol.DeviceOrientation');\n  \n  goog.require('ol.events');\n  goog.require('ol');\n  goog.require('ol.Object');\n  goog.require('ol.has');\n  goog.require('ol.math');\n  \n  \n  /**\n   * @classdesc\n   * The ol.DeviceOrientation class provides access to information from\n   * DeviceOrientation events.  See the [HTML 5 DeviceOrientation Specification](\n   * http://www.w3.org/TR/orientation-event/) for more details.\n   *\n   * Many new computers, and especially mobile phones\n   * and tablets, provide hardware support for device orientation. Web\n   * developers targeting mobile devices will be especially interested in this\n   * class.\n   *\n   * Device orientation data are relative to a common starting point. For mobile\n   * devices, the starting point is to lay your phone face up on a table with the\n   * top of the phone pointing north. This represents the zero state. All\n   * angles are then relative to this state. For computers, it is the same except\n   * the screen is open at 90 degrees.\n   *\n   * Device orientation is reported as three angles - `alpha`, `beta`, and\n   * `gamma` - relative to the starting position along the three planar axes X, Y\n   * and Z. The X axis runs from the left edge to the right edge through the\n   * middle of the device. Similarly, the Y axis runs from the bottom to the top\n   * of the device through the middle. The Z axis runs from the back to the front\n   * through the middle. In the starting position, the X axis points to the\n   * right, the Y axis points away from you and the Z axis points straight up\n   * from the device lying flat.\n   *\n   * The three angles representing the device orientation are relative to the\n   * three axes. `alpha` indicates how much the device has been rotated around the\n   * Z axis, which is commonly interpreted as the compass heading (see note\n   * below). `beta` indicates how much the device has been rotated around the X\n   * axis, or how much it is tilted from front to back.  `gamma` indicates how\n   * much the device has been rotated around the Y axis, or how much it is tilted\n   * from left to right.\n   *\n   * For most browsers, the `alpha` value returns the compass heading so if the\n   * device points north, it will be 0.  With Safari on iOS, the 0 value of\n   * `alpha` is calculated from when device orientation was first requested.\n   * ol.DeviceOrientation provides the `heading` property which normalizes this\n   * behavior across all browsers for you.\n   *\n   * It is important to note that the HTML 5 DeviceOrientation specification\n   * indicates that `alpha`, `beta` and `gamma` are in degrees while the\n   * equivalent properties in ol.DeviceOrientation are in radians for consistency\n   * with all other uses of angles throughout OpenLayers.\n   *\n   * To get notified of device orientation changes, register a listener for the\n   * generic `change` event on your `ol.DeviceOrientation` instance.\n   *\n   * @see {@link http://www.w3.org/TR/orientation-event/}\n   *\n   * @deprecated This class is deprecated and will removed in the next major release.\n   *\n   * @constructor\n   * @extends {ol.Object}\n   * @param {olx.DeviceOrientationOptions=} opt_options Options.\n   * @api\n   */\n  ol.DeviceOrientation = function(opt_options) {\n  \n    ol.Object.call(this);\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {?ol.EventsKey}\n     */\n    this.listenerKey_ = null;\n  \n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.DeviceOrientation.Property_.TRACKING),\n        this.handleTrackingChanged_, this);\n  \n    this.setTracking(options.tracking !== undefined ? options.tracking : false);\n  \n  };\n  ol.inherits(ol.DeviceOrientation, ol.Object);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.DeviceOrientation.prototype.disposeInternal = function() {\n    this.setTracking(false);\n    ol.Object.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} originalEvent Event.\n   */\n  ol.DeviceOrientation.prototype.orientationChange_ = function(originalEvent) {\n    var event = /** @type {DeviceOrientationEvent} */ (originalEvent);\n    if (event.alpha !== null) {\n      var alpha = ol.math.toRadians(event.alpha);\n      this.set(ol.DeviceOrientation.Property_.ALPHA, alpha);\n      // event.absolute is undefined in iOS.\n      if (typeof event.absolute === 'boolean' && event.absolute) {\n        this.set(ol.DeviceOrientation.Property_.HEADING, alpha);\n      } else if (typeof event.webkitCompassHeading === 'number' &&\n                 event.webkitCompassAccuracy != -1) {\n        var heading = ol.math.toRadians(event.webkitCompassHeading);\n        this.set(ol.DeviceOrientation.Property_.HEADING, heading);\n      }\n    }\n    if (event.beta !== null) {\n      this.set(ol.DeviceOrientation.Property_.BETA,\n          ol.math.toRadians(event.beta));\n    }\n    if (event.gamma !== null) {\n      this.set(ol.DeviceOrientation.Property_.GAMMA,\n          ol.math.toRadians(event.gamma));\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * Rotation around the device z-axis (in radians).\n   * @return {number|undefined} The euler angle in radians of the device from the\n   *     standard Z axis.\n   * @observable\n   * @api\n   */\n  ol.DeviceOrientation.prototype.getAlpha = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.DeviceOrientation.Property_.ALPHA));\n  };\n  \n  \n  /**\n   * Rotation around the device x-axis (in radians).\n   * @return {number|undefined} The euler angle in radians of the device from the\n   *     planar X axis.\n   * @observable\n   * @api\n   */\n  ol.DeviceOrientation.prototype.getBeta = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.DeviceOrientation.Property_.BETA));\n  };\n  \n  \n  /**\n   * Rotation around the device y-axis (in radians).\n   * @return {number|undefined} The euler angle in radians of the device from the\n   *     planar Y axis.\n   * @observable\n   * @api\n   */\n  ol.DeviceOrientation.prototype.getGamma = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.DeviceOrientation.Property_.GAMMA));\n  };\n  \n  \n  /**\n   * The heading of the device relative to north (in radians).\n   * @return {number|undefined} The heading of the device relative to north, in\n   *     radians, normalizing for different browser behavior.\n   * @observable\n   * @api\n   */\n  ol.DeviceOrientation.prototype.getHeading = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.DeviceOrientation.Property_.HEADING));\n  };\n  \n  \n  /**\n   * Determine if orientation is being tracked.\n   * @return {boolean} Changes in device orientation are being tracked.\n   * @observable\n   * @api\n   */\n  ol.DeviceOrientation.prototype.getTracking = function() {\n    return /** @type {boolean} */ (\n      this.get(ol.DeviceOrientation.Property_.TRACKING));\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.DeviceOrientation.prototype.handleTrackingChanged_ = function() {\n    if (ol.has.DEVICE_ORIENTATION) {\n      var tracking = this.getTracking();\n      if (tracking && !this.listenerKey_) {\n        this.listenerKey_ = ol.events.listen(window, 'deviceorientation',\n            this.orientationChange_, this);\n      } else if (!tracking && this.listenerKey_ !== null) {\n        ol.events.unlistenByKey(this.listenerKey_);\n        this.listenerKey_ = null;\n      }\n    }\n  };\n  \n  \n  /**\n   * Enable or disable tracking of device orientation events.\n   * @param {boolean} tracking The status of tracking changes to alpha, beta and\n   *     gamma. If true, changes are tracked and reported immediately.\n   * @observable\n   * @api\n   */\n  ol.DeviceOrientation.prototype.setTracking = function(tracking) {\n    this.set(ol.DeviceOrientation.Property_.TRACKING, tracking);\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.DeviceOrientation.Property_ = {\n    ALPHA: 'alpha',\n    BETA: 'beta',\n    GAMMA: 'gamma',\n    HEADING: 'heading',\n    TRACKING: 'tracking'\n  };\n  \n  goog.provide('ol.style.Image');\n  \n  \n  /**\n   * @classdesc\n   * A base class used for creating subclasses and not instantiated in\n   * apps. Base class for {@link ol.style.Icon}, {@link ol.style.Circle} and\n   * {@link ol.style.RegularShape}.\n   *\n   * @constructor\n   * @abstract\n   * @param {ol.StyleImageOptions} options Options.\n   * @api\n   */\n  ol.style.Image = function(options) {\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = options.opacity;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotateWithView_ = options.rotateWithView;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.rotation_ = options.rotation;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.scale_ = options.scale;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.snapToPixel_ = options.snapToPixel;\n  \n  };\n  \n  \n  /**\n   * Get the symbolizer opacity.\n   * @return {number} Opacity.\n   * @api\n   */\n  ol.style.Image.prototype.getOpacity = function() {\n    return this.opacity_;\n  };\n  \n  \n  /**\n   * Determine whether the symbolizer rotates with the map.\n   * @return {boolean} Rotate with map.\n   * @api\n   */\n  ol.style.Image.prototype.getRotateWithView = function() {\n    return this.rotateWithView_;\n  };\n  \n  \n  /**\n   * Get the symoblizer rotation.\n   * @return {number} Rotation.\n   * @api\n   */\n  ol.style.Image.prototype.getRotation = function() {\n    return this.rotation_;\n  };\n  \n  \n  /**\n   * Get the symbolizer scale.\n   * @return {number} Scale.\n   * @api\n   */\n  ol.style.Image.prototype.getScale = function() {\n    return this.scale_;\n  };\n  \n  \n  /**\n   * Determine whether the symbolizer should be snapped to a pixel.\n   * @return {boolean} The symbolizer should snap to a pixel.\n   * @api\n   */\n  ol.style.Image.prototype.getSnapToPixel = function() {\n    return this.snapToPixel_;\n  };\n  \n  \n  /**\n   * Get the anchor point in pixels. The anchor determines the center point for the\n   * symbolizer.\n   * @abstract\n   * @return {Array.<number>} Anchor.\n   */\n  ol.style.Image.prototype.getAnchor = function() {};\n  \n  \n  /**\n   * Get the image element for the symbolizer.\n   * @abstract\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.\n   */\n  ol.style.Image.prototype.getImage = function(pixelRatio) {};\n  \n  \n  /**\n   * @abstract\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.\n   */\n  ol.style.Image.prototype.getHitDetectionImage = function(pixelRatio) {};\n  \n  \n  /**\n   * @abstract\n   * @return {ol.ImageState} Image state.\n   */\n  ol.style.Image.prototype.getImageState = function() {};\n  \n  \n  /**\n   * @abstract\n   * @return {ol.Size} Image size.\n   */\n  ol.style.Image.prototype.getImageSize = function() {};\n  \n  \n  /**\n   * @abstract\n   * @return {ol.Size} Size of the hit-detection image.\n   */\n  ol.style.Image.prototype.getHitDetectionImageSize = function() {};\n  \n  \n  /**\n   * Get the origin of the symbolizer.\n   * @abstract\n   * @return {Array.<number>} Origin.\n   */\n  ol.style.Image.prototype.getOrigin = function() {};\n  \n  \n  /**\n   * Get the size of the symbolizer (in pixels).\n   * @abstract\n   * @return {ol.Size} Size.\n   */\n  ol.style.Image.prototype.getSize = function() {};\n  \n  \n  /**\n   * Set the opacity.\n   *\n   * @param {number} opacity Opacity.\n   * @api\n   */\n  ol.style.Image.prototype.setOpacity = function(opacity) {\n    this.opacity_ = opacity;\n  };\n  \n  \n  /**\n   * Set whether to rotate the style with the view.\n   *\n   * @param {boolean} rotateWithView Rotate with map.\n   */\n  ol.style.Image.prototype.setRotateWithView = function(rotateWithView) {\n    this.rotateWithView_ = rotateWithView;\n  };\n  \n  \n  /**\n   * Set the rotation.\n   *\n   * @param {number} rotation Rotation.\n   * @api\n   */\n  ol.style.Image.prototype.setRotation = function(rotation) {\n    this.rotation_ = rotation;\n  };\n  \n  \n  /**\n   * Set the scale.\n   *\n   * @param {number} scale Scale.\n   * @api\n   */\n  ol.style.Image.prototype.setScale = function(scale) {\n    this.scale_ = scale;\n  };\n  \n  \n  /**\n   * Set whether to snap the image to the closest pixel.\n   *\n   * @param {boolean} snapToPixel Snap to pixel?\n   */\n  ol.style.Image.prototype.setSnapToPixel = function(snapToPixel) {\n    this.snapToPixel_ = snapToPixel;\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {function(this: T, ol.events.Event)} listener Listener function.\n   * @param {T} thisArg Value to use as `this` when executing `listener`.\n   * @return {ol.EventsKey|undefined} Listener key.\n   * @template T\n   */\n  ol.style.Image.prototype.listenImageChange = function(listener, thisArg) {};\n  \n  \n  /**\n   * Load not yet loaded URI.\n   * @abstract\n   */\n  ol.style.Image.prototype.load = function() {};\n  \n  \n  /**\n   * @abstract\n   * @param {function(this: T, ol.events.Event)} listener Listener function.\n   * @param {T} thisArg Value to use as `this` when executing `listener`.\n   * @template T\n   */\n  ol.style.Image.prototype.unlistenImageChange = function(listener, thisArg) {};\n  \n  goog.provide('ol.style.RegularShape');\n  \n  goog.require('ol');\n  goog.require('ol.colorlike');\n  goog.require('ol.dom');\n  goog.require('ol.has');\n  goog.require('ol.ImageState');\n  goog.require('ol.render.canvas');\n  goog.require('ol.style.Image');\n  \n  \n  /**\n   * @classdesc\n   * Set regular shape style for vector features. The resulting shape will be\n   * a regular polygon when `radius` is provided, or a star when `radius1` and\n   * `radius2` are provided.\n   *\n   * @constructor\n   * @param {olx.style.RegularShapeOptions} options Options.\n   * @extends {ol.style.Image}\n   * @api\n   */\n  ol.style.RegularShape = function(options) {\n    /**\n     * @private\n     * @type {Array.<string>}\n     */\n    this.checksums_ = null;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.hitDetectionCanvas_ = null;\n  \n    /**\n     * @private\n     * @type {ol.style.Fill}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.origin_ = [0, 0];\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.points_ = options.points;\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.radius_ = /** @type {number} */ (options.radius !== undefined ?\n      options.radius : options.radius1);\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.radius2_ = options.radius2;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n  \n    /**\n     * @private\n     * @type {ol.style.Stroke}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.anchor_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.size_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.imageSize_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.hitDetectionImageSize_ = null;\n  \n    /**\n     * @protected\n     * @type {ol.style.AtlasManager|undefined}\n     */\n    this.atlasManager_ = options.atlasManager;\n  \n    this.render_(this.atlasManager_);\n  \n    /**\n     * @type {boolean}\n     */\n    var snapToPixel = options.snapToPixel !== undefined ?\n      options.snapToPixel : true;\n  \n    /**\n     * @type {boolean}\n     */\n    var rotateWithView = options.rotateWithView !== undefined ?\n      options.rotateWithView : false;\n  \n    ol.style.Image.call(this, {\n      opacity: 1,\n      rotateWithView: rotateWithView,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: 1,\n      snapToPixel: snapToPixel\n    });\n  };\n  ol.inherits(ol.style.RegularShape, ol.style.Image);\n  \n  \n  /**\n   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n   * @return {ol.style.RegularShape} The cloned style.\n   * @api\n   */\n  ol.style.RegularShape.prototype.clone = function() {\n    var style = new ol.style.RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      snapToPixel: this.getSnapToPixel(),\n      stroke: this.getStroke() ?  this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      atlasManager: this.atlasManager_\n    });\n    style.setOpacity(this.getOpacity());\n    style.setScale(this.getScale());\n    return style;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.style.RegularShape.prototype.getAnchor = function() {\n    return this.anchor_;\n  };\n  \n  \n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape's rotation in radians.\n   * @api\n   */\n  ol.style.RegularShape.prototype.getAngle = function() {\n    return this.angle_;\n  };\n  \n  \n  /**\n   * Get the fill style for the shape.\n   * @return {ol.style.Fill} Fill style.\n   * @api\n   */\n  ol.style.RegularShape.prototype.getFill = function() {\n    return this.fill_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.style.RegularShape.prototype.getHitDetectionImage = function(pixelRatio) {\n    return this.hitDetectionCanvas_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.style.RegularShape.prototype.getImage = function(pixelRatio) {\n    return this.canvas_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.style.RegularShape.prototype.getImageSize = function() {\n    return this.imageSize_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.style.RegularShape.prototype.getHitDetectionImageSize = function() {\n    return this.hitDetectionImageSize_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.style.RegularShape.prototype.getImageState = function() {\n    return ol.ImageState.LOADED;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.style.RegularShape.prototype.getOrigin = function() {\n    return this.origin_;\n  };\n  \n  \n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n  ol.style.RegularShape.prototype.getPoints = function() {\n    return this.points_;\n  };\n  \n  \n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n  ol.style.RegularShape.prototype.getRadius = function() {\n    return this.radius_;\n  };\n  \n  \n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n  ol.style.RegularShape.prototype.getRadius2 = function() {\n    return this.radius2_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.style.RegularShape.prototype.getSize = function() {\n    return this.size_;\n  };\n  \n  \n  /**\n   * Get the stroke style for the shape.\n   * @return {ol.style.Stroke} Stroke style.\n   * @api\n   */\n  ol.style.RegularShape.prototype.getStroke = function() {\n    return this.stroke_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.style.RegularShape.prototype.listenImageChange = function(listener, thisArg) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.style.RegularShape.prototype.load = function() {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.style.RegularShape.prototype.unlistenImageChange = function(listener, thisArg) {};\n  \n  \n  /**\n   * @protected\n   * @param {ol.style.AtlasManager|undefined} atlasManager An atlas manager.\n   */\n  ol.style.RegularShape.prototype.render_ = function(atlasManager) {\n    var imageSize;\n    var lineCap = '';\n    var lineJoin = '';\n    var miterLimit = 0;\n    var lineDash = null;\n    var lineDashOffset = 0;\n    var strokeStyle;\n    var strokeWidth = 0;\n  \n    if (this.stroke_) {\n      strokeStyle = this.stroke_.getColor();\n      if (strokeStyle === null) {\n        strokeStyle = ol.render.canvas.defaultStrokeStyle;\n      }\n      strokeStyle = ol.colorlike.asColorLike(strokeStyle);\n      strokeWidth = this.stroke_.getWidth();\n      if (strokeWidth === undefined) {\n        strokeWidth = ol.render.canvas.defaultLineWidth;\n      }\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset();\n      if (!ol.has.CANVAS_LINE_DASH) {\n        lineDash = null;\n        lineDashOffset = 0;\n      }\n      lineJoin = this.stroke_.getLineJoin();\n      if (lineJoin === undefined) {\n        lineJoin = ol.render.canvas.defaultLineJoin;\n      }\n      lineCap = this.stroke_.getLineCap();\n      if (lineCap === undefined) {\n        lineCap = ol.render.canvas.defaultLineCap;\n      }\n      miterLimit = this.stroke_.getMiterLimit();\n      if (miterLimit === undefined) {\n        miterLimit = ol.render.canvas.defaultMiterLimit;\n      }\n    }\n  \n    var size = 2 * (this.radius_ + strokeWidth) + 1;\n  \n    /** @type {ol.RegularShapeRenderOptions} */\n    var renderOptions = {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineCap: lineCap,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit\n    };\n  \n    if (atlasManager === undefined) {\n      // no atlas manager is used, create a new canvas\n      var context = ol.dom.createCanvasContext2D(size, size);\n      this.canvas_ = context.canvas;\n  \n      // canvas.width and height are rounded to the closest integer\n      size = this.canvas_.width;\n      imageSize = size;\n  \n      this.draw_(renderOptions, context, 0, 0);\n  \n      this.createHitDetectionCanvas_(renderOptions);\n    } else {\n      // an atlas manager is used, add the symbol to an atlas\n      size = Math.round(size);\n  \n      var hasCustomHitDetectionImage = !this.fill_;\n      var renderHitDetectionCallback;\n      if (hasCustomHitDetectionImage) {\n        // render the hit-detection image into a separate atlas image\n        renderHitDetectionCallback =\n            this.drawHitDetectionCanvas_.bind(this, renderOptions);\n      }\n  \n      var id = this.getChecksum();\n      var info = atlasManager.add(\n          id, size, size, this.draw_.bind(this, renderOptions),\n          renderHitDetectionCallback);\n  \n      this.canvas_ = info.image;\n      this.origin_ = [info.offsetX, info.offsetY];\n      imageSize = info.image.width;\n  \n      if (hasCustomHitDetectionImage) {\n        this.hitDetectionCanvas_ = info.hitImage;\n        this.hitDetectionImageSize_ =\n            [info.hitImage.width, info.hitImage.height];\n      } else {\n        this.hitDetectionCanvas_ = this.canvas_;\n        this.hitDetectionImageSize_ = [imageSize, imageSize];\n      }\n    }\n  \n    this.anchor_ = [size / 2, size / 2];\n    this.size_ = [size, size];\n    this.imageSize_ = [imageSize, imageSize];\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.RegularShapeRenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  ol.style.RegularShape.prototype.draw_ = function(renderOptions, context, x, y) {\n    var i, angle0, radiusC;\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n  \n    // then move to (x, y)\n    context.translate(x, y);\n  \n    context.beginPath();\n  \n    var points = this.points_;\n    if (points === Infinity) {\n      context.arc(\n          renderOptions.size / 2, renderOptions.size / 2,\n          this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      var radius2 = (this.radius2_ !== undefined) ? this.radius2_\n        : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\n            renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n  \n  \n    if (this.fill_) {\n      var color = this.fill_.getColor();\n      if (color === null) {\n        color = ol.render.canvas.defaultFillStyle;\n      }\n      context.fillStyle = ol.colorlike.asColorLike(color);\n      context.fill();\n    }\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineCap = renderOptions.lineCap;\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n    context.closePath();\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.RegularShapeRenderOptions} renderOptions Render options.\n   */\n  ol.style.RegularShape.prototype.createHitDetectionCanvas_ = function(renderOptions) {\n    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n    if (this.fill_) {\n      this.hitDetectionCanvas_ = this.canvas_;\n      return;\n    }\n  \n    // if no fill style is set, create an extra hit-detection image with a\n    // default fill style\n    var context = ol.dom.createCanvasContext2D(renderOptions.size, renderOptions.size);\n    this.hitDetectionCanvas_ = context.canvas;\n  \n    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.RegularShapeRenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  ol.style.RegularShape.prototype.drawHitDetectionCanvas_ = function(renderOptions, context, x, y) {\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n  \n    // then move to (x, y)\n    context.translate(x, y);\n  \n    context.beginPath();\n  \n    var points = this.points_;\n    if (points === Infinity) {\n      context.arc(\n          renderOptions.size / 2, renderOptions.size / 2,\n          this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      var radius2 = (this.radius2_ !== undefined) ? this.radius2_\n        : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      var i, radiusC, angle0;\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\n            renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n  \n    context.fillStyle = ol.render.canvas.defaultFillStyle;\n    context.fill();\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.stroke();\n    }\n    context.closePath();\n  };\n  \n  \n  /**\n   * @return {string} The checksum.\n   */\n  ol.style.RegularShape.prototype.getChecksum = function() {\n    var strokeChecksum = this.stroke_ ?\n      this.stroke_.getChecksum() : '-';\n    var fillChecksum = this.fill_ ?\n      this.fill_.getChecksum() : '-';\n  \n    var recalculate = !this.checksums_ ||\n        (strokeChecksum != this.checksums_[1] ||\n        fillChecksum != this.checksums_[2] ||\n        this.radius_ != this.checksums_[3] ||\n        this.radius2_ != this.checksums_[4] ||\n        this.angle_ != this.checksums_[5] ||\n        this.points_ != this.checksums_[6]);\n  \n    if (recalculate) {\n      var checksum = 'r' + strokeChecksum + fillChecksum +\n          (this.radius_ !== undefined ? this.radius_.toString() : '-') +\n          (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +\n          (this.angle_ !== undefined ? this.angle_.toString() : '-') +\n          (this.points_ !== undefined ? this.points_.toString() : '-');\n      this.checksums_ = [checksum, strokeChecksum, fillChecksum,\n        this.radius_, this.radius2_, this.angle_, this.points_];\n    }\n  \n    return this.checksums_[0];\n  };\n  \n  goog.provide('ol.style.Circle');\n  \n  goog.require('ol');\n  goog.require('ol.style.RegularShape');\n  \n  \n  /**\n   * @classdesc\n   * Set circle style for vector features.\n   *\n   * @constructor\n   * @param {olx.style.CircleOptions=} opt_options Options.\n   * @extends {ol.style.RegularShape}\n   * @api\n   */\n  ol.style.Circle = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    ol.style.RegularShape.call(this, {\n      points: Infinity,\n      fill: options.fill,\n      radius: options.radius,\n      snapToPixel: options.snapToPixel,\n      stroke: options.stroke,\n      atlasManager: options.atlasManager\n    });\n  \n  };\n  ol.inherits(ol.style.Circle, ol.style.RegularShape);\n  \n  \n  /**\n   * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n   * @return {ol.style.Circle} The cloned style.\n   * @override\n   * @api\n   */\n  ol.style.Circle.prototype.clone = function() {\n    var style = new ol.style.Circle({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      radius: this.getRadius(),\n      snapToPixel: this.getSnapToPixel(),\n      atlasManager: this.atlasManager_\n    });\n    style.setOpacity(this.getOpacity());\n    style.setScale(this.getScale());\n    return style;\n  };\n  \n  \n  /**\n   * Set the circle radius.\n   *\n   * @param {number} radius Circle radius.\n   * @api\n   */\n  ol.style.Circle.prototype.setRadius = function(radius) {\n    this.radius_ = radius;\n    this.render_(this.atlasManager_);\n  };\n  \n  goog.provide('ol.style.Fill');\n  \n  goog.require('ol');\n  goog.require('ol.color');\n  \n  \n  /**\n   * @classdesc\n   * Set fill style for vector features.\n   *\n   * @constructor\n   * @param {olx.style.FillOptions=} opt_options Options.\n   * @api\n   */\n  ol.style.Fill = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @type {ol.Color|ol.ColorLike}\n     */\n    this.color_ = options.color !== undefined ? options.color : null;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * Clones the style. The color is not cloned if it is an {@link ol.ColorLike}.\n   * @return {ol.style.Fill} The cloned style.\n   * @api\n   */\n  ol.style.Fill.prototype.clone = function() {\n    var color = this.getColor();\n    return new ol.style.Fill({\n      color: (color && color.slice) ? color.slice() : color || undefined\n    });\n  };\n  \n  \n  /**\n   * Get the fill color.\n   * @return {ol.Color|ol.ColorLike} Color.\n   * @api\n   */\n  ol.style.Fill.prototype.getColor = function() {\n    return this.color_;\n  };\n  \n  \n  /**\n   * Set the color.\n   *\n   * @param {ol.Color|ol.ColorLike} color Color.\n   * @api\n   */\n  ol.style.Fill.prototype.setColor = function(color) {\n    this.color_ = color;\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * @return {string} The checksum.\n   */\n  ol.style.Fill.prototype.getChecksum = function() {\n    if (this.checksum_ === undefined) {\n      if (\n        this.color_ instanceof CanvasPattern ||\n          this.color_ instanceof CanvasGradient\n      ) {\n        this.checksum_ = ol.getUid(this.color_).toString();\n      } else {\n        this.checksum_ = 'f' + (this.color_ ?\n          ol.color.asString(this.color_) : '-');\n      }\n    }\n  \n    return this.checksum_;\n  };\n  \n  goog.provide('ol.style.Stroke');\n  \n  goog.require('ol');\n  \n  \n  /**\n   * @classdesc\n   * Set stroke style for vector features.\n   * Note that the defaults given are the Canvas defaults, which will be used if\n   * option is not defined. The `get` functions return whatever was entered in\n   * the options; they will not return the default.\n   *\n   * @constructor\n   * @param {olx.style.StrokeOptions=} opt_options Options.\n   * @api\n   */\n  ol.style.Stroke = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @type {ol.Color|ol.ColorLike}\n     */\n    this.color_ = options.color !== undefined ? options.color : null;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.lineCap_ = options.lineCap;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lineDashOffset_ = options.lineDashOffset;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.lineJoin_ = options.lineJoin;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.miterLimit_ = options.miterLimit;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.width_ = options.width;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * Clones the style.\n   * @return {ol.style.Stroke} The cloned style.\n   * @api\n   */\n  ol.style.Stroke.prototype.clone = function() {\n    var color = this.getColor();\n    return new ol.style.Stroke({\n      color: (color && color.slice) ? color.slice() : color || undefined,\n      lineCap: this.getLineCap(),\n      lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,\n      lineDashOffset: this.getLineDashOffset(),\n      lineJoin: this.getLineJoin(),\n      miterLimit: this.getMiterLimit(),\n      width: this.getWidth()\n    });\n  };\n  \n  \n  /**\n   * Get the stroke color.\n   * @return {ol.Color|ol.ColorLike} Color.\n   * @api\n   */\n  ol.style.Stroke.prototype.getColor = function() {\n    return this.color_;\n  };\n  \n  \n  /**\n   * Get the line cap type for the stroke.\n   * @return {string|undefined} Line cap.\n   * @api\n   */\n  ol.style.Stroke.prototype.getLineCap = function() {\n    return this.lineCap_;\n  };\n  \n  \n  /**\n   * Get the line dash style for the stroke.\n   * @return {Array.<number>} Line dash.\n   * @api\n   */\n  ol.style.Stroke.prototype.getLineDash = function() {\n    return this.lineDash_;\n  };\n  \n  \n  /**\n   * Get the line dash offset for the stroke.\n   * @return {number|undefined} Line dash offset.\n   * @api\n   */\n  ol.style.Stroke.prototype.getLineDashOffset = function() {\n    return this.lineDashOffset_;\n  };\n  \n  \n  /**\n   * Get the line join type for the stroke.\n   * @return {string|undefined} Line join.\n   * @api\n   */\n  ol.style.Stroke.prototype.getLineJoin = function() {\n    return this.lineJoin_;\n  };\n  \n  \n  /**\n   * Get the miter limit for the stroke.\n   * @return {number|undefined} Miter limit.\n   * @api\n   */\n  ol.style.Stroke.prototype.getMiterLimit = function() {\n    return this.miterLimit_;\n  };\n  \n  \n  /**\n   * Get the stroke width.\n   * @return {number|undefined} Width.\n   * @api\n   */\n  ol.style.Stroke.prototype.getWidth = function() {\n    return this.width_;\n  };\n  \n  \n  /**\n   * Set the color.\n   *\n   * @param {ol.Color|ol.ColorLike} color Color.\n   * @api\n   */\n  ol.style.Stroke.prototype.setColor = function(color) {\n    this.color_ = color;\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * Set the line cap.\n   *\n   * @param {string|undefined} lineCap Line cap.\n   * @api\n   */\n  ol.style.Stroke.prototype.setLineCap = function(lineCap) {\n    this.lineCap_ = lineCap;\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * Set the line dash.\n   *\n   * Please note that Internet Explorer 10 and lower [do not support][mdn] the\n   * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this\n   * property will have no visual effect in these browsers.\n   *\n   * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility\n   *\n   * @param {Array.<number>} lineDash Line dash.\n   * @api\n   */\n  ol.style.Stroke.prototype.setLineDash = function(lineDash) {\n    this.lineDash_ = lineDash;\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * Set the line dash offset.\n   *\n   * @param {number|undefined} lineDashOffset Line dash offset.\n   * @api\n   */\n  ol.style.Stroke.prototype.setLineDashOffset = function(lineDashOffset) {\n    this.lineDashOffset_ = lineDashOffset;\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * Set the line join.\n   *\n   * @param {string|undefined} lineJoin Line join.\n   * @api\n   */\n  ol.style.Stroke.prototype.setLineJoin = function(lineJoin) {\n    this.lineJoin_ = lineJoin;\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * Set the miter limit.\n   *\n   * @param {number|undefined} miterLimit Miter limit.\n   * @api\n   */\n  ol.style.Stroke.prototype.setMiterLimit = function(miterLimit) {\n    this.miterLimit_ = miterLimit;\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * Set the width.\n   *\n   * @param {number|undefined} width Width.\n   * @api\n   */\n  ol.style.Stroke.prototype.setWidth = function(width) {\n    this.width_ = width;\n    this.checksum_ = undefined;\n  };\n  \n  \n  /**\n   * @return {string} The checksum.\n   */\n  ol.style.Stroke.prototype.getChecksum = function() {\n    if (this.checksum_ === undefined) {\n      this.checksum_ = 's';\n      if (this.color_) {\n        if (typeof this.color_ === 'string') {\n          this.checksum_ += this.color_;\n        } else {\n          this.checksum_ += ol.getUid(this.color_).toString();\n        }\n      } else {\n        this.checksum_ += '-';\n      }\n      this.checksum_ += ',' +\n          (this.lineCap_ !== undefined ?\n            this.lineCap_.toString() : '-') + ',' +\n          (this.lineDash_ ?\n            this.lineDash_.toString() : '-') + ',' +\n          (this.lineDashOffset_ !== undefined ?\n            this.lineDashOffset_ : '-') + ',' +\n          (this.lineJoin_ !== undefined ?\n            this.lineJoin_ : '-') + ',' +\n          (this.miterLimit_ !== undefined ?\n            this.miterLimit_.toString() : '-') + ',' +\n          (this.width_ !== undefined ?\n            this.width_.toString() : '-');\n    }\n  \n    return this.checksum_;\n  };\n  \n  goog.provide('ol.style.Style');\n  \n  goog.require('ol.asserts');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.style.Circle');\n  goog.require('ol.style.Fill');\n  goog.require('ol.style.Stroke');\n  \n  \n  /**\n   * @classdesc\n   * Container for vector feature rendering styles. Any changes made to the style\n   * or its children through `set*()` methods will not take effect until the\n   * feature or layer that uses the style is re-rendered.\n   *\n   * @constructor\n   * @struct\n   * @param {olx.style.StyleOptions=} opt_options Style options.\n   * @api\n   */\n  ol.style.Style = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @type {string|ol.geom.Geometry|ol.StyleGeometryFunction}\n     */\n    this.geometry_ = null;\n  \n    /**\n     * @private\n     * @type {!ol.StyleGeometryFunction}\n     */\n    this.geometryFunction_ = ol.style.Style.defaultGeometryFunction;\n  \n    if (options.geometry !== undefined) {\n      this.setGeometry(options.geometry);\n    }\n  \n    /**\n     * @private\n     * @type {ol.style.Fill}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n  \n    /**\n     * @private\n     * @type {ol.style.Image}\n     */\n    this.image_ = options.image !== undefined ? options.image : null;\n  \n    /**\n     * @private\n     * @type {ol.StyleRenderFunction|null}\n     */\n    this.renderer_ = options.renderer !== undefined ? options.renderer : null;\n  \n    /**\n     * @private\n     * @type {ol.style.Stroke}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n  \n    /**\n     * @private\n     * @type {ol.style.Text}\n     */\n    this.text_ = options.text !== undefined ? options.text : null;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zIndex_ = options.zIndex;\n  \n  };\n  \n  \n  /**\n   * Clones the style.\n   * @return {ol.style.Style} The cloned style.\n   * @api\n   */\n  ol.style.Style.prototype.clone = function() {\n    var geometry = this.getGeometry();\n    if (geometry && geometry.clone) {\n      geometry = geometry.clone();\n    }\n    return new ol.style.Style({\n      geometry: geometry,\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      image: this.getImage() ? this.getImage().clone() : undefined,\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      text: this.getText() ? this.getText().clone() : undefined,\n      zIndex: this.getZIndex()\n    });\n  };\n  \n  \n  /**\n   * Get the custom renderer function that was configured with\n   * {@link #setRenderer} or the `renderer` constructor option.\n   * @return {ol.StyleRenderFunction|null} Custom renderer function.\n   * @api\n   */\n  ol.style.Style.prototype.getRenderer = function() {\n    return this.renderer_;\n  };\n  \n  \n  /**\n   * Sets a custom renderer function for this style. When set, `fill`, `stroke`\n   * and `image` options of the style will be ignored.\n   * @param {ol.StyleRenderFunction|null} renderer Custom renderer function.\n   * @api\n   */\n  ol.style.Style.prototype.setRenderer = function(renderer) {\n    this.renderer_ = renderer;\n  };\n  \n  \n  /**\n   * Get the geometry to be rendered.\n   * @return {string|ol.geom.Geometry|ol.StyleGeometryFunction}\n   * Feature property or geometry or function that returns the geometry that will\n   * be rendered with this style.\n   * @api\n   */\n  ol.style.Style.prototype.getGeometry = function() {\n    return this.geometry_;\n  };\n  \n  \n  /**\n   * Get the function used to generate a geometry for rendering.\n   * @return {!ol.StyleGeometryFunction} Function that is called with a feature\n   * and returns the geometry to render instead of the feature's geometry.\n   * @api\n   */\n  ol.style.Style.prototype.getGeometryFunction = function() {\n    return this.geometryFunction_;\n  };\n  \n  \n  /**\n   * Get the fill style.\n   * @return {ol.style.Fill} Fill style.\n   * @api\n   */\n  ol.style.Style.prototype.getFill = function() {\n    return this.fill_;\n  };\n  \n  \n  /**\n   * Set the fill style.\n   * @param {ol.style.Fill} fill Fill style.\n   * @api\n   */\n  ol.style.Style.prototype.setFill = function(fill) {\n    this.fill_ = fill;\n  };\n  \n  \n  /**\n   * Get the image style.\n   * @return {ol.style.Image} Image style.\n   * @api\n   */\n  ol.style.Style.prototype.getImage = function() {\n    return this.image_;\n  };\n  \n  \n  /**\n   * Set the image style.\n   * @param {ol.style.Image} image Image style.\n   * @api\n   */\n  ol.style.Style.prototype.setImage = function(image) {\n    this.image_ = image;\n  };\n  \n  \n  /**\n   * Get the stroke style.\n   * @return {ol.style.Stroke} Stroke style.\n   * @api\n   */\n  ol.style.Style.prototype.getStroke = function() {\n    return this.stroke_;\n  };\n  \n  \n  /**\n   * Set the stroke style.\n   * @param {ol.style.Stroke} stroke Stroke style.\n   * @api\n   */\n  ol.style.Style.prototype.setStroke = function(stroke) {\n    this.stroke_ = stroke;\n  };\n  \n  \n  /**\n   * Get the text style.\n   * @return {ol.style.Text} Text style.\n   * @api\n   */\n  ol.style.Style.prototype.getText = function() {\n    return this.text_;\n  };\n  \n  \n  /**\n   * Set the text style.\n   * @param {ol.style.Text} text Text style.\n   * @api\n   */\n  ol.style.Style.prototype.setText = function(text) {\n    this.text_ = text;\n  };\n  \n  \n  /**\n   * Get the z-index for the style.\n   * @return {number|undefined} ZIndex.\n   * @api\n   */\n  ol.style.Style.prototype.getZIndex = function() {\n    return this.zIndex_;\n  };\n  \n  \n  /**\n   * Set a geometry that is rendered instead of the feature's geometry.\n   *\n   * @param {string|ol.geom.Geometry|ol.StyleGeometryFunction} geometry\n   *     Feature property or geometry or function returning a geometry to render\n   *     for this style.\n   * @api\n   */\n  ol.style.Style.prototype.setGeometry = function(geometry) {\n    if (typeof geometry === 'function') {\n      this.geometryFunction_ = geometry;\n    } else if (typeof geometry === 'string') {\n      this.geometryFunction_ = function(feature) {\n        return /** @type {ol.geom.Geometry} */ (feature.get(geometry));\n      };\n    } else if (!geometry) {\n      this.geometryFunction_ = ol.style.Style.defaultGeometryFunction;\n    } else if (geometry !== undefined) {\n      this.geometryFunction_ = function() {\n        return /** @type {ol.geom.Geometry} */ (geometry);\n      };\n    }\n    this.geometry_ = geometry;\n  };\n  \n  \n  /**\n   * Set the z-index.\n   *\n   * @param {number|undefined} zIndex ZIndex.\n   * @api\n   */\n  ol.style.Style.prototype.setZIndex = function(zIndex) {\n    this.zIndex_ = zIndex;\n  };\n  \n  \n  /**\n   * Convert the provided object into a style function.  Functions passed through\n   * unchanged.  Arrays of ol.style.Style or single style objects wrapped in a\n   * new style function.\n   * @param {ol.StyleFunction|Array.<ol.style.Style>|ol.style.Style} obj\n   *     A style function, a single style, or an array of styles.\n   * @return {ol.StyleFunction} A style function.\n   */\n  ol.style.Style.createFunction = function(obj) {\n    var styleFunction;\n  \n    if (typeof obj === 'function') {\n      styleFunction = obj;\n    } else {\n      /**\n       * @type {Array.<ol.style.Style>}\n       */\n      var styles;\n      if (Array.isArray(obj)) {\n        styles = obj;\n      } else {\n        ol.asserts.assert(obj instanceof ol.style.Style,\n            41); // Expected an `ol.style.Style` or an array of `ol.style.Style`\n        styles = [obj];\n      }\n      styleFunction = function() {\n        return styles;\n      };\n    }\n    return styleFunction;\n  };\n  \n  \n  /**\n   * @type {Array.<ol.style.Style>}\n   * @private\n   */\n  ol.style.Style.default_ = null;\n  \n  \n  /**\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @param {number} resolution Resolution.\n   * @return {Array.<ol.style.Style>} Style.\n   */\n  ol.style.Style.defaultFunction = function(feature, resolution) {\n    // We don't use an immediately-invoked function\n    // and a closure so we don't get an error at script evaluation time in\n    // browsers that do not support Canvas. (ol.style.Circle does\n    // canvas.getContext('2d') at construction time, which will cause an.error\n    // in such browsers.)\n    if (!ol.style.Style.default_) {\n      var fill = new ol.style.Fill({\n        color: 'rgba(255,255,255,0.4)'\n      });\n      var stroke = new ol.style.Stroke({\n        color: '#3399CC',\n        width: 1.25\n      });\n      ol.style.Style.default_ = [\n        new ol.style.Style({\n          image: new ol.style.Circle({\n            fill: fill,\n            stroke: stroke,\n            radius: 5\n          }),\n          fill: fill,\n          stroke: stroke\n        })\n      ];\n    }\n    return ol.style.Style.default_;\n  };\n  \n  \n  /**\n   * Default styles for editing features.\n   * @return {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} Styles\n   */\n  ol.style.Style.createDefaultEditing = function() {\n    /** @type {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} */\n    var styles = {};\n    var white = [255, 255, 255, 1];\n    var blue = [0, 153, 255, 1];\n    var width = 3;\n    styles[ol.geom.GeometryType.POLYGON] = [\n      new ol.style.Style({\n        fill: new ol.style.Fill({\n          color: [255, 255, 255, 0.5]\n        })\n      })\n    ];\n    styles[ol.geom.GeometryType.MULTI_POLYGON] =\n        styles[ol.geom.GeometryType.POLYGON];\n  \n    styles[ol.geom.GeometryType.LINE_STRING] = [\n      new ol.style.Style({\n        stroke: new ol.style.Stroke({\n          color: white,\n          width: width + 2\n        })\n      }),\n      new ol.style.Style({\n        stroke: new ol.style.Stroke({\n          color: blue,\n          width: width\n        })\n      })\n    ];\n    styles[ol.geom.GeometryType.MULTI_LINE_STRING] =\n        styles[ol.geom.GeometryType.LINE_STRING];\n  \n    styles[ol.geom.GeometryType.CIRCLE] =\n        styles[ol.geom.GeometryType.POLYGON].concat(\n            styles[ol.geom.GeometryType.LINE_STRING]\n        );\n  \n  \n    styles[ol.geom.GeometryType.POINT] = [\n      new ol.style.Style({\n        image: new ol.style.Circle({\n          radius: width * 2,\n          fill: new ol.style.Fill({\n            color: blue\n          }),\n          stroke: new ol.style.Stroke({\n            color: white,\n            width: width / 2\n          })\n        }),\n        zIndex: Infinity\n      })\n    ];\n    styles[ol.geom.GeometryType.MULTI_POINT] =\n        styles[ol.geom.GeometryType.POINT];\n  \n    styles[ol.geom.GeometryType.GEOMETRY_COLLECTION] =\n        styles[ol.geom.GeometryType.POLYGON].concat(\n            styles[ol.geom.GeometryType.LINE_STRING],\n            styles[ol.geom.GeometryType.POINT]\n        );\n  \n    return styles;\n  };\n  \n  \n  /**\n   * Function that is called with a feature and returns its default geometry.\n   * @param {ol.Feature|ol.render.Feature} feature Feature to get the geometry\n   *     for.\n   * @return {ol.geom.Geometry|ol.render.Feature|undefined} Geometry to render.\n   */\n  ol.style.Style.defaultGeometryFunction = function(feature) {\n    return feature.getGeometry();\n  };\n  \n  goog.provide('ol.Feature');\n  \n  goog.require('ol.asserts');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol');\n  goog.require('ol.Object');\n  goog.require('ol.geom.Geometry');\n  goog.require('ol.style.Style');\n  \n  \n  /**\n   * @classdesc\n   * A vector object for geographic features with a geometry and other\n   * attribute properties, similar to the features in vector file formats like\n   * GeoJSON.\n   *\n   * Features can be styled individually with `setStyle`; otherwise they use the\n   * style of their vector layer.\n   *\n   * Note that attribute properties are set as {@link ol.Object} properties on\n   * the feature object, so they are observable, and have get/set accessors.\n   *\n   * Typically, a feature has a single geometry property. You can set the\n   * geometry using the `setGeometry` method and get it with `getGeometry`.\n   * It is possible to store more than one geometry on a feature using attribute\n   * properties. By default, the geometry used for rendering is identified by\n   * the property name `geometry`. If you want to use another geometry property\n   * for rendering, use the `setGeometryName` method to change the attribute\n   * property associated with the geometry for the feature.  For example:\n   *\n   * ```js\n   * var feature = new ol.Feature({\n   *   geometry: new ol.geom.Polygon(polyCoords),\n   *   labelPoint: new ol.geom.Point(labelCoords),\n   *   name: 'My Polygon'\n   * });\n   *\n   * // get the polygon geometry\n   * var poly = feature.getGeometry();\n   *\n   * // Render the feature as a point using the coordinates from labelPoint\n   * feature.setGeometryName('labelPoint');\n   *\n   * // get the point geometry\n   * var point = feature.getGeometry();\n   * ```\n   *\n   * @constructor\n   * @extends {ol.Object}\n   * @param {ol.geom.Geometry|Object.<string, *>=} opt_geometryOrProperties\n   *     You may pass a Geometry object directly, or an object literal\n   *     containing properties.  If you pass an object literal, you may\n   *     include a Geometry associated with a `geometry` key.\n   * @api\n   */\n  ol.Feature = function(opt_geometryOrProperties) {\n  \n    ol.Object.call(this);\n  \n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = undefined;\n  \n    /**\n     * @type {string}\n     * @private\n     */\n    this.geometryName_ = 'geometry';\n  \n    /**\n     * User provided style.\n     * @private\n     * @type {ol.style.Style|Array.<ol.style.Style>|\n     *     ol.FeatureStyleFunction}\n     */\n    this.style_ = null;\n  \n    /**\n     * @private\n     * @type {ol.FeatureStyleFunction|undefined}\n     */\n    this.styleFunction_ = undefined;\n  \n    /**\n     * @private\n     * @type {?ol.EventsKey}\n     */\n    this.geometryChangeKey_ = null;\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(this.geometryName_),\n        this.handleGeometryChanged_, this);\n  \n    if (opt_geometryOrProperties !== undefined) {\n      if (opt_geometryOrProperties instanceof ol.geom.Geometry ||\n          !opt_geometryOrProperties) {\n        var geometry = opt_geometryOrProperties;\n        this.setGeometry(geometry);\n      } else {\n        /** @type {Object.<string, *>} */\n        var properties = opt_geometryOrProperties;\n        this.setProperties(properties);\n      }\n    }\n  };\n  ol.inherits(ol.Feature, ol.Object);\n  \n  \n  /**\n   * Clone this feature. If the original feature has a geometry it\n   * is also cloned. The feature id is not set in the clone.\n   * @return {ol.Feature} The clone.\n   * @api\n   */\n  ol.Feature.prototype.clone = function() {\n    var clone = new ol.Feature(this.getProperties());\n    clone.setGeometryName(this.getGeometryName());\n    var geometry = this.getGeometry();\n    if (geometry) {\n      clone.setGeometry(geometry.clone());\n    }\n    var style = this.getStyle();\n    if (style) {\n      clone.setStyle(style);\n    }\n    return clone;\n  };\n  \n  \n  /**\n   * Get the feature's default geometry.  A feature may have any number of named\n   * geometries.  The \"default\" geometry (the one that is rendered by default) is\n   * set when calling {@link ol.Feature#setGeometry}.\n   * @return {ol.geom.Geometry|undefined} The default geometry for the feature.\n   * @api\n   * @observable\n   */\n  ol.Feature.prototype.getGeometry = function() {\n    return /** @type {ol.geom.Geometry|undefined} */ (\n      this.get(this.geometryName_));\n  };\n  \n  \n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is either set when reading data from a remote source or set explicitly by\n   * calling {@link ol.Feature#setId}.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  ol.Feature.prototype.getId = function() {\n    return this.id_;\n  };\n  \n  \n  /**\n   * Get the name of the feature's default geometry.  By default, the default\n   * geometry is named `geometry`.\n   * @return {string} Get the property name associated with the default geometry\n   *     for this feature.\n   * @api\n   */\n  ol.Feature.prototype.getGeometryName = function() {\n    return this.geometryName_;\n  };\n  \n  \n  /**\n   * Get the feature's style. Will return what was provided to the\n   * {@link ol.Feature#setStyle} method.\n   * @return {ol.style.Style|Array.<ol.style.Style>|\n   *     ol.FeatureStyleFunction|ol.StyleFunction} The feature style.\n   * @api\n   */\n  ol.Feature.prototype.getStyle = function() {\n    return this.style_;\n  };\n  \n  \n  /**\n   * Get the feature's style function.\n   * @return {ol.FeatureStyleFunction|undefined} Return a function\n   * representing the current style of this feature.\n   * @api\n   */\n  ol.Feature.prototype.getStyleFunction = function() {\n    return this.styleFunction_;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.Feature.prototype.handleGeometryChange_ = function() {\n    this.changed();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.Feature.prototype.handleGeometryChanged_ = function() {\n    if (this.geometryChangeKey_) {\n      ol.events.unlistenByKey(this.geometryChangeKey_);\n      this.geometryChangeKey_ = null;\n    }\n    var geometry = this.getGeometry();\n    if (geometry) {\n      this.geometryChangeKey_ = ol.events.listen(geometry,\n          ol.events.EventType.CHANGE, this.handleGeometryChange_, this);\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the default geometry for the feature.  This will update the property\n   * with the name returned by {@link ol.Feature#getGeometryName}.\n   * @param {ol.geom.Geometry|undefined} geometry The new geometry.\n   * @api\n   * @observable\n   */\n  ol.Feature.prototype.setGeometry = function(geometry) {\n    this.set(this.geometryName_, geometry);\n  };\n  \n  \n  /**\n   * Set the style for the feature.  This can be a single style object, an array\n   * of styles, or a function that takes a resolution and returns an array of\n   * styles. If it is `null` the feature has no style (a `null` style).\n   * @param {ol.style.Style|Array.<ol.style.Style>|\n   *     ol.FeatureStyleFunction|ol.StyleFunction} style Style for this feature.\n   * @api\n   * @fires ol.events.Event#event:change\n   */\n  ol.Feature.prototype.setStyle = function(style) {\n    this.style_ = style;\n    this.styleFunction_ = !style ?\n      undefined : ol.Feature.createStyleFunction(style);\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the feature id.  The feature id is considered stable and may be used when\n   * requesting features or comparing identifiers returned from a remote source.\n   * The feature id can be used with the {@link ol.source.Vector#getFeatureById}\n   * method.\n   * @param {number|string|undefined} id The feature id.\n   * @api\n   * @fires ol.events.Event#event:change\n   */\n  ol.Feature.prototype.setId = function(id) {\n    this.id_ = id;\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the property name to be used when getting the feature's default geometry.\n   * When calling {@link ol.Feature#getGeometry}, the value of the property with\n   * this name will be returned.\n   * @param {string} name The property name of the default geometry.\n   * @api\n   */\n  ol.Feature.prototype.setGeometryName = function(name) {\n    ol.events.unlisten(\n        this, ol.Object.getChangeEventType(this.geometryName_),\n        this.handleGeometryChanged_, this);\n    this.geometryName_ = name;\n    ol.events.listen(\n        this, ol.Object.getChangeEventType(this.geometryName_),\n        this.handleGeometryChanged_, this);\n    this.handleGeometryChanged_();\n  };\n  \n  \n  /**\n   * Convert the provided object into a feature style function.  Functions passed\n   * through unchanged.  Arrays of ol.style.Style or single style objects wrapped\n   * in a new feature style function.\n   * @param {ol.FeatureStyleFunction|!Array.<ol.style.Style>|!ol.style.Style} obj\n   *     A feature style function, a single style, or an array of styles.\n   * @return {ol.FeatureStyleFunction} A style function.\n   */\n  ol.Feature.createStyleFunction = function(obj) {\n    var styleFunction;\n  \n    if (typeof obj === 'function') {\n      if (obj.length == 2) {\n        styleFunction = function(resolution) {\n          return /** @type {ol.StyleFunction} */ (obj)(this, resolution);\n        };\n      } else {\n        styleFunction = obj;\n      }\n    } else {\n      /**\n       * @type {Array.<ol.style.Style>}\n       */\n      var styles;\n      if (Array.isArray(obj)) {\n        styles = obj;\n      } else {\n        ol.asserts.assert(obj instanceof ol.style.Style,\n            41); // Expected an `ol.style.Style` or an array of `ol.style.Style`\n        styles = [obj];\n      }\n      styleFunction = function() {\n        return styles;\n      };\n    }\n    return styleFunction;\n  };\n  \n  goog.provide('ol.format.FormatType');\n  \n  \n  /**\n   * @enum {string}\n   */\n  ol.format.FormatType = {\n    ARRAY_BUFFER: 'arraybuffer',\n    JSON: 'json',\n    TEXT: 'text',\n    XML: 'xml'\n  };\n  \n  goog.provide('ol.xml');\n  \n  goog.require('ol.array');\n  \n  \n  /**\n   * This document should be used when creating nodes for XML serializations. This\n   * document is also used by {@link ol.xml.createElementNS} and\n   * {@link ol.xml.setAttributeNS}\n   * @const\n   * @type {Document}\n   */\n  ol.xml.DOCUMENT = document.implementation.createDocument('', '', null);\n  \n  \n  /**\n   * @param {string} namespaceURI Namespace URI.\n   * @param {string} qualifiedName Qualified name.\n   * @return {Node} Node.\n   */\n  ol.xml.createElementNS = function(namespaceURI, qualifiedName) {\n    return ol.xml.DOCUMENT.createElementNS(namespaceURI, qualifiedName);\n  };\n  \n  \n  /**\n   * Recursively grab all text content of child nodes into a single string.\n   * @param {Node} node Node.\n   * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n   * breaks.\n   * @return {string} All text content.\n   * @api\n   */\n  ol.xml.getAllTextContent = function(node, normalizeWhitespace) {\n    return ol.xml.getAllTextContent_(node, normalizeWhitespace, []).join('');\n  };\n  \n  \n  /**\n   * Recursively grab all text content of child nodes into a single string.\n   * @param {Node} node Node.\n   * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n   * breaks.\n   * @param {Array.<string>} accumulator Accumulator.\n   * @private\n   * @return {Array.<string>} Accumulator.\n   */\n  ol.xml.getAllTextContent_ = function(node, normalizeWhitespace, accumulator) {\n    if (node.nodeType == Node.CDATA_SECTION_NODE ||\n        node.nodeType == Node.TEXT_NODE) {\n      if (normalizeWhitespace) {\n        accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n      } else {\n        accumulator.push(node.nodeValue);\n      }\n    } else {\n      var n;\n      for (n = node.firstChild; n; n = n.nextSibling) {\n        ol.xml.getAllTextContent_(n, normalizeWhitespace, accumulator);\n      }\n    }\n    return accumulator;\n  };\n  \n  \n  /**\n   * @param {?} value Value.\n   * @return {boolean} Is document.\n   */\n  ol.xml.isDocument = function(value) {\n    return value instanceof Document;\n  };\n  \n  \n  /**\n   * @param {?} value Value.\n   * @return {boolean} Is node.\n   */\n  ol.xml.isNode = function(value) {\n    return value instanceof Node;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {?string} namespaceURI Namespace URI.\n   * @param {string} name Attribute name.\n   * @return {string} Value\n   */\n  ol.xml.getAttributeNS = function(node, namespaceURI, name) {\n    return node.getAttributeNS(namespaceURI, name) || '';\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {?string} namespaceURI Namespace URI.\n   * @param {string} name Attribute name.\n   * @param {string|number} value Value.\n   */\n  ol.xml.setAttributeNS = function(node, namespaceURI, name, value) {\n    node.setAttributeNS(namespaceURI, name, value);\n  };\n  \n  \n  /**\n   * Parse an XML string to an XML Document.\n   * @param {string} xml XML.\n   * @return {Document} Document.\n   * @api\n   */\n  ol.xml.parse = function(xml) {\n    return new DOMParser().parseFromString(xml, 'application/xml');\n  };\n  \n  \n  /**\n   * Make an array extender function for extending the array at the top of the\n   * object stack.\n   * @param {function(this: T, Node, Array.<*>): (Array.<*>|undefined)}\n   *     valueReader Value reader.\n   * @param {T=} opt_this The object to use as `this` in `valueReader`.\n   * @return {ol.XmlParser} Parser.\n   * @template T\n   */\n  ol.xml.makeArrayExtender = function(valueReader, opt_this) {\n    return (\n      /**\n       * @param {Node} node Node.\n       * @param {Array.<*>} objectStack Object stack.\n       */\n      function(node, objectStack) {\n        var value = valueReader.call(opt_this, node, objectStack);\n        if (value !== undefined) {\n          var array = /** @type {Array.<*>} */\n                (objectStack[objectStack.length - 1]);\n          ol.array.extend(array, value);\n        }\n      });\n  };\n  \n  \n  /**\n   * Make an array pusher function for pushing to the array at the top of the\n   * object stack.\n   * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.\n   * @param {T=} opt_this The object to use as `this` in `valueReader`.\n   * @return {ol.XmlParser} Parser.\n   * @template T\n   */\n  ol.xml.makeArrayPusher = function(valueReader, opt_this) {\n    return (\n      /**\n       * @param {Node} node Node.\n       * @param {Array.<*>} objectStack Object stack.\n       */\n      function(node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this,\n            node, objectStack);\n        if (value !== undefined) {\n          var array = objectStack[objectStack.length - 1];\n          array.push(value);\n        }\n      });\n  };\n  \n  \n  /**\n   * Make an object stack replacer function for replacing the object at the\n   * top of the stack.\n   * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.\n   * @param {T=} opt_this The object to use as `this` in `valueReader`.\n   * @return {ol.XmlParser} Parser.\n   * @template T\n   */\n  ol.xml.makeReplacer = function(valueReader, opt_this) {\n    return (\n      /**\n       * @param {Node} node Node.\n       * @param {Array.<*>} objectStack Object stack.\n       */\n      function(node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this,\n            node, objectStack);\n        if (value !== undefined) {\n          objectStack[objectStack.length - 1] = value;\n        }\n      });\n  };\n  \n  \n  /**\n   * Make an object property pusher function for adding a property to the\n   * object at the top of the stack.\n   * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.\n   * @param {string=} opt_property Property.\n   * @param {T=} opt_this The object to use as `this` in `valueReader`.\n   * @return {ol.XmlParser} Parser.\n   * @template T\n   */\n  ol.xml.makeObjectPropertyPusher = function(valueReader, opt_property, opt_this) {\n    return (\n      /**\n       * @param {Node} node Node.\n       * @param {Array.<*>} objectStack Object stack.\n       */\n      function(node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this,\n            node, objectStack);\n        if (value !== undefined) {\n          var object = /** @type {Object} */\n                (objectStack[objectStack.length - 1]);\n          var property = opt_property !== undefined ?\n            opt_property : node.localName;\n          var array;\n          if (property in object) {\n            array = object[property];\n          } else {\n            array = object[property] = [];\n          }\n          array.push(value);\n        }\n      });\n  };\n  \n  \n  /**\n   * Make an object property setter function.\n   * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.\n   * @param {string=} opt_property Property.\n   * @param {T=} opt_this The object to use as `this` in `valueReader`.\n   * @return {ol.XmlParser} Parser.\n   * @template T\n   */\n  ol.xml.makeObjectPropertySetter = function(valueReader, opt_property, opt_this) {\n    return (\n      /**\n       * @param {Node} node Node.\n       * @param {Array.<*>} objectStack Object stack.\n       */\n      function(node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this,\n            node, objectStack);\n        if (value !== undefined) {\n          var object = /** @type {Object} */\n                (objectStack[objectStack.length - 1]);\n          var property = opt_property !== undefined ?\n            opt_property : node.localName;\n          object[property] = value;\n        }\n      });\n  };\n  \n  \n  /**\n   * Create a serializer that appends nodes written by its `nodeWriter` to its\n   * designated parent. The parent is the `node` of the\n   * {@link ol.XmlNodeStackItem} at the top of the `objectStack`.\n   * @param {function(this: T, Node, V, Array.<*>)}\n   *     nodeWriter Node writer.\n   * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\n   * @return {ol.XmlSerializer} Serializer.\n   * @template T, V\n   */\n  ol.xml.makeChildAppender = function(nodeWriter, opt_this) {\n    return function(node, value, objectStack) {\n      nodeWriter.call(opt_this !== undefined ? opt_this : this,\n          node, value, objectStack);\n      var parent = objectStack[objectStack.length - 1];\n      var parentNode = parent.node;\n      parentNode.appendChild(node);\n    };\n  };\n  \n  \n  /**\n   * Create a serializer that calls the provided `nodeWriter` from\n   * {@link ol.xml.serialize}. This can be used by the parent writer to have the\n   * 'nodeWriter' called with an array of values when the `nodeWriter` was\n   * designed to serialize a single item. An example would be a LineString\n   * geometry writer, which could be reused for writing MultiLineString\n   * geometries.\n   * @param {function(this: T, Node, V, Array.<*>)}\n   *     nodeWriter Node writer.\n   * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\n   * @return {ol.XmlSerializer} Serializer.\n   * @template T, V\n   */\n  ol.xml.makeArraySerializer = function(nodeWriter, opt_this) {\n    var serializersNS, nodeFactory;\n    return function(node, value, objectStack) {\n      if (serializersNS === undefined) {\n        serializersNS = {};\n        var serializers = {};\n        serializers[node.localName] = nodeWriter;\n        serializersNS[node.namespaceURI] = serializers;\n        nodeFactory = ol.xml.makeSimpleNodeFactory(node.localName);\n      }\n      ol.xml.serialize(serializersNS, nodeFactory, value, objectStack);\n    };\n  };\n  \n  \n  /**\n   * Create a node factory which can use the `opt_keys` passed to\n   * {@link ol.xml.serialize} or {@link ol.xml.pushSerializeAndPop} as node names,\n   * or a fixed node name. The namespace of the created nodes can either be fixed,\n   * or the parent namespace will be used.\n   * @param {string=} opt_nodeName Fixed node name which will be used for all\n   *     created nodes. If not provided, the 3rd argument to the resulting node\n   *     factory needs to be provided and will be the nodeName.\n   * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for\n   *     all created nodes. If not provided, the namespace of the parent node will\n   *     be used.\n   * @return {function(*, Array.<*>, string=): (Node|undefined)} Node factory.\n   */\n  ol.xml.makeSimpleNodeFactory = function(opt_nodeName, opt_namespaceURI) {\n    var fixedNodeName = opt_nodeName;\n    return (\n      /**\n       * @param {*} value Value.\n       * @param {Array.<*>} objectStack Object stack.\n       * @param {string=} opt_nodeName Node name.\n       * @return {Node} Node.\n       */\n      function(value, objectStack, opt_nodeName) {\n        var context = objectStack[objectStack.length - 1];\n        var node = context.node;\n        var nodeName = fixedNodeName;\n        if (nodeName === undefined) {\n          nodeName = opt_nodeName;\n        }\n        var namespaceURI = opt_namespaceURI;\n        if (opt_namespaceURI === undefined) {\n          namespaceURI = node.namespaceURI;\n        }\n        return ol.xml.createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n      }\n    );\n  };\n  \n  \n  /**\n   * A node factory that creates a node using the parent's `namespaceURI` and the\n   * `nodeName` passed by {@link ol.xml.serialize} or\n   * {@link ol.xml.pushSerializeAndPop} to the node factory.\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   */\n  ol.xml.OBJECT_PROPERTY_NODE_FACTORY = ol.xml.makeSimpleNodeFactory();\n  \n  \n  /**\n   * Create an array of `values` to be used with {@link ol.xml.serialize} or\n   * {@link ol.xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n   * `opt_key` argument.\n   * @param {Object.<string, V>} object Key-value pairs for the sequence. Keys can\n   *     be a subset of the `orderedKeys`.\n   * @param {Array.<string>} orderedKeys Keys in the order of the sequence.\n   * @return {Array.<V>} Values in the order of the sequence. The resulting array\n   *     has the same length as the `orderedKeys` array. Values that are not\n   *     present in `object` will be `undefined` in the resulting array.\n   * @template V\n   */\n  ol.xml.makeSequence = function(object, orderedKeys) {\n    var length = orderedKeys.length;\n    var sequence = new Array(length);\n    for (var i = 0; i < length; ++i) {\n      sequence[i] = object[orderedKeys[i]];\n    }\n    return sequence;\n  };\n  \n  \n  /**\n   * Create a namespaced structure, using the same values for each namespace.\n   * This can be used as a starting point for versioned parsers, when only a few\n   * values are version specific.\n   * @param {Array.<string>} namespaceURIs Namespace URIs.\n   * @param {T} structure Structure.\n   * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.\n   * @return {Object.<string, T>} Namespaced structure.\n   * @template T\n   */\n  ol.xml.makeStructureNS = function(namespaceURIs, structure, opt_structureNS) {\n    /**\n     * @type {Object.<string, *>}\n     */\n    var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n    var i, ii;\n    for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n      structureNS[namespaceURIs[i]] = structure;\n    }\n    return structureNS;\n  };\n  \n  \n  /**\n   * Parse a node using the parsers and object stack.\n   * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS\n   *     Parsers by namespace.\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {*=} opt_this The object to use as `this`.\n   */\n  ol.xml.parseNode = function(parsersNS, node, objectStack, opt_this) {\n    var n;\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n      var parsers = parsersNS[n.namespaceURI];\n      if (parsers !== undefined) {\n        var parser = parsers[n.localName];\n        if (parser !== undefined) {\n          parser.call(opt_this, n, objectStack);\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * Push an object on top of the stack, parse and return the popped object.\n   * @param {T} object Object.\n   * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS\n   *     Parsers by namespace.\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {*=} opt_this The object to use as `this`.\n   * @return {T} Object.\n   * @template T\n   */\n  ol.xml.pushParseAndPop = function(\n      object, parsersNS, node, objectStack, opt_this) {\n    objectStack.push(object);\n    ol.xml.parseNode(parsersNS, node, objectStack, opt_this);\n    return objectStack.pop();\n  };\n  \n  \n  /**\n   * Walk through an array of `values` and call a serializer for each value.\n   * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS\n   *     Namespaced serializers.\n   * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory\n   *     Node factory. The `nodeFactory` creates the node whose namespace and name\n   *     will be used to choose a node writer from `serializersNS`. This\n   *     separation allows us to decide what kind of node to create, depending on\n   *     the value we want to serialize. An example for this would be different\n   *     geometry writers based on the geometry type.\n   * @param {Array.<*>} values Values to serialize. An example would be an array\n   *     of {@link ol.Feature} instances.\n   * @param {Array.<*>} objectStack Node stack.\n   * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the\n   *     `nodeFactory`. This is used for serializing object literals where the\n   *     node name relates to the property key. The array length of `opt_keys` has\n   *     to match the length of `values`. For serializing a sequence, `opt_keys`\n   *     determines the order of the sequence.\n   * @param {T=} opt_this The object to use as `this` for the node factory and\n   *     serializers.\n   * @template T\n   */\n  ol.xml.serialize = function(\n      serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n    var length = (opt_keys !== undefined ? opt_keys : values).length;\n    var value, node;\n    for (var i = 0; i < length; ++i) {\n      value = values[i];\n      if (value !== undefined) {\n        node = nodeFactory.call(opt_this, value, objectStack,\n            opt_keys !== undefined ? opt_keys[i] : undefined);\n        if (node !== undefined) {\n          serializersNS[node.namespaceURI][node.localName]\n              .call(opt_this, node, value, objectStack);\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {O} object Object.\n   * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS\n   *     Namespaced serializers.\n   * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory\n   *     Node factory. The `nodeFactory` creates the node whose namespace and name\n   *     will be used to choose a node writer from `serializersNS`. This\n   *     separation allows us to decide what kind of node to create, depending on\n   *     the value we want to serialize. An example for this would be different\n   *     geometry writers based on the geometry type.\n   * @param {Array.<*>} values Values to serialize. An example would be an array\n   *     of {@link ol.Feature} instances.\n   * @param {Array.<*>} objectStack Node stack.\n   * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the\n   *     `nodeFactory`. This is used for serializing object literals where the\n   *     node name relates to the property key. The array length of `opt_keys` has\n   *     to match the length of `values`. For serializing a sequence, `opt_keys`\n   *     determines the order of the sequence.\n   * @param {T=} opt_this The object to use as `this` for the node factory and\n   *     serializers.\n   * @return {O|undefined} Object.\n   * @template O, T\n   */\n  ol.xml.pushSerializeAndPop = function(object,\n      serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n    objectStack.push(object);\n    ol.xml.serialize(\n        serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\n    return objectStack.pop();\n  };\n  \n  goog.provide('ol.featureloader');\n  \n  goog.require('ol');\n  goog.require('ol.format.FormatType');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @param {string|ol.FeatureUrlFunction} url Feature URL service.\n   * @param {ol.format.Feature} format Feature format.\n   * @param {function(this:ol.VectorTile, Array.<ol.Feature>, ol.proj.Projection, ol.Extent)|function(this:ol.source.Vector, Array.<ol.Feature>)} success\n   *     Function called with the loaded features and optionally with the data\n   *     projection. Called with the vector tile or source as `this`.\n   * @param {function(this:ol.VectorTile)|function(this:ol.source.Vector)} failure\n   *     Function called when loading failed. Called with the vector tile or\n   *     source as `this`.\n   * @return {ol.FeatureLoader} The feature loader.\n   */\n  ol.featureloader.loadFeaturesXhr = function(url, format, success, failure) {\n    return (\n      /**\n       * @param {ol.Extent} extent Extent.\n       * @param {number} resolution Resolution.\n       * @param {ol.proj.Projection} projection Projection.\n       * @this {ol.source.Vector|ol.VectorTile}\n       */\n      function(extent, resolution, projection) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET',\n            typeof url === 'function' ? url(extent, resolution, projection) : url,\n            true);\n        if (format.getType() == ol.format.FormatType.ARRAY_BUFFER) {\n          xhr.responseType = 'arraybuffer';\n        }\n        /**\n         * @param {Event} event Event.\n         * @private\n         */\n        xhr.onload = function(event) {\n          // status will be 0 for file:// urls\n          if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {\n            var type = format.getType();\n            /** @type {Document|Node|Object|string|undefined} */\n            var source;\n            if (type == ol.format.FormatType.JSON ||\n                  type == ol.format.FormatType.TEXT) {\n              source = xhr.responseText;\n            } else if (type == ol.format.FormatType.XML) {\n              source = xhr.responseXML;\n              if (!source) {\n                source = ol.xml.parse(xhr.responseText);\n              }\n            } else if (type == ol.format.FormatType.ARRAY_BUFFER) {\n              source = /** @type {ArrayBuffer} */ (xhr.response);\n            }\n            if (source) {\n              success.call(this, format.readFeatures(source,\n                  {featureProjection: projection}),\n              format.readProjection(source), format.getLastExtent());\n            } else {\n              failure.call(this);\n            }\n          } else {\n            failure.call(this);\n          }\n        }.bind(this);\n        /**\n         * @private\n         */\n        xhr.onerror = function() {\n          failure.call(this);\n        }.bind(this);\n        xhr.send();\n      });\n  };\n  \n  \n  /**\n   * Create an XHR feature loader for a `url` and `format`. The feature loader\n   * loads features (with XHR), parses the features, and adds them to the\n   * vector source.\n   * @param {string|ol.FeatureUrlFunction} url Feature URL service.\n   * @param {ol.format.Feature} format Feature format.\n   * @return {ol.FeatureLoader} The feature loader.\n   * @api\n   */\n  ol.featureloader.xhr = function(url, format) {\n    return ol.featureloader.loadFeaturesXhr(url, format,\n        /**\n         * @param {Array.<ol.Feature>} features The loaded features.\n         * @param {ol.proj.Projection} dataProjection Data projection.\n         * @this {ol.source.Vector}\n         */\n        function(features, dataProjection) {\n          this.addFeatures(features);\n        }, /* FIXME handle error */ ol.nullFunction);\n  };\n  \n  goog.provide('ol.format.Feature');\n  \n  goog.require('ol.geom.Geometry');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Base class for feature formats.\n   * {ol.format.Feature} subclasses provide the ability to decode and encode\n   * {@link ol.Feature} objects from a variety of commonly used geospatial\n   * file formats.  See the documentation for each format for more details.\n   *\n   * @constructor\n   * @abstract\n   * @api\n   */\n  ol.format.Feature = function() {\n  \n    /**\n     * @protected\n     * @type {ol.proj.Projection}\n     */\n    this.defaultDataProjection = null;\n  \n    /**\n     * @protected\n     * @type {ol.proj.Projection}\n     */\n    this.defaultFeatureProjection = null;\n  \n  };\n  \n  \n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @return {olx.format.ReadOptions|undefined} Options.\n   * @protected\n   */\n  ol.format.Feature.prototype.getReadOptions = function(source, opt_options) {\n    var options;\n    if (opt_options) {\n      options = {\n        dataProjection: opt_options.dataProjection ?\n          opt_options.dataProjection : this.readProjection(source),\n        featureProjection: opt_options.featureProjection\n      };\n    }\n    return this.adaptOptions(options);\n  };\n  \n  \n  /**\n   * Sets the `defaultDataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {olx.format.WriteOptions|olx.format.ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {olx.format.WriteOptions|olx.format.ReadOptions|undefined}\n   *     Updated options.\n   */\n  ol.format.Feature.prototype.adaptOptions = function(options) {\n    return ol.obj.assign({\n      dataProjection: this.defaultDataProjection,\n      featureProjection: this.defaultFeatureProjection\n    }, options);\n  };\n  \n  \n  /**\n   * Get the extent from the source of the last {@link readFeatures} call.\n   * @return {ol.Extent} Tile extent.\n   */\n  ol.format.Feature.prototype.getLastExtent = function() {\n    return null;\n  };\n  \n  \n  /**\n   * @abstract\n   * @return {ol.format.FormatType} Format.\n   */\n  ol.format.Feature.prototype.getType = function() {};\n  \n  \n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   */\n  ol.format.Feature.prototype.readFeature = function(source, opt_options) {};\n  \n  \n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Node|ArrayBuffer|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   */\n  ol.format.Feature.prototype.readFeatures = function(source, opt_options) {};\n  \n  \n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.geom.Geometry} Geometry.\n   */\n  ol.format.Feature.prototype.readGeometry = function(source, opt_options) {};\n  \n  \n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.proj.Projection} Projection.\n   */\n  ol.format.Feature.prototype.readProjection = function(source) {};\n  \n  \n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {ol.Feature} feature Feature.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} Result.\n   */\n  ol.format.Feature.prototype.writeFeature = function(feature, opt_options) {};\n  \n  \n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} Result.\n   */\n  ol.format.Feature.prototype.writeFeatures = function(features, opt_options) {};\n  \n  \n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} Result.\n   */\n  ol.format.Feature.prototype.writeGeometry = function(geometry, opt_options) {};\n  \n  \n  /**\n   * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.\n   * @param {boolean} write Set to true for writing, false for reading.\n   * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options\n   *     Options.\n   * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.\n   * @protected\n   */\n  ol.format.Feature.transformWithOptions = function(\n      geometry, write, opt_options) {\n    var featureProjection = opt_options ?\n      ol.proj.get(opt_options.featureProjection) : null;\n    var dataProjection = opt_options ?\n      ol.proj.get(opt_options.dataProjection) : null;\n    /**\n     * @type {ol.geom.Geometry|ol.Extent}\n     */\n    var transformed;\n    if (featureProjection && dataProjection &&\n        !ol.proj.equivalent(featureProjection, dataProjection)) {\n      if (geometry instanceof ol.geom.Geometry) {\n        transformed = (write ? geometry.clone() : geometry).transform(\n            write ? featureProjection : dataProjection,\n            write ? dataProjection : featureProjection);\n      } else {\n        // FIXME this is necessary because ol.format.GML treats extents\n        // as geometries\n        transformed = ol.proj.transformExtent(\n            geometry,\n            dataProjection,\n            featureProjection);\n      }\n    } else {\n      transformed = geometry;\n    }\n    if (write && opt_options && opt_options.decimals !== undefined) {\n      var power = Math.pow(10, opt_options.decimals);\n      // if decimals option on write, round each coordinate appropriately\n      /**\n       * @param {Array.<number>} coordinates Coordinates.\n       * @return {Array.<number>} Transformed coordinates.\n       */\n      var transform = function(coordinates) {\n        for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n          coordinates[i] = Math.round(coordinates[i] * power) / power;\n        }\n        return coordinates;\n      };\n      if (transformed === geometry) {\n        transformed = transformed.clone();\n      }\n      transformed.applyTransform(transform);\n    }\n    return transformed;\n  };\n  \n  goog.provide('ol.format.JSONFeature');\n  \n  goog.require('ol');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.FormatType');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Base class for JSON feature formats.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.format.Feature}\n   */\n  ol.format.JSONFeature = function() {\n    ol.format.Feature.call(this);\n  };\n  ol.inherits(ol.format.JSONFeature, ol.format.Feature);\n  \n  \n  /**\n   * @param {Document|Node|Object|string} source Source.\n   * @private\n   * @return {Object} Object.\n   */\n  ol.format.JSONFeature.prototype.getObject_ = function(source) {\n    if (typeof source === 'string') {\n      var object = JSON.parse(source);\n      return object ? /** @type {Object} */ (object) : null;\n    } else if (source !== null) {\n      return source;\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.JSONFeature.prototype.getType = function() {\n    return ol.format.FormatType.JSON;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.JSONFeature.prototype.readFeature = function(source, opt_options) {\n    return this.readFeatureFromObject(\n        this.getObject_(source), this.getReadOptions(source, opt_options));\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.JSONFeature.prototype.readFeatures = function(source, opt_options) {\n    return this.readFeaturesFromObject(\n        this.getObject_(source), this.getReadOptions(source, opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {ol.Feature} Feature.\n   */\n  ol.format.JSONFeature.prototype.readFeatureFromObject = function(object, opt_options) {};\n  \n  \n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {Array.<ol.Feature>} Features.\n   */\n  ol.format.JSONFeature.prototype.readFeaturesFromObject = function(object, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.JSONFeature.prototype.readGeometry = function(source, opt_options) {\n    return this.readGeometryFromObject(\n        this.getObject_(source), this.getReadOptions(source, opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {ol.geom.Geometry} Geometry.\n   */\n  ol.format.JSONFeature.prototype.readGeometryFromObject = function(object, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.JSONFeature.prototype.readProjection = function(source) {\n    return this.readProjectionFromObject(this.getObject_(source));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {ol.proj.Projection} Projection.\n   */\n  ol.format.JSONFeature.prototype.readProjectionFromObject = function(object) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.JSONFeature.prototype.writeFeature = function(feature, opt_options) {\n    return JSON.stringify(this.writeFeatureObject(feature, opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {ol.Feature} feature Feature.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {Object} Object.\n   */\n  ol.format.JSONFeature.prototype.writeFeatureObject = function(feature, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.JSONFeature.prototype.writeFeatures = function(features, opt_options) {\n    return JSON.stringify(this.writeFeaturesObject(features, opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {Object} Object.\n   */\n  ol.format.JSONFeature.prototype.writeFeaturesObject = function(features, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.JSONFeature.prototype.writeGeometry = function(geometry, opt_options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {Object} Object.\n   */\n  ol.format.JSONFeature.prototype.writeGeometryObject = function(geometry, opt_options) {};\n  \n  goog.provide('ol.geom.flat.interpolate');\n  \n  goog.require('ol.array');\n  goog.require('ol.math');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} fraction Fraction.\n   * @param {Array.<number>=} opt_dest Destination.\n   * @return {Array.<number>} Destination.\n   */\n  ol.geom.flat.interpolate.lineString = function(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n    var pointX = NaN;\n    var pointY = NaN;\n    var n = (end - offset) / stride;\n    if (n === 1) {\n      pointX = flatCoordinates[offset];\n      pointY = flatCoordinates[offset + 1];\n    } else if (n == 2) {\n      pointX = (1 - fraction) * flatCoordinates[offset] +\n          fraction * flatCoordinates[offset + stride];\n      pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n          fraction * flatCoordinates[offset + stride + 1];\n    } else if (n !== 0) {\n      var x1 = flatCoordinates[offset];\n      var y1 = flatCoordinates[offset + 1];\n      var length = 0;\n      var cumulativeLengths = [0];\n      var i;\n      for (i = offset + stride; i < end; i += stride) {\n        var x2 = flatCoordinates[i];\n        var y2 = flatCoordinates[i + 1];\n        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n        cumulativeLengths.push(length);\n        x1 = x2;\n        y1 = y2;\n      }\n      var target = fraction * length;\n      var index = ol.array.binarySearch(cumulativeLengths, target);\n      if (index < 0) {\n        var t = (target - cumulativeLengths[-index - 2]) /\n            (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n        var o = offset + (-index - 2) * stride;\n        pointX = ol.math.lerp(\n            flatCoordinates[o], flatCoordinates[o + stride], t);\n        pointY = ol.math.lerp(\n            flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n      } else {\n        pointX = flatCoordinates[offset + index * stride];\n        pointY = flatCoordinates[offset + index * stride + 1];\n      }\n    }\n    if (opt_dest) {\n      opt_dest[0] = pointX;\n      opt_dest[1] = pointY;\n      return opt_dest;\n    } else {\n      return [pointX, pointY];\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {number} m M.\n   * @param {boolean} extrapolate Extrapolate.\n   * @return {ol.Coordinate} Coordinate.\n   */\n  ol.geom.flat.interpolate.lineStringCoordinateAtM = function(flatCoordinates, offset, end, stride, m, extrapolate) {\n    if (end == offset) {\n      return null;\n    }\n    var coordinate;\n    if (m < flatCoordinates[offset + stride - 1]) {\n      if (extrapolate) {\n        coordinate = flatCoordinates.slice(offset, offset + stride);\n        coordinate[stride - 1] = m;\n        return coordinate;\n      } else {\n        return null;\n      }\n    } else if (flatCoordinates[end - 1] < m) {\n      if (extrapolate) {\n        coordinate = flatCoordinates.slice(end - stride, end);\n        coordinate[stride - 1] = m;\n        return coordinate;\n      } else {\n        return null;\n      }\n    }\n    // FIXME use O(1) search\n    if (m == flatCoordinates[offset + stride - 1]) {\n      return flatCoordinates.slice(offset, offset + stride);\n    }\n    var lo = offset / stride;\n    var hi = end / stride;\n    while (lo < hi) {\n      var mid = (lo + hi) >> 1;\n      if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    var m0 = flatCoordinates[lo * stride - 1];\n    if (m == m0) {\n      return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n    }\n    var m1 = flatCoordinates[(lo + 1) * stride - 1];\n    var t = (m - m0) / (m1 - m0);\n    coordinate = [];\n    var i;\n    for (i = 0; i < stride - 1; ++i) {\n      coordinate.push(ol.math.lerp(flatCoordinates[(lo - 1) * stride + i],\n          flatCoordinates[lo * stride + i], t));\n    }\n    coordinate.push(m);\n    return coordinate;\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {number} m M.\n   * @param {boolean} extrapolate Extrapolate.\n   * @param {boolean} interpolate Interpolate.\n   * @return {ol.Coordinate} Coordinate.\n   */\n  ol.geom.flat.interpolate.lineStringsCoordinateAtM = function(\n      flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n    if (interpolate) {\n      return ol.geom.flat.interpolate.lineStringCoordinateAtM(\n          flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n    }\n    var coordinate;\n    if (m < flatCoordinates[stride - 1]) {\n      if (extrapolate) {\n        coordinate = flatCoordinates.slice(0, stride);\n        coordinate[stride - 1] = m;\n        return coordinate;\n      } else {\n        return null;\n      }\n    }\n    if (flatCoordinates[flatCoordinates.length - 1] < m) {\n      if (extrapolate) {\n        coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n        coordinate[stride - 1] = m;\n        return coordinate;\n      } else {\n        return null;\n      }\n    }\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      if (offset == end) {\n        continue;\n      }\n      if (m < flatCoordinates[offset + stride - 1]) {\n        return null;\n      } else if (m <= flatCoordinates[end - 1]) {\n        return ol.geom.flat.interpolate.lineStringCoordinateAtM(\n            flatCoordinates, offset, end, stride, m, false);\n      }\n      offset = end;\n    }\n    return null;\n  };\n  \n  goog.provide('ol.geom.LineString');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.closest');\n  goog.require('ol.geom.flat.deflate');\n  goog.require('ol.geom.flat.inflate');\n  goog.require('ol.geom.flat.interpolate');\n  goog.require('ol.geom.flat.intersectsextent');\n  goog.require('ol.geom.flat.length');\n  goog.require('ol.geom.flat.segments');\n  goog.require('ol.geom.flat.simplify');\n  \n  \n  /**\n   * @classdesc\n   * Linestring geometry.\n   *\n   * @constructor\n   * @extends {ol.geom.SimpleGeometry}\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.LineString = function(coordinates, opt_layout) {\n  \n    ol.geom.SimpleGeometry.call(this);\n  \n    /**\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.flatMidpoint_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n  \n    this.setCoordinates(coordinates, opt_layout);\n  \n  };\n  ol.inherits(ol.geom.LineString, ol.geom.SimpleGeometry);\n  \n  \n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @api\n   */\n  ol.geom.LineString.prototype.appendCoordinate = function(coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      ol.array.extend(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.LineString} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.LineString.prototype.clone = function() {\n    var lineString = new ol.geom.LineString(null);\n    lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n    return lineString;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.LineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance <\n        ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getMaxSquaredDelta(\n          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return ol.geom.flat.closest.getClosestPoint(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n        this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n  \n  \n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function\n   *     called for each segment.\n   * @param {S=} opt_this The object to be used as the value of 'this'\n   *     within callback.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  ol.geom.LineString.prototype.forEachSegment = function(callback, opt_this) {\n    return ol.geom.flat.segments.forEach(this.flatCoordinates, 0,\n        this.flatCoordinates.length, this.stride, callback, opt_this);\n  };\n  \n  \n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @return {ol.Coordinate} Coordinate.\n   * @api\n   */\n  ol.geom.LineString.prototype.getCoordinateAtM = function(m, opt_extrapolate) {\n    if (this.layout != ol.geom.GeometryLayout.XYM &&\n        this.layout != ol.geom.GeometryLayout.XYZM) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    return ol.geom.flat.interpolate.lineStringCoordinateAtM(this.flatCoordinates, 0,\n        this.flatCoordinates.length, this.stride, m, extrapolate);\n  };\n  \n  \n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array.<ol.Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  ol.geom.LineString.prototype.getCoordinates = function() {\n    return ol.geom.flat.inflate.coordinates(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  \n  \n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {ol.Coordinate=} opt_dest Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {ol.Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  ol.geom.LineString.prototype.getCoordinateAt = function(fraction, opt_dest) {\n    return ol.geom.flat.interpolate.lineString(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n        fraction, opt_dest);\n  };\n  \n  \n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  ol.geom.LineString.prototype.getLength = function() {\n    return ol.geom.flat.length.lineString(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat midpoint.\n   */\n  ol.geom.LineString.prototype.getFlatMidpoint = function() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.LineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = ol.geom.flat.simplify.douglasPeucker(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n        squaredTolerance, simplifiedFlatCoordinates, 0);\n    var simplifiedLineString = new ol.geom.LineString(null);\n    simplifiedLineString.setFlatCoordinates(\n        ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates);\n    return simplifiedLineString;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.LineString.prototype.getType = function() {\n    return ol.geom.GeometryType.LINE_STRING;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.LineString.prototype.intersectsExtent = function(extent) {\n    return ol.geom.flat.intersectsextent.lineString(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n        extent);\n  };\n  \n  \n  /**\n   * Set the coordinates of the linestring.\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  ol.geom.LineString.prototype.setCoordinates = function(coordinates, opt_layout) {\n    if (!coordinates) {\n      this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);\n    } else {\n      this.setLayout(opt_layout, coordinates, 1);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      this.flatCoordinates.length = ol.geom.flat.deflate.coordinates(\n          this.flatCoordinates, 0, coordinates, this.stride);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   */\n  ol.geom.LineString.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n    this.setFlatCoordinatesInternal(layout, flatCoordinates);\n    this.changed();\n  };\n  \n  goog.provide('ol.geom.MultiLineString');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.closest');\n  goog.require('ol.geom.flat.deflate');\n  goog.require('ol.geom.flat.inflate');\n  goog.require('ol.geom.flat.interpolate');\n  goog.require('ol.geom.flat.intersectsextent');\n  goog.require('ol.geom.flat.simplify');\n  \n  \n  /**\n   * @classdesc\n   * Multi-linestring geometry.\n   *\n   * @constructor\n   * @extends {ol.geom.SimpleGeometry}\n   * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.MultiLineString = function(coordinates, opt_layout) {\n  \n    ol.geom.SimpleGeometry.call(this);\n  \n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n    this.ends_ = [];\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n  \n    this.setCoordinates(coordinates, opt_layout);\n  \n  };\n  ol.inherits(ol.geom.MultiLineString, ol.geom.SimpleGeometry);\n  \n  \n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {ol.geom.LineString} lineString LineString.\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.appendLineString = function(lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      ol.array.extend(\n          this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.MultiLineString} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.clone = function() {\n    var multiLineString = new ol.geom.MultiLineString(null);\n    multiLineString.setFlatCoordinates(\n        this.layout, this.flatCoordinates.slice(), this.ends_.slice());\n    return multiLineString;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.MultiLineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance <\n        ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getsMaxSquaredDelta(\n          this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return ol.geom.flat.closest.getsClosestPoint(\n        this.flatCoordinates, 0, this.ends_, this.stride,\n        this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n  \n  \n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n   * @return {ol.Coordinate} Coordinate.\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.getCoordinateAtM = function(m, opt_extrapolate, opt_interpolate) {\n    if ((this.layout != ol.geom.GeometryLayout.XYM &&\n         this.layout != ol.geom.GeometryLayout.XYZM) ||\n        this.flatCoordinates.length === 0) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return ol.geom.flat.interpolate.lineStringsCoordinateAtM(this.flatCoordinates, 0,\n        this.ends_, this.stride, m, extrapolate, interpolate);\n  };\n  \n  \n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array.<Array.<ol.Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.getCoordinates = function() {\n    return ol.geom.flat.inflate.coordinatess(\n        this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Ends.\n   */\n  ol.geom.MultiLineString.prototype.getEnds = function() {\n    return this.ends_;\n  };\n  \n  \n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {ol.geom.LineString} LineString.\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.getLineString = function(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    var lineString = new ol.geom.LineString(null);\n    lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));\n    return lineString;\n  };\n  \n  \n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array.<ol.geom.LineString>} LineStrings.\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.getLineStrings = function() {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    /** @type {Array.<ol.geom.LineString>} */\n    var lineStrings = [];\n    var offset = 0;\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var lineString = new ol.geom.LineString(null);\n      lineString.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat midpoints.\n   */\n  ol.geom.MultiLineString.prototype.getFlatMidpoints = function() {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n    var i, ii;\n    for (i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var midpoint = ol.geom.flat.interpolate.lineString(\n          flatCoordinates, offset, end, stride, 0.5);\n      ol.array.extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.MultiLineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = ol.geom.flat.simplify.douglasPeuckers(\n        this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,\n        simplifiedFlatCoordinates, 0, simplifiedEnds);\n    var simplifiedMultiLineString = new ol.geom.MultiLineString(null);\n    simplifiedMultiLineString.setFlatCoordinates(\n        ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEnds);\n    return simplifiedMultiLineString;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.getType = function() {\n    return ol.geom.GeometryType.MULTI_LINE_STRING;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.intersectsExtent = function(extent) {\n    return ol.geom.flat.intersectsextent.lineStrings(\n        this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  };\n  \n  \n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  ol.geom.MultiLineString.prototype.setCoordinates = function(coordinates, opt_layout) {\n    if (!coordinates) {\n      this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null, this.ends_);\n    } else {\n      this.setLayout(opt_layout, coordinates, 2);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      var ends = ol.geom.flat.deflate.coordinatess(\n          this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n      this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {Array.<number>} ends Ends.\n   */\n  ol.geom.MultiLineString.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {\n    this.setFlatCoordinatesInternal(layout, flatCoordinates);\n    this.ends_ = ends;\n    this.changed();\n  };\n  \n  \n  /**\n   * @param {Array.<ol.geom.LineString>} lineStrings LineStrings.\n   */\n  ol.geom.MultiLineString.prototype.setLineStrings = function(lineStrings) {\n    var layout = this.getLayout();\n    var flatCoordinates = [];\n    var ends = [];\n    var i, ii;\n    for (i = 0, ii = lineStrings.length; i < ii; ++i) {\n      var lineString = lineStrings[i];\n      if (i === 0) {\n        layout = lineString.getLayout();\n      }\n      ol.array.extend(flatCoordinates, lineString.getFlatCoordinates());\n      ends.push(flatCoordinates.length);\n    }\n    this.setFlatCoordinates(layout, flatCoordinates, ends);\n  };\n  \n  goog.provide('ol.geom.MultiPoint');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.deflate');\n  goog.require('ol.geom.flat.inflate');\n  goog.require('ol.math');\n  \n  \n  /**\n   * @classdesc\n   * Multi-point geometry.\n   *\n   * @constructor\n   * @extends {ol.geom.SimpleGeometry}\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.MultiPoint = function(coordinates, opt_layout) {\n    ol.geom.SimpleGeometry.call(this);\n    this.setCoordinates(coordinates, opt_layout);\n  };\n  ol.inherits(ol.geom.MultiPoint, ol.geom.SimpleGeometry);\n  \n  \n  /**\n   * Append the passed point to this multipoint.\n   * @param {ol.geom.Point} point Point.\n   * @api\n   */\n  ol.geom.MultiPoint.prototype.appendPoint = function(point) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = point.getFlatCoordinates().slice();\n    } else {\n      ol.array.extend(this.flatCoordinates, point.getFlatCoordinates());\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.MultiPoint} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.MultiPoint.prototype.clone = function() {\n    var multiPoint = new ol.geom.MultiPoint(null);\n    multiPoint.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n    return multiPoint;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.MultiPoint.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance <\n        ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    var i, ii, j;\n    for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var squaredDistance = ol.math.squaredDistance(\n          x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  };\n  \n  \n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array.<ol.Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  ol.geom.MultiPoint.prototype.getCoordinates = function() {\n    return ol.geom.flat.inflate.coordinates(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  \n  \n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {ol.geom.Point} Point.\n   * @api\n   */\n  ol.geom.MultiPoint.prototype.getPoint = function(index) {\n    var n = !this.flatCoordinates ?\n      0 : this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    var point = new ol.geom.Point(null);\n    point.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\n        index * this.stride, (index + 1) * this.stride));\n    return point;\n  };\n  \n  \n  /**\n   * Return the points of this multipoint.\n   * @return {Array.<ol.geom.Point>} Points.\n   * @api\n   */\n  ol.geom.MultiPoint.prototype.getPoints = function() {\n    var flatCoordinates = this.flatCoordinates;\n    var layout = this.layout;\n    var stride = this.stride;\n    /** @type {Array.<ol.geom.Point>} */\n    var points = [];\n    var i, ii;\n    for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var point = new ol.geom.Point(null);\n      point.setFlatCoordinates(layout, flatCoordinates.slice(i, i + stride));\n      points.push(point);\n    }\n    return points;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.MultiPoint.prototype.getType = function() {\n    return ol.geom.GeometryType.MULTI_POINT;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.MultiPoint.prototype.intersectsExtent = function(extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    var i, ii, x, y;\n    for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      x = flatCoordinates[i];\n      y = flatCoordinates[i + 1];\n      if (ol.extent.containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  \n  \n  /**\n   * Set the coordinates of the multipoint.\n   * @param {Array.<ol.Coordinate>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  ol.geom.MultiPoint.prototype.setCoordinates = function(coordinates, opt_layout) {\n    if (!coordinates) {\n      this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);\n    } else {\n      this.setLayout(opt_layout, coordinates, 1);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      this.flatCoordinates.length = ol.geom.flat.deflate.coordinates(\n          this.flatCoordinates, 0, coordinates, this.stride);\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   */\n  ol.geom.MultiPoint.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n    this.setFlatCoordinatesInternal(layout, flatCoordinates);\n    this.changed();\n  };\n  \n  goog.provide('ol.geom.flat.center');\n  \n  goog.require('ol.extent');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<Array.<number>>} endss Endss.\n   * @param {number} stride Stride.\n   * @return {Array.<number>} Flat centers.\n   */\n  ol.geom.flat.center.linearRingss = function(flatCoordinates, offset, endss, stride) {\n    var flatCenters = [];\n    var i, ii;\n    var extent = ol.extent.createEmpty();\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      extent = ol.extent.createOrUpdateFromFlatCoordinates(\n          flatCoordinates, offset, ends[0], stride);\n      flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n      offset = ends[ends.length - 1];\n    }\n    return flatCenters;\n  };\n  \n  goog.provide('ol.geom.MultiPolygon');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.area');\n  goog.require('ol.geom.flat.center');\n  goog.require('ol.geom.flat.closest');\n  goog.require('ol.geom.flat.contains');\n  goog.require('ol.geom.flat.deflate');\n  goog.require('ol.geom.flat.inflate');\n  goog.require('ol.geom.flat.interiorpoint');\n  goog.require('ol.geom.flat.intersectsextent');\n  goog.require('ol.geom.flat.orient');\n  goog.require('ol.geom.flat.simplify');\n  \n  \n  /**\n   * @classdesc\n   * Multi-polygon geometry.\n   *\n   * @constructor\n   * @extends {ol.geom.SimpleGeometry}\n   * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.MultiPolygon = function(coordinates, opt_layout) {\n  \n    ol.geom.SimpleGeometry.call(this);\n  \n    /**\n     * @type {Array.<Array.<number>>}\n     * @private\n     */\n    this.endss_ = [];\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.flatInteriorPoints_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n  \n    this.setCoordinates(coordinates, opt_layout);\n  \n  };\n  ol.inherits(ol.geom.MultiPolygon, ol.geom.SimpleGeometry);\n  \n  \n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {ol.geom.Polygon} polygon Polygon.\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.appendPolygon = function(polygon) {\n    /** @type {Array.<number>} */\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      ol.array.extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      var i, ii;\n      for (i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.MultiPolygon} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.clone = function() {\n    var multiPolygon = new ol.geom.MultiPolygon(null);\n  \n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n  \n    multiPolygon.setFlatCoordinates(\n        this.layout, this.flatCoordinates.slice(), newEndss);\n    return multiPolygon;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.MultiPolygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance <\n        ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getssMaxSquaredDelta(\n          this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return ol.geom.flat.closest.getssClosestPoint(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n        this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.MultiPolygon.prototype.containsXY = function(x, y) {\n    return ol.geom.flat.contains.linearRingssContainsXY(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n  \n  \n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.getArea = function() {\n    return ol.geom.flat.area.linearRingss(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n  \n  \n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinates.\n   * @override\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.getCoordinates = function(opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      ol.geom.flat.orient.orientLinearRingss(\n          flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n  \n    return ol.geom.flat.inflate.coordinatesss(\n        flatCoordinates, 0, this.endss_, this.stride);\n  };\n  \n  \n  /**\n   * @return {Array.<Array.<number>>} Endss.\n   */\n  ol.geom.MultiPolygon.prototype.getEndss = function() {\n    return this.endss_;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat interior points.\n   */\n  ol.geom.MultiPolygon.prototype.getFlatInteriorPoints = function() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = ol.geom.flat.center.linearRingss(\n          this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = ol.geom.flat.interiorpoint.linearRingss(\n          this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n          flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n  \n  \n  /**\n   * Return the interior points as {@link ol.geom.MultiPoint multipoint}.\n   * @return {ol.geom.MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.getInteriorPoints = function() {\n    var interiorPoints = new ol.geom.MultiPoint(null);\n    interiorPoints.setFlatCoordinates(ol.geom.GeometryLayout.XYM,\n        this.getFlatInteriorPoints().slice());\n    return interiorPoints;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Oriented flat coordinates.\n   */\n  ol.geom.MultiPolygon.prototype.getOrientedFlatCoordinates = function() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (ol.geom.flat.orient.linearRingssAreOriented(\n          flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            ol.geom.flat.orient.orientLinearRingss(\n                this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.MultiPolygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = ol.geom.flat.simplify.quantizess(\n        this.flatCoordinates, 0, this.endss_, this.stride,\n        Math.sqrt(squaredTolerance),\n        simplifiedFlatCoordinates, 0, simplifiedEndss);\n    var simplifiedMultiPolygon = new ol.geom.MultiPolygon(null);\n    simplifiedMultiPolygon.setFlatCoordinates(\n        ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEndss);\n    return simplifiedMultiPolygon;\n  };\n  \n  \n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {ol.geom.Polygon} Polygon.\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.getPolygon = function(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    var offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      var i, ii;\n      for (i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    var polygon = new ol.geom.Polygon(null);\n    polygon.setFlatCoordinates(\n        this.layout, this.flatCoordinates.slice(offset, end), ends);\n    return polygon;\n  };\n  \n  \n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array.<ol.geom.Polygon>} Polygons.\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.getPolygons = function() {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n    var i, ii, j, jj;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      var polygon = new ol.geom.Polygon(null);\n      polygon.setFlatCoordinates(\n          layout, flatCoordinates.slice(offset, end), ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.getType = function() {\n    return ol.geom.GeometryType.MULTI_POLYGON;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.intersectsExtent = function(extent) {\n    return ol.geom.flat.intersectsextent.linearRingss(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n  \n  \n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  ol.geom.MultiPolygon.prototype.setCoordinates = function(coordinates, opt_layout) {\n    if (!coordinates) {\n      this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null, this.endss_);\n    } else {\n      this.setLayout(opt_layout, coordinates, 3);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      var endss = ol.geom.flat.deflate.coordinatesss(\n          this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n      if (endss.length === 0) {\n        this.flatCoordinates.length = 0;\n      } else {\n        var lastEnds = endss[endss.length - 1];\n        this.flatCoordinates.length = lastEnds.length === 0 ?\n          0 : lastEnds[lastEnds.length - 1];\n      }\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {Array.<Array.<number>>} endss Endss.\n   */\n  ol.geom.MultiPolygon.prototype.setFlatCoordinates = function(layout, flatCoordinates, endss) {\n    this.setFlatCoordinatesInternal(layout, flatCoordinates);\n    this.endss_ = endss;\n    this.changed();\n  };\n  \n  \n  /**\n   * @param {Array.<ol.geom.Polygon>} polygons Polygons.\n   */\n  ol.geom.MultiPolygon.prototype.setPolygons = function(polygons) {\n    var layout = this.getLayout();\n    var flatCoordinates = [];\n    var endss = [];\n    var i, ii, ends;\n    for (i = 0, ii = polygons.length; i < ii; ++i) {\n      var polygon = polygons[i];\n      if (i === 0) {\n        layout = polygon.getLayout();\n      }\n      var offset = flatCoordinates.length;\n      ends = polygon.getEnds();\n      var j, jj;\n      for (j = 0, jj = ends.length; j < jj; ++j) {\n        ends[j] += offset;\n      }\n      ol.array.extend(flatCoordinates, polygon.getFlatCoordinates());\n      endss.push(ends);\n    }\n    this.setFlatCoordinates(layout, flatCoordinates, endss);\n  };\n  \n  goog.provide('ol.format.EsriJSON');\n  \n  goog.require('ol');\n  goog.require('ol.Feature');\n  goog.require('ol.asserts');\n  goog.require('ol.extent');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.JSONFeature');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.LinearRing');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.geom.flat.deflate');\n  goog.require('ol.geom.flat.orient');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the EsriJSON format.\n   *\n   * @constructor\n   * @extends {ol.format.JSONFeature}\n   * @param {olx.format.EsriJSONOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.EsriJSON = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.format.JSONFeature.call(this);\n  \n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n  \n  };\n  ol.inherits(ol.format.EsriJSON, ol.format.JSONFeature);\n  \n  \n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @private\n   * @return {ol.geom.Geometry} Geometry.\n   */\n  ol.format.EsriJSON.readGeometry_ = function(object, opt_options) {\n    if (!object) {\n      return null;\n    }\n    /** @type {ol.geom.GeometryType} */\n    var type;\n    if (typeof object.x === 'number' && typeof object.y === 'number') {\n      type = ol.geom.GeometryType.POINT;\n    } else if (object.points) {\n      type = ol.geom.GeometryType.MULTI_POINT;\n    } else if (object.paths) {\n      if (object.paths.length === 1) {\n        type = ol.geom.GeometryType.LINE_STRING;\n      } else {\n        type = ol.geom.GeometryType.MULTI_LINE_STRING;\n      }\n    } else if (object.rings) {\n      var layout = ol.format.EsriJSON.getGeometryLayout_(object);\n      var rings = ol.format.EsriJSON.convertRings_(object.rings, layout);\n      object = /** @type {EsriJSONGeometry} */(ol.obj.assign({}, object));\n      if (rings.length === 1) {\n        type = ol.geom.GeometryType.POLYGON;\n        object.rings = rings[0];\n      } else {\n        type = ol.geom.GeometryType.MULTI_POLYGON;\n        object.rings = rings;\n      }\n    }\n    var geometryReader = ol.format.EsriJSON.GEOMETRY_READERS_[type];\n    return /** @type {ol.geom.Geometry} */ (\n      ol.format.Feature.transformWithOptions(\n          geometryReader(object), false, opt_options));\n  };\n  \n  \n  /**\n   * Determines inner and outer rings.\n   * Checks if any polygons in this array contain any other polygons in this\n   * array. It is used for checking for holes.\n   * Logic inspired by: https://github.com/Esri/terraformer-arcgis-parser\n   * @param {Array.<!Array.<!Array.<number>>>} rings Rings.\n   * @param {ol.geom.GeometryLayout} layout Geometry layout.\n   * @private\n   * @return {Array.<!Array.<!Array.<number>>>} Transformed rings.\n   */\n  ol.format.EsriJSON.convertRings_ = function(rings, layout) {\n    var flatRing = [];\n    var outerRings = [];\n    var holes = [];\n    var i, ii;\n    for (i = 0, ii = rings.length; i < ii; ++i) {\n      flatRing.length = 0;\n      ol.geom.flat.deflate.coordinates(flatRing, 0, rings[i], layout.length);\n      // is this ring an outer ring? is it clockwise?\n      var clockwise = ol.geom.flat.orient.linearRingIsClockwise(flatRing, 0,\n          flatRing.length, layout.length);\n      if (clockwise) {\n        outerRings.push([rings[i]]);\n      } else {\n        holes.push(rings[i]);\n      }\n    }\n    while (holes.length) {\n      var hole = holes.shift();\n      var matched = false;\n      // loop over all outer rings and see if they contain our hole.\n      for (i = outerRings.length - 1; i >= 0; i--) {\n        var outerRing = outerRings[i][0];\n        var containsHole = ol.extent.containsExtent(\n            new ol.geom.LinearRing(outerRing).getExtent(),\n            new ol.geom.LinearRing(hole).getExtent()\n        );\n        if (containsHole) {\n          // the hole is contained push it into our polygon\n          outerRings[i].push(hole);\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        // no outer rings contain this hole turn it into and outer\n        // ring (reverse it)\n        outerRings.push([hole.reverse()]);\n      }\n    }\n    return outerRings;\n  };\n  \n  \n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.Geometry} Point.\n   */\n  ol.format.EsriJSON.readPointGeometry_ = function(object) {\n    var point;\n    if (object.m !== undefined && object.z !== undefined) {\n      point = new ol.geom.Point([object.x, object.y, object.z, object.m],\n          ol.geom.GeometryLayout.XYZM);\n    } else if (object.z !== undefined) {\n      point = new ol.geom.Point([object.x, object.y, object.z],\n          ol.geom.GeometryLayout.XYZ);\n    } else if (object.m !== undefined) {\n      point = new ol.geom.Point([object.x, object.y, object.m],\n          ol.geom.GeometryLayout.XYM);\n    } else {\n      point = new ol.geom.Point([object.x, object.y]);\n    }\n    return point;\n  };\n  \n  \n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.Geometry} LineString.\n   */\n  ol.format.EsriJSON.readLineStringGeometry_ = function(object) {\n    var layout = ol.format.EsriJSON.getGeometryLayout_(object);\n    return new ol.geom.LineString(object.paths[0], layout);\n  };\n  \n  \n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.Geometry} MultiLineString.\n   */\n  ol.format.EsriJSON.readMultiLineStringGeometry_ = function(object) {\n    var layout = ol.format.EsriJSON.getGeometryLayout_(object);\n    return new ol.geom.MultiLineString(object.paths, layout);\n  };\n  \n  \n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.GeometryLayout} The geometry layout to use.\n   */\n  ol.format.EsriJSON.getGeometryLayout_ = function(object) {\n    var layout = ol.geom.GeometryLayout.XY;\n    if (object.hasZ === true && object.hasM === true) {\n      layout = ol.geom.GeometryLayout.XYZM;\n    } else if (object.hasZ === true) {\n      layout = ol.geom.GeometryLayout.XYZ;\n    } else if (object.hasM === true) {\n      layout = ol.geom.GeometryLayout.XYM;\n    }\n    return layout;\n  };\n  \n  \n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.Geometry} MultiPoint.\n   */\n  ol.format.EsriJSON.readMultiPointGeometry_ = function(object) {\n    var layout = ol.format.EsriJSON.getGeometryLayout_(object);\n    return new ol.geom.MultiPoint(object.points, layout);\n  };\n  \n  \n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.Geometry} MultiPolygon.\n   */\n  ol.format.EsriJSON.readMultiPolygonGeometry_ = function(object) {\n    var layout = ol.format.EsriJSON.getGeometryLayout_(object);\n    return new ol.geom.MultiPolygon(\n        /** @type {Array.<Array.<Array.<Array.<number>>>>} */(object.rings),\n        layout);\n  };\n  \n  \n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.Geometry} Polygon.\n   */\n  ol.format.EsriJSON.readPolygonGeometry_ = function(object) {\n    var layout = ol.format.EsriJSON.getGeometryLayout_(object);\n    return new ol.geom.Polygon(object.rings, layout);\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {EsriJSONGeometry} EsriJSON geometry.\n   */\n  ol.format.EsriJSON.writePointGeometry_ = function(geometry, opt_options) {\n    var coordinates = /** @type {ol.geom.Point} */ (geometry).getCoordinates();\n    var esriJSON;\n    var layout = /** @type {ol.geom.Point} */ (geometry).getLayout();\n    if (layout === ol.geom.GeometryLayout.XYZ) {\n      esriJSON = /** @type {EsriJSONPoint} */ ({\n        x: coordinates[0],\n        y: coordinates[1],\n        z: coordinates[2]\n      });\n    } else if (layout === ol.geom.GeometryLayout.XYM) {\n      esriJSON = /** @type {EsriJSONPoint} */ ({\n        x: coordinates[0],\n        y: coordinates[1],\n        m: coordinates[2]\n      });\n    } else if (layout === ol.geom.GeometryLayout.XYZM) {\n      esriJSON = /** @type {EsriJSONPoint} */ ({\n        x: coordinates[0],\n        y: coordinates[1],\n        z: coordinates[2],\n        m: coordinates[3]\n      });\n    } else if (layout === ol.geom.GeometryLayout.XY) {\n      esriJSON = /** @type {EsriJSONPoint} */ ({\n        x: coordinates[0],\n        y: coordinates[1]\n      });\n    } else {\n      ol.asserts.assert(false, 34); // Invalid geometry layout\n    }\n    return /** @type {EsriJSONGeometry} */ (esriJSON);\n  };\n  \n  \n  /**\n   * @param {ol.geom.SimpleGeometry} geometry Geometry.\n   * @private\n   * @return {Object} Object with boolean hasZ and hasM keys.\n   */\n  ol.format.EsriJSON.getHasZM_ = function(geometry) {\n    var layout = geometry.getLayout();\n    return {\n      hasZ: (layout === ol.geom.GeometryLayout.XYZ ||\n        layout === ol.geom.GeometryLayout.XYZM),\n      hasM: (layout === ol.geom.GeometryLayout.XYM ||\n        layout === ol.geom.GeometryLayout.XYZM)\n    };\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {EsriJSONPolyline} EsriJSON geometry.\n   */\n  ol.format.EsriJSON.writeLineStringGeometry_ = function(geometry, opt_options) {\n    var hasZM = ol.format.EsriJSON.getHasZM_(/** @type {ol.geom.LineString} */(geometry));\n    return /** @type {EsriJSONPolyline} */ ({\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      paths: [\n        /** @type {ol.geom.LineString} */ (geometry).getCoordinates()\n      ]\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {EsriJSONPolygon} EsriJSON geometry.\n   */\n  ol.format.EsriJSON.writePolygonGeometry_ = function(geometry, opt_options) {\n    // Esri geometries use the left-hand rule\n    var hasZM = ol.format.EsriJSON.getHasZM_(/** @type {ol.geom.Polygon} */(geometry));\n    return /** @type {EsriJSONPolygon} */ ({\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      rings: /** @type {ol.geom.Polygon} */ (geometry).getCoordinates(false)\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {EsriJSONPolyline} EsriJSON geometry.\n   */\n  ol.format.EsriJSON.writeMultiLineStringGeometry_ = function(geometry, opt_options) {\n    var hasZM = ol.format.EsriJSON.getHasZM_(/** @type {ol.geom.MultiLineString} */(geometry));\n    return /** @type {EsriJSONPolyline} */ ({\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      paths: /** @type {ol.geom.MultiLineString} */ (geometry).getCoordinates()\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {EsriJSONMultipoint} EsriJSON geometry.\n   */\n  ol.format.EsriJSON.writeMultiPointGeometry_ = function(geometry, opt_options) {\n    var hasZM = ol.format.EsriJSON.getHasZM_(/** @type {ol.geom.MultiPoint} */(geometry));\n    return /** @type {EsriJSONMultipoint} */ ({\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      points: /** @type {ol.geom.MultiPoint} */ (geometry).getCoordinates()\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {EsriJSONPolygon} EsriJSON geometry.\n   */\n  ol.format.EsriJSON.writeMultiPolygonGeometry_ = function(geometry,\n      opt_options) {\n    var hasZM = ol.format.EsriJSON.getHasZM_(/** @type {ol.geom.MultiPolygon} */(geometry));\n    var coordinates = /** @type {ol.geom.MultiPolygon} */ (geometry).getCoordinates(false);\n    var output = [];\n    for (var i = 0; i < coordinates.length; i++) {\n      for (var x = coordinates[i].length - 1; x >= 0; x--) {\n        output.push(coordinates[i][x]);\n      }\n    }\n    return /** @type {EsriJSONPolygon} */ ({\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      rings: output\n    });\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Object.<ol.geom.GeometryType, function(EsriJSONGeometry): ol.geom.Geometry>}\n   */\n  ol.format.EsriJSON.GEOMETRY_READERS_ = {};\n  ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.POINT] =\n    ol.format.EsriJSON.readPointGeometry_;\n  ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.LINE_STRING] =\n    ol.format.EsriJSON.readLineStringGeometry_;\n  ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.POLYGON] =\n    ol.format.EsriJSON.readPolygonGeometry_;\n  ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_POINT] =\n    ol.format.EsriJSON.readMultiPointGeometry_;\n  ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_LINE_STRING] =\n    ol.format.EsriJSON.readMultiLineStringGeometry_;\n  ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_POLYGON] =\n    ol.format.EsriJSON.readMultiPolygonGeometry_;\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Object.<string, function(ol.geom.Geometry, olx.format.WriteOptions=): (EsriJSONGeometry)>}\n   */\n  ol.format.EsriJSON.GEOMETRY_WRITERS_ = {};\n  ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.POINT] =\n    ol.format.EsriJSON.writePointGeometry_;\n  ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.LINE_STRING] =\n    ol.format.EsriJSON.writeLineStringGeometry_;\n  ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.POLYGON] =\n    ol.format.EsriJSON.writePolygonGeometry_;\n  ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_POINT] =\n    ol.format.EsriJSON.writeMultiPointGeometry_;\n  ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_LINE_STRING] =\n    ol.format.EsriJSON.writeMultiLineStringGeometry_;\n  ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_POLYGON] =\n    ol.format.EsriJSON.writeMultiPolygonGeometry_;\n  \n  \n  /**\n   * Read a feature from a EsriJSON Feature source.  Only works for Feature,\n   * use `readFeatures` to read FeatureCollection source.\n   *\n   * @function\n   * @param {ArrayBuffer|Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   * @api\n   */\n  ol.format.EsriJSON.prototype.readFeature;\n  \n  \n  /**\n   * Read all features from a EsriJSON source.  Works with both Feature and\n   * FeatureCollection sources.\n   *\n   * @function\n   * @param {ArrayBuffer|Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.EsriJSON.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.EsriJSON.prototype.readFeatureFromObject = function(\n      object, opt_options) {\n    var esriJSONFeature = /** @type {EsriJSONFeature} */ (object);\n    var geometry = ol.format.EsriJSON.readGeometry_(esriJSONFeature.geometry,\n        opt_options);\n    var feature = new ol.Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    }\n    feature.setGeometry(geometry);\n    if (opt_options && opt_options.idField &&\n      esriJSONFeature.attributes[opt_options.idField]) {\n      feature.setId(/** @type {number} */(\n        esriJSONFeature.attributes[opt_options.idField]));\n    }\n    if (esriJSONFeature.attributes) {\n      feature.setProperties(esriJSONFeature.attributes);\n    }\n    return feature;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.EsriJSON.prototype.readFeaturesFromObject = function(\n      object, opt_options) {\n    var esriJSONObject = /** @type {EsriJSONObject} */ (object);\n    var options = opt_options ? opt_options : {};\n    if (esriJSONObject.features) {\n      var esriJSONFeatureCollection = /** @type {EsriJSONFeatureCollection} */\n        (object);\n      /** @type {Array.<ol.Feature>} */\n      var features = [];\n      var esriJSONFeatures = esriJSONFeatureCollection.features;\n      var i, ii;\n      options.idField = object.objectIdFieldName;\n      for (i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {\n        features.push(this.readFeatureFromObject(esriJSONFeatures[i],\n            options));\n      }\n      return features;\n    } else {\n      return [this.readFeatureFromObject(object, options)];\n    }\n  };\n  \n  \n  /**\n   * Read a geometry from a EsriJSON source.\n   *\n   * @function\n   * @param {ArrayBuffer|Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.geom.Geometry} Geometry.\n   * @api\n   */\n  ol.format.EsriJSON.prototype.readGeometry;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.EsriJSON.prototype.readGeometryFromObject = function(\n      object, opt_options) {\n    return ol.format.EsriJSON.readGeometry_(\n        /** @type {EsriJSONGeometry} */(object), opt_options);\n  };\n  \n  \n  /**\n   * Read the projection from a EsriJSON source.\n   *\n   * @function\n   * @param {ArrayBuffer|Document|Node|Object|string} source Source.\n   * @return {ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.format.EsriJSON.prototype.readProjection;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.EsriJSON.prototype.readProjectionFromObject = function(object) {\n    var esriJSONObject = /** @type {EsriJSONObject} */ (object);\n    if (esriJSONObject.spatialReference && esriJSONObject.spatialReference.wkid) {\n      var crs = esriJSONObject.spatialReference.wkid;\n      return ol.proj.get('EPSG:' + crs);\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {EsriJSONGeometry} EsriJSON geometry.\n   */\n  ol.format.EsriJSON.writeGeometry_ = function(geometry, opt_options) {\n    var geometryWriter = ol.format.EsriJSON.GEOMETRY_WRITERS_[geometry.getType()];\n    return geometryWriter(/** @type {ol.geom.Geometry} */(\n      ol.format.Feature.transformWithOptions(geometry, true, opt_options)),\n    opt_options);\n  };\n  \n  \n  /**\n   * Encode a geometry as a EsriJSON string.\n   *\n   * @function\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} EsriJSON.\n   * @api\n   */\n  ol.format.EsriJSON.prototype.writeGeometry;\n  \n  \n  /**\n   * Encode a geometry as a EsriJSON object.\n   *\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {EsriJSONGeometry} Object.\n   * @override\n   * @api\n   */\n  ol.format.EsriJSON.prototype.writeGeometryObject = function(geometry,\n      opt_options) {\n    return ol.format.EsriJSON.writeGeometry_(geometry,\n        this.adaptOptions(opt_options));\n  };\n  \n  \n  /**\n   * Encode a feature as a EsriJSON Feature string.\n   *\n   * @function\n   * @param {ol.Feature} feature Feature.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} EsriJSON.\n   * @api\n   */\n  ol.format.EsriJSON.prototype.writeFeature;\n  \n  \n  /**\n   * Encode a feature as a esriJSON Feature object.\n   *\n   * @param {ol.Feature} feature Feature.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {Object} Object.\n   * @override\n   * @api\n   */\n  ol.format.EsriJSON.prototype.writeFeatureObject = function(\n      feature, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var object = {};\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      object['geometry'] =\n        ol.format.EsriJSON.writeGeometry_(geometry, opt_options);\n      if (opt_options && opt_options.featureProjection) {\n        object['geometry']['spatialReference'] = /** @type {EsriJSONCRS} */({\n          wkid: ol.proj.get(\n              opt_options.featureProjection).getCode().split(':').pop()\n        });\n      }\n    }\n    var properties = feature.getProperties();\n    delete properties[feature.getGeometryName()];\n    if (!ol.obj.isEmpty(properties)) {\n      object['attributes'] = properties;\n    } else {\n      object['attributes'] = {};\n    }\n    return object;\n  };\n  \n  \n  /**\n   * Encode an array of features as EsriJSON.\n   *\n   * @function\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} EsriJSON.\n   * @api\n   */\n  ol.format.EsriJSON.prototype.writeFeatures;\n  \n  \n  /**\n   * Encode an array of features as a EsriJSON object.\n   *\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {Object} EsriJSON Object.\n   * @override\n   * @api\n   */\n  ol.format.EsriJSON.prototype.writeFeaturesObject = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var objects = [];\n    var i, ii;\n    for (i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], opt_options));\n    }\n    return /** @type {EsriJSONFeatureCollection} */ ({\n      'features': objects\n    });\n  };\n  \n  goog.provide('ol.format.filter.Filter');\n  \n  \n  /**\n   * @classdesc\n   * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n   * Base class for WFS GetFeature filters.\n   *\n   * deprecated: This class will no longer be exported starting from the next major version.\n   *\n   * @constructor\n   * @abstract\n   * @param {!string} tagName The XML tag name for this filter.\n   * @struct\n   * @api\n   */\n  ol.format.filter.Filter = function(tagName) {\n  \n    /**\n     * @private\n     * @type {!string}\n     */\n    this.tagName_ = tagName;\n  };\n  \n  /**\n   * The XML tag name for a filter.\n   * @returns {!string} Name.\n   */\n  ol.format.filter.Filter.prototype.getTagName = function() {\n    return this.tagName_;\n  };\n  \n  goog.provide('ol.format.filter.LogicalNary');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.format.filter.Filter');\n  \n  \n  /**\n   * @classdesc\n   * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n   * Base class for WFS GetFeature n-ary logical filters.\n   *\n   * @constructor\n   * @abstract\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {...ol.format.filter.Filter} conditions Conditions.\n   * @extends {ol.format.filter.Filter}\n   */\n  ol.format.filter.LogicalNary = function(tagName, conditions) {\n  \n    ol.format.filter.Filter.call(this, tagName);\n  \n    /**\n     * @public\n     * @type {Array.<ol.format.filter.Filter>}\n     */\n    this.conditions = Array.prototype.slice.call(arguments, 1);\n    ol.asserts.assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\n  };\n  ol.inherits(ol.format.filter.LogicalNary, ol.format.filter.Filter);\n  \n  goog.provide('ol.format.filter.And');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.LogicalNary');\n  \n  /**\n   * @classdesc\n   * Represents a logical `<And>` operator between two or more filter conditions.\n   *\n   * deprecated: This class will no longer be exported starting from the next major version.\n   *\n   * @constructor\n   * @abstract\n   * @param {...ol.format.filter.Filter} conditions Conditions.\n   * @extends {ol.format.filter.LogicalNary}\n   * @api\n   */\n  ol.format.filter.And = function(conditions) {\n    var params = ['And'].concat(Array.prototype.slice.call(arguments));\n    ol.format.filter.LogicalNary.apply(this, params);\n  };\n  ol.inherits(ol.format.filter.And, ol.format.filter.LogicalNary);\n  \n  goog.provide('ol.format.filter.Bbox');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Filter');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<BBOX>` operator to test whether a geometry-valued property\n   * intersects a fixed bounding box\n   *\n   * @constructor\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.Extent} extent Extent.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @extends {ol.format.filter.Filter}\n   * @api\n   */\n  ol.format.filter.Bbox = function(geometryName, extent, opt_srsName) {\n  \n    ol.format.filter.Filter.call(this, 'BBOX');\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.geometryName = geometryName;\n  \n    /**\n     * @public\n     * @type {ol.Extent}\n     */\n    this.extent = extent;\n  \n    /**\n     * @public\n     * @type {string|undefined}\n     */\n    this.srsName = opt_srsName;\n  };\n  ol.inherits(ol.format.filter.Bbox, ol.format.filter.Filter);\n  \n  goog.provide('ol.format.filter.Spatial');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Filter');\n  \n  \n  /**\n   * @classdesc\n   * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n   * Represents a spatial operator to test whether a geometry-valued property\n   * relates to a given geometry.\n   *\n   * deprecated: This class will no longer be exported starting from the next major version.\n   *\n   * @constructor\n   * @abstract\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.geom.Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @extends {ol.format.filter.Filter}\n   * @api\n   */\n  ol.format.filter.Spatial = function(tagName, geometryName, geometry, opt_srsName) {\n  \n    ol.format.filter.Filter.call(this, tagName);\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.geometryName = geometryName || 'the_geom';\n  \n    /**\n     * @public\n     * @type {ol.geom.Geometry}\n     */\n    this.geometry = geometry;\n  \n    /**\n     * @public\n     * @type {string|undefined}\n     */\n    this.srsName = opt_srsName;\n  };\n  ol.inherits(ol.format.filter.Spatial, ol.format.filter.Filter);\n  \n  goog.provide('ol.format.filter.Contains');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Spatial');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<Contains>` operator to test whether a geometry-valued property\n   * contains a given geometry.\n   *\n   * @constructor\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.geom.Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @extends {ol.format.filter.Spatial}\n   * @api\n   */\n  ol.format.filter.Contains = function(geometryName, geometry, opt_srsName) {\n  \n    ol.format.filter.Spatial.call(this, 'Contains', geometryName, geometry, opt_srsName);\n  \n  };\n  ol.inherits(ol.format.filter.Contains, ol.format.filter.Spatial);\n  \n  goog.provide('ol.format.filter.Comparison');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Filter');\n  \n  \n  /**\n   * @classdesc\n   * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n   * Base class for WFS GetFeature property comparison filters.\n   *\n   * deprecated: This class will no longer be exported starting from the next major version.\n   *\n   * @constructor\n   * @abstract\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   * @extends {ol.format.filter.Filter}\n   * @api\n   */\n  ol.format.filter.Comparison = function(tagName, propertyName) {\n  \n    ol.format.filter.Filter.call(this, tagName);\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.propertyName = propertyName;\n  };\n  ol.inherits(ol.format.filter.Comparison, ol.format.filter.Filter);\n  \n  goog.provide('ol.format.filter.During');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Comparison');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<During>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} begin The begin date in ISO-8601 format.\n   * @param {!string} end The end date in ISO-8601 format.\n   * @extends {ol.format.filter.Comparison}\n   * @api\n   */\n  ol.format.filter.During = function(propertyName, begin, end) {\n    ol.format.filter.Comparison.call(this, 'During', propertyName);\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.begin = begin;\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.end = end;\n  };\n  ol.inherits(ol.format.filter.During, ol.format.filter.Comparison);\n  \n  goog.provide('ol.format.filter.ComparisonBinary');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Comparison');\n  \n  \n  /**\n   * @classdesc\n   * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n   * Base class for WFS GetFeature property binary comparison filters.\n   *\n   * deprecated: This class will no longer be exported starting from the next major version.\n   *\n   * @constructor\n   * @abstract\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @extends {ol.format.filter.Comparison}\n   * @api\n   */\n  ol.format.filter.ComparisonBinary = function(\n      tagName, propertyName, expression, opt_matchCase) {\n  \n    ol.format.filter.Comparison.call(this, tagName, propertyName);\n  \n    /**\n     * @public\n     * @type {!(string|number)}\n     */\n    this.expression = expression;\n  \n    /**\n     * @public\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n  };\n  ol.inherits(ol.format.filter.ComparisonBinary, ol.format.filter.Comparison);\n  \n  goog.provide('ol.format.filter.EqualTo');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.ComparisonBinary');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsEqualTo>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @extends {ol.format.filter.ComparisonBinary}\n   * @api\n   */\n  ol.format.filter.EqualTo = function(propertyName, expression, opt_matchCase) {\n    ol.format.filter.ComparisonBinary.call(this, 'PropertyIsEqualTo', propertyName, expression, opt_matchCase);\n  };\n  ol.inherits(ol.format.filter.EqualTo, ol.format.filter.ComparisonBinary);\n  \n  goog.provide('ol.format.filter.GreaterThan');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.ComparisonBinary');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsGreaterThan>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @extends {ol.format.filter.ComparisonBinary}\n   * @api\n   */\n  ol.format.filter.GreaterThan = function(propertyName, expression) {\n    ol.format.filter.ComparisonBinary.call(this, 'PropertyIsGreaterThan', propertyName, expression);\n  };\n  ol.inherits(ol.format.filter.GreaterThan, ol.format.filter.ComparisonBinary);\n  \n  goog.provide('ol.format.filter.GreaterThanOrEqualTo');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.ComparisonBinary');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @extends {ol.format.filter.ComparisonBinary}\n   * @api\n   */\n  ol.format.filter.GreaterThanOrEqualTo = function(propertyName, expression) {\n    ol.format.filter.ComparisonBinary.call(this, 'PropertyIsGreaterThanOrEqualTo', propertyName, expression);\n  };\n  ol.inherits(ol.format.filter.GreaterThanOrEqualTo, ol.format.filter.ComparisonBinary);\n  \n  goog.provide('ol.format.filter.Intersects');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Spatial');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<Intersects>` operator to test whether a geometry-valued property\n   * intersects a given geometry.\n   *\n   * @constructor\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.geom.Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @extends {ol.format.filter.Spatial}\n   * @api\n   */\n  ol.format.filter.Intersects = function(geometryName, geometry, opt_srsName) {\n  \n    ol.format.filter.Spatial.call(this, 'Intersects', geometryName, geometry, opt_srsName);\n  \n  };\n  ol.inherits(ol.format.filter.Intersects, ol.format.filter.Spatial);\n  \n  goog.provide('ol.format.filter.IsBetween');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Comparison');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsBetween>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} lowerBoundary The lower bound of the range.\n   * @param {!number} upperBoundary The upper bound of the range.\n   * @extends {ol.format.filter.Comparison}\n   * @api\n   */\n  ol.format.filter.IsBetween = function(propertyName, lowerBoundary, upperBoundary) {\n    ol.format.filter.Comparison.call(this, 'PropertyIsBetween', propertyName);\n  \n    /**\n     * @public\n     * @type {!number}\n     */\n    this.lowerBoundary = lowerBoundary;\n  \n    /**\n     * @public\n     * @type {!number}\n     */\n    this.upperBoundary = upperBoundary;\n  };\n  ol.inherits(ol.format.filter.IsBetween, ol.format.filter.Comparison);\n  \n  goog.provide('ol.format.filter.IsLike');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Comparison');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsLike>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} pattern Text pattern.\n   * @param {string=} opt_wildCard Pattern character which matches any sequence of\n   *    zero or more string characters. Default is '*'.\n   * @param {string=} opt_singleChar pattern character which matches any single\n   *    string character. Default is '.'.\n   * @param {string=} opt_escapeChar Escape character which can be used to escape\n   *    the pattern characters. Default is '!'.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @extends {ol.format.filter.Comparison}\n   * @api\n   */\n  ol.format.filter.IsLike = function(propertyName, pattern,\n      opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n    ol.format.filter.Comparison.call(this, 'PropertyIsLike', propertyName);\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.pattern = pattern;\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.wildCard = (opt_wildCard !== undefined) ? opt_wildCard : '*';\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.singleChar = (opt_singleChar !== undefined) ? opt_singleChar : '.';\n  \n    /**\n     * @public\n     * @type {!string}\n     */\n    this.escapeChar = (opt_escapeChar !== undefined) ? opt_escapeChar : '!';\n  \n    /**\n     * @public\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n  };\n  ol.inherits(ol.format.filter.IsLike, ol.format.filter.Comparison);\n  \n  goog.provide('ol.format.filter.IsNull');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Comparison');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsNull>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @extends {ol.format.filter.Comparison}\n   * @api\n   */\n  ol.format.filter.IsNull = function(propertyName) {\n    ol.format.filter.Comparison.call(this, 'PropertyIsNull', propertyName);\n  };\n  ol.inherits(ol.format.filter.IsNull, ol.format.filter.Comparison);\n  \n  goog.provide('ol.format.filter.LessThan');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.ComparisonBinary');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsLessThan>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @extends {ol.format.filter.ComparisonBinary}\n   * @api\n   */\n  ol.format.filter.LessThan = function(propertyName, expression) {\n    ol.format.filter.ComparisonBinary.call(this, 'PropertyIsLessThan', propertyName, expression);\n  };\n  ol.inherits(ol.format.filter.LessThan, ol.format.filter.ComparisonBinary);\n  \n  goog.provide('ol.format.filter.LessThanOrEqualTo');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.ComparisonBinary');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @extends {ol.format.filter.ComparisonBinary}\n   * @api\n   */\n  ol.format.filter.LessThanOrEqualTo = function(propertyName, expression) {\n    ol.format.filter.ComparisonBinary.call(this, 'PropertyIsLessThanOrEqualTo', propertyName, expression);\n  };\n  ol.inherits(ol.format.filter.LessThanOrEqualTo, ol.format.filter.ComparisonBinary);\n  \n  goog.provide('ol.format.filter.Not');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Filter');\n  \n  \n  /**\n   * @classdesc\n   * Represents a logical `<Not>` operator for a filter condition.\n   *\n   * @constructor\n   * @param {!ol.format.filter.Filter} condition Filter condition.\n   * @extends {ol.format.filter.Filter}\n   * @api\n   */\n  ol.format.filter.Not = function(condition) {\n  \n    ol.format.filter.Filter.call(this, 'Not');\n  \n    /**\n     * @public\n     * @type {!ol.format.filter.Filter}\n     */\n    this.condition = condition;\n  };\n  ol.inherits(ol.format.filter.Not, ol.format.filter.Filter);\n  \n  goog.provide('ol.format.filter.NotEqualTo');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.ComparisonBinary');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<PropertyIsNotEqualTo>` comparison operator.\n   *\n   * @constructor\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @extends {ol.format.filter.ComparisonBinary}\n   * @api\n   */\n  ol.format.filter.NotEqualTo = function(propertyName, expression, opt_matchCase) {\n    ol.format.filter.ComparisonBinary.call(this, 'PropertyIsNotEqualTo', propertyName, expression, opt_matchCase);\n  };\n  ol.inherits(ol.format.filter.NotEqualTo, ol.format.filter.ComparisonBinary);\n  \n  goog.provide('ol.format.filter.Or');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.LogicalNary');\n  \n  \n  /**\n   * @classdesc\n   * Represents a logical `<Or>` operator between two ore more filter conditions.\n   *\n   * @constructor\n   * @param {...ol.format.filter.Filter} conditions Conditions.\n   * @extends {ol.format.filter.LogicalNary}\n   * @api\n   */\n  ol.format.filter.Or = function(conditions) {\n    var params = ['Or'].concat(Array.prototype.slice.call(arguments));\n    ol.format.filter.LogicalNary.apply(this, params);\n  };\n  ol.inherits(ol.format.filter.Or, ol.format.filter.LogicalNary);\n  \n  goog.provide('ol.format.filter.Within');\n  \n  goog.require('ol');\n  goog.require('ol.format.filter.Spatial');\n  \n  \n  /**\n   * @classdesc\n   * Represents a `<Within>` operator to test whether a geometry-valued property\n   * is within a given geometry.\n   *\n   * @constructor\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.geom.Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @extends {ol.format.filter.Spatial}\n   * @api\n   */\n  ol.format.filter.Within = function(geometryName, geometry, opt_srsName) {\n  \n    ol.format.filter.Spatial.call(this, 'Within', geometryName, geometry, opt_srsName);\n  \n  };\n  ol.inherits(ol.format.filter.Within, ol.format.filter.Spatial);\n  \n  goog.provide('ol.format.filter');\n  \n  goog.require('ol.format.filter.And');\n  goog.require('ol.format.filter.Bbox');\n  goog.require('ol.format.filter.Contains');\n  goog.require('ol.format.filter.During');\n  goog.require('ol.format.filter.EqualTo');\n  goog.require('ol.format.filter.GreaterThan');\n  goog.require('ol.format.filter.GreaterThanOrEqualTo');\n  goog.require('ol.format.filter.Intersects');\n  goog.require('ol.format.filter.IsBetween');\n  goog.require('ol.format.filter.IsLike');\n  goog.require('ol.format.filter.IsNull');\n  goog.require('ol.format.filter.LessThan');\n  goog.require('ol.format.filter.LessThanOrEqualTo');\n  goog.require('ol.format.filter.Not');\n  goog.require('ol.format.filter.NotEqualTo');\n  goog.require('ol.format.filter.Or');\n  goog.require('ol.format.filter.Within');\n  \n  \n  /**\n   * Create a logical `<And>` operator between two or more filter conditions.\n   *\n   * @param {...ol.format.filter.Filter} conditions Filter conditions.\n   * @returns {!ol.format.filter.And} `<And>` operator.\n   * @api\n   */\n  ol.format.filter.and = function(conditions) {\n    var params = [null].concat(Array.prototype.slice.call(arguments));\n    return new (Function.prototype.bind.apply(ol.format.filter.And, params));\n  };\n  \n  \n  /**\n   * Create a logical `<Or>` operator between two or more filter conditions.\n   *\n   * @param {...ol.format.filter.Filter} conditions Filter conditions.\n   * @returns {!ol.format.filter.Or} `<Or>` operator.\n   * @api\n   */\n  ol.format.filter.or = function(conditions) {\n    var params = [null].concat(Array.prototype.slice.call(arguments));\n    return new (Function.prototype.bind.apply(ol.format.filter.Or, params));\n  };\n  \n  \n  /**\n   * Represents a logical `<Not>` operator for a filter condition.\n   *\n   * @param {!ol.format.filter.Filter} condition Filter condition.\n   * @returns {!ol.format.filter.Not} `<Not>` operator.\n   * @api\n   */\n  ol.format.filter.not = function(condition) {\n    return new ol.format.filter.Not(condition);\n  };\n  \n  \n  /**\n   * Create a `<BBOX>` operator to test whether a geometry-valued property\n   * intersects a fixed bounding box\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.Extent} extent Extent.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @returns {!ol.format.filter.Bbox} `<BBOX>` operator.\n   * @api\n   */\n  ol.format.filter.bbox = function(geometryName, extent, opt_srsName) {\n    return new ol.format.filter.Bbox(geometryName, extent, opt_srsName);\n  };\n  \n  /**\n   * Create a `<Contains>` operator to test whether a geometry-valued property\n   * contains a given geometry.\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.geom.Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @returns {!ol.format.filter.Contains} `<Contains>` operator.\n   * @api\n   */\n  ol.format.filter.contains = function(geometryName, geometry, opt_srsName) {\n    return new ol.format.filter.Contains(geometryName, geometry, opt_srsName);\n  };\n  \n  /**\n   * Create a `<Intersects>` operator to test whether a geometry-valued property\n   * intersects a given geometry.\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.geom.Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @returns {!ol.format.filter.Intersects} `<Intersects>` operator.\n   * @api\n   */\n  ol.format.filter.intersects = function(geometryName, geometry, opt_srsName) {\n    return new ol.format.filter.Intersects(geometryName, geometry, opt_srsName);\n  };\n  \n  /**\n   * Create a `<Within>` operator to test whether a geometry-valued property\n   * is within a given geometry.\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!ol.geom.Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @returns {!ol.format.filter.Within} `<Within>` operator.\n   * @api\n   */\n  ol.format.filter.within = function(geometryName, geometry, opt_srsName) {\n    return new ol.format.filter.Within(geometryName, geometry, opt_srsName);\n  };\n  \n  \n  /**\n   * Creates a `<PropertyIsEqualTo>` comparison operator.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @returns {!ol.format.filter.EqualTo} `<PropertyIsEqualTo>` operator.\n   * @api\n   */\n  ol.format.filter.equalTo = function(propertyName, expression, opt_matchCase) {\n    return new ol.format.filter.EqualTo(propertyName, expression, opt_matchCase);\n  };\n  \n  \n  /**\n   * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @returns {!ol.format.filter.NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n   * @api\n   */\n  ol.format.filter.notEqualTo = function(propertyName, expression, opt_matchCase) {\n    return new ol.format.filter.NotEqualTo(propertyName, expression, opt_matchCase);\n  };\n  \n  \n  /**\n   * Creates a `<PropertyIsLessThan>` comparison operator.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @returns {!ol.format.filter.LessThan} `<PropertyIsLessThan>` operator.\n   * @api\n   */\n  ol.format.filter.lessThan = function(propertyName, expression) {\n    return new ol.format.filter.LessThan(propertyName, expression);\n  };\n  \n  \n  /**\n   * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @returns {!ol.format.filter.LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n   * @api\n   */\n  ol.format.filter.lessThanOrEqualTo = function(propertyName, expression) {\n    return new ol.format.filter.LessThanOrEqualTo(propertyName, expression);\n  };\n  \n  \n  /**\n   * Creates a `<PropertyIsGreaterThan>` comparison operator.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @returns {!ol.format.filter.GreaterThan} `<PropertyIsGreaterThan>` operator.\n   * @api\n   */\n  ol.format.filter.greaterThan = function(propertyName, expression) {\n    return new ol.format.filter.GreaterThan(propertyName, expression);\n  };\n  \n  \n  /**\n   * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @returns {!ol.format.filter.GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n   * @api\n   */\n  ol.format.filter.greaterThanOrEqualTo = function(propertyName, expression) {\n    return new ol.format.filter.GreaterThanOrEqualTo(propertyName, expression);\n  };\n  \n  \n  /**\n   * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n   * is null.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @returns {!ol.format.filter.IsNull} `<PropertyIsNull>` operator.\n   * @api\n   */\n  ol.format.filter.isNull = function(propertyName) {\n    return new ol.format.filter.IsNull(propertyName);\n  };\n  \n  \n  /**\n   * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n   * value lies within a range given by a lower and upper bound (inclusive).\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} lowerBoundary The lower bound of the range.\n   * @param {!number} upperBoundary The upper bound of the range.\n   * @returns {!ol.format.filter.IsBetween} `<PropertyIsBetween>` operator.\n   * @api\n   */\n  ol.format.filter.between = function(propertyName, lowerBoundary, upperBoundary) {\n    return new ol.format.filter.IsBetween(propertyName, lowerBoundary, upperBoundary);\n  };\n  \n  \n  /**\n   * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n   * value against a text pattern.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} pattern Text pattern.\n   * @param {string=} opt_wildCard Pattern character which matches any sequence of\n   *    zero or more string characters. Default is '*'.\n   * @param {string=} opt_singleChar pattern character which matches any single\n   *    string character. Default is '.'.\n   * @param {string=} opt_escapeChar Escape character which can be used to escape\n   *    the pattern characters. Default is '!'.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @returns {!ol.format.filter.IsLike} `<PropertyIsLike>` operator.\n   * @api\n   */\n  ol.format.filter.like = function(propertyName, pattern,\n      opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n    return new ol.format.filter.IsLike(propertyName, pattern,\n        opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);\n  };\n  \n  \n  /**\n   * Create a `<During>` temporal operator.\n   *\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} begin The begin date in ISO-8601 format.\n   * @param {!string} end The end date in ISO-8601 format.\n   * @returns {!ol.format.filter.During} `<During>` operator.\n   * @api\n   */\n  ol.format.filter.during = function(propertyName, begin, end) {\n    return new ol.format.filter.During(propertyName, begin, end);\n  };\n  \n  goog.provide('ol.geom.GeometryCollection');\n  \n  goog.require('ol');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.geom.Geometry');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * @classdesc\n   * An array of {@link ol.geom.Geometry} objects.\n   *\n   * @constructor\n   * @extends {ol.geom.Geometry}\n   * @param {Array.<ol.geom.Geometry>=} opt_geometries Geometries.\n   * @api\n   */\n  ol.geom.GeometryCollection = function(opt_geometries) {\n  \n    ol.geom.Geometry.call(this);\n  \n    /**\n     * @private\n     * @type {Array.<ol.geom.Geometry>}\n     */\n    this.geometries_ = opt_geometries ? opt_geometries : null;\n  \n    this.listenGeometriesChange_();\n  };\n  ol.inherits(ol.geom.GeometryCollection, ol.geom.Geometry);\n  \n  \n  /**\n   * @param {Array.<ol.geom.Geometry>} geometries Geometries.\n   * @private\n   * @return {Array.<ol.geom.Geometry>} Cloned geometries.\n   */\n  ol.geom.GeometryCollection.cloneGeometries_ = function(geometries) {\n    var clonedGeometries = [];\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      clonedGeometries.push(geometries[i].clone());\n    }\n    return clonedGeometries;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.geom.GeometryCollection.prototype.unlistenGeometriesChange_ = function() {\n    var i, ii;\n    if (!this.geometries_) {\n      return;\n    }\n    for (i = 0, ii = this.geometries_.length; i < ii; ++i) {\n      ol.events.unlisten(\n          this.geometries_[i], ol.events.EventType.CHANGE,\n          this.changed, this);\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.geom.GeometryCollection.prototype.listenGeometriesChange_ = function() {\n    var i, ii;\n    if (!this.geometries_) {\n      return;\n    }\n    for (i = 0, ii = this.geometries_.length; i < ii; ++i) {\n      ol.events.listen(\n          this.geometries_[i], ol.events.EventType.CHANGE,\n          this.changed, this);\n    }\n  };\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.GeometryCollection} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.clone = function() {\n    var geometryCollection = new ol.geom.GeometryCollection(null);\n    geometryCollection.setGeometries(this.geometries_);\n    return geometryCollection;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.GeometryCollection.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance <\n        ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    var geometries = this.geometries_;\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(\n          x, y, closestPoint, minSquaredDistance);\n    }\n    return minSquaredDistance;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.GeometryCollection.prototype.containsXY = function(x, y) {\n    var geometries = this.geometries_;\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.GeometryCollection.prototype.computeExtent = function(extent) {\n    ol.extent.createOrUpdateEmpty(extent);\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      ol.extent.extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  };\n  \n  \n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array.<ol.geom.Geometry>} Geometries.\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.getGeometries = function() {\n    return ol.geom.GeometryCollection.cloneGeometries_(this.geometries_);\n  };\n  \n  \n  /**\n   * @return {Array.<ol.geom.Geometry>} Geometries.\n   */\n  ol.geom.GeometryCollection.prototype.getGeometriesArray = function() {\n    return this.geometries_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.GeometryCollection.prototype.getSimplifiedGeometry = function(squaredTolerance) {\n    if (this.simplifiedGeometryRevision != this.getRevision()) {\n      ol.obj.clear(this.simplifiedGeometryCache);\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (squaredTolerance < 0 ||\n        (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n         squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {\n      return this;\n    }\n    var key = squaredTolerance.toString();\n    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n      return this.simplifiedGeometryCache[key];\n    } else {\n      var simplifiedGeometries = [];\n      var geometries = this.geometries_;\n      var simplified = false;\n      var i, ii;\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometry = geometries[i];\n        var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n        simplifiedGeometries.push(simplifiedGeometry);\n        if (simplifiedGeometry !== geometry) {\n          simplified = true;\n        }\n      }\n      if (simplified) {\n        var simplifiedGeometryCollection = new ol.geom.GeometryCollection(null);\n        simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n        this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;\n        return simplifiedGeometryCollection;\n      } else {\n        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n        return this;\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.getType = function() {\n    return ol.geom.GeometryType.GEOMETRY_COLLECTION;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.intersectsExtent = function(extent) {\n    var geometries = this.geometries_;\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @return {boolean} Is empty.\n   */\n  ol.geom.GeometryCollection.prototype.isEmpty = function() {\n    return this.geometries_.length === 0;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.rotate = function(angle, anchor) {\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.scale = function(sx, opt_sy, opt_anchor) {\n    var anchor = opt_anchor;\n    if (!anchor) {\n      anchor = ol.extent.getCenter(this.getExtent());\n    }\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, opt_sy, anchor);\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array.<ol.geom.Geometry>} geometries Geometries.\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.setGeometries = function(geometries) {\n    this.setGeometriesArray(\n        ol.geom.GeometryCollection.cloneGeometries_(geometries));\n  };\n  \n  \n  /**\n   * @param {Array.<ol.geom.Geometry>} geometries Geometries.\n   */\n  ol.geom.GeometryCollection.prototype.setGeometriesArray = function(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.applyTransform = function(transformFn) {\n    var geometries = this.geometries_;\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * Translate the geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @override\n   * @api\n   */\n  ol.geom.GeometryCollection.prototype.translate = function(deltaX, deltaY) {\n    var geometries = this.geometries_;\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.GeometryCollection.prototype.disposeInternal = function() {\n    this.unlistenGeometriesChange_();\n    ol.geom.Geometry.prototype.disposeInternal.call(this);\n  };\n  \n  // TODO: serialize dataProjection as crs member when writing\n  // see https://github.com/openlayers/openlayers/issues/2078\n  \n  goog.provide('ol.format.GeoJSON');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.Feature');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.JSONFeature');\n  goog.require('ol.geom.GeometryCollection');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the GeoJSON format.\n   *\n   * @constructor\n   * @extends {ol.format.JSONFeature}\n   * @param {olx.format.GeoJSONOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.GeoJSON = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.format.JSONFeature.call(this);\n  \n    /**\n     * @inheritDoc\n     */\n    this.defaultDataProjection = ol.proj.get(\n        options.defaultDataProjection ?\n          options.defaultDataProjection : 'EPSG:4326');\n  \n  \n    if (options.featureProjection) {\n      this.defaultFeatureProjection = ol.proj.get(options.featureProjection);\n    }\n  \n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n  \n    /**\n     * Look for the geometry name in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */\n    this.extractGeometryName_ = options.extractGeometryName;\n  \n  };\n  ol.inherits(ol.format.GeoJSON, ol.format.JSONFeature);\n  \n  \n  /**\n   * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @private\n   * @return {ol.geom.Geometry} Geometry.\n   */\n  ol.format.GeoJSON.readGeometry_ = function(object, opt_options) {\n    if (!object) {\n      return null;\n    }\n    var geometryReader = ol.format.GeoJSON.GEOMETRY_READERS_[object.type];\n    return /** @type {ol.geom.Geometry} */ (\n      ol.format.Feature.transformWithOptions(\n          geometryReader(object), false, opt_options));\n  };\n  \n  \n  /**\n   * @param {GeoJSONGeometryCollection} object Object.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @private\n   * @return {ol.geom.GeometryCollection} Geometry collection.\n   */\n  ol.format.GeoJSON.readGeometryCollectionGeometry_ = function(\n      object, opt_options) {\n    var geometries = object.geometries.map(\n        /**\n         * @param {GeoJSONGeometry} geometry Geometry.\n         * @return {ol.geom.Geometry} geometry Geometry.\n         */\n        function(geometry) {\n          return ol.format.GeoJSON.readGeometry_(geometry, opt_options);\n        });\n    return new ol.geom.GeometryCollection(geometries);\n  };\n  \n  \n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.Point} Point.\n   */\n  ol.format.GeoJSON.readPointGeometry_ = function(object) {\n    return new ol.geom.Point(object.coordinates);\n  };\n  \n  \n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.LineString} LineString.\n   */\n  ol.format.GeoJSON.readLineStringGeometry_ = function(object) {\n    return new ol.geom.LineString(object.coordinates);\n  };\n  \n  \n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.MultiLineString} MultiLineString.\n   */\n  ol.format.GeoJSON.readMultiLineStringGeometry_ = function(object) {\n    return new ol.geom.MultiLineString(object.coordinates);\n  };\n  \n  \n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.MultiPoint} MultiPoint.\n   */\n  ol.format.GeoJSON.readMultiPointGeometry_ = function(object) {\n    return new ol.geom.MultiPoint(object.coordinates);\n  };\n  \n  \n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.MultiPolygon} MultiPolygon.\n   */\n  ol.format.GeoJSON.readMultiPolygonGeometry_ = function(object) {\n    return new ol.geom.MultiPolygon(object.coordinates);\n  };\n  \n  \n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @private\n   * @return {ol.geom.Polygon} Polygon.\n   */\n  ol.format.GeoJSON.readPolygonGeometry_ = function(object) {\n    return new ol.geom.Polygon(object.coordinates);\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} GeoJSON geometry.\n   */\n  ol.format.GeoJSON.writeGeometry_ = function(geometry, opt_options) {\n    var geometryWriter = ol.format.GeoJSON.GEOMETRY_WRITERS_[geometry.getType()];\n    return geometryWriter(/** @type {ol.geom.Geometry} */ (\n      ol.format.Feature.transformWithOptions(geometry, true, opt_options)),\n    opt_options);\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @private\n   * @return {GeoJSONGeometryCollection} Empty GeoJSON geometry collection.\n   */\n  ol.format.GeoJSON.writeEmptyGeometryCollectionGeometry_ = function(geometry) {\n    return /** @type {GeoJSONGeometryCollection} */ ({\n      type: 'GeometryCollection',\n      geometries: []\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryCollection} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n   */\n  ol.format.GeoJSON.writeGeometryCollectionGeometry_ = function(\n      geometry, opt_options) {\n    var geometries = geometry.getGeometriesArray().map(function(geometry) {\n      var options = ol.obj.assign({}, opt_options);\n      delete options.featureProjection;\n      return ol.format.GeoJSON.writeGeometry_(geometry, options);\n    });\n    return /** @type {GeoJSONGeometryCollection} */ ({\n      type: 'GeometryCollection',\n      geometries: geometries\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.LineString} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {GeoJSONGeometry} GeoJSON geometry.\n   */\n  ol.format.GeoJSON.writeLineStringGeometry_ = function(geometry, opt_options) {\n    return /** @type {GeoJSONGeometry} */ ({\n      type: 'LineString',\n      coordinates: geometry.getCoordinates()\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.MultiLineString} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {GeoJSONGeometry} GeoJSON geometry.\n   */\n  ol.format.GeoJSON.writeMultiLineStringGeometry_ = function(geometry, opt_options) {\n    return /** @type {GeoJSONGeometry} */ ({\n      type: 'MultiLineString',\n      coordinates: geometry.getCoordinates()\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.MultiPoint} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {GeoJSONGeometry} GeoJSON geometry.\n   */\n  ol.format.GeoJSON.writeMultiPointGeometry_ = function(geometry, opt_options) {\n    return /** @type {GeoJSONGeometry} */ ({\n      type: 'MultiPoint',\n      coordinates: geometry.getCoordinates()\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.MultiPolygon} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {GeoJSONGeometry} GeoJSON geometry.\n   */\n  ol.format.GeoJSON.writeMultiPolygonGeometry_ = function(geometry, opt_options) {\n    var right;\n    if (opt_options) {\n      right = opt_options.rightHanded;\n    }\n    return /** @type {GeoJSONGeometry} */ ({\n      type: 'MultiPolygon',\n      coordinates: geometry.getCoordinates(right)\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.Point} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {GeoJSONGeometry} GeoJSON geometry.\n   */\n  ol.format.GeoJSON.writePointGeometry_ = function(geometry, opt_options) {\n    return /** @type {GeoJSONGeometry} */ ({\n      type: 'Point',\n      coordinates: geometry.getCoordinates()\n    });\n  };\n  \n  \n  /**\n   * @param {ol.geom.Polygon} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @private\n   * @return {GeoJSONGeometry} GeoJSON geometry.\n   */\n  ol.format.GeoJSON.writePolygonGeometry_ = function(geometry, opt_options) {\n    var right;\n    if (opt_options) {\n      right = opt_options.rightHanded;\n    }\n    return /** @type {GeoJSONGeometry} */ ({\n      type: 'Polygon',\n      coordinates: geometry.getCoordinates(right)\n    });\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Object.<string, function(GeoJSONObject): ol.geom.Geometry>}\n   */\n  ol.format.GeoJSON.GEOMETRY_READERS_ = {\n    'Point': ol.format.GeoJSON.readPointGeometry_,\n    'LineString': ol.format.GeoJSON.readLineStringGeometry_,\n    'Polygon': ol.format.GeoJSON.readPolygonGeometry_,\n    'MultiPoint': ol.format.GeoJSON.readMultiPointGeometry_,\n    'MultiLineString': ol.format.GeoJSON.readMultiLineStringGeometry_,\n    'MultiPolygon': ol.format.GeoJSON.readMultiPolygonGeometry_,\n    'GeometryCollection': ol.format.GeoJSON.readGeometryCollectionGeometry_\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Object.<string, function(ol.geom.Geometry, olx.format.WriteOptions=): (GeoJSONGeometry|GeoJSONGeometryCollection)>}\n   */\n  ol.format.GeoJSON.GEOMETRY_WRITERS_ = {\n    'Point': ol.format.GeoJSON.writePointGeometry_,\n    'LineString': ol.format.GeoJSON.writeLineStringGeometry_,\n    'Polygon': ol.format.GeoJSON.writePolygonGeometry_,\n    'MultiPoint': ol.format.GeoJSON.writeMultiPointGeometry_,\n    'MultiLineString': ol.format.GeoJSON.writeMultiLineStringGeometry_,\n    'MultiPolygon': ol.format.GeoJSON.writeMultiPolygonGeometry_,\n    'GeometryCollection': ol.format.GeoJSON.writeGeometryCollectionGeometry_,\n    'Circle': ol.format.GeoJSON.writeEmptyGeometryCollectionGeometry_\n  };\n  \n  \n  /**\n   * Read a feature from a GeoJSON Feature source.  Only works for Feature or\n   * geometry types.  Use {@link ol.format.GeoJSON#readFeatures} to read\n   * FeatureCollection source. If feature at source has an id, it will be used\n   * as Feature id by calling {@link ol.Feature#setId} internally.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   * @api\n   */\n  ol.format.GeoJSON.prototype.readFeature;\n  \n  \n  /**\n   * Read all features from a GeoJSON source.  Works for all GeoJSON types.\n   * If the source includes only geometries, features will be created with those\n   * geometries.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.GeoJSON.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GeoJSON.prototype.readFeatureFromObject = function(\n      object, opt_options) {\n    /**\n     * @type {GeoJSONFeature}\n     */\n    var geoJSONFeature = null;\n    if (object.type === 'Feature') {\n      geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n    } else {\n      geoJSONFeature = /** @type {GeoJSONFeature} */ ({\n        type: 'Feature',\n        geometry: /** @type {GeoJSONGeometry|GeoJSONGeometryCollection} */ (object)\n      });\n    }\n  \n    var geometry = ol.format.GeoJSON.readGeometry_(geoJSONFeature.geometry, opt_options);\n    var feature = new ol.Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    } else if (this.extractGeometryName_ && geoJSONFeature.geometry_name !== undefined) {\n      feature.setGeometryName(geoJSONFeature.geometry_name);\n    }\n    feature.setGeometry(geometry);\n    if (geoJSONFeature.id !== undefined) {\n      feature.setId(geoJSONFeature.id);\n    }\n    if (geoJSONFeature.properties) {\n      feature.setProperties(geoJSONFeature.properties);\n    }\n    return feature;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GeoJSON.prototype.readFeaturesFromObject = function(\n      object, opt_options) {\n    var geoJSONObject = /** @type {GeoJSONObject} */ (object);\n    /** @type {Array.<ol.Feature>} */\n    var features = null;\n    if (geoJSONObject.type === 'FeatureCollection') {\n      var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */\n          (object);\n      features = [];\n      var geoJSONFeatures = geoJSONFeatureCollection.features;\n      var i, ii;\n      for (i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n        features.push(this.readFeatureFromObject(geoJSONFeatures[i],\n            opt_options));\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, opt_options)];\n    }\n    return features;\n  };\n  \n  \n  /**\n   * Read a geometry from a GeoJSON source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.geom.Geometry} Geometry.\n   * @api\n   */\n  ol.format.GeoJSON.prototype.readGeometry;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GeoJSON.prototype.readGeometryFromObject = function(\n      object, opt_options) {\n    return ol.format.GeoJSON.readGeometry_(\n        /** @type {GeoJSONGeometry} */ (object), opt_options);\n  };\n  \n  \n  /**\n   * Read the projection from a GeoJSON source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.format.GeoJSON.prototype.readProjection;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GeoJSON.prototype.readProjectionFromObject = function(object) {\n    var geoJSONObject = /** @type {GeoJSONObject} */ (object);\n    var crs = geoJSONObject.crs;\n    var projection;\n    if (crs) {\n      if (crs.type == 'name') {\n        projection = ol.proj.get(crs.properties.name);\n      } else {\n        ol.asserts.assert(false, 36); // Unknown SRS type\n      }\n    } else {\n      projection = this.defaultDataProjection;\n    }\n    return /** @type {ol.proj.Projection} */ (projection);\n  };\n  \n  \n  /**\n   * Encode a feature as a GeoJSON Feature string.\n   *\n   * @function\n   * @param {ol.Feature} feature Feature.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} GeoJSON.\n   * @override\n   * @api\n   */\n  ol.format.GeoJSON.prototype.writeFeature;\n  \n  \n  /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {ol.Feature} feature Feature.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {GeoJSONFeature} Object.\n   * @override\n   * @api\n   */\n  ol.format.GeoJSON.prototype.writeFeatureObject = function(feature, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n  \n    var object = /** @type {GeoJSONFeature} */ ({\n      'type': 'Feature'\n    });\n    var id = feature.getId();\n    if (id !== undefined) {\n      object.id = id;\n    }\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      object.geometry =\n          ol.format.GeoJSON.writeGeometry_(geometry, opt_options);\n    } else {\n      object.geometry = null;\n    }\n    var properties = feature.getProperties();\n    delete properties[feature.getGeometryName()];\n    if (!ol.obj.isEmpty(properties)) {\n      object.properties = properties;\n    } else {\n      object.properties = null;\n    }\n    return object;\n  };\n  \n  \n  /**\n   * Encode an array of features as GeoJSON.\n   *\n   * @function\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} GeoJSON.\n   * @api\n   */\n  ol.format.GeoJSON.prototype.writeFeatures;\n  \n  \n  /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @override\n   * @api\n   */\n  ol.format.GeoJSON.prototype.writeFeaturesObject = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var objects = [];\n    var i, ii;\n    for (i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], opt_options));\n    }\n    return /** @type {GeoJSONFeatureCollection} */ ({\n      type: 'FeatureCollection',\n      features: objects\n    });\n  };\n  \n  \n  /**\n   * Encode a geometry as a GeoJSON string.\n   *\n   * @function\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} GeoJSON.\n   * @api\n   */\n  ol.format.GeoJSON.prototype.writeGeometry;\n  \n  \n  /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @override\n   * @api\n   */\n  ol.format.GeoJSON.prototype.writeGeometryObject = function(geometry,\n      opt_options) {\n    return ol.format.GeoJSON.writeGeometry_(geometry,\n        this.adaptOptions(opt_options));\n  };\n  \n  goog.provide('ol.format.XMLFeature');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.FormatType');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Base class for XML feature formats.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.format.Feature}\n   */\n  ol.format.XMLFeature = function() {\n  \n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = new XMLSerializer();\n  \n    ol.format.Feature.call(this);\n  };\n  ol.inherits(ol.format.XMLFeature, ol.format.Feature);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.XMLFeature.prototype.getType = function() {\n    return ol.format.FormatType.XML;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.XMLFeature.prototype.readFeature = function(source, opt_options) {\n    if (ol.xml.isDocument(source)) {\n      return this.readFeatureFromDocument(\n          /** @type {Document} */ (source), opt_options);\n    } else if (ol.xml.isNode(source)) {\n      return this.readFeatureFromNode(/** @type {Node} */ (source), opt_options);\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      return this.readFeatureFromDocument(doc, opt_options);\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @return {ol.Feature} Feature.\n   */\n  ol.format.XMLFeature.prototype.readFeatureFromDocument = function(\n      doc, opt_options) {\n    var features = this.readFeaturesFromDocument(doc, opt_options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @return {ol.Feature} Feature.\n   */\n  ol.format.XMLFeature.prototype.readFeatureFromNode = function(node, opt_options) {\n    return null; // not implemented\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.XMLFeature.prototype.readFeatures = function(source, opt_options) {\n    if (ol.xml.isDocument(source)) {\n      return this.readFeaturesFromDocument(\n          /** @type {Document} */ (source), opt_options);\n    } else if (ol.xml.isNode(source)) {\n      return this.readFeaturesFromNode(/** @type {Node} */ (source), opt_options);\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      return this.readFeaturesFromDocument(doc, opt_options);\n    } else {\n      return [];\n    }\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @protected\n   * @return {Array.<ol.Feature>} Features.\n   */\n  ol.format.XMLFeature.prototype.readFeaturesFromDocument = function(\n      doc, opt_options) {\n    /** @type {Array.<ol.Feature>} */\n    var features = [];\n    var n;\n    for (n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        ol.array.extend(features, this.readFeaturesFromNode(n, opt_options));\n      }\n    }\n    return features;\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Node} node Node.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @protected\n   * @return {Array.<ol.Feature>} Features.\n   */\n  ol.format.XMLFeature.prototype.readFeaturesFromNode = function(node, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.XMLFeature.prototype.readGeometry = function(source, opt_options) {\n    if (ol.xml.isDocument(source)) {\n      return this.readGeometryFromDocument(\n          /** @type {Document} */ (source), opt_options);\n    } else if (ol.xml.isNode(source)) {\n      return this.readGeometryFromNode(/** @type {Node} */ (source), opt_options);\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      return this.readGeometryFromDocument(doc, opt_options);\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @protected\n   * @return {ol.geom.Geometry} Geometry.\n   */\n  ol.format.XMLFeature.prototype.readGeometryFromDocument = function(doc, opt_options) {\n    return null; // not implemented\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @protected\n   * @return {ol.geom.Geometry} Geometry.\n   */\n  ol.format.XMLFeature.prototype.readGeometryFromNode = function(node, opt_options) {\n    return null; // not implemented\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.XMLFeature.prototype.readProjection = function(source) {\n    if (ol.xml.isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    } else if (ol.xml.isNode(source)) {\n      return this.readProjectionFromNode(/** @type {Node} */ (source));\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      return this.readProjectionFromDocument(doc);\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {ol.proj.Projection} Projection.\n   */\n  ol.format.XMLFeature.prototype.readProjectionFromDocument = function(doc) {\n    return this.defaultDataProjection;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @protected\n   * @return {ol.proj.Projection} Projection.\n   */\n  ol.format.XMLFeature.prototype.readProjectionFromNode = function(node) {\n    return this.defaultDataProjection;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.XMLFeature.prototype.writeFeature = function(feature, opt_options) {\n    var node = this.writeFeatureNode(feature, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  ol.format.XMLFeature.prototype.writeFeatureNode = function(feature, opt_options) {\n    return null; // not implemented\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.XMLFeature.prototype.writeFeatures = function(features, opt_options) {\n    var node = this.writeFeaturesNode(features, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  };\n  \n  \n  /**\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   */\n  ol.format.XMLFeature.prototype.writeFeaturesNode = function(features, opt_options) {\n    return null; // not implemented\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.XMLFeature.prototype.writeGeometry = function(geometry, opt_options) {\n    var node = this.writeGeometryNode(geometry, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  };\n  \n  \n  /**\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   */\n  ol.format.XMLFeature.prototype.writeGeometryNode = function(geometry, opt_options) {\n    return null; // not implemented\n  };\n  \n  // FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n  // of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n  // envelopes/extents, only geometries!\n  goog.provide('ol.format.GMLBase');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.Feature');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.XMLFeature');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.LinearRing');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Feature base format for reading and writing data in the GML format.\n   * This class cannot be instantiated, it contains only base content that\n   * is shared with versioned format classes ol.format.GML2 and\n   * ol.format.GML3.\n   *\n   * @constructor\n   * @abstract\n   * @param {olx.format.GMLOptions=} opt_options\n   *     Optional configuration object.\n   * @extends {ol.format.XMLFeature}\n   */\n  ol.format.GMLBase = function(opt_options) {\n    var options = /** @type {olx.format.GMLOptions} */\n        (opt_options ? opt_options : {});\n  \n    /**\n     * @protected\n     * @type {Array.<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n  \n    /**\n     * @protected\n     * @type {Object.<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n  \n    /**\n     * @protected\n     * @type {string}\n     */\n    this.srsName = options.srsName;\n  \n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n  \n    /**\n     * @type {Object.<string, Object.<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS] = {\n      'featureMember': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readFeaturesInternal),\n      'featureMembers': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readFeaturesInternal)\n    };\n  \n    ol.format.XMLFeature.call(this);\n  };\n  ol.inherits(ol.format.GMLBase, ol.format.XMLFeature);\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.GMLBase.GMLNS = 'http://www.opengis.net/gml';\n  \n  \n  /**\n   * A regular expression that matches if a string only contains whitespace\n   * characters. It will e.g. match `''`, `' '`, `'\\n'` etc. The non-breaking\n   * space (0xa0) is explicitly included as IE doesn't include it in its\n   * definition of `\\s`.\n   *\n   * Information from `goog.string.isEmptyOrWhitespace`: https://github.com/google/closure-library/blob/e877b1e/closure/goog/string/string.js#L156-L160\n   *\n   * @const\n   * @type {RegExp}\n   * @private\n   */\n  ol.format.GMLBase.ONLY_WHITESPACE_RE_ = /^[\\s\\xa0]*$/;\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Array.<ol.Feature> | undefined} Features.\n   */\n  ol.format.GMLBase.prototype.readFeaturesInternal = function(node, objectStack) {\n    var localName = node.localName;\n    var features = null;\n    if (localName == 'FeatureCollection') {\n      if (node.namespaceURI === 'http://www.opengis.net/wfs') {\n        features = ol.xml.pushParseAndPop([],\n            this.FEATURE_COLLECTION_PARSERS, node,\n            objectStack, this);\n      } else {\n        features = ol.xml.pushParseAndPop(null,\n            this.FEATURE_COLLECTION_PARSERS, node,\n            objectStack, this);\n      }\n    } else if (localName == 'featureMembers' || localName == 'featureMember') {\n      var context = objectStack[0];\n      var featureType = context['featureType'];\n      var featureNS = context['featureNS'];\n      var i, ii, prefix = 'p', defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        featureType = [], featureNS = {};\n        for (i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          var child = node.childNodes[i];\n          if (child.nodeType === 1) {\n            var ft = child.nodeName.split(':').pop();\n            if (featureType.indexOf(ft) === -1) {\n              var key = '';\n              var count = 0;\n              var uri = child.namespaceURI;\n              for (var candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        var ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      var parsersNS = {};\n      var featureTypes = Array.isArray(featureType) ? featureType : [featureType];\n      for (var p in featureNS) {\n        var parsers = {};\n        for (i = 0, ii = featureTypes.length; i < ii; ++i) {\n          var featurePrefix = featureTypes[i].indexOf(':') === -1 ?\n            defaultPrefix : featureTypes[i].split(':')[0];\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] =\n                (localName == 'featureMembers') ?\n                  ol.xml.makeArrayPusher(this.readFeatureElement, this) :\n                  ol.xml.makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember') {\n        features = ol.xml.pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.geom.Geometry|undefined} Geometry.\n   */\n  ol.format.GMLBase.prototype.readGeometryElement = function(node, objectStack) {\n    var context = /** @type {Object} */ (objectStack[0]);\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');\n    /** @type {ol.geom.Geometry} */\n    var geometry = ol.xml.pushParseAndPop(null,\n        this.GEOMETRY_PARSERS_, node, objectStack, this);\n    if (geometry) {\n      return /** @type {ol.geom.Geometry} */ (\n        ol.format.Feature.transformWithOptions(geometry, false, context));\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.Feature} Feature.\n   */\n  ol.format.GMLBase.prototype.readFeatureElement = function(node, objectStack) {\n    var n;\n    var fid = node.getAttribute('fid') ||\n        ol.xml.getAttributeNS(node, ol.format.GMLBase.GMLNS, 'id');\n    var values = {}, geometryName;\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n      var localName = n.localName;\n      // Assume attribute elements have one child node and that the child\n      // is a text or CDATA node (to be treated as text).\n      // Otherwise assume it is a geometry node.\n      if (n.childNodes.length === 0 ||\n          (n.childNodes.length === 1 &&\n          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))) {\n        var value = ol.xml.getAllTextContent(n, false);\n        if (ol.format.GMLBase.ONLY_WHITESPACE_RE_.test(value)) {\n          value = undefined;\n        }\n        values[localName] = value;\n      } else {\n        // boundedBy is an extent and must not be considered as a geometry\n        if (localName !== 'boundedBy') {\n          geometryName = localName;\n        }\n        values[localName] = this.readGeometryElement(n, objectStack);\n      }\n    }\n    var feature = new ol.Feature(values);\n    if (geometryName) {\n      feature.setGeometryName(geometryName);\n    }\n    if (fid) {\n      feature.setId(fid);\n    }\n    return feature;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.geom.Point|undefined} Point.\n   */\n  ol.format.GMLBase.prototype.readPoint = function(node, objectStack) {\n    var flatCoordinates =\n        this.readFlatCoordinatesFromNode_(node, objectStack);\n    if (flatCoordinates) {\n      var point = new ol.geom.Point(null);\n      point.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);\n      return point;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.geom.MultiPoint|undefined} MultiPoint.\n   */\n  ol.format.GMLBase.prototype.readMultiPoint = function(node, objectStack) {\n    /** @type {Array.<Array.<number>>} */\n    var coordinates = ol.xml.pushParseAndPop([],\n        this.MULTIPOINT_PARSERS_, node, objectStack, this);\n    if (coordinates) {\n      return new ol.geom.MultiPoint(coordinates);\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.geom.MultiLineString|undefined} MultiLineString.\n   */\n  ol.format.GMLBase.prototype.readMultiLineString = function(node, objectStack) {\n    /** @type {Array.<ol.geom.LineString>} */\n    var lineStrings = ol.xml.pushParseAndPop([],\n        this.MULTILINESTRING_PARSERS_, node, objectStack, this);\n    if (lineStrings) {\n      var multiLineString = new ol.geom.MultiLineString(null);\n      multiLineString.setLineStrings(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.geom.MultiPolygon|undefined} MultiPolygon.\n   */\n  ol.format.GMLBase.prototype.readMultiPolygon = function(node, objectStack) {\n    /** @type {Array.<ol.geom.Polygon>} */\n    var polygons = ol.xml.pushParseAndPop([],\n        this.MULTIPOLYGON_PARSERS_, node, objectStack, this);\n    if (polygons) {\n      var multiPolygon = new ol.geom.MultiPolygon(null);\n      multiPolygon.setPolygons(polygons);\n      return multiPolygon;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GMLBase.prototype.pointMemberParser_ = function(node, objectStack) {\n    ol.xml.parseNode(this.POINTMEMBER_PARSERS_,\n        node, objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GMLBase.prototype.lineStringMemberParser_ = function(node, objectStack) {\n    ol.xml.parseNode(this.LINESTRINGMEMBER_PARSERS_,\n        node, objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GMLBase.prototype.polygonMemberParser_ = function(node, objectStack) {\n    ol.xml.parseNode(this.POLYGONMEMBER_PARSERS_, node,\n        objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.geom.LineString|undefined} LineString.\n   */\n  ol.format.GMLBase.prototype.readLineString = function(node, objectStack) {\n    var flatCoordinates =\n        this.readFlatCoordinatesFromNode_(node, objectStack);\n    if (flatCoordinates) {\n      var lineString = new ol.geom.LineString(null);\n      lineString.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} LinearRing flat coordinates.\n   */\n  ol.format.GMLBase.prototype.readFlatLinearRing_ = function(node, objectStack) {\n    var ring = ol.xml.pushParseAndPop(null,\n        this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node,\n        objectStack, this);\n    if (ring) {\n      return ring;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.geom.LinearRing|undefined} LinearRing.\n   */\n  ol.format.GMLBase.prototype.readLinearRing = function(node, objectStack) {\n    var flatCoordinates =\n        this.readFlatCoordinatesFromNode_(node, objectStack);\n    if (flatCoordinates) {\n      var ring = new ol.geom.LinearRing(null);\n      ring.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);\n      return ring;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.geom.Polygon|undefined} Polygon.\n   */\n  ol.format.GMLBase.prototype.readPolygon = function(node, objectStack) {\n    /** @type {Array.<Array.<number>>} */\n    var flatLinearRings = ol.xml.pushParseAndPop([null],\n        this.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack, this);\n    if (flatLinearRings && flatLinearRings[0]) {\n      var polygon = new ol.geom.Polygon(null);\n      var flatCoordinates = flatLinearRings[0];\n      var ends = [flatCoordinates.length];\n      var i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        ol.array.extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      polygon.setFlatCoordinates(\n          ol.geom.GeometryLayout.XYZ, flatCoordinates, ends);\n      return polygon;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.format.GMLBase.prototype.readFlatCoordinatesFromNode_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(null,\n        this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node,\n        objectStack, this);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'pointMember': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.pointMemberParser_),\n      'pointMembers': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.pointMemberParser_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'lineStringMember': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.lineStringMemberParser_),\n      'lineStringMembers': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.lineStringMemberParser_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'polygonMember': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.polygonMemberParser_),\n      'polygonMembers': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.polygonMemberParser_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'Point': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.readFlatCoordinatesFromNode_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'LineString': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.readLineString)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'Polygon': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.readPolygon)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @protected\n   */\n  ol.format.GMLBase.prototype.RING_PARSERS = {\n    'http://www.opengis.net/gml': {\n      'LinearRing': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readFlatLinearRing_)\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GMLBase.prototype.readGeometryFromNode = function(node, opt_options) {\n    var geometry = this.readGeometryElement(node,\n        [this.getReadOptions(node, opt_options ? opt_options : {})]);\n    return geometry ? geometry : null;\n  };\n  \n  \n  /**\n   * Read all features from a GML FeatureCollection.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.GMLBase.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GMLBase.prototype.readFeaturesFromNode = function(node, opt_options) {\n    var options = {\n      featureType: this.featureType,\n      featureNS: this.featureNS\n    };\n    if (opt_options) {\n      ol.obj.assign(options, this.getReadOptions(node, opt_options));\n    }\n    var features = this.readFeaturesInternal(node, [options]);\n    return features || [];\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GMLBase.prototype.readProjectionFromNode = function(node) {\n    return ol.proj.get(this.srsName ? this.srsName :\n      node.firstElementChild.getAttribute('srsName'));\n  };\n  \n  goog.provide('ol.format.XSD');\n  \n  goog.require('ol.xml');\n  goog.require('ol.string');\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.XSD.NAMESPACE_URI = 'http://www.w3.org/2001/XMLSchema';\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {boolean|undefined} Boolean.\n   */\n  ol.format.XSD.readBoolean = function(node) {\n    var s = ol.xml.getAllTextContent(node, false);\n    return ol.format.XSD.readBooleanString(s);\n  };\n  \n  \n  /**\n   * @param {string} string String.\n   * @return {boolean|undefined} Boolean.\n   */\n  ol.format.XSD.readBooleanString = function(string) {\n    var m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n    if (m) {\n      return m[1] !== undefined || false;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {number|undefined} DateTime in seconds.\n   */\n  ol.format.XSD.readDateTime = function(node) {\n    var s = ol.xml.getAllTextContent(node, false);\n    var dateTime = Date.parse(s);\n    return isNaN(dateTime) ? undefined : dateTime / 1000;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {number|undefined} Decimal.\n   */\n  ol.format.XSD.readDecimal = function(node) {\n    var s = ol.xml.getAllTextContent(node, false);\n    return ol.format.XSD.readDecimalString(s);\n  };\n  \n  \n  /**\n   * @param {string} string String.\n   * @return {number|undefined} Decimal.\n   */\n  ol.format.XSD.readDecimalString = function(string) {\n    // FIXME check spec\n    var m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n    if (m) {\n      return parseFloat(m[1]);\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {number|undefined} Non negative integer.\n   */\n  ol.format.XSD.readNonNegativeInteger = function(node) {\n    var s = ol.xml.getAllTextContent(node, false);\n    return ol.format.XSD.readNonNegativeIntegerString(s);\n  };\n  \n  \n  /**\n   * @param {string} string String.\n   * @return {number|undefined} Non negative integer.\n   */\n  ol.format.XSD.readNonNegativeIntegerString = function(string) {\n    var m = /^\\s*(\\d+)\\s*$/.exec(string);\n    if (m) {\n      return parseInt(m[1], 10);\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {string|undefined} String.\n   */\n  ol.format.XSD.readString = function(node) {\n    return ol.xml.getAllTextContent(node, false).trim();\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the boolean to.\n   * @param {boolean} bool Boolean.\n   */\n  ol.format.XSD.writeBooleanTextNode = function(node, bool) {\n    ol.format.XSD.writeStringTextNode(node, (bool) ? '1' : '0');\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a CDATA Section with the string to.\n   * @param {string} string String.\n   */\n  ol.format.XSD.writeCDATASection = function(node, string) {\n    node.appendChild(ol.xml.DOCUMENT.createCDATASection(string));\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the dateTime to.\n   * @param {number} dateTime DateTime in seconds.\n   */\n  ol.format.XSD.writeDateTimeTextNode = function(node, dateTime) {\n    var date = new Date(dateTime * 1000);\n    var string = date.getUTCFullYear() + '-' +\n        ol.string.padNumber(date.getUTCMonth() + 1, 2) + '-' +\n        ol.string.padNumber(date.getUTCDate(), 2) + 'T' +\n        ol.string.padNumber(date.getUTCHours(), 2) + ':' +\n        ol.string.padNumber(date.getUTCMinutes(), 2) + ':' +\n        ol.string.padNumber(date.getUTCSeconds(), 2) + 'Z';\n    node.appendChild(ol.xml.DOCUMENT.createTextNode(string));\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the decimal to.\n   * @param {number} decimal Decimal.\n   */\n  ol.format.XSD.writeDecimalTextNode = function(node, decimal) {\n    var string = decimal.toPrecision();\n    node.appendChild(ol.xml.DOCUMENT.createTextNode(string));\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the decimal to.\n   * @param {number} nonNegativeInteger Non negative integer.\n   */\n  ol.format.XSD.writeNonNegativeIntegerTextNode = function(node, nonNegativeInteger) {\n    var string = nonNegativeInteger.toString();\n    node.appendChild(ol.xml.DOCUMENT.createTextNode(string));\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the string to.\n   * @param {string} string String.\n   */\n  ol.format.XSD.writeStringTextNode = function(node, string) {\n    node.appendChild(ol.xml.DOCUMENT.createTextNode(string));\n  };\n  \n  goog.provide('ol.format.GML3');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.GMLBase');\n  goog.require('ol.format.XSD');\n  goog.require('ol.geom.Geometry');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the GML format\n   * version 3.1.1.\n   * Currently only supports GML 3.1.1 Simple Features profile.\n   *\n   * @constructor\n   * @param {olx.format.GMLOptions=} opt_options\n   *     Optional configuration object.\n   * @extends {ol.format.GMLBase}\n   * @api\n   */\n  ol.format.GML3 = function(opt_options) {\n    var options = /** @type {olx.format.GMLOptions} */\n        (opt_options ? opt_options : {});\n  \n    ol.format.GMLBase.call(this, options);\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ = options.multiCurve !== undefined ?\n      options.multiCurve : true;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ = options.multiSurface !== undefined ?\n      options.multiSurface : true;\n  \n    /**\n     * @inheritDoc\n     */\n    this.schemaLocation = options.schemaLocation ?\n      options.schemaLocation : ol.format.GML3.schemaLocation_;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ?\n      options.hasZ : false;\n  \n  };\n  ol.inherits(ol.format.GML3, ol.format.GMLBase);\n  \n  \n  /**\n   * @const\n   * @type {string}\n   * @private\n   */\n  ol.format.GML3.schemaLocation_ = ol.format.GMLBase.GMLNS +\n      ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n      '1.0.0/gmlsf.xsd';\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.MultiLineString|undefined} MultiLineString.\n   */\n  ol.format.GML3.prototype.readMultiCurve_ = function(node, objectStack) {\n    /** @type {Array.<ol.geom.LineString>} */\n    var lineStrings = ol.xml.pushParseAndPop([],\n        this.MULTICURVE_PARSERS_, node, objectStack, this);\n    if (lineStrings) {\n      var multiLineString = new ol.geom.MultiLineString(null);\n      multiLineString.setLineStrings(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.MultiPolygon|undefined} MultiPolygon.\n   */\n  ol.format.GML3.prototype.readMultiSurface_ = function(node, objectStack) {\n    /** @type {Array.<ol.geom.Polygon>} */\n    var polygons = ol.xml.pushParseAndPop([],\n        this.MULTISURFACE_PARSERS_, node, objectStack, this);\n    if (polygons) {\n      var multiPolygon = new ol.geom.MultiPolygon(null);\n      multiPolygon.setPolygons(polygons);\n      return multiPolygon;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GML3.prototype.curveMemberParser_ = function(node, objectStack) {\n    ol.xml.parseNode(this.CURVEMEMBER_PARSERS_, node, objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GML3.prototype.surfaceMemberParser_ = function(node, objectStack) {\n    ol.xml.parseNode(this.SURFACEMEMBER_PARSERS_,\n        node, objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<(Array.<number>)>|undefined} flat coordinates.\n   */\n  ol.format.GML3.prototype.readPatch_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop([null],\n        this.PATCHES_PARSERS_, node, objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} flat coordinates.\n   */\n  ol.format.GML3.prototype.readSegment_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop([null],\n        this.SEGMENTS_PARSERS_, node, objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<(Array.<number>)>|undefined} flat coordinates.\n   */\n  ol.format.GML3.prototype.readPolygonPatch_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop([null],\n        this.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} flat coordinates.\n   */\n  ol.format.GML3.prototype.readLineStringSegment_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop([null],\n        this.GEOMETRY_FLAT_COORDINATES_PARSERS_,\n        node, objectStack, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GML3.prototype.interiorParser_ = function(node, objectStack) {\n    /** @type {Array.<number>|undefined} */\n    var flatLinearRing = ol.xml.pushParseAndPop(undefined,\n        this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      var flatLinearRings = /** @type {Array.<Array.<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GML3.prototype.exteriorParser_ = function(node, objectStack) {\n    /** @type {Array.<number>|undefined} */\n    var flatLinearRing = ol.xml.pushParseAndPop(undefined,\n        this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      var flatLinearRings = /** @type {Array.<Array.<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.Polygon|undefined} Polygon.\n   */\n  ol.format.GML3.prototype.readSurface_ = function(node, objectStack) {\n    /** @type {Array.<Array.<number>>} */\n    var flatLinearRings = ol.xml.pushParseAndPop([null],\n        this.SURFACE_PARSERS_, node, objectStack, this);\n    if (flatLinearRings && flatLinearRings[0]) {\n      var polygon = new ol.geom.Polygon(null);\n      var flatCoordinates = flatLinearRings[0];\n      var ends = [flatCoordinates.length];\n      var i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        ol.array.extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      polygon.setFlatCoordinates(\n          ol.geom.GeometryLayout.XYZ, flatCoordinates, ends);\n      return polygon;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.LineString|undefined} LineString.\n   */\n  ol.format.GML3.prototype.readCurve_ = function(node, objectStack) {\n    /** @type {Array.<number>} */\n    var flatCoordinates = ol.xml.pushParseAndPop([null],\n        this.CURVE_PARSERS_, node, objectStack, this);\n    if (flatCoordinates) {\n      var lineString = new ol.geom.LineString(null);\n      lineString.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.Extent|undefined} Envelope.\n   */\n  ol.format.GML3.prototype.readEnvelope_ = function(node, objectStack) {\n    /** @type {Array.<number>} */\n    var flatCoordinates = ol.xml.pushParseAndPop([null],\n        this.ENVELOPE_PARSERS_, node, objectStack, this);\n    return ol.extent.createOrUpdate(flatCoordinates[1][0],\n        flatCoordinates[1][1], flatCoordinates[2][0],\n        flatCoordinates[2][1]);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} Flat coordinates.\n   */\n  ol.format.GML3.prototype.readFlatPos_ = function(node, objectStack) {\n    var s = ol.xml.getAllTextContent(node, false);\n    var re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array.<number>} */\n    var flatCoordinates = [];\n    var m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    var context = objectStack[0];\n    var containerSrs = context['srsName'];\n    var axisOrientation = 'enu';\n    if (containerSrs) {\n      var proj = ol.proj.get(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      var i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        var y = flatCoordinates[i];\n        var x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    var len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} Flat coordinates.\n   */\n  ol.format.GML3.prototype.readFlatPosList_ = function(node, objectStack) {\n    var s = ol.xml.getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    var context = objectStack[0];\n    var containerSrs = context['srsName'];\n    var contextDimension = context['srsDimension'];\n    var axisOrientation = 'enu';\n    if (containerSrs) {\n      var proj = ol.proj.get(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    var coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    var dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = ol.format.XSD.readNonNegativeIntegerString(\n          node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = ol.format.XSD.readNonNegativeIntegerString(\n          node.getAttribute('dimension'));\n    } else if (node.parentNode.getAttribute('srsDimension')) {\n      dim = ol.format.XSD.readNonNegativeIntegerString(\n          node.parentNode.getAttribute('srsDimension'));\n    } else if (contextDimension) {\n      dim = ol.format.XSD.readNonNegativeIntegerString(contextDimension);\n    }\n    var x, y, z;\n    var flatCoordinates = [];\n    for (var i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = (dim === 3) ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'pos': ol.xml.makeReplacer(ol.format.GML3.prototype.readFlatPos_),\n      'posList': ol.xml.makeReplacer(ol.format.GML3.prototype.readFlatPosList_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'interior': ol.format.GML3.prototype.interiorParser_,\n      'exterior': ol.format.GML3.prototype.exteriorParser_\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.GEOMETRY_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'Point': ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPoint),\n      'MultiPoint': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readMultiPoint),\n      'LineString': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readLineString),\n      'MultiLineString': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readMultiLineString),\n      'LinearRing': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readLinearRing),\n      'Polygon': ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPolygon),\n      'MultiPolygon': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readMultiPolygon),\n      'Surface': ol.xml.makeReplacer(ol.format.GML3.prototype.readSurface_),\n      'MultiSurface': ol.xml.makeReplacer(\n          ol.format.GML3.prototype.readMultiSurface_),\n      'Curve': ol.xml.makeReplacer(ol.format.GML3.prototype.readCurve_),\n      'MultiCurve': ol.xml.makeReplacer(\n          ol.format.GML3.prototype.readMultiCurve_),\n      'Envelope': ol.xml.makeReplacer(ol.format.GML3.prototype.readEnvelope_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.MULTICURVE_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'curveMember': ol.xml.makeArrayPusher(\n          ol.format.GML3.prototype.curveMemberParser_),\n      'curveMembers': ol.xml.makeArrayPusher(\n          ol.format.GML3.prototype.curveMemberParser_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.MULTISURFACE_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'surfaceMember': ol.xml.makeArrayPusher(\n          ol.format.GML3.prototype.surfaceMemberParser_),\n      'surfaceMembers': ol.xml.makeArrayPusher(\n          ol.format.GML3.prototype.surfaceMemberParser_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.CURVEMEMBER_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'LineString': ol.xml.makeArrayPusher(\n          ol.format.GMLBase.prototype.readLineString),\n      'Curve': ol.xml.makeArrayPusher(ol.format.GML3.prototype.readCurve_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'Polygon': ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readPolygon),\n      'Surface': ol.xml.makeArrayPusher(ol.format.GML3.prototype.readSurface_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.SURFACE_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'patches': ol.xml.makeReplacer(ol.format.GML3.prototype.readPatch_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.CURVE_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'segments': ol.xml.makeReplacer(ol.format.GML3.prototype.readSegment_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.ENVELOPE_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'lowerCorner': ol.xml.makeArrayPusher(\n          ol.format.GML3.prototype.readFlatPosList_),\n      'upperCorner': ol.xml.makeArrayPusher(\n          ol.format.GML3.prototype.readFlatPosList_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.PATCHES_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'PolygonPatch': ol.xml.makeReplacer(\n          ol.format.GML3.prototype.readPolygonPatch_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML3.prototype.SEGMENTS_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'LineStringSegment': ol.xml.makeReplacer(\n          ol.format.GML3.prototype.readLineStringSegment_)\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Point} value Point geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writePos_ = function(node, value, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsDimension = hasZ ? 3 : 2;\n    node.setAttribute('srsDimension', srsDimension);\n    var srsName = context['srsName'];\n    var axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = ol.proj.get(srsName).getAxisOrientation();\n    }\n    var point = value.getCoordinates();\n    var coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = (point[0] + ' ' + point[1]);\n    } else {\n      coords = (point[1] + ' ' + point[0]);\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      var z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    ol.format.XSD.writeStringTextNode(node, coords);\n  };\n  \n  \n  /**\n   * @param {Array.<number>} point Point geometry.\n   * @param {string=} opt_srsName Optional srsName\n   * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  ol.format.GML3.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {\n    var axisOrientation = 'enu';\n    if (opt_srsName) {\n      axisOrientation = ol.proj.get(opt_srsName).getAxisOrientation();\n    }\n    var coords = ((axisOrientation.substr(0, 2) === 'en') ?\n      point[0] + ' ' + point[1] :\n      point[1] + ' ' + point[0]);\n    if (opt_hasZ) {\n      // For newly created points, Z can be undefined.\n      var z = point[2] || 0;\n      coords += ' ' + z;\n    }\n  \n    return coords;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString|ol.geom.LinearRing} value Geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writePosList_ = function(node, value, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsDimension = hasZ ? 3 : 2;\n    node.setAttribute('srsDimension', srsDimension);\n    var srsName = context['srsName'];\n    // only 2d for simple features profile\n    var points = value.getCoordinates();\n    var len = points.length;\n    var parts = new Array(len);\n    var point;\n    for (var i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    ol.format.XSD.writeStringTextNode(node, parts.join(' '));\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Point} geometry Point geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writePoint_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var pos = ol.xml.createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML3.ENVELOPE_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'lowerCorner': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n      'upperCorner': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Extent} extent Extent.\n   * @param {Array.<*>} objectStack Node stack.\n   */\n  ol.format.GML3.prototype.writeEnvelope = function(node, extent, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var keys = ['lowerCorner', 'upperCorner'];\n    var values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        ({node: node}), ol.format.GML3.ENVELOPE_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY,\n        values,\n        objectStack, keys, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LinearRing} geometry LinearRing geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeLinearRing_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var posList = ol.xml.createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  };\n  \n  \n  /**\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  ol.format.GML3.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var parentNode = context.node;\n    var exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return ol.xml.createElementNS(parentNode.namespaceURI,\n        exteriorWritten !== undefined ? 'interior' : 'exterior');\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Polygon} geometry Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeSurfaceOrPolygon_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      var rings = geometry.getLinearRings();\n      ol.xml.pushSerializeAndPop(\n          {node: node, hasZ: hasZ, srsName: srsName},\n          ol.format.GML3.RING_SERIALIZERS_,\n          this.RING_NODE_FACTORY_,\n          rings, objectStack, undefined, this);\n    } else if (node.nodeName === 'Surface') {\n      var patches = ol.xml.createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(\n          patches, geometry, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString} geometry LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeCurveOrLineString_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'LineString' ||\n        node.nodeName === 'LineStringSegment') {\n      var posList = ol.xml.createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      var segments = ol.xml.createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments,\n          geometry, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    var surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var polygons = geometry.getPolygons();\n    ol.xml.pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n        ol.format.GML3.SURFACEORPOLYGONMEMBER_SERIALIZERS_,\n        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons,\n        objectStack, undefined, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.MultiPoint} geometry MultiPoint geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeMultiPoint_ = function(node, geometry,\n      objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    var hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var points = geometry.getPoints();\n    ol.xml.pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName},\n        ol.format.GML3.POINTMEMBER_SERIALIZERS_,\n        ol.xml.makeSimpleNodeFactory('pointMember'), points,\n        objectStack, undefined, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.MultiLineString} geometry MultiLineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeMultiCurveOrLineString_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    var curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var lines = geometry.getLineStrings();\n    ol.xml.pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n        ol.format.GML3.LINESTRINGORCURVEMEMBER_SERIALIZERS_,\n        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines,\n        objectStack, undefined, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LinearRing} ring LinearRing geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeRing_ = function(node, ring, objectStack) {\n    var linearRing = ol.xml.createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing_(linearRing, ring, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Polygon} polygon Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeSurfaceOrPolygonMember_ = function(node, polygon, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(\n        polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Point} point Point geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writePointMember_ = function(node, point, objectStack) {\n    var child = ol.xml.createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint_(child, point, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString} line LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeLineStringOrCurveMember_ = function(node, line, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString_(child, line, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Polygon} polygon Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {\n    var child = ol.xml.createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString} line LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeCurveSegments_ = function(node, line, objectStack) {\n    var child = ol.xml.createElementNS(node.namespaceURI,\n        'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString_(child, line, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   */\n  ol.format.GML3.prototype.writeGeometryElement = function(node, geometry, objectStack) {\n    var context = /** @type {olx.format.WriteOptions} */ (objectStack[objectStack.length - 1]);\n    var item = ol.obj.assign({}, context);\n    item.node = node;\n    var value;\n    if (Array.isArray(geometry)) {\n      if (context.dataProjection) {\n        value = ol.proj.transformExtent(\n            geometry, context.featureProjection, context.dataProjection);\n      } else {\n        value = geometry;\n      }\n    } else {\n      value =\n          ol.format.Feature.transformWithOptions(/** @type {ol.geom.Geometry} */ (geometry), true, context);\n    }\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        (item), ol.format.GML3.GEOMETRY_SERIALIZERS_,\n        this.GEOMETRY_NODE_FACTORY_, [value],\n        objectStack, undefined, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Node stack.\n   */\n  ol.format.GML3.prototype.writeFeatureElement = function(node, feature, objectStack) {\n    var fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', fid);\n    }\n    var context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var featureNS = context['featureNS'];\n    var geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    var properties = feature.getProperties();\n    var keys = [], values = [];\n    for (var key in properties) {\n      var value = properties[key];\n      if (value !== null) {\n        keys.push(key);\n        values.push(value);\n        if (key == geometryName || value instanceof ol.geom.Geometry) {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = ol.xml.makeChildAppender(\n                this.writeGeometryElement, this);\n          }\n        } else {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = ol.xml.makeChildAppender(\n                ol.format.XSD.writeStringTextNode);\n          }\n        }\n      }\n    }\n    var item = ol.obj.assign({}, context);\n    item.node = node;\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        (item), context.serializers,\n        ol.xml.makeSimpleNodeFactory(undefined, featureNS),\n        values,\n        objectStack, keys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML3.prototype.writeFeatureMembers_ = function(node, features, objectStack) {\n    var context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var featureType = context['featureType'];\n    var featureNS = context['featureNS'];\n    var serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = ol.xml.makeChildAppender(\n        this.writeFeatureElement, this);\n    var item = ol.obj.assign({}, context);\n    item.node = node;\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        (item),\n        serializers,\n        ol.xml.makeSimpleNodeFactory(featureType, featureNS), features,\n        objectStack);\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML3.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'surfaceMember': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeSurfaceOrPolygonMember_),\n      'polygonMember': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeSurfaceOrPolygonMember_)\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML3.POINTMEMBER_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'pointMember': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writePointMember_)\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML3.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'lineStringMember': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeLineStringOrCurveMember_),\n      'curveMember': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeLineStringOrCurveMember_)\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML3.RING_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'exterior': ol.xml.makeChildAppender(ol.format.GML3.prototype.writeRing_),\n      'interior': ol.xml.makeChildAppender(ol.format.GML3.prototype.writeRing_)\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML3.GEOMETRY_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'Curve': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeCurveOrLineString_),\n      'MultiCurve': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeMultiCurveOrLineString_),\n      'Point': ol.xml.makeChildAppender(ol.format.GML3.prototype.writePoint_),\n      'MultiPoint': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeMultiPoint_),\n      'LineString': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeCurveOrLineString_),\n      'MultiLineString': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeMultiCurveOrLineString_),\n      'LinearRing': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeLinearRing_),\n      'Polygon': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeSurfaceOrPolygon_),\n      'MultiPolygon': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_),\n      'Surface': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeSurfaceOrPolygon_),\n      'MultiSurface': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_),\n      'Envelope': ol.xml.makeChildAppender(\n          ol.format.GML3.prototype.writeEnvelope)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, string>}\n   * @private\n   */\n  ol.format.GML3.MULTIGEOMETRY_TO_MEMBER_NODENAME_ = {\n    'MultiLineString': 'lineStringMember',\n    'MultiCurve': 'curveMember',\n    'MultiPolygon': 'polygonMember',\n    'MultiSurface': 'surfaceMember'\n  };\n  \n  \n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  ol.format.GML3.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var parentNode = objectStack[objectStack.length - 1].node;\n    return ol.xml.createElementNS('http://www.opengis.net/gml',\n        ol.format.GML3.MULTIGEOMETRY_TO_MEMBER_NODENAME_[parentNode.nodeName]);\n  };\n  \n  \n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  ol.format.GML3.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var multiSurface = context['multiSurface'];\n    var surface = context['surface'];\n    var curve = context['curve'];\n    var multiCurve = context['multiCurve'];\n    var nodeName;\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {ol.geom.Geometry} */ (value).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return ol.xml.createElementNS('http://www.opengis.net/gml',\n        nodeName);\n  };\n  \n  \n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n  ol.format.GML3.prototype.writeGeometryNode = function(geometry, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var geom = ol.xml.createElementNS('http://www.opengis.net/gml', 'geom');\n    var context = {node: geom, hasZ: this.hasZ, srsName: this.srsName,\n      curve: this.curve_, surface: this.surface_,\n      multiSurface: this.multiSurface_, multiCurve: this.multiCurve_};\n    if (opt_options) {\n      ol.obj.assign(context, opt_options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  };\n  \n  \n  /**\n   * Encode an array of features in GML 3.1.1 Simple Features.\n   *\n   * @function\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {string} Result.\n   * @api\n   */\n  ol.format.GML3.prototype.writeFeatures;\n  \n  \n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n  ol.format.GML3.prototype.writeFeaturesNode = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var node = ol.xml.createElementNS('http://www.opengis.net/gml',\n        'featureMembers');\n    ol.xml.setAttributeNS(node, 'http://www.w3.org/2001/XMLSchema-instance',\n        'xsi:schemaLocation', this.schemaLocation);\n    var context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType\n    };\n    if (opt_options) {\n      ol.obj.assign(context, opt_options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  };\n  \n  goog.provide('ol.format.GML');\n  \n  goog.require('ol.format.GML3');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the GML format\n   * version 3.1.1.\n   * Currently only supports GML 3.1.1 Simple Features profile.\n   *\n   * @constructor\n   * @param {olx.format.GMLOptions=} opt_options\n   *     Optional configuration object.\n   * @extends {ol.format.GMLBase}\n   * @api\n   */\n  ol.format.GML = ol.format.GML3;\n  \n  \n  /**\n   * Encode an array of features in GML 3.1.1 Simple Features.\n   *\n   * @function\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {string} Result.\n   * @api\n   */\n  ol.format.GML.prototype.writeFeatures;\n  \n  \n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @function\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @api\n   */\n  ol.format.GML.prototype.writeFeaturesNode;\n  \n  goog.provide('ol.format.GML2');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.GMLBase');\n  goog.require('ol.format.XSD');\n  goog.require('ol.geom.Geometry');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the GML format,\n   * version 2.1.2.\n   *\n   * @constructor\n   * @param {olx.format.GMLOptions=} opt_options Optional configuration object.\n   * @extends {ol.format.GMLBase}\n   * @api\n   */\n  ol.format.GML2 = function(opt_options) {\n    var options = /** @type {olx.format.GMLOptions} */\n        (opt_options ? opt_options : {});\n  \n    ol.format.GMLBase.call(this, options);\n  \n    this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS][\n        'featureMember'] =\n        ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFeaturesInternal);\n  \n    /**\n     * @inheritDoc\n     */\n    this.schemaLocation = options.schemaLocation ?\n      options.schemaLocation : ol.format.GML2.schemaLocation_;\n  \n  };\n  ol.inherits(ol.format.GML2, ol.format.GMLBase);\n  \n  \n  /**\n   * @const\n   * @type {string}\n   * @private\n   */\n  ol.format.GML2.schemaLocation_ = ol.format.GMLBase.GMLNS +\n      ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} Flat coordinates.\n   */\n  ol.format.GML2.prototype.readFlatCoordinates_ = function(node, objectStack) {\n    var s = ol.xml.getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    var context = /** @type {ol.XmlNodeStackItem} */ (objectStack[0]);\n    var containerSrs = context['srsName'];\n    var axisOrientation = 'enu';\n    if (containerSrs) {\n      var proj = ol.proj.get(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    var coordsGroups = s.trim().split(/\\s+/);\n    var x, y, z;\n    var flatCoordinates = [];\n    for (var i = 0, ii = coordsGroups.length; i < ii; i++) {\n      var coords = coordsGroups[i].split(/,+/);\n      x = parseFloat(coords[0]);\n      y = parseFloat(coords[1]);\n      z = (coords.length === 3) ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.Extent|undefined} Envelope.\n   */\n  ol.format.GML2.prototype.readBox_ = function(node, objectStack) {\n    /** @type {Array.<number>} */\n    var flatCoordinates = ol.xml.pushParseAndPop([null],\n        this.BOX_PARSERS_, node, objectStack, this);\n    return ol.extent.createOrUpdate(flatCoordinates[1][0],\n        flatCoordinates[1][1], flatCoordinates[1][3],\n        flatCoordinates[1][4]);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GML2.prototype.innerBoundaryIsParser_ = function(node, objectStack) {\n    /** @type {Array.<number>|undefined} */\n    var flatLinearRing = ol.xml.pushParseAndPop(undefined,\n        this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      var flatLinearRings = /** @type {Array.<Array.<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GML2.prototype.outerBoundaryIsParser_ = function(node, objectStack) {\n    /** @type {Array.<number>|undefined} */\n    var flatLinearRing = ol.xml.pushParseAndPop(undefined,\n        this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      var flatLinearRings = /** @type {Array.<Array.<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'coordinates': ol.xml.makeReplacer(\n          ol.format.GML2.prototype.readFlatCoordinates_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML2.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'innerBoundaryIs': ol.format.GML2.prototype.innerBoundaryIsParser_,\n      'outerBoundaryIs': ol.format.GML2.prototype.outerBoundaryIsParser_\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML2.prototype.BOX_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'coordinates': ol.xml.makeArrayPusher(\n          ol.format.GML2.prototype.readFlatCoordinates_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GML2.prototype.GEOMETRY_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'Point': ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPoint),\n      'MultiPoint': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readMultiPoint),\n      'LineString': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readLineString),\n      'MultiLineString': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readMultiLineString),\n      'LinearRing': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readLinearRing),\n      'Polygon': ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPolygon),\n      'MultiPolygon': ol.xml.makeReplacer(\n          ol.format.GMLBase.prototype.readMultiPolygon),\n      'Box': ol.xml.makeReplacer(ol.format.GML2.prototype.readBox_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  ol.format.GML2.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var multiSurface = context['multiSurface'];\n    var surface = context['surface'];\n    var multiCurve = context['multiCurve'];\n    var nodeName;\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {ol.geom.Geometry} */ (value).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return ol.xml.createElementNS('http://www.opengis.net/gml',\n        nodeName);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Node stack.\n   */\n  ol.format.GML2.prototype.writeFeatureElement = function(node, feature, objectStack) {\n    var fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', fid);\n    }\n    var context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var featureNS = context['featureNS'];\n    var geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    var properties = feature.getProperties();\n    var keys = [], values = [];\n    for (var key in properties) {\n      var value = properties[key];\n      if (value !== null) {\n        keys.push(key);\n        values.push(value);\n        if (key == geometryName || value instanceof ol.geom.Geometry) {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = ol.xml.makeChildAppender(\n                this.writeGeometryElement, this);\n          }\n        } else {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = ol.xml.makeChildAppender(\n                ol.format.XSD.writeStringTextNode);\n          }\n        }\n      }\n    }\n    var item = ol.obj.assign({}, context);\n    item.node = node;\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        (item), context.serializers,\n        ol.xml.makeSimpleNodeFactory(undefined, featureNS),\n        values,\n        objectStack, keys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   */\n  ol.format.GML2.prototype.writeGeometryElement = function(node, geometry, objectStack) {\n    var context = /** @type {olx.format.WriteOptions} */ (objectStack[objectStack.length - 1]);\n    var item = ol.obj.assign({}, context);\n    item.node = node;\n    var value;\n    if (Array.isArray(geometry)) {\n      if (context.dataProjection) {\n        value = ol.proj.transformExtent(\n            geometry, context.featureProjection, context.dataProjection);\n      } else {\n        value = geometry;\n      }\n    } else {\n      value =\n          ol.format.Feature.transformWithOptions(/** @type {ol.geom.Geometry} */ (geometry), true, context);\n    }\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        (item), ol.format.GML2.GEOMETRY_SERIALIZERS_,\n        this.GEOMETRY_NODE_FACTORY_, [value],\n        objectStack, undefined, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString} geometry LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeCurveOrLineString_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'LineString' ||\n        node.nodeName === 'LineStringSegment') {\n      var coordinates = this.createCoordinatesNode_(node.namespaceURI);\n      node.appendChild(coordinates);\n      this.writeCoordinates_(coordinates, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      var segments = ol.xml.createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments,\n          geometry, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {string} namespaceURI XML namespace.\n   * @returns {Node} coordinates node.\n   * @private\n   */\n  ol.format.GML2.prototype.createCoordinatesNode_ = function(namespaceURI) {\n    var coordinates = ol.xml.createElementNS(namespaceURI, 'coordinates');\n    coordinates.setAttribute('decimal', '.');\n    coordinates.setAttribute('cs', ',');\n    coordinates.setAttribute('ts', ' ');\n  \n    return coordinates;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString|ol.geom.LinearRing} value Geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeCoordinates_ = function(node, value, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    // only 2d for simple features profile\n    var points = value.getCoordinates();\n    var len = points.length;\n    var parts = new Array(len);\n    var point;\n    for (var i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    ol.format.XSD.writeStringTextNode(node, parts.join(' '));\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString} line LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeCurveSegments_ = function(node, line, objectStack) {\n    var child = ol.xml.createElementNS(node.namespaceURI,\n        'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString_(child, line, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Polygon} geometry Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeSurfaceOrPolygon_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      var rings = geometry.getLinearRings();\n      ol.xml.pushSerializeAndPop(\n          {node: node, hasZ: hasZ, srsName: srsName},\n          ol.format.GML2.RING_SERIALIZERS_,\n          this.RING_NODE_FACTORY_,\n          rings, objectStack, undefined, this);\n    } else if (node.nodeName === 'Surface') {\n      var patches = ol.xml.createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(\n          patches, geometry, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  ol.format.GML2.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var parentNode = context.node;\n    var exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return ol.xml.createElementNS(parentNode.namespaceURI,\n        exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs');\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Polygon} polygon Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {\n    var child = ol.xml.createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LinearRing} ring LinearRing geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeRing_ = function(node, ring, objectStack) {\n    var linearRing = ol.xml.createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing_(linearRing, ring, objectStack);\n  };\n  \n  \n  /**\n   * @param {Array.<number>} point Point geometry.\n   * @param {string=} opt_srsName Optional srsName\n   * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  ol.format.GML2.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {\n    var axisOrientation = 'enu';\n    if (opt_srsName) {\n      axisOrientation = ol.proj.get(opt_srsName).getAxisOrientation();\n    }\n    var coords = ((axisOrientation.substr(0, 2) === 'en') ?\n      point[0] + ',' + point[1] :\n      point[1] + ',' + point[0]);\n    if (opt_hasZ) {\n      // For newly created points, Z can be undefined.\n      var z = point[2] || 0;\n      coords += ',' + z;\n    }\n  \n    return coords;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.MultiLineString} geometry MultiLineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeMultiCurveOrLineString_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    var curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var lines = geometry.getLineStrings();\n    ol.xml.pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n        ol.format.GML2.LINESTRINGORCURVEMEMBER_SERIALIZERS_,\n        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines,\n        objectStack, undefined, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Point} geometry Point geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writePoint_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    var point = geometry.getCoordinates();\n    var coord = this.getCoords_(point, srsName, hasZ);\n    ol.format.XSD.writeStringTextNode(coordinates, coord);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.MultiPoint} geometry MultiPoint geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeMultiPoint_ = function(node, geometry,\n      objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var points = geometry.getPoints();\n    ol.xml.pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName},\n        ol.format.GML2.POINTMEMBER_SERIALIZERS_,\n        ol.xml.makeSimpleNodeFactory('pointMember'), points,\n        objectStack, undefined, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Point} point Point geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writePointMember_ = function(node, point, objectStack) {\n    var child = ol.xml.createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint_(child, point, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString} line LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeLineStringOrCurveMember_ = function(node, line, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString_(child, line, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LinearRing} geometry LinearRing geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeLinearRing_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_ = function(node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    var surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var polygons = geometry.getPolygons();\n    ol.xml.pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n        ol.format.GML2.SURFACEORPOLYGONMEMBER_SERIALIZERS_,\n        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons,\n        objectStack, undefined, this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Polygon} polygon Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeSurfaceOrPolygonMember_ = function(node, polygon, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(\n        polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Extent} extent Extent.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GML2.prototype.writeEnvelope = function(node, extent, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    var keys = ['lowerCorner', 'upperCorner'];\n    var values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        ({node: node}), ol.format.GML2.ENVELOPE_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY,\n        values,\n        objectStack, keys, this);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML2.GEOMETRY_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'Curve': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeCurveOrLineString_),\n      'MultiCurve': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeMultiCurveOrLineString_),\n      'Point': ol.xml.makeChildAppender(ol.format.GML2.prototype.writePoint_),\n      'MultiPoint': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeMultiPoint_),\n      'LineString': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeCurveOrLineString_),\n      'MultiLineString': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeMultiCurveOrLineString_),\n      'LinearRing': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeLinearRing_),\n      'Polygon': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeSurfaceOrPolygon_),\n      'MultiPolygon': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_),\n      'Surface': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeSurfaceOrPolygon_),\n      'MultiSurface': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_),\n      'Envelope': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeEnvelope)\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML2.RING_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'outerBoundaryIs': ol.xml.makeChildAppender(ol.format.GML2.prototype.writeRing_),\n      'innerBoundaryIs': ol.xml.makeChildAppender(ol.format.GML2.prototype.writeRing_)\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML2.POINTMEMBER_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'pointMember': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writePointMember_)\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML2.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'lineStringMember': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeLineStringOrCurveMember_),\n      'curveMember': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeLineStringOrCurveMember_)\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  ol.format.GML2.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var parentNode = objectStack[objectStack.length - 1].node;\n    return ol.xml.createElementNS('http://www.opengis.net/gml',\n        ol.format.GML2.MULTIGEOMETRY_TO_MEMBER_NODENAME_[parentNode.nodeName]);\n  };\n  \n  /**\n   * @const\n   * @type {Object.<string, string>}\n   * @private\n   */\n  ol.format.GML2.MULTIGEOMETRY_TO_MEMBER_NODENAME_ = {\n    'MultiLineString': 'lineStringMember',\n    'MultiCurve': 'curveMember',\n    'MultiPolygon': 'polygonMember',\n    'MultiSurface': 'surfaceMember'\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML2.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'surfaceMember': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeSurfaceOrPolygonMember_),\n      'polygonMember': ol.xml.makeChildAppender(\n          ol.format.GML2.prototype.writeSurfaceOrPolygonMember_)\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GML2.ENVELOPE_SERIALIZERS_ = {\n    'http://www.opengis.net/gml': {\n      'lowerCorner': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n      'upperCorner': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)\n    }\n  };\n  \n  goog.provide('ol.format.GPX');\n  \n  goog.require('ol');\n  goog.require('ol.Feature');\n  goog.require('ol.array');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.XMLFeature');\n  goog.require('ol.format.XSD');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.Point');\n  goog.require('ol.proj');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the GPX format.\n   *\n   * @constructor\n   * @extends {ol.format.XMLFeature}\n   * @param {olx.format.GPXOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.GPX = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.format.XMLFeature.call(this);\n  \n    /**\n     * @inheritDoc\n     */\n    this.defaultDataProjection = ol.proj.get('EPSG:4326');\n  \n    /**\n     * @type {function(ol.Feature, Node)|undefined}\n     * @private\n     */\n    this.readExtensions_ = options.readExtensions;\n  };\n  ol.inherits(ol.format.GPX, ol.format.XMLFeature);\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Array.<string>}\n   */\n  ol.format.GPX.NAMESPACE_URIS_ = [\n    null,\n    'http://www.topografix.com/GPX/1/0',\n    'http://www.topografix.com/GPX/1/1'\n  ];\n  \n  \n  /**\n   * @const\n   * @type {string}\n   * @private\n   */\n  ol.format.GPX.SCHEMA_LOCATION_ = 'http://www.topografix.com/GPX/1/1 ' +\n      'http://www.topografix.com/GPX/1/1/gpx.xsd';\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {ol.LayoutOptions} layoutOptions Layout options.\n   * @param {Node} node Node.\n   * @param {Object} values Values.\n   * @private\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.format.GPX.appendCoordinate_ = function(flatCoordinates, layoutOptions, node, values) {\n    flatCoordinates.push(\n        parseFloat(node.getAttribute('lon')),\n        parseFloat(node.getAttribute('lat')));\n    if ('ele' in values) {\n      flatCoordinates.push(/** @type {number} */ (values['ele']));\n      delete values['ele'];\n      layoutOptions.hasZ = true;\n    } else {\n      flatCoordinates.push(0);\n    }\n    if ('time' in values) {\n      flatCoordinates.push(/** @type {number} */ (values['time']));\n      delete values['time'];\n      layoutOptions.hasM = true;\n    } else {\n      flatCoordinates.push(0);\n    }\n    return flatCoordinates;\n  };\n  \n  \n  /**\n   * Choose GeometryLayout based on flags in layoutOptions and adjust flatCoordinates\n   * and ends arrays by shrinking them accordingly (removing unused zero entries).\n   *\n   * @param {ol.LayoutOptions} layoutOptions Layout options.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {Array.<number>=} ends Ends.\n   * @return {ol.geom.GeometryLayout} Layout.\n   */\n  ol.format.GPX.applyLayoutOptions_ = function(layoutOptions, flatCoordinates, ends) {\n    var layout = ol.geom.GeometryLayout.XY;\n    var stride = 2;\n    if (layoutOptions.hasZ && layoutOptions.hasM) {\n      layout = ol.geom.GeometryLayout.XYZM;\n      stride = 4;\n    } else if (layoutOptions.hasZ) {\n      layout = ol.geom.GeometryLayout.XYZ;\n      stride = 3;\n    } else if (layoutOptions.hasM) {\n      layout = ol.geom.GeometryLayout.XYM;\n      stride = 3;\n    }\n    if (stride !== 4) {\n      var i, ii;\n      for (i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {\n        flatCoordinates[i * stride] = flatCoordinates[i * 4];\n        flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];\n        if (layoutOptions.hasZ) {\n          flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];\n        }\n        if (layoutOptions.hasM) {\n          flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];\n        }\n      }\n      flatCoordinates.length = flatCoordinates.length / 4 * stride;\n      if (ends) {\n        for (i = 0, ii = ends.length; i < ii; i++) {\n          ends[i] = ends[i] / 4 * stride;\n        }\n      }\n    }\n    return layout;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.parseLink_ = function(node, objectStack) {\n    var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var href = node.getAttribute('href');\n    if (href !== null) {\n      values['link'] = href;\n    }\n    ol.xml.parseNode(ol.format.GPX.LINK_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.parseExtensions_ = function(node, objectStack) {\n    var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    values['extensionsNode_'] = node;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.parseRtePt_ = function(node, objectStack) {\n    var values = ol.xml.pushParseAndPop(\n        {}, ol.format.GPX.RTEPT_PARSERS_, node, objectStack);\n    if (values) {\n      var rteValues = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n      var flatCoordinates = /** @type {Array.<number>} */\n          (rteValues['flatCoordinates']);\n      var layoutOptions = /** @type {ol.LayoutOptions} */\n          (rteValues['layoutOptions']);\n      ol.format.GPX.appendCoordinate_(flatCoordinates, layoutOptions, node, values);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.parseTrkPt_ = function(node, objectStack) {\n    var values = ol.xml.pushParseAndPop(\n        {}, ol.format.GPX.TRKPT_PARSERS_, node, objectStack);\n    if (values) {\n      var trkValues = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n      var flatCoordinates = /** @type {Array.<number>} */\n          (trkValues['flatCoordinates']);\n      var layoutOptions = /** @type {ol.LayoutOptions} */\n          (trkValues['layoutOptions']);\n      ol.format.GPX.appendCoordinate_(flatCoordinates, layoutOptions, node, values);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.parseTrkSeg_ = function(node, objectStack) {\n    var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    ol.xml.parseNode(ol.format.GPX.TRKSEG_PARSERS_, node, objectStack);\n    var flatCoordinates = /** @type {Array.<number>} */\n        (values['flatCoordinates']);\n    var ends = /** @type {Array.<number>} */ (values['ends']);\n    ends.push(flatCoordinates.length);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.Feature|undefined} Track.\n   */\n  ol.format.GPX.readRte_ = function(node, objectStack) {\n    var options = /** @type {olx.format.ReadOptions} */ (objectStack[0]);\n    var values = ol.xml.pushParseAndPop({\n      'flatCoordinates': [],\n      'layoutOptions': {}\n    }, ol.format.GPX.RTE_PARSERS_, node, objectStack);\n    if (!values) {\n      return undefined;\n    }\n    var flatCoordinates = /** @type {Array.<number>} */\n        (values['flatCoordinates']);\n    delete values['flatCoordinates'];\n    var layoutOptions = /** @type {ol.LayoutOptions} */ (values['layoutOptions']);\n    delete values['layoutOptions'];\n    var layout = ol.format.GPX.applyLayoutOptions_(layoutOptions, flatCoordinates);\n    var geometry = new ol.geom.LineString(null);\n    geometry.setFlatCoordinates(layout, flatCoordinates);\n    ol.format.Feature.transformWithOptions(geometry, false, options);\n    var feature = new ol.Feature(geometry);\n    feature.setProperties(values);\n    return feature;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.Feature|undefined} Track.\n   */\n  ol.format.GPX.readTrk_ = function(node, objectStack) {\n    var options = /** @type {olx.format.ReadOptions} */ (objectStack[0]);\n    var values = ol.xml.pushParseAndPop({\n      'flatCoordinates': [],\n      'ends': [],\n      'layoutOptions': {}\n    }, ol.format.GPX.TRK_PARSERS_, node, objectStack);\n    if (!values) {\n      return undefined;\n    }\n    var flatCoordinates = /** @type {Array.<number>} */\n        (values['flatCoordinates']);\n    delete values['flatCoordinates'];\n    var ends = /** @type {Array.<number>} */ (values['ends']);\n    delete values['ends'];\n    var layoutOptions = /** @type {ol.LayoutOptions} */ (values['layoutOptions']);\n    delete values['layoutOptions'];\n    var layout = ol.format.GPX.applyLayoutOptions_(layoutOptions, flatCoordinates, ends);\n    var geometry = new ol.geom.MultiLineString(null);\n    geometry.setFlatCoordinates(layout, flatCoordinates, ends);\n    ol.format.Feature.transformWithOptions(geometry, false, options);\n    var feature = new ol.Feature(geometry);\n    feature.setProperties(values);\n    return feature;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.Feature|undefined} Waypoint.\n   */\n  ol.format.GPX.readWpt_ = function(node, objectStack) {\n    var options = /** @type {olx.format.ReadOptions} */ (objectStack[0]);\n    var values = ol.xml.pushParseAndPop(\n        {}, ol.format.GPX.WPT_PARSERS_, node, objectStack);\n    if (!values) {\n      return undefined;\n    }\n    var layoutOptions = /** @type {ol.LayoutOptions} */ ({});\n    var coordinates = ol.format.GPX.appendCoordinate_([], layoutOptions, node, values);\n    var layout = ol.format.GPX.applyLayoutOptions_(layoutOptions, coordinates);\n    var geometry = new ol.geom.Point(coordinates, layout);\n    ol.format.Feature.transformWithOptions(geometry, false, options);\n    var feature = new ol.Feature(geometry);\n    feature.setProperties(values);\n    return feature;\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, function(Node, Array.<*>): (ol.Feature|undefined)>}\n   * @private\n   */\n  ol.format.GPX.FEATURE_READER_ = {\n    'rte': ol.format.GPX.readRte_,\n    'trk': ol.format.GPX.readTrk_,\n    'wpt': ol.format.GPX.readWpt_\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GPX.GPX_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'rte': ol.xml.makeArrayPusher(ol.format.GPX.readRte_),\n        'trk': ol.xml.makeArrayPusher(ol.format.GPX.readTrk_),\n        'wpt': ol.xml.makeArrayPusher(ol.format.GPX.readWpt_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GPX.LINK_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'text':\n            ol.xml.makeObjectPropertySetter(ol.format.XSD.readString, 'linkText'),\n        'type':\n            ol.xml.makeObjectPropertySetter(ol.format.XSD.readString, 'linkType')\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GPX.RTE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'name': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'cmt': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'desc': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'src': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'link': ol.format.GPX.parseLink_,\n        'number':\n            ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),\n        'extensions': ol.format.GPX.parseExtensions_,\n        'type': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'rtept': ol.format.GPX.parseRtePt_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GPX.RTEPT_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'ele': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'time': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GPX.TRK_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'name': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'cmt': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'desc': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'src': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'link': ol.format.GPX.parseLink_,\n        'number':\n            ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),\n        'type': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'extensions': ol.format.GPX.parseExtensions_,\n        'trkseg': ol.format.GPX.parseTrkSeg_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GPX.TRKSEG_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'trkpt': ol.format.GPX.parseTrkPt_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GPX.TRKPT_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'ele': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'time': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.GPX.WPT_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'ele': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'time': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime),\n        'magvar': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'geoidheight': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'name': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'cmt': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'desc': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'src': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'link': ol.format.GPX.parseLink_,\n        'sym': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'type': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'fix': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'sat': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'hdop': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'vdop': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'pdop': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'ageofdgpsdata':\n            ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'dgpsid':\n            ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger),\n        'extensions': ol.format.GPX.parseExtensions_\n      });\n  \n  \n  /**\n   * @param {Array.<ol.Feature>} features List of features.\n   * @private\n   */\n  ol.format.GPX.prototype.handleReadExtensions_ = function(features) {\n    if (!features) {\n      features = [];\n    }\n    for (var i = 0, ii = features.length; i < ii; ++i) {\n      var feature = features[i];\n      if (this.readExtensions_) {\n        var extensionsNode = feature.get('extensionsNode_') || null;\n        this.readExtensions_(feature, extensionsNode);\n      }\n      feature.set('extensionsNode_', undefined);\n    }\n  };\n  \n  \n  /**\n   * Read the first feature from a GPX source.\n   * Routes (`<rte>`) are converted into LineString geometries, and tracks (`<trk>`)\n   * into MultiLineString. Any properties on route and track waypoints are ignored.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   * @api\n   */\n  ol.format.GPX.prototype.readFeature;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GPX.prototype.readFeatureFromNode = function(node, opt_options) {\n    if (!ol.array.includes(ol.format.GPX.NAMESPACE_URIS_, node.namespaceURI)) {\n      return null;\n    }\n    var featureReader = ol.format.GPX.FEATURE_READER_[node.localName];\n    if (!featureReader) {\n      return null;\n    }\n    var feature = featureReader(node, [this.getReadOptions(node, opt_options)]);\n    if (!feature) {\n      return null;\n    }\n    this.handleReadExtensions_([feature]);\n    return feature;\n  };\n  \n  \n  /**\n   * Read all features from a GPX source.\n   * Routes (`<rte>`) are converted into LineString geometries, and tracks (`<trk>`)\n   * into MultiLineString. Any properties on route and track waypoints are ignored.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.GPX.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.GPX.prototype.readFeaturesFromNode = function(node, opt_options) {\n    if (!ol.array.includes(ol.format.GPX.NAMESPACE_URIS_, node.namespaceURI)) {\n      return [];\n    }\n    if (node.localName == 'gpx') {\n      /** @type {Array.<ol.Feature>} */\n      var features = ol.xml.pushParseAndPop([], ol.format.GPX.GPX_PARSERS_,\n          node, [this.getReadOptions(node, opt_options)]);\n      if (features) {\n        this.handleReadExtensions_(features);\n        return features;\n      } else {\n        return [];\n      }\n    }\n    return [];\n  };\n  \n  \n  /**\n   * Read the projection from a GPX source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.format.GPX.prototype.readProjection;\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {string} value Value for the link's `href` attribute.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.GPX.writeLink_ = function(node, value, objectStack) {\n    node.setAttribute('href', value);\n    var context = objectStack[objectStack.length - 1];\n    var properties = context['properties'];\n    var link = [\n      properties['linkText'],\n      properties['linkType']\n    ];\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */ ({node: node}),\n        ol.format.GPX.LINK_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,\n        link, objectStack, ol.format.GPX.LINK_SEQUENCE_);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.writeWptType_ = function(node, coordinate, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var parentNode = context.node;\n    var namespaceURI = parentNode.namespaceURI;\n    var properties = context['properties'];\n    //FIXME Projection handling\n    ol.xml.setAttributeNS(node, null, 'lat', coordinate[1]);\n    ol.xml.setAttributeNS(node, null, 'lon', coordinate[0]);\n    var geometryLayout = context['geometryLayout'];\n    switch (geometryLayout) {\n      case ol.geom.GeometryLayout.XYZM:\n        if (coordinate[3] !== 0) {\n          properties['time'] = coordinate[3];\n        }\n        // fall through\n      case ol.geom.GeometryLayout.XYZ:\n        if (coordinate[2] !== 0) {\n          properties['ele'] = coordinate[2];\n        }\n        break;\n      case ol.geom.GeometryLayout.XYM:\n        if (coordinate[2] !== 0) {\n          properties['time'] = coordinate[2];\n        }\n        break;\n      default:\n        // pass\n    }\n    var orderedKeys = (node.nodeName == 'rtept') ?\n      ol.format.GPX.RTEPT_TYPE_SEQUENCE_[namespaceURI] :\n      ol.format.GPX.WPT_TYPE_SEQUENCE_[namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        ({node: node, 'properties': properties}),\n        ol.format.GPX.WPT_TYPE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,\n        values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.writeRte_ = function(node, feature, objectStack) {\n    var options = /** @type {olx.format.WriteOptions} */ (objectStack[0]);\n    var properties = feature.getProperties();\n    var context = {node: node, 'properties': properties};\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      geometry = /** @type {ol.geom.LineString} */\n        (ol.format.Feature.transformWithOptions(geometry, true, options));\n      context['geometryLayout'] = geometry.getLayout();\n      properties['rtept'] = geometry.getCoordinates();\n    }\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = ol.format.GPX.RTE_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context,\n        ol.format.GPX.RTE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,\n        values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.writeTrk_ = function(node, feature, objectStack) {\n    var options = /** @type {olx.format.WriteOptions} */ (objectStack[0]);\n    var properties = feature.getProperties();\n    /** @type {ol.XmlNodeStackItem} */\n    var context = {node: node, 'properties': properties};\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      geometry = /** @type {ol.geom.MultiLineString} */\n        (ol.format.Feature.transformWithOptions(geometry, true, options));\n      properties['trkseg'] = geometry.getLineStrings();\n    }\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = ol.format.GPX.TRK_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context,\n        ol.format.GPX.TRK_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,\n        values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LineString} lineString LineString.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.writeTrkSeg_ = function(node, lineString, objectStack) {\n    /** @type {ol.XmlNodeStackItem} */\n    var context = {node: node, 'geometryLayout': lineString.getLayout(),\n      'properties': {}};\n    ol.xml.pushSerializeAndPop(context,\n        ol.format.GPX.TRKSEG_SERIALIZERS_, ol.format.GPX.TRKSEG_NODE_FACTORY_,\n        lineString.getCoordinates(), objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.GPX.writeWpt_ = function(node, feature, objectStack) {\n    var options = /** @type {olx.format.WriteOptions} */ (objectStack[0]);\n    var context = objectStack[objectStack.length - 1];\n    context['properties'] = feature.getProperties();\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      geometry = /** @type {ol.geom.Point} */\n        (ol.format.Feature.transformWithOptions(geometry, true, options));\n      context['geometryLayout'] = geometry.getLayout();\n      ol.format.GPX.writeWptType_(node, geometry.getCoordinates(), objectStack);\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Array.<string>}\n   * @private\n   */\n  ol.format.GPX.LINK_SEQUENCE_ = ['text', 'type'];\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GPX.LINK_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'text': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'type': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.GPX.RTE_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, [\n        'name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'rtept'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GPX.RTE_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'name': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'cmt': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'desc': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'src': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'link': ol.xml.makeChildAppender(ol.format.GPX.writeLink_),\n        'number': ol.xml.makeChildAppender(\n            ol.format.XSD.writeNonNegativeIntegerTextNode),\n        'type': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'rtept': ol.xml.makeArraySerializer(ol.xml.makeChildAppender(\n            ol.format.GPX.writeWptType_))\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.GPX.RTEPT_TYPE_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, [\n        'ele', 'time'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.GPX.TRK_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, [\n        'name', 'cmt', 'desc', 'src', 'link', 'number', 'type', 'trkseg'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GPX.TRK_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'name': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'cmt': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'desc': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'src': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'link': ol.xml.makeChildAppender(ol.format.GPX.writeLink_),\n        'number': ol.xml.makeChildAppender(\n            ol.format.XSD.writeNonNegativeIntegerTextNode),\n        'type': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'trkseg': ol.xml.makeArraySerializer(ol.xml.makeChildAppender(\n            ol.format.GPX.writeTrkSeg_))\n      });\n  \n  \n  /**\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   * @private\n   */\n  ol.format.GPX.TRKSEG_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory('trkpt');\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GPX.TRKSEG_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'trkpt': ol.xml.makeChildAppender(ol.format.GPX.writeWptType_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.GPX.WPT_TYPE_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, [\n        'ele', 'time', 'magvar', 'geoidheight', 'name', 'cmt', 'desc', 'src',\n        'link', 'sym', 'type', 'fix', 'sat', 'hdop', 'vdop', 'pdop',\n        'ageofdgpsdata', 'dgpsid'\n      ]);\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GPX.WPT_TYPE_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'ele': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n        'time': ol.xml.makeChildAppender(ol.format.XSD.writeDateTimeTextNode),\n        'magvar': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n        'geoidheight': ol.xml.makeChildAppender(\n            ol.format.XSD.writeDecimalTextNode),\n        'name': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'cmt': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'desc': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'src': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'link': ol.xml.makeChildAppender(ol.format.GPX.writeLink_),\n        'sym': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'type': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'fix': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'sat': ol.xml.makeChildAppender(\n            ol.format.XSD.writeNonNegativeIntegerTextNode),\n        'hdop': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n        'vdop': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n        'pdop': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n        'ageofdgpsdata': ol.xml.makeChildAppender(\n            ol.format.XSD.writeDecimalTextNode),\n        'dgpsid': ol.xml.makeChildAppender(\n            ol.format.XSD.writeNonNegativeIntegerTextNode)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, string>}\n   * @private\n   */\n  ol.format.GPX.GEOMETRY_TYPE_TO_NODENAME_ = {\n    'Point': 'wpt',\n    'LineString': 'rte',\n    'MultiLineString': 'trk'\n  };\n  \n  \n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  ol.format.GPX.GPX_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var geometry = /** @type {ol.Feature} */ (value).getGeometry();\n    if (geometry) {\n      var nodeName = ol.format.GPX.GEOMETRY_TYPE_TO_NODENAME_[geometry.getType()];\n      if (nodeName) {\n        var parentNode = objectStack[objectStack.length - 1].node;\n        return ol.xml.createElementNS(parentNode.namespaceURI, nodeName);\n      }\n    }\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.GPX.GPX_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.GPX.NAMESPACE_URIS_, {\n        'rte': ol.xml.makeChildAppender(ol.format.GPX.writeRte_),\n        'trk': ol.xml.makeChildAppender(ol.format.GPX.writeTrk_),\n        'wpt': ol.xml.makeChildAppender(ol.format.GPX.writeWpt_)\n      });\n  \n  \n  /**\n   * Encode an array of features in the GPX format.\n   * LineString geometries are output as routes (`<rte>`), and MultiLineString\n   * as tracks (`<trk>`).\n   *\n   * @function\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} Result.\n   * @api\n   */\n  ol.format.GPX.prototype.writeFeatures;\n  \n  \n  /**\n   * Encode an array of features in the GPX format as an XML node.\n   * LineString geometries are output as routes (`<rte>`), and MultiLineString\n   * as tracks (`<trk>`).\n   *\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n  ol.format.GPX.prototype.writeFeaturesNode = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    //FIXME Serialize metadata\n    var gpx = ol.xml.createElementNS('http://www.topografix.com/GPX/1/1', 'gpx');\n    var xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    var xmlSchemaInstanceUri = 'http://www.w3.org/2001/XMLSchema-instance';\n    ol.xml.setAttributeNS(gpx, xmlnsUri, 'xmlns:xsi', xmlSchemaInstanceUri);\n    ol.xml.setAttributeNS(gpx, xmlSchemaInstanceUri, 'xsi:schemaLocation',\n        ol.format.GPX.SCHEMA_LOCATION_);\n    gpx.setAttribute('version', '1.1');\n    gpx.setAttribute('creator', 'OpenLayers');\n  \n    ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */\n        ({node: gpx}), ol.format.GPX.GPX_SERIALIZERS_,\n        ol.format.GPX.GPX_NODE_FACTORY_, features, [opt_options]);\n    return gpx;\n  };\n  \n  goog.provide('ol.format.IGCZ');\n  \n  /**\n   * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n   * @enum {string}\n   */\n  ol.format.IGCZ = {\n    BAROMETRIC: 'barometric',\n    GPS: 'gps',\n    NONE: 'none'\n  };\n  \n  goog.provide('ol.format.TextFeature');\n  \n  goog.require('ol');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.FormatType');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Base class for text feature formats.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.format.Feature}\n   */\n  ol.format.TextFeature = function() {\n    ol.format.Feature.call(this);\n  };\n  ol.inherits(ol.format.TextFeature, ol.format.Feature);\n  \n  \n  /**\n   * @param {Document|Node|Object|string} source Source.\n   * @private\n   * @return {string} Text.\n   */\n  ol.format.TextFeature.prototype.getText_ = function(source) {\n    if (typeof source === 'string') {\n      return source;\n    } else {\n      return '';\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TextFeature.prototype.getType = function() {\n    return ol.format.FormatType.TEXT;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TextFeature.prototype.readFeature = function(source, opt_options) {\n    return this.readFeatureFromText(\n        this.getText_(source), this.adaptOptions(opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {ol.Feature} Feature.\n   */\n  ol.format.TextFeature.prototype.readFeatureFromText = function(text, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TextFeature.prototype.readFeatures = function(source, opt_options) {\n    return this.readFeaturesFromText(\n        this.getText_(source), this.adaptOptions(opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {Array.<ol.Feature>} Features.\n   */\n  ol.format.TextFeature.prototype.readFeaturesFromText = function(text, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TextFeature.prototype.readGeometry = function(source, opt_options) {\n    return this.readGeometryFromText(\n        this.getText_(source), this.adaptOptions(opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {ol.geom.Geometry} Geometry.\n   */\n  ol.format.TextFeature.prototype.readGeometryFromText = function(text, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TextFeature.prototype.readProjection = function(source) {\n    return this.readProjectionFromText(this.getText_(source));\n  };\n  \n  \n  /**\n   * @param {string} text Text.\n   * @protected\n   * @return {ol.proj.Projection} Projection.\n   */\n  ol.format.TextFeature.prototype.readProjectionFromText = function(text) {\n    return this.defaultDataProjection;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TextFeature.prototype.writeFeature = function(feature, opt_options) {\n    return this.writeFeatureText(feature, this.adaptOptions(opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {ol.Feature} feature Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  ol.format.TextFeature.prototype.writeFeatureText = function(feature, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TextFeature.prototype.writeFeatures = function(\n      features, opt_options) {\n    return this.writeFeaturesText(features, this.adaptOptions(opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  ol.format.TextFeature.prototype.writeFeaturesText = function(features, opt_options) {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TextFeature.prototype.writeGeometry = function(\n      geometry, opt_options) {\n    return this.writeGeometryText(geometry, this.adaptOptions(opt_options));\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  ol.format.TextFeature.prototype.writeGeometryText = function(geometry, opt_options) {};\n  \n  goog.provide('ol.format.IGC');\n  \n  goog.require('ol');\n  goog.require('ol.Feature');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.IGCZ');\n  goog.require('ol.format.TextFeature');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for `*.igc` flight recording files.\n   *\n   * @constructor\n   * @extends {ol.format.TextFeature}\n   * @param {olx.format.IGCOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.IGC = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.format.TextFeature.call(this);\n  \n    /**\n     * @inheritDoc\n     */\n    this.defaultDataProjection = ol.proj.get('EPSG:4326');\n  \n    /**\n     * @private\n     * @type {ol.format.IGCZ}\n     */\n    this.altitudeMode_ = options.altitudeMode ?\n      options.altitudeMode : ol.format.IGCZ.NONE;\n  \n  };\n  ol.inherits(ol.format.IGC, ol.format.TextFeature);\n  \n  \n  /**\n   * @const\n   * @type {RegExp}\n   * @private\n   */\n  ol.format.IGC.B_RECORD_RE_ =\n      /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n  \n  \n  /**\n   * @const\n   * @type {RegExp}\n   * @private\n   */\n  ol.format.IGC.H_RECORD_RE_ = /^H.([A-Z]{3}).*?:(.*)/;\n  \n  \n  /**\n   * @const\n   * @type {RegExp}\n   * @private\n   */\n  ol.format.IGC.HFDTE_RECORD_RE_ = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n  \n  \n  /**\n   * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n   *\n   * @const\n   * @type {RegExp}\n   * @private\n   */\n  ol.format.IGC.NEWLINE_RE_ = /\\r\\n|\\r|\\n/;\n  \n  \n  /**\n   * Read the feature from the IGC source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   * @api\n   */\n  ol.format.IGC.prototype.readFeature;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.IGC.prototype.readFeatureFromText = function(text, opt_options) {\n    var altitudeMode = this.altitudeMode_;\n    var lines = text.split(ol.format.IGC.NEWLINE_RE_);\n    /** @type {Object.<string, string>} */\n    var properties = {};\n    var flatCoordinates = [];\n    var year = 2000;\n    var month = 0;\n    var day = 1;\n    var lastDateTime = -1;\n    var i, ii;\n    for (i = 0, ii = lines.length; i < ii; ++i) {\n      var line = lines[i];\n      var m;\n      if (line.charAt(0) == 'B') {\n        m = ol.format.IGC.B_RECORD_RE_.exec(line);\n        if (m) {\n          var hour = parseInt(m[1], 10);\n          var minute = parseInt(m[2], 10);\n          var second = parseInt(m[3], 10);\n          var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n          if (m[6] == 'S') {\n            y = -y;\n          }\n          var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n          if (m[9] == 'W') {\n            x = -x;\n          }\n          flatCoordinates.push(x, y);\n          if (altitudeMode != ol.format.IGCZ.NONE) {\n            var z;\n            if (altitudeMode == ol.format.IGCZ.GPS) {\n              z = parseInt(m[11], 10);\n            } else if (altitudeMode == ol.format.IGCZ.BAROMETRIC) {\n              z = parseInt(m[12], 10);\n            } else {\n              z = 0;\n            }\n            flatCoordinates.push(z);\n          }\n          var dateTime = Date.UTC(year, month, day, hour, minute, second);\n          // Detect UTC midnight wrap around.\n          if (dateTime < lastDateTime) {\n            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n          }\n          flatCoordinates.push(dateTime / 1000);\n          lastDateTime = dateTime;\n        }\n      } else if (line.charAt(0) == 'H') {\n        m = ol.format.IGC.HFDTE_RECORD_RE_.exec(line);\n        if (m) {\n          day = parseInt(m[1], 10);\n          month = parseInt(m[2], 10) - 1;\n          year = 2000 + parseInt(m[3], 10);\n        } else {\n          m = ol.format.IGC.H_RECORD_RE_.exec(line);\n          if (m) {\n            properties[m[1]] = m[2].trim();\n          }\n        }\n      }\n    }\n    if (flatCoordinates.length === 0) {\n      return null;\n    }\n    var lineString = new ol.geom.LineString(null);\n    var layout = altitudeMode == ol.format.IGCZ.NONE ?\n      ol.geom.GeometryLayout.XYM : ol.geom.GeometryLayout.XYZM;\n    lineString.setFlatCoordinates(layout, flatCoordinates);\n    var feature = new ol.Feature(ol.format.Feature.transformWithOptions(\n        lineString, false, opt_options));\n    feature.setProperties(properties);\n    return feature;\n  };\n  \n  \n  /**\n   * Read the feature from the source. As IGC sources contain a single\n   * feature, this will return the feature in an array.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.IGC.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.IGC.prototype.readFeaturesFromText = function(text, opt_options) {\n    var feature = this.readFeatureFromText(text, opt_options);\n    if (feature) {\n      return [feature];\n    } else {\n      return [];\n    }\n  };\n  \n  \n  /**\n   * Read the projection from the IGC source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.format.IGC.prototype.readProjection;\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.IGC.prototype.writeFeatureText = function(feature, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.IGC.prototype.writeFeaturesText = function(features, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.IGC.prototype.writeGeometryText = function(geometry, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.IGC.prototype.readGeometryFromText = function(text, opt_options) {};\n  \n  goog.provide('ol.style.IconAnchorUnits');\n  \n  /**\n   * Icon anchor units. One of 'fraction', 'pixels'.\n   * @enum {string}\n   */\n  ol.style.IconAnchorUnits = {\n    FRACTION: 'fraction',\n    PIXELS: 'pixels'\n  };\n  \n  goog.provide('ol.style.IconImage');\n  \n  goog.require('ol');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventTarget');\n  goog.require('ol.events.EventType');\n  goog.require('ol.ImageState');\n  goog.require('ol.style');\n  \n  \n  /**\n   * @constructor\n   * @param {Image|HTMLCanvasElement} image Image.\n   * @param {string|undefined} src Src.\n   * @param {ol.Size} size Size.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {ol.ImageState} imageState Image state.\n   * @param {ol.Color} color Color.\n   * @extends {ol.events.EventTarget}\n   */\n  ol.style.IconImage = function(image, src, size, crossOrigin, imageState,\n      color) {\n  \n    ol.events.EventTarget.call(this);\n  \n    /**\n     * @private\n     * @type {Image|HTMLCanvasElement}\n     */\n    this.hitDetectionImage_ = null;\n  \n    /**\n     * @private\n     * @type {Image|HTMLCanvasElement}\n     */\n    this.image_ = !image ? new Image() : image;\n  \n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = color ?\n      /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS')) :\n      null;\n  \n    /**\n     * @private\n     * @type {ol.Color}\n     */\n    this.color_ = color;\n  \n    /**\n     * @private\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.imageListenerKeys_ = null;\n  \n    /**\n     * @private\n     * @type {ol.ImageState}\n     */\n    this.imageState_ = imageState;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.size_ = size;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.src_ = src;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.tainting_ = false;\n    if (this.imageState_ == ol.ImageState.LOADED) {\n      this.determineTainting_();\n    }\n  \n  };\n  ol.inherits(ol.style.IconImage, ol.events.EventTarget);\n  \n  \n  /**\n   * @param {Image|HTMLCanvasElement} image Image.\n   * @param {string} src Src.\n   * @param {ol.Size} size Size.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {ol.ImageState} imageState Image state.\n   * @param {ol.Color} color Color.\n   * @return {ol.style.IconImage} Icon image.\n   */\n  ol.style.IconImage.get = function(image, src, size, crossOrigin, imageState,\n      color) {\n    var iconImageCache = ol.style.iconImageCache;\n    var iconImage = iconImageCache.get(src, crossOrigin, color);\n    if (!iconImage) {\n      iconImage = new ol.style.IconImage(\n          image, src, size, crossOrigin, imageState, color);\n      iconImageCache.set(src, crossOrigin, color, iconImage);\n    }\n    return iconImage;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.style.IconImage.prototype.determineTainting_ = function() {\n    var context = ol.dom.createCanvasContext2D(1, 1);\n    try {\n      context.drawImage(this.image_, 0, 0);\n      context.getImageData(0, 0, 1, 1);\n    } catch (e) {\n      this.tainting_ = true;\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.style.IconImage.prototype.dispatchChangeEvent_ = function() {\n    this.dispatchEvent(ol.events.EventType.CHANGE);\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.style.IconImage.prototype.handleImageError_ = function() {\n    this.imageState_ = ol.ImageState.ERROR;\n    this.unlistenImage_();\n    this.dispatchChangeEvent_();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.style.IconImage.prototype.handleImageLoad_ = function() {\n    this.imageState_ = ol.ImageState.LOADED;\n    if (this.size_) {\n      this.image_.width = this.size_[0];\n      this.image_.height = this.size_[1];\n    }\n    this.size_ = [this.image_.width, this.image_.height];\n    this.unlistenImage_();\n    this.determineTainting_();\n    this.replaceColor_();\n    this.dispatchChangeEvent_();\n  };\n  \n  \n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {Image|HTMLCanvasElement} Image or Canvas element.\n   */\n  ol.style.IconImage.prototype.getImage = function(pixelRatio) {\n    return this.canvas_ ? this.canvas_ : this.image_;\n  };\n  \n  \n  /**\n   * @return {ol.ImageState} Image state.\n   */\n  ol.style.IconImage.prototype.getImageState = function() {\n    return this.imageState_;\n  };\n  \n  \n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {Image|HTMLCanvasElement} Image element.\n   */\n  ol.style.IconImage.prototype.getHitDetectionImage = function(pixelRatio) {\n    if (!this.hitDetectionImage_) {\n      if (this.tainting_) {\n        var width = this.size_[0];\n        var height = this.size_[1];\n        var context = ol.dom.createCanvasContext2D(width, height);\n        context.fillRect(0, 0, width, height);\n        this.hitDetectionImage_ = context.canvas;\n      } else {\n        this.hitDetectionImage_ = this.image_;\n      }\n    }\n    return this.hitDetectionImage_;\n  };\n  \n  \n  /**\n   * @return {ol.Size} Image size.\n   */\n  ol.style.IconImage.prototype.getSize = function() {\n    return this.size_;\n  };\n  \n  \n  /**\n   * @return {string|undefined} Image src.\n   */\n  ol.style.IconImage.prototype.getSrc = function() {\n    return this.src_;\n  };\n  \n  \n  /**\n   * Load not yet loaded URI.\n   */\n  ol.style.IconImage.prototype.load = function() {\n    if (this.imageState_ == ol.ImageState.IDLE) {\n      this.imageState_ = ol.ImageState.LOADING;\n      this.imageListenerKeys_ = [\n        ol.events.listenOnce(this.image_, ol.events.EventType.ERROR,\n            this.handleImageError_, this),\n        ol.events.listenOnce(this.image_, ol.events.EventType.LOAD,\n            this.handleImageLoad_, this)\n      ];\n      try {\n        this.image_.src = this.src_;\n      } catch (e) {\n        this.handleImageError_();\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.style.IconImage.prototype.replaceColor_ = function() {\n    if (this.tainting_ || this.color_ === null) {\n      return;\n    }\n  \n    this.canvas_.width = this.image_.width;\n    this.canvas_.height = this.image_.height;\n  \n    var ctx = this.canvas_.getContext('2d');\n    ctx.drawImage(this.image_, 0, 0);\n  \n    var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);\n    var data = imgData.data;\n    var r = this.color_[0] / 255.0;\n    var g = this.color_[1] / 255.0;\n    var b = this.color_[2] / 255.0;\n  \n    for (var i = 0, ii = data.length; i < ii; i += 4) {\n      data[i] *= r;\n      data[i + 1] *= g;\n      data[i + 2] *= b;\n    }\n    ctx.putImageData(imgData, 0, 0);\n  };\n  \n  \n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  ol.style.IconImage.prototype.unlistenImage_ = function() {\n    this.imageListenerKeys_.forEach(ol.events.unlistenByKey);\n    this.imageListenerKeys_ = null;\n  };\n  \n  goog.provide('ol.style.IconOrigin');\n  \n  /**\n   * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.\n   * @enum {string}\n   */\n  ol.style.IconOrigin = {\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_RIGHT: 'bottom-right',\n    TOP_LEFT: 'top-left',\n    TOP_RIGHT: 'top-right'\n  };\n  \n  goog.provide('ol.style.Icon');\n  \n  goog.require('ol');\n  goog.require('ol.ImageState');\n  goog.require('ol.asserts');\n  goog.require('ol.color');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.style.IconAnchorUnits');\n  goog.require('ol.style.IconImage');\n  goog.require('ol.style.IconOrigin');\n  goog.require('ol.style.Image');\n  \n  \n  /**\n   * @classdesc\n   * Set icon style for vector features.\n   *\n   * @constructor\n   * @param {olx.style.IconOptions=} opt_options Options.\n   * @extends {ol.style.Image}\n   * @api\n   */\n  ol.style.Icon = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.normalizedAnchor_ = null;\n  \n    /**\n     * @private\n     * @type {ol.style.IconOrigin}\n     */\n    this.anchorOrigin_ = options.anchorOrigin !== undefined ?\n      options.anchorOrigin : ol.style.IconOrigin.TOP_LEFT;\n  \n    /**\n     * @private\n     * @type {ol.style.IconAnchorUnits}\n     */\n    this.anchorXUnits_ = options.anchorXUnits !== undefined ?\n      options.anchorXUnits : ol.style.IconAnchorUnits.FRACTION;\n  \n    /**\n     * @private\n     * @type {ol.style.IconAnchorUnits}\n     */\n    this.anchorYUnits_ = options.anchorYUnits !== undefined ?\n      options.anchorYUnits : ol.style.IconAnchorUnits.FRACTION;\n  \n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n        options.crossOrigin !== undefined ? options.crossOrigin : null;\n  \n    /**\n     * @type {Image|HTMLCanvasElement}\n     */\n    var image = options.img !== undefined ? options.img : null;\n  \n    /**\n     * @type {ol.Size}\n     */\n    var imgSize = options.imgSize !== undefined ? options.imgSize : null;\n  \n    /**\n     * @type {string|undefined}\n     */\n    var src = options.src;\n  \n    ol.asserts.assert(!(src !== undefined && image),\n        4); // `image` and `src` cannot be provided at the same time\n    ol.asserts.assert(!image || (image && imgSize),\n        5); // `imgSize` must be set when `image` is provided\n  \n    if ((src === undefined || src.length === 0) && image) {\n      src = image.src || ol.getUid(image).toString();\n    }\n    ol.asserts.assert(src !== undefined && src.length > 0,\n        6); // A defined and non-empty `src` or `image` must be provided\n  \n    /**\n     * @type {ol.ImageState}\n     */\n    var imageState = options.src !== undefined ?\n      ol.ImageState.IDLE : ol.ImageState.LOADED;\n  \n    /**\n     * @private\n     * @type {ol.Color}\n     */\n    this.color_ = options.color !== undefined ? ol.color.asArray(options.color) :\n      null;\n  \n    /**\n     * @private\n     * @type {ol.style.IconImage}\n     */\n    this.iconImage_ = ol.style.IconImage.get(\n        image, /** @type {string} */ (src), imgSize, this.crossOrigin_, imageState, this.color_);\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.offset_ = options.offset !== undefined ? options.offset : [0, 0];\n  \n    /**\n     * @private\n     * @type {ol.style.IconOrigin}\n     */\n    this.offsetOrigin_ = options.offsetOrigin !== undefined ?\n      options.offsetOrigin : ol.style.IconOrigin.TOP_LEFT;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.origin_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.size_ = options.size !== undefined ? options.size : null;\n  \n    /**\n     * @type {number}\n     */\n    var opacity = options.opacity !== undefined ? options.opacity : 1;\n  \n    /**\n     * @type {boolean}\n     */\n    var rotateWithView = options.rotateWithView !== undefined ?\n      options.rotateWithView : false;\n  \n    /**\n     * @type {number}\n     */\n    var rotation = options.rotation !== undefined ? options.rotation : 0;\n  \n    /**\n     * @type {number}\n     */\n    var scale = options.scale !== undefined ? options.scale : 1;\n  \n    /**\n     * @type {boolean}\n     */\n    var snapToPixel = options.snapToPixel !== undefined ?\n      options.snapToPixel : true;\n  \n    ol.style.Image.call(this, {\n      opacity: opacity,\n      rotation: rotation,\n      scale: scale,\n      snapToPixel: snapToPixel,\n      rotateWithView: rotateWithView\n    });\n  \n  };\n  ol.inherits(ol.style.Icon, ol.style.Image);\n  \n  \n  /**\n   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.\n   * @return {ol.style.Icon} The cloned style.\n   * @api\n   */\n  ol.style.Icon.prototype.clone = function() {\n    return new ol.style.Icon({\n      anchor: this.anchor_.slice(),\n      anchorOrigin: this.anchorOrigin_,\n      anchorXUnits: this.anchorXUnits_,\n      anchorYUnits: this.anchorYUnits_,\n      crossOrigin: this.crossOrigin_,\n      color: (this.color_ && this.color_.slice) ? this.color_.slice() : this.color_ || undefined,\n      src: this.getSrc(),\n      offset: this.offset_.slice(),\n      offsetOrigin: this.offsetOrigin_,\n      size: this.size_ !== null ? this.size_.slice() : undefined,\n      opacity: this.getOpacity(),\n      scale: this.getScale(),\n      snapToPixel: this.getSnapToPixel(),\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView()\n    });\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.style.Icon.prototype.getAnchor = function() {\n    if (this.normalizedAnchor_) {\n      return this.normalizedAnchor_;\n    }\n    var anchor = this.anchor_;\n    var size = this.getSize();\n    if (this.anchorXUnits_ == ol.style.IconAnchorUnits.FRACTION ||\n        this.anchorYUnits_ == ol.style.IconAnchorUnits.FRACTION) {\n      if (!size) {\n        return null;\n      }\n      anchor = this.anchor_.slice();\n      if (this.anchorXUnits_ == ol.style.IconAnchorUnits.FRACTION) {\n        anchor[0] *= size[0];\n      }\n      if (this.anchorYUnits_ == ol.style.IconAnchorUnits.FRACTION) {\n        anchor[1] *= size[1];\n      }\n    }\n  \n    if (this.anchorOrigin_ != ol.style.IconOrigin.TOP_LEFT) {\n      if (!size) {\n        return null;\n      }\n      if (anchor === this.anchor_) {\n        anchor = this.anchor_.slice();\n      }\n      if (this.anchorOrigin_ == ol.style.IconOrigin.TOP_RIGHT ||\n          this.anchorOrigin_ == ol.style.IconOrigin.BOTTOM_RIGHT) {\n        anchor[0] = -anchor[0] + size[0];\n      }\n      if (this.anchorOrigin_ == ol.style.IconOrigin.BOTTOM_LEFT ||\n          this.anchorOrigin_ == ol.style.IconOrigin.BOTTOM_RIGHT) {\n        anchor[1] = -anchor[1] + size[1];\n      }\n    }\n    this.normalizedAnchor_ = anchor;\n    return this.normalizedAnchor_;\n  };\n  \n  \n  /**\n   * Get the icon color.\n   * @return {ol.Color} Color.\n   * @api\n   */\n  ol.style.Icon.prototype.getColor = function() {\n    return this.color_;\n  };\n  \n  \n  /**\n   * Get the image icon.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {Image|HTMLCanvasElement} Image or Canvas element.\n   * @override\n   * @api\n   */\n  ol.style.Icon.prototype.getImage = function(pixelRatio) {\n    return this.iconImage_.getImage(pixelRatio);\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.style.Icon.prototype.getImageSize = function() {\n    return this.iconImage_.getSize();\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.style.Icon.prototype.getHitDetectionImageSize = function() {\n    return this.getImageSize();\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.style.Icon.prototype.getImageState = function() {\n    return this.iconImage_.getImageState();\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.style.Icon.prototype.getHitDetectionImage = function(pixelRatio) {\n    return this.iconImage_.getHitDetectionImage(pixelRatio);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.style.Icon.prototype.getOrigin = function() {\n    if (this.origin_) {\n      return this.origin_;\n    }\n    var offset = this.offset_;\n  \n    if (this.offsetOrigin_ != ol.style.IconOrigin.TOP_LEFT) {\n      var size = this.getSize();\n      var iconImageSize = this.iconImage_.getSize();\n      if (!size || !iconImageSize) {\n        return null;\n      }\n      offset = offset.slice();\n      if (this.offsetOrigin_ == ol.style.IconOrigin.TOP_RIGHT ||\n          this.offsetOrigin_ == ol.style.IconOrigin.BOTTOM_RIGHT) {\n        offset[0] = iconImageSize[0] - size[0] - offset[0];\n      }\n      if (this.offsetOrigin_ == ol.style.IconOrigin.BOTTOM_LEFT ||\n          this.offsetOrigin_ == ol.style.IconOrigin.BOTTOM_RIGHT) {\n        offset[1] = iconImageSize[1] - size[1] - offset[1];\n      }\n    }\n    this.origin_ = offset;\n    return this.origin_;\n  };\n  \n  \n  /**\n   * Get the image URL.\n   * @return {string|undefined} Image src.\n   * @api\n   */\n  ol.style.Icon.prototype.getSrc = function() {\n    return this.iconImage_.getSrc();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.style.Icon.prototype.getSize = function() {\n    return !this.size_ ? this.iconImage_.getSize() : this.size_;\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.style.Icon.prototype.listenImageChange = function(listener, thisArg) {\n    return ol.events.listen(this.iconImage_, ol.events.EventType.CHANGE,\n        listener, thisArg);\n  };\n  \n  \n  /**\n   * Load not yet loaded URI.\n   * When rendering a feature with an icon style, the vector renderer will\n   * automatically call this method. However, you might want to call this\n   * method yourself for preloading or other purposes.\n   * @override\n   * @api\n   */\n  ol.style.Icon.prototype.load = function() {\n    this.iconImage_.load();\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.style.Icon.prototype.unlistenImageChange = function(listener, thisArg) {\n    ol.events.unlisten(this.iconImage_, ol.events.EventType.CHANGE,\n        listener, thisArg);\n  };\n  \n  goog.provide('ol.style.Text');\n  \n  \n  goog.require('ol.style.Fill');\n  goog.require('ol.style.TextPlacement');\n  \n  \n  /**\n   * @classdesc\n   * Set text style for vector features.\n   *\n   * @constructor\n   * @param {olx.style.TextOptions=} opt_options Options.\n   * @api\n   */\n  ol.style.Text = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.font_ = options.font;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.rotation_ = options.rotation;\n  \n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.rotateWithView_ = options.rotateWithView;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.scale_ = options.scale;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.text_ = options.text;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.textAlign_ = options.textAlign;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.textBaseline_ = options.textBaseline;\n  \n    /**\n     * @private\n     * @type {ol.style.Fill}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill :\n      new ol.style.Fill({color: ol.style.Text.DEFAULT_FILL_COLOR_});\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;\n  \n    /**\n     * @private\n     * @type {ol.style.TextPlacement|string}\n     */\n    this.placement_ = options.placement !== undefined ? options.placement : ol.style.TextPlacement.POINT;\n  \n    //TODO Use options.overflow directly after removing @deprecated exceedLength\n    var overflow = options.overflow === undefined ? options.exceedLength : options.overflow;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overflow_ = overflow !== undefined ? overflow : false;\n  \n    /**\n     * @private\n     * @type {ol.style.Stroke}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;\n  \n    /**\n     * @private\n     * @type {ol.style.Fill}\n     */\n    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;\n  \n    /**\n     * @private\n     * @type {ol.style.Stroke}\n     */\n    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.padding_ = options.padding === undefined ? null : options.padding;\n  };\n  \n  \n  /**\n   * The default fill color to use if no fill was set at construction time; a\n   * blackish `#333`.\n   *\n   * @const {string}\n   * @private\n   */\n  ol.style.Text.DEFAULT_FILL_COLOR_ = '#333';\n  \n  \n  /**\n   * Clones the style.\n   * @return {ol.style.Text} The cloned style.\n   * @api\n   */\n  ol.style.Text.prototype.clone = function() {\n    return new ol.style.Text({\n      font: this.getFont(),\n      placement: this.getPlacement(),\n      maxAngle: this.getMaxAngle(),\n      overflow: this.getOverflow(),\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      scale: this.getScale(),\n      text: this.getText(),\n      textAlign: this.getTextAlign(),\n      textBaseline: this.getTextBaseline(),\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      offsetX: this.getOffsetX(),\n      offsetY: this.getOffsetY()\n    });\n  };\n  \n  \n  /**\n   * Get the `overflow` configuration.\n   * @return {boolean} Let text overflow the length of the path they follow.\n   * @api\n   */\n  ol.style.Text.prototype.getOverflow = function() {\n    return this.overflow_;\n  };\n  \n  \n  /**\n   * Get the font name.\n   * @return {string|undefined} Font.\n   * @api\n   */\n  ol.style.Text.prototype.getFont = function() {\n    return this.font_;\n  };\n  \n  \n  /**\n   * Get the maximum angle between adjacent characters.\n   * @return {number} Angle in radians.\n   * @api\n   */\n  ol.style.Text.prototype.getMaxAngle = function() {\n    return this.maxAngle_;\n  };\n  \n  \n  /**\n   * Get the label placement.\n   * @return {ol.style.TextPlacement|string} Text placement.\n   * @api\n   */\n  ol.style.Text.prototype.getPlacement = function() {\n    return this.placement_;\n  };\n  \n  \n  /**\n   * Get the x-offset for the text.\n   * @return {number} Horizontal text offset.\n   * @api\n   */\n  ol.style.Text.prototype.getOffsetX = function() {\n    return this.offsetX_;\n  };\n  \n  \n  /**\n   * Get the y-offset for the text.\n   * @return {number} Vertical text offset.\n   * @api\n   */\n  ol.style.Text.prototype.getOffsetY = function() {\n    return this.offsetY_;\n  };\n  \n  \n  /**\n   * Get the fill style for the text.\n   * @return {ol.style.Fill} Fill style.\n   * @api\n   */\n  ol.style.Text.prototype.getFill = function() {\n    return this.fill_;\n  };\n  \n  \n  /**\n   * Determine whether the text rotates with the map.\n   * @return {boolean|undefined} Rotate with map.\n   * @api\n   */\n  ol.style.Text.prototype.getRotateWithView = function() {\n    return this.rotateWithView_;\n  };\n  \n  \n  /**\n   * Get the text rotation.\n   * @return {number|undefined} Rotation.\n   * @api\n   */\n  ol.style.Text.prototype.getRotation = function() {\n    return this.rotation_;\n  };\n  \n  \n  /**\n   * Get the text scale.\n   * @return {number|undefined} Scale.\n   * @api\n   */\n  ol.style.Text.prototype.getScale = function() {\n    return this.scale_;\n  };\n  \n  \n  /**\n   * Get the stroke style for the text.\n   * @return {ol.style.Stroke} Stroke style.\n   * @api\n   */\n  ol.style.Text.prototype.getStroke = function() {\n    return this.stroke_;\n  };\n  \n  \n  /**\n   * Get the text to be rendered.\n   * @return {string|undefined} Text.\n   * @api\n   */\n  ol.style.Text.prototype.getText = function() {\n    return this.text_;\n  };\n  \n  \n  /**\n   * Get the text alignment.\n   * @return {string|undefined} Text align.\n   * @api\n   */\n  ol.style.Text.prototype.getTextAlign = function() {\n    return this.textAlign_;\n  };\n  \n  \n  /**\n   * Get the text baseline.\n   * @return {string|undefined} Text baseline.\n   * @api\n   */\n  ol.style.Text.prototype.getTextBaseline = function() {\n    return this.textBaseline_;\n  };\n  \n  \n  /**\n   * Get the background fill style for the text.\n   * @return {ol.style.Fill} Fill style.\n   * @api\n   */\n  ol.style.Text.prototype.getBackgroundFill = function() {\n    return this.backgroundFill_;\n  };\n  \n  \n  /**\n   * Get the background stroke style for the text.\n   * @return {ol.style.Stroke} Stroke style.\n   * @api\n   */\n  ol.style.Text.prototype.getBackgroundStroke = function() {\n    return this.backgroundStroke_;\n  };\n  \n  \n  /**\n   * Get the padding for the text.\n   * @return {Array.<number>} Padding.\n   * @api\n   */\n  ol.style.Text.prototype.getPadding = function() {\n    return this.padding_;\n  };\n  \n  \n  /**\n   * Set the `overflow` property.\n   *\n   * @param {boolean} overflow Let text overflow the path that it follows.\n   * @api\n   */\n  ol.style.Text.prototype.setOverflow = function(overflow) {\n    this.overflow_ = overflow;\n  };\n  \n  \n  /**\n   * Set the font.\n   *\n   * @param {string|undefined} font Font.\n   * @api\n   */\n  ol.style.Text.prototype.setFont = function(font) {\n    this.font_ = font;\n  };\n  \n  \n  /**\n   * Set the maximum angle between adjacent characters.\n   *\n   * @param {number} maxAngle Angle in radians.\n   * @api\n   */\n  ol.style.Text.prototype.setMaxAngle = function(maxAngle) {\n    this.maxAngle_ = maxAngle;\n  };\n  \n  \n  /**\n   * Set the x offset.\n   *\n   * @param {number} offsetX Horizontal text offset.\n   * @api\n   */\n  ol.style.Text.prototype.setOffsetX = function(offsetX) {\n    this.offsetX_ = offsetX;\n  };\n  \n  \n  /**\n   * Set the y offset.\n   *\n   * @param {number} offsetY Vertical text offset.\n   * @api\n   */\n  ol.style.Text.prototype.setOffsetY = function(offsetY) {\n    this.offsetY_ = offsetY;\n  };\n  \n  \n  /**\n   * Set the text placement.\n   *\n   * @param {ol.style.TextPlacement|string} placement Placement.\n   * @api\n   */\n  ol.style.Text.prototype.setPlacement = function(placement) {\n    this.placement_ = placement;\n  };\n  \n  \n  /**\n   * Set the fill.\n   *\n   * @param {ol.style.Fill} fill Fill style.\n   * @api\n   */\n  ol.style.Text.prototype.setFill = function(fill) {\n    this.fill_ = fill;\n  };\n  \n  \n  /**\n   * Set the rotation.\n   *\n   * @param {number|undefined} rotation Rotation.\n   * @api\n   */\n  ol.style.Text.prototype.setRotation = function(rotation) {\n    this.rotation_ = rotation;\n  };\n  \n  \n  /**\n   * Set the scale.\n   *\n   * @param {number|undefined} scale Scale.\n   * @api\n   */\n  ol.style.Text.prototype.setScale = function(scale) {\n    this.scale_ = scale;\n  };\n  \n  \n  /**\n   * Set the stroke.\n   *\n   * @param {ol.style.Stroke} stroke Stroke style.\n   * @api\n   */\n  ol.style.Text.prototype.setStroke = function(stroke) {\n    this.stroke_ = stroke;\n  };\n  \n  \n  /**\n   * Set the text.\n   *\n   * @param {string|undefined} text Text.\n   * @api\n   */\n  ol.style.Text.prototype.setText = function(text) {\n    this.text_ = text;\n  };\n  \n  \n  /**\n   * Set the text alignment.\n   *\n   * @param {string|undefined} textAlign Text align.\n   * @api\n   */\n  ol.style.Text.prototype.setTextAlign = function(textAlign) {\n    this.textAlign_ = textAlign;\n  };\n  \n  \n  /**\n   * Set the text baseline.\n   *\n   * @param {string|undefined} textBaseline Text baseline.\n   * @api\n   */\n  ol.style.Text.prototype.setTextBaseline = function(textBaseline) {\n    this.textBaseline_ = textBaseline;\n  };\n  \n  \n  /**\n   * Set the background fill.\n   *\n   * @param {ol.style.Fill} fill Fill style.\n   * @api\n   */\n  ol.style.Text.prototype.setBackgroundFill = function(fill) {\n    this.backgroundFill_ = fill;\n  };\n  \n  \n  /**\n   * Set the background stroke.\n   *\n   * @param {ol.style.Stroke} stroke Stroke style.\n   * @api\n   */\n  ol.style.Text.prototype.setBackgroundStroke = function(stroke) {\n    this.backgroundStroke_ = stroke;\n  };\n  \n  \n  /**\n   * Set the padding (`[top, right, bottom, left]`).\n   *\n   * @param {!Array.<number>} padding Padding.\n   * @api\n   */\n  ol.style.Text.prototype.setPadding = function(padding) {\n    this.padding_ = padding;\n  };\n  \n  // FIXME http://earth.google.com/kml/1.0 namespace?\n  // FIXME why does node.getAttribute return an unknown type?\n  // FIXME serialize arbitrary feature properties\n  // FIXME don't parse style if extractStyles is false\n  \n  goog.provide('ol.format.KML');\n  \n  goog.require('ol');\n  goog.require('ol.Feature');\n  goog.require('ol.array');\n  goog.require('ol.asserts');\n  goog.require('ol.color');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.XMLFeature');\n  goog.require('ol.format.XSD');\n  goog.require('ol.geom.GeometryCollection');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.math');\n  goog.require('ol.proj');\n  goog.require('ol.style.Fill');\n  goog.require('ol.style.Icon');\n  goog.require('ol.style.IconAnchorUnits');\n  goog.require('ol.style.IconOrigin');\n  goog.require('ol.style.Stroke');\n  goog.require('ol.style.Style');\n  goog.require('ol.style.Text');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the KML format.\n   *\n   * Note that the KML format uses the URL() constructor. Older browsers such as IE\n   * which do not support this will need a URL polyfill to be loaded before use.\n   *\n   * @constructor\n   * @extends {ol.format.XMLFeature}\n   * @param {olx.format.KMLOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.KML = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.format.XMLFeature.call(this);\n  \n    if (!ol.format.KML.DEFAULT_STYLE_ARRAY_) {\n      ol.format.KML.createStyleDefaults_();\n    }\n  \n    /**\n     * @inheritDoc\n     */\n    this.defaultDataProjection = ol.proj.get('EPSG:4326');\n  \n    /**\n     * @private\n     * @type {Array.<ol.style.Style>}\n     */\n    this.defaultStyle_ = options.defaultStyle ?\n      options.defaultStyle : ol.format.KML.DEFAULT_STYLE_ARRAY_;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.extractStyles_ = options.extractStyles !== undefined ?\n      options.extractStyles : true;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.writeStyles_ = options.writeStyles !== undefined ?\n      options.writeStyles : true;\n  \n    /**\n     * @private\n     * @type {Object.<string, (Array.<ol.style.Style>|string)>}\n     */\n    this.sharedStyles_ = {};\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.showPointNames_ = options.showPointNames !== undefined ?\n      options.showPointNames : true;\n  \n  };\n  ol.inherits(ol.format.KML, ol.format.XMLFeature);\n  \n  \n  /**\n   * @const\n   * @type {Array.<string>}\n   * @private\n   */\n  ol.format.KML.GX_NAMESPACE_URIS_ = [\n    'http://www.google.com/kml/ext/2.2'\n  ];\n  \n  \n  /**\n   * @const\n   * @type {Array.<string>}\n   * @private\n   */\n  ol.format.KML.NAMESPACE_URIS_ = [\n    null,\n    'http://earth.google.com/kml/2.0',\n    'http://earth.google.com/kml/2.1',\n    'http://earth.google.com/kml/2.2',\n    'http://www.opengis.net/kml/2.2'\n  ];\n  \n  \n  /**\n   * @const\n   * @type {string}\n   * @private\n   */\n  ol.format.KML.SCHEMA_LOCATION_ = 'http://www.opengis.net/kml/2.2 ' +\n      'https://developers.google.com/kml/schema/kml22gx.xsd';\n  \n  \n  /**\n   * @return {Array.<ol.style.Style>} Default style.\n   * @private\n   */\n  ol.format.KML.createStyleDefaults_ = function() {\n    /**\n     * @const\n     * @type {ol.Color}\n     * @private\n     */\n    ol.format.KML.DEFAULT_COLOR_ = [255, 255, 255, 1];\n  \n    /**\n     * @const\n     * @type {ol.style.Fill}\n     * @private\n     */\n    ol.format.KML.DEFAULT_FILL_STYLE_ = new ol.style.Fill({\n      color: ol.format.KML.DEFAULT_COLOR_\n    });\n  \n    /**\n     * @const\n     * @type {ol.Size}\n     * @private\n     */\n    ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_ = [20, 2]; // FIXME maybe [8, 32] ?\n  \n    /**\n     * @const\n     * @type {ol.style.IconAnchorUnits}\n     * @private\n     */\n    ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_ =\n        ol.style.IconAnchorUnits.PIXELS;\n  \n    /**\n     * @const\n     * @type {ol.style.IconAnchorUnits}\n     * @private\n     */\n    ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_ =\n        ol.style.IconAnchorUnits.PIXELS;\n  \n    /**\n     * @const\n     * @type {ol.Size}\n     * @private\n     */\n    ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_ = [64, 64];\n  \n    /**\n     * @const\n     * @type {string}\n     * @private\n     */\n    ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_ =\n        'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';\n  \n    /**\n     * @const\n     * @type {number}\n     * @private\n     */\n    ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_ = 0.5;\n  \n    /**\n     * @const\n     * @type {ol.style.Image}\n     * @private\n     */\n    ol.format.KML.DEFAULT_IMAGE_STYLE_ = new ol.style.Icon({\n      anchor: ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_,\n      anchorOrigin: ol.style.IconOrigin.BOTTOM_LEFT,\n      anchorXUnits: ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_,\n      anchorYUnits: ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_,\n      crossOrigin: 'anonymous',\n      rotation: 0,\n      scale: ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_,\n      size: ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_,\n      src: ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_\n    });\n  \n    /**\n     * @const\n     * @type {string}\n     * @private\n     */\n    ol.format.KML.DEFAULT_NO_IMAGE_STYLE_ = 'NO_IMAGE';\n  \n    /**\n     * @const\n     * @type {ol.style.Stroke}\n     * @private\n     */\n    ol.format.KML.DEFAULT_STROKE_STYLE_ = new ol.style.Stroke({\n      color: ol.format.KML.DEFAULT_COLOR_,\n      width: 1\n    });\n  \n    /**\n     * @const\n     * @type {ol.style.Stroke}\n     * @private\n     */\n    ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_ = new ol.style.Stroke({\n      color: [51, 51, 51, 1],\n      width: 2\n    });\n  \n    /**\n     * @const\n     * @type {ol.style.Text}\n     * @private\n     */\n    ol.format.KML.DEFAULT_TEXT_STYLE_ = new ol.style.Text({\n      font: 'bold 16px Helvetica',\n      fill: ol.format.KML.DEFAULT_FILL_STYLE_,\n      stroke: ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_,\n      scale: 0.8\n    });\n  \n    /**\n     * @const\n     * @type {ol.style.Style}\n     * @private\n     */\n    ol.format.KML.DEFAULT_STYLE_ = new ol.style.Style({\n      fill: ol.format.KML.DEFAULT_FILL_STYLE_,\n      image: ol.format.KML.DEFAULT_IMAGE_STYLE_,\n      text: ol.format.KML.DEFAULT_TEXT_STYLE_,\n      stroke: ol.format.KML.DEFAULT_STROKE_STYLE_,\n      zIndex: 0\n    });\n  \n    /**\n     * @const\n     * @type {Array.<ol.style.Style>}\n     * @private\n     */\n    ol.format.KML.DEFAULT_STYLE_ARRAY_ = [ol.format.KML.DEFAULT_STYLE_];\n  \n    return ol.format.KML.DEFAULT_STYLE_ARRAY_;\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, ol.style.IconAnchorUnits>}\n   * @private\n   */\n  ol.format.KML.ICON_ANCHOR_UNITS_MAP_ = {\n    'fraction': ol.style.IconAnchorUnits.FRACTION,\n    'pixels': ol.style.IconAnchorUnits.PIXELS,\n    'insetPixels': ol.style.IconAnchorUnits.PIXELS\n  };\n  \n  \n  /**\n   * @param {ol.style.Style|undefined} foundStyle Style.\n   * @param {string} name Name.\n   * @return {ol.style.Style} style Style.\n   * @private\n   */\n  ol.format.KML.createNameStyleFunction_ = function(foundStyle, name) {\n    var textStyle = null;\n    var textOffset = [0, 0];\n    var textAlign = 'start';\n    if (foundStyle.getImage()) {\n      var imageSize = foundStyle.getImage().getImageSize();\n      if (imageSize === null) {\n        imageSize = ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_;\n      }\n      if (imageSize.length == 2) {\n        var imageScale = foundStyle.getImage().getScale();\n        // Offset the label to be centered to the right of the icon, if there is\n        // one.\n        textOffset[0] = imageScale * imageSize[0] / 2;\n        textOffset[1] = -imageScale * imageSize[1] / 2;\n        textAlign = 'left';\n      }\n    }\n    if (foundStyle.getText() !== null) {\n      // clone the text style, customizing it with name, alignments and offset.\n      // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).\n      var foundText = foundStyle.getText();\n      textStyle = foundText.clone();\n      textStyle.setFont(foundText.getFont() || ol.format.KML.DEFAULT_TEXT_STYLE_.getFont());\n      textStyle.setScale(foundText.getScale() || ol.format.KML.DEFAULT_TEXT_STYLE_.getScale());\n      textStyle.setFill(foundText.getFill() || ol.format.KML.DEFAULT_TEXT_STYLE_.getFill());\n      textStyle.setStroke(foundText.getStroke() || ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_);\n    } else {\n      textStyle = ol.format.KML.DEFAULT_TEXT_STYLE_.clone();\n    }\n    textStyle.setText(name);\n    textStyle.setOffsetX(textOffset[0]);\n    textStyle.setOffsetY(textOffset[1]);\n    textStyle.setTextAlign(textAlign);\n  \n    var nameStyle = new ol.style.Style({\n      text: textStyle\n    });\n    return nameStyle;\n  };\n  \n  \n  /**\n   * @param {Array.<ol.style.Style>|undefined} style Style.\n   * @param {string} styleUrl Style URL.\n   * @param {Array.<ol.style.Style>} defaultStyle Default style.\n   * @param {Object.<string, (Array.<ol.style.Style>|string)>} sharedStyles Shared\n   *          styles.\n   * @param {boolean|undefined} showPointNames true to show names for point\n   *          placemarks.\n   * @return {ol.FeatureStyleFunction} Feature style function.\n   * @private\n   */\n  ol.format.KML.createFeatureStyleFunction_ = function(style, styleUrl,\n      defaultStyle, sharedStyles, showPointNames) {\n  \n    return (\n    /**\n         * @param {number} resolution Resolution.\n         * @return {Array.<ol.style.Style>} Style.\n         * @this {ol.Feature}\n         */\n      function(resolution) {\n        var drawName = showPointNames;\n        /** @type {ol.style.Style|undefined} */\n        var nameStyle;\n        var name = '';\n        if (drawName) {\n          if (this.getGeometry()) {\n            drawName = (this.getGeometry().getType() ===\n                          ol.geom.GeometryType.POINT);\n          }\n        }\n  \n        if (drawName) {\n          name = /** @type {string} */ (this.get('name'));\n          drawName = drawName && name;\n        }\n  \n        if (style) {\n          if (drawName) {\n            nameStyle = ol.format.KML.createNameStyleFunction_(style[0],\n                name);\n            return style.concat(nameStyle);\n          }\n          return style;\n        }\n        if (styleUrl) {\n          var foundStyle = ol.format.KML.findStyle_(styleUrl, defaultStyle,\n              sharedStyles);\n          if (drawName) {\n            nameStyle = ol.format.KML.createNameStyleFunction_(foundStyle[0],\n                name);\n            return foundStyle.concat(nameStyle);\n          }\n          return foundStyle;\n        }\n        if (drawName) {\n          nameStyle = ol.format.KML.createNameStyleFunction_(defaultStyle[0],\n              name);\n          return defaultStyle.concat(nameStyle);\n        }\n        return defaultStyle;\n      });\n  };\n  \n  \n  /**\n   * @param {Array.<ol.style.Style>|string|undefined} styleValue Style value.\n   * @param {Array.<ol.style.Style>} defaultStyle Default style.\n   * @param {Object.<string, (Array.<ol.style.Style>|string)>} sharedStyles\n   * Shared styles.\n   * @return {Array.<ol.style.Style>} Style.\n   * @private\n   */\n  ol.format.KML.findStyle_ = function(styleValue, defaultStyle, sharedStyles) {\n    if (Array.isArray(styleValue)) {\n      return styleValue;\n    } else if (typeof styleValue === 'string') {\n      // KML files in the wild occasionally forget the leading `#` on styleUrls\n      // defined in the same document.  Add a leading `#` if it enables to find\n      // a style.\n      if (!(styleValue in sharedStyles) && ('#' + styleValue in sharedStyles)) {\n        styleValue = '#' + styleValue;\n      }\n      return ol.format.KML.findStyle_(\n          sharedStyles[styleValue], defaultStyle, sharedStyles);\n    } else {\n      return defaultStyle;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @private\n   * @return {ol.Color|undefined} Color.\n   */\n  ol.format.KML.readColor_ = function(node) {\n    var s = ol.xml.getAllTextContent(node, false);\n    // The KML specification states that colors should not include a leading `#`\n    // but we tolerate them.\n    var m = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s);\n    if (m) {\n      var hexColor = m[1];\n      return [\n        parseInt(hexColor.substr(6, 2), 16),\n        parseInt(hexColor.substr(4, 2), 16),\n        parseInt(hexColor.substr(2, 2), 16),\n        parseInt(hexColor.substr(0, 2), 16) / 255\n      ];\n  \n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @private\n   * @return {Array.<number>|undefined} Flat coordinates.\n   */\n  ol.format.KML.readFlatCoordinates_ = function(node) {\n    var s = ol.xml.getAllTextContent(node, false);\n    var flatCoordinates = [];\n    // The KML specification states that coordinate tuples should not include\n    // spaces, but we tolerate them.\n    var re =\n        /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*,\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s*,\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?))?\\s*/i;\n    var m;\n    while ((m = re.exec(s))) {\n      var x = parseFloat(m[1]);\n      var y = parseFloat(m[2]);\n      var z = m[3] ? parseFloat(m[3]) : 0;\n      flatCoordinates.push(x, y, z);\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    return flatCoordinates;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @private\n   * @return {string} URI.\n   */\n  ol.format.KML.readURI_ = function(node) {\n    var s = ol.xml.getAllTextContent(node, false).trim();\n    var baseURI = node.baseURI;\n    if (!baseURI || baseURI == 'about:blank') {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      var url = new URL(s, baseURI);\n      return url.href;\n    } else {\n      return s;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @private\n   * @return {ol.KMLVec2_} Vec2.\n   */\n  ol.format.KML.readVec2_ = function(node) {\n    var xunits = node.getAttribute('xunits');\n    var yunits = node.getAttribute('yunits');\n    var origin;\n    if (xunits !== 'insetPixels') {\n      if (yunits !== 'insetPixels') {\n        origin = ol.style.IconOrigin.BOTTOM_LEFT;\n      } else {\n        origin = ol.style.IconOrigin.TOP_LEFT;\n      }\n    } else {\n      if (yunits !== 'insetPixels') {\n        origin = ol.style.IconOrigin.BOTTOM_RIGHT;\n      } else {\n        origin = ol.style.IconOrigin.TOP_RIGHT;\n      }\n    }\n    return {\n      x: parseFloat(node.getAttribute('x')),\n      xunits: ol.format.KML.ICON_ANCHOR_UNITS_MAP_[xunits],\n      y: parseFloat(node.getAttribute('y')),\n      yunits: ol.format.KML.ICON_ANCHOR_UNITS_MAP_[yunits],\n      origin: origin\n    };\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @private\n   * @return {number|undefined} Scale.\n   */\n  ol.format.KML.readScale_ = function(node) {\n    return ol.format.XSD.readDecimal(node);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<ol.style.Style>|string|undefined} StyleMap.\n   */\n  ol.format.KML.readStyleMapValue_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(undefined,\n        ol.format.KML.STYLE_MAP_PARSERS_, node, objectStack);\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.IconStyleParser_ = function(node, objectStack) {\n    // FIXME refreshMode\n    // FIXME refreshInterval\n    // FIXME viewRefreshTime\n    // FIXME viewBoundScale\n    // FIXME viewFormat\n    // FIXME httpQuery\n    var object = ol.xml.pushParseAndPop(\n        {}, ol.format.KML.ICON_STYLE_PARSERS_, node, objectStack);\n    if (!object) {\n      return;\n    }\n    var styleObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var IconObject = 'Icon' in object ? object['Icon'] : {};\n    var drawIcon = (!('Icon' in object) || Object.keys(IconObject).length > 0);\n    var src;\n    var href = /** @type {string|undefined} */\n        (IconObject['href']);\n    if (href) {\n      src = href;\n    } else if (drawIcon) {\n      src = ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_;\n    }\n    var anchor, anchorXUnits, anchorYUnits;\n    var anchorOrigin = ol.style.IconOrigin.BOTTOM_LEFT;\n    var hotSpot = /** @type {ol.KMLVec2_|undefined} */\n        (object['hotSpot']);\n    if (hotSpot) {\n      anchor = [hotSpot.x, hotSpot.y];\n      anchorXUnits = hotSpot.xunits;\n      anchorYUnits = hotSpot.yunits;\n      anchorOrigin = hotSpot.origin;\n    } else if (src === ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_) {\n      anchor = ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_;\n      anchorXUnits = ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_;\n      anchorYUnits = ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_;\n    } else if (/^http:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\n      anchor = [0.5, 0];\n      anchorXUnits = ol.style.IconAnchorUnits.FRACTION;\n      anchorYUnits = ol.style.IconAnchorUnits.FRACTION;\n    }\n  \n    var offset;\n    var x = /** @type {number|undefined} */\n        (IconObject['x']);\n    var y = /** @type {number|undefined} */\n        (IconObject['y']);\n    if (x !== undefined && y !== undefined) {\n      offset = [x, y];\n    }\n  \n    var size;\n    var w = /** @type {number|undefined} */\n        (IconObject['w']);\n    var h = /** @type {number|undefined} */\n        (IconObject['h']);\n    if (w !== undefined && h !== undefined) {\n      size = [w, h];\n    }\n  \n    var rotation;\n    var heading = /** @type {number} */\n        (object['heading']);\n    if (heading !== undefined) {\n      rotation = ol.math.toRadians(heading);\n    }\n  \n    var scale = /** @type {number|undefined} */\n        (object['scale']);\n  \n    if (drawIcon) {\n      if (src == ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_) {\n        size = ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_;\n        if (scale === undefined) {\n          scale = ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_;\n        }\n      }\n  \n      var imageStyle = new ol.style.Icon({\n        anchor: anchor,\n        anchorOrigin: anchorOrigin,\n        anchorXUnits: anchorXUnits,\n        anchorYUnits: anchorYUnits,\n        crossOrigin: 'anonymous', // FIXME should this be configurable?\n        offset: offset,\n        offsetOrigin: ol.style.IconOrigin.BOTTOM_LEFT,\n        rotation: rotation,\n        scale: scale,\n        size: size,\n        src: src\n      });\n      styleObject['imageStyle'] = imageStyle;\n    } else {\n      // handle the case when we explicitly want to draw no icon.\n      styleObject['imageStyle'] = ol.format.KML.DEFAULT_NO_IMAGE_STYLE_;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.LabelStyleParser_ = function(node, objectStack) {\n    // FIXME colorMode\n    var object = ol.xml.pushParseAndPop(\n        {}, ol.format.KML.LABEL_STYLE_PARSERS_, node, objectStack);\n    if (!object) {\n      return;\n    }\n    var styleObject = objectStack[objectStack.length - 1];\n    var textStyle = new ol.style.Text({\n      fill: new ol.style.Fill({\n        color: /** @type {ol.Color} */\n            ('color' in object ? object['color'] : ol.format.KML.DEFAULT_COLOR_)\n      }),\n      scale: /** @type {number|undefined} */\n          (object['scale'])\n    });\n    styleObject['textStyle'] = textStyle;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.LineStyleParser_ = function(node, objectStack) {\n    // FIXME colorMode\n    // FIXME gx:outerColor\n    // FIXME gx:outerWidth\n    // FIXME gx:physicalWidth\n    // FIXME gx:labelVisibility\n    var object = ol.xml.pushParseAndPop(\n        {}, ol.format.KML.LINE_STYLE_PARSERS_, node, objectStack);\n    if (!object) {\n      return;\n    }\n    var styleObject = objectStack[objectStack.length - 1];\n    var strokeStyle = new ol.style.Stroke({\n      color: /** @type {ol.Color} */\n          ('color' in object ? object['color'] : ol.format.KML.DEFAULT_COLOR_),\n      width: /** @type {number} */ ('width' in object ? object['width'] : 1)\n    });\n    styleObject['strokeStyle'] = strokeStyle;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.PolyStyleParser_ = function(node, objectStack) {\n    // FIXME colorMode\n    var object = ol.xml.pushParseAndPop(\n        {}, ol.format.KML.POLY_STYLE_PARSERS_, node, objectStack);\n    if (!object) {\n      return;\n    }\n    var styleObject = objectStack[objectStack.length - 1];\n    var fillStyle = new ol.style.Fill({\n      color: /** @type {ol.Color} */\n          ('color' in object ? object['color'] : ol.format.KML.DEFAULT_COLOR_)\n    });\n    styleObject['fillStyle'] = fillStyle;\n    var fill = /** @type {boolean|undefined} */ (object['fill']);\n    if (fill !== undefined) {\n      styleObject['fill'] = fill;\n    }\n    var outline =\n        /** @type {boolean|undefined} */ (object['outline']);\n    if (outline !== undefined) {\n      styleObject['outline'] = outline;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>} LinearRing flat coordinates.\n   */\n  ol.format.KML.readFlatLinearRing_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(null,\n        ol.format.KML.FLAT_LINEAR_RING_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.gxCoordParser_ = function(node, objectStack) {\n    var gxTrackObject = /** @type {ol.KMLGxTrackObject_} */\n        (objectStack[objectStack.length - 1]);\n    var flatCoordinates = gxTrackObject.flatCoordinates;\n    var s = ol.xml.getAllTextContent(node, false);\n    var re =\n        /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\n    var m = re.exec(s);\n    if (m) {\n      var x = parseFloat(m[1]);\n      var y = parseFloat(m[2]);\n      var z = parseFloat(m[3]);\n      flatCoordinates.push(x, y, z, 0);\n    } else {\n      flatCoordinates.push(0, 0, 0, 0);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.MultiLineString|undefined} MultiLineString.\n   */\n  ol.format.KML.readGxMultiTrack_ = function(node, objectStack) {\n    var lineStrings = ol.xml.pushParseAndPop([],\n        ol.format.KML.GX_MULTITRACK_GEOMETRY_PARSERS_, node, objectStack);\n    if (!lineStrings) {\n      return undefined;\n    }\n    var multiLineString = new ol.geom.MultiLineString(null);\n    multiLineString.setLineStrings(lineStrings);\n    return multiLineString;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.LineString|undefined} LineString.\n   */\n  ol.format.KML.readGxTrack_ = function(node, objectStack) {\n    var gxTrackObject = ol.xml.pushParseAndPop(\n        /** @type {ol.KMLGxTrackObject_} */ ({\n          flatCoordinates: [],\n          whens: []\n        }), ol.format.KML.GX_TRACK_PARSERS_, node, objectStack);\n    if (!gxTrackObject) {\n      return undefined;\n    }\n    var flatCoordinates = gxTrackObject.flatCoordinates;\n    var whens = gxTrackObject.whens;\n    var i, ii;\n    for (i = 0, ii = Math.min(flatCoordinates.length, whens.length); i < ii;\n      ++i) {\n      flatCoordinates[4 * i + 3] = whens[i];\n    }\n    var lineString = new ol.geom.LineString(null);\n    lineString.setFlatCoordinates(ol.geom.GeometryLayout.XYZM, flatCoordinates);\n    return lineString;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object} Icon object.\n   */\n  ol.format.KML.readIcon_ = function(node, objectStack) {\n    var iconObject = ol.xml.pushParseAndPop(\n        {}, ol.format.KML.ICON_PARSERS_, node, objectStack);\n    if (iconObject) {\n      return iconObject;\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.format.KML.readFlatCoordinatesFromNode_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(null,\n        ol.format.KML.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.LineString|undefined} LineString.\n   */\n  ol.format.KML.readLineString_ = function(node, objectStack) {\n    var properties = ol.xml.pushParseAndPop({},\n        ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node,\n        objectStack);\n    var flatCoordinates =\n        ol.format.KML.readFlatCoordinatesFromNode_(node, objectStack);\n    if (flatCoordinates) {\n      var lineString = new ol.geom.LineString(null);\n      lineString.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);\n      lineString.setProperties(properties);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.Polygon|undefined} Polygon.\n   */\n  ol.format.KML.readLinearRing_ = function(node, objectStack) {\n    var properties = ol.xml.pushParseAndPop({},\n        ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node,\n        objectStack);\n    var flatCoordinates =\n        ol.format.KML.readFlatCoordinatesFromNode_(node, objectStack);\n    if (flatCoordinates) {\n      var polygon = new ol.geom.Polygon(null);\n      polygon.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates,\n          [flatCoordinates.length]);\n      polygon.setProperties(properties);\n      return polygon;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.Geometry} Geometry.\n   */\n  ol.format.KML.readMultiGeometry_ = function(node, objectStack) {\n    var geometries = ol.xml.pushParseAndPop([],\n        ol.format.KML.MULTI_GEOMETRY_PARSERS_, node, objectStack);\n    if (!geometries) {\n      return null;\n    }\n    if (geometries.length === 0) {\n      return new ol.geom.GeometryCollection(geometries);\n    }\n    /** @type {ol.geom.Geometry} */\n    var multiGeometry;\n    var homogeneous = true;\n    var type = geometries[0].getType();\n    var geometry, i, ii;\n    for (i = 1, ii = geometries.length; i < ii; ++i) {\n      geometry = geometries[i];\n      if (geometry.getType() != type) {\n        homogeneous = false;\n        break;\n      }\n    }\n    if (homogeneous) {\n      var layout;\n      var flatCoordinates;\n      if (type == ol.geom.GeometryType.POINT) {\n        var point = geometries[0];\n        layout = point.getLayout();\n        flatCoordinates = point.getFlatCoordinates();\n        for (i = 1, ii = geometries.length; i < ii; ++i) {\n          geometry = geometries[i];\n          ol.array.extend(flatCoordinates, geometry.getFlatCoordinates());\n        }\n        multiGeometry = new ol.geom.MultiPoint(null);\n        multiGeometry.setFlatCoordinates(layout, flatCoordinates);\n        ol.format.KML.setCommonGeometryProperties_(multiGeometry, geometries);\n      } else if (type == ol.geom.GeometryType.LINE_STRING) {\n        multiGeometry = new ol.geom.MultiLineString(null);\n        multiGeometry.setLineStrings(geometries);\n        ol.format.KML.setCommonGeometryProperties_(multiGeometry, geometries);\n      } else if (type == ol.geom.GeometryType.POLYGON) {\n        multiGeometry = new ol.geom.MultiPolygon(null);\n        multiGeometry.setPolygons(geometries);\n        ol.format.KML.setCommonGeometryProperties_(multiGeometry, geometries);\n      } else if (type == ol.geom.GeometryType.GEOMETRY_COLLECTION) {\n        multiGeometry = new ol.geom.GeometryCollection(geometries);\n      } else {\n        ol.asserts.assert(false, 37); // Unknown geometry type found\n      }\n    } else {\n      multiGeometry = new ol.geom.GeometryCollection(geometries);\n    }\n    return /** @type {ol.geom.Geometry} */ (multiGeometry);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.Point|undefined} Point.\n   */\n  ol.format.KML.readPoint_ = function(node, objectStack) {\n    var properties = ol.xml.pushParseAndPop({},\n        ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node,\n        objectStack);\n    var flatCoordinates =\n        ol.format.KML.readFlatCoordinatesFromNode_(node, objectStack);\n    if (flatCoordinates) {\n      var point = new ol.geom.Point(null);\n      point.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);\n      point.setProperties(properties);\n      return point;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.geom.Polygon|undefined} Polygon.\n   */\n  ol.format.KML.readPolygon_ = function(node, objectStack) {\n    var properties = ol.xml.pushParseAndPop(/** @type {Object<string,*>} */ ({}),\n        ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node,\n        objectStack);\n    var flatLinearRings = ol.xml.pushParseAndPop([null],\n        ol.format.KML.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack);\n    if (flatLinearRings && flatLinearRings[0]) {\n      var polygon = new ol.geom.Polygon(null);\n      var flatCoordinates = flatLinearRings[0];\n      var ends = [flatCoordinates.length];\n      var i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        ol.array.extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      polygon.setFlatCoordinates(\n          ol.geom.GeometryLayout.XYZ, flatCoordinates, ends);\n      polygon.setProperties(properties);\n      return polygon;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<ol.style.Style>} Style.\n   */\n  ol.format.KML.readStyle_ = function(node, objectStack) {\n    var styleObject = ol.xml.pushParseAndPop(\n        {}, ol.format.KML.STYLE_PARSERS_, node, objectStack);\n    if (!styleObject) {\n      return null;\n    }\n    var fillStyle = /** @type {ol.style.Fill} */\n        ('fillStyle' in styleObject ?\n          styleObject['fillStyle'] : ol.format.KML.DEFAULT_FILL_STYLE_);\n    var fill = /** @type {boolean|undefined} */ (styleObject['fill']);\n    if (fill !== undefined && !fill) {\n      fillStyle = null;\n    }\n    var imageStyle = /** @type {ol.style.Image} */\n        ('imageStyle' in styleObject ?\n          styleObject['imageStyle'] : ol.format.KML.DEFAULT_IMAGE_STYLE_);\n    if (imageStyle == ol.format.KML.DEFAULT_NO_IMAGE_STYLE_) {\n      imageStyle = undefined;\n    }\n    var textStyle = /** @type {ol.style.Text} */\n        ('textStyle' in styleObject ?\n          styleObject['textStyle'] : ol.format.KML.DEFAULT_TEXT_STYLE_);\n    var strokeStyle = /** @type {ol.style.Stroke} */\n        ('strokeStyle' in styleObject ?\n          styleObject['strokeStyle'] : ol.format.KML.DEFAULT_STROKE_STYLE_);\n    var outline = /** @type {boolean|undefined} */\n        (styleObject['outline']);\n    if (outline !== undefined && !outline) {\n      strokeStyle = null;\n    }\n    return [new ol.style.Style({\n      fill: fillStyle,\n      image: imageStyle,\n      stroke: strokeStyle,\n      text: textStyle,\n      zIndex: undefined // FIXME\n    })];\n  };\n  \n  \n  /**\n   * Reads an array of geometries and creates arrays for common geometry\n   * properties. Then sets them to the multi geometry.\n   * @param {ol.geom.MultiPoint|ol.geom.MultiLineString|ol.geom.MultiPolygon}\n   *     multiGeometry A multi-geometry.\n   * @param {Array.<ol.geom.Geometry>} geometries List of geometries.\n   * @private\n   */\n  ol.format.KML.setCommonGeometryProperties_ = function(multiGeometry,\n      geometries) {\n    var ii = geometries.length;\n    var extrudes = new Array(geometries.length);\n    var tessellates = new Array(geometries.length);\n    var altitudeModes = new Array(geometries.length);\n    var geometry, i, hasExtrude, hasTessellate, hasAltitudeMode;\n    hasExtrude = hasTessellate = hasAltitudeMode = false;\n    for (i = 0; i < ii; ++i) {\n      geometry = geometries[i];\n      extrudes[i] = geometry.get('extrude');\n      tessellates[i] = geometry.get('tessellate');\n      altitudeModes[i] = geometry.get('altitudeMode');\n      hasExtrude = hasExtrude || extrudes[i] !== undefined;\n      hasTessellate = hasTessellate || tessellates[i] !== undefined;\n      hasAltitudeMode = hasAltitudeMode || altitudeModes[i];\n    }\n    if (hasExtrude) {\n      multiGeometry.set('extrude', extrudes);\n    }\n    if (hasTessellate) {\n      multiGeometry.set('tessellate', tessellates);\n    }\n    if (hasAltitudeMode) {\n      multiGeometry.set('altitudeMode', altitudeModes);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.DataParser_ = function(node, objectStack) {\n    var name = node.getAttribute('name');\n    ol.xml.parseNode(ol.format.KML.DATA_PARSERS_, node, objectStack);\n    var featureObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    if (name !== null) {\n      featureObject[name] = featureObject.value;\n    } else if (featureObject.displayName !== null) {\n      featureObject[featureObject.displayName] = featureObject.value;\n    }\n    delete featureObject['value'];\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.ExtendedDataParser_ = function(node, objectStack) {\n    ol.xml.parseNode(ol.format.KML.EXTENDED_DATA_PARSERS_, node, objectStack);\n  };\n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.RegionParser_ = function(node, objectStack) {\n    ol.xml.parseNode(ol.format.KML.REGION_PARSERS_, node, objectStack);\n  };\n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.PairDataParser_ = function(node, objectStack) {\n    var pairObject = ol.xml.pushParseAndPop(\n        {}, ol.format.KML.PAIR_PARSERS_, node, objectStack);\n    if (!pairObject) {\n      return;\n    }\n    var key = /** @type {string|undefined} */\n        (pairObject['key']);\n    if (key && key == 'normal') {\n      var styleUrl = /** @type {string|undefined} */\n          (pairObject['styleUrl']);\n      if (styleUrl) {\n        objectStack[objectStack.length - 1] = styleUrl;\n      }\n      var Style = /** @type {ol.style.Style} */\n          (pairObject['Style']);\n      if (Style) {\n        objectStack[objectStack.length - 1] = Style;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.PlacemarkStyleMapParser_ = function(node, objectStack) {\n    var styleMapValue = ol.format.KML.readStyleMapValue_(node, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    var placemarkObject = objectStack[objectStack.length - 1];\n    if (Array.isArray(styleMapValue)) {\n      placemarkObject['Style'] = styleMapValue;\n    } else if (typeof styleMapValue === 'string') {\n      placemarkObject['styleUrl'] = styleMapValue;\n    } else {\n      ol.asserts.assert(false, 38); // `styleMapValue` has an unknown type\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.SchemaDataParser_ = function(node, objectStack) {\n    ol.xml.parseNode(ol.format.KML.SCHEMA_DATA_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.SimpleDataParser_ = function(node, objectStack) {\n    var name = node.getAttribute('name');\n    if (name !== null) {\n      var data = ol.format.XSD.readString(node);\n      var featureObject =\n          /** @type {Object} */ (objectStack[objectStack.length - 1]);\n      featureObject[name] = data;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.LatLonAltBoxParser_ = function(node, objectStack) {\n    var object = ol.xml.pushParseAndPop({}, ol.format.KML.LAT_LON_ALT_BOX_PARSERS_, node, objectStack);\n    if (!object) {\n      return;\n    }\n    var regionObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var extent = [\n      parseFloat(object['west']),\n      parseFloat(object['south']),\n      parseFloat(object['east']),\n      parseFloat(object['north'])\n    ];\n    regionObject['extent'] = extent;\n    regionObject['altitudeMode'] = object['altitudeMode'];\n    regionObject['minAltitude'] = parseFloat(object['minAltitude']);\n    regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.LodParser_ = function(node, objectStack) {\n    var object = ol.xml.pushParseAndPop({}, ol.format.KML.LOD_PARSERS_, node, objectStack);\n    if (!object) {\n      return;\n    }\n    var lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);\n    lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);\n    lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);\n    lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.innerBoundaryIsParser_ = function(node, objectStack) {\n    /** @type {Array.<number>|undefined} */\n    var flatLinearRing = ol.xml.pushParseAndPop(undefined,\n        ol.format.KML.INNER_BOUNDARY_IS_PARSERS_, node, objectStack);\n    if (flatLinearRing) {\n      var flatLinearRings = /** @type {Array.<Array.<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.outerBoundaryIsParser_ = function(node, objectStack) {\n    /** @type {Array.<number>|undefined} */\n    var flatLinearRing = ol.xml.pushParseAndPop(undefined,\n        ol.format.KML.OUTER_BOUNDARY_IS_PARSERS_, node, objectStack);\n    if (flatLinearRing) {\n      var flatLinearRings = /** @type {Array.<Array.<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.LinkParser_ = function(node, objectStack) {\n    ol.xml.parseNode(ol.format.KML.LINK_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.whenParser_ = function(node, objectStack) {\n    var gxTrackObject = /** @type {ol.KMLGxTrackObject_} */\n        (objectStack[objectStack.length - 1]);\n    var whens = gxTrackObject.whens;\n    var s = ol.xml.getAllTextContent(node, false);\n    var when = Date.parse(s);\n    whens.push(isNaN(when) ? 0 : when);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.DATA_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'displayName': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'value': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.EXTENDED_DATA_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'Data': ol.format.KML.DataParser_,\n        'SchemaData': ol.format.KML.SchemaDataParser_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.REGION_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'LatLonAltBox': ol.format.KML.LatLonAltBoxParser_,\n        'Lod': ol.format.KML.LodParser_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.LAT_LON_ALT_BOX_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'altitudeMode': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'minAltitude': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'maxAltitude': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'north': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'south': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'east': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'west': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.LOD_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'minLodPixels': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'maxLodPixels': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'minFadeExtent': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'maxFadeExtent': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'extrude': ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),\n        'tessellate': ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),\n        'altitudeMode': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.FLAT_LINEAR_RING_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'coordinates': ol.xml.makeReplacer(ol.format.KML.readFlatCoordinates_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.FLAT_LINEAR_RINGS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'innerBoundaryIs': ol.format.KML.innerBoundaryIsParser_,\n        'outerBoundaryIs': ol.format.KML.outerBoundaryIsParser_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.GX_TRACK_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'when': ol.format.KML.whenParser_\n      }, ol.xml.makeStructureNS(\n          ol.format.KML.GX_NAMESPACE_URIS_, {\n            'coord': ol.format.KML.gxCoordParser_\n          }));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.GEOMETRY_FLAT_COORDINATES_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'coordinates': ol.xml.makeReplacer(ol.format.KML.readFlatCoordinates_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.ICON_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'href': ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)\n      }, ol.xml.makeStructureNS(\n          ol.format.KML.GX_NAMESPACE_URIS_, {\n            'x': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n            'y': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n            'w': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n            'h': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)\n          }));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.ICON_STYLE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'Icon': ol.xml.makeObjectPropertySetter(ol.format.KML.readIcon_),\n        'heading': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal),\n        'hotSpot': ol.xml.makeObjectPropertySetter(ol.format.KML.readVec2_),\n        'scale': ol.xml.makeObjectPropertySetter(ol.format.KML.readScale_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.INNER_BOUNDARY_IS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'LinearRing': ol.xml.makeReplacer(ol.format.KML.readFlatLinearRing_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.LABEL_STYLE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'color': ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_),\n        'scale': ol.xml.makeObjectPropertySetter(ol.format.KML.readScale_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.LINE_STYLE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'color': ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_),\n        'width': ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.MULTI_GEOMETRY_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'LineString': ol.xml.makeArrayPusher(ol.format.KML.readLineString_),\n        'LinearRing': ol.xml.makeArrayPusher(ol.format.KML.readLinearRing_),\n        'MultiGeometry': ol.xml.makeArrayPusher(ol.format.KML.readMultiGeometry_),\n        'Point': ol.xml.makeArrayPusher(ol.format.KML.readPoint_),\n        'Polygon': ol.xml.makeArrayPusher(ol.format.KML.readPolygon_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.GX_MULTITRACK_GEOMETRY_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.GX_NAMESPACE_URIS_, {\n        'Track': ol.xml.makeArrayPusher(ol.format.KML.readGxTrack_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.NETWORK_LINK_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'ExtendedData': ol.format.KML.ExtendedDataParser_,\n        'Region': ol.format.KML.RegionParser_,\n        'Link': ol.format.KML.LinkParser_,\n        'address': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'description': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'name': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'open': ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),\n        'phoneNumber': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'visibility': ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.LINK_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'href': ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.OUTER_BOUNDARY_IS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'LinearRing': ol.xml.makeReplacer(ol.format.KML.readFlatLinearRing_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.PAIR_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'Style': ol.xml.makeObjectPropertySetter(ol.format.KML.readStyle_),\n        'key': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'styleUrl': ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.PLACEMARK_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'ExtendedData': ol.format.KML.ExtendedDataParser_,\n        'Region': ol.format.KML.RegionParser_,\n        'MultiGeometry': ol.xml.makeObjectPropertySetter(\n            ol.format.KML.readMultiGeometry_, 'geometry'),\n        'LineString': ol.xml.makeObjectPropertySetter(\n            ol.format.KML.readLineString_, 'geometry'),\n        'LinearRing': ol.xml.makeObjectPropertySetter(\n            ol.format.KML.readLinearRing_, 'geometry'),\n        'Point': ol.xml.makeObjectPropertySetter(\n            ol.format.KML.readPoint_, 'geometry'),\n        'Polygon': ol.xml.makeObjectPropertySetter(\n            ol.format.KML.readPolygon_, 'geometry'),\n        'Style': ol.xml.makeObjectPropertySetter(ol.format.KML.readStyle_),\n        'StyleMap': ol.format.KML.PlacemarkStyleMapParser_,\n        'address': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'description': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'name': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'open': ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),\n        'phoneNumber': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'styleUrl': ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_),\n        'visibility': ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)\n      }, ol.xml.makeStructureNS(\n          ol.format.KML.GX_NAMESPACE_URIS_, {\n            'MultiTrack': ol.xml.makeObjectPropertySetter(\n                ol.format.KML.readGxMultiTrack_, 'geometry'),\n            'Track': ol.xml.makeObjectPropertySetter(\n                ol.format.KML.readGxTrack_, 'geometry')\n          }\n      ));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.POLY_STYLE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'color': ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_),\n        'fill': ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean),\n        'outline': ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.SCHEMA_DATA_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'SimpleData': ol.format.KML.SimpleDataParser_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.STYLE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'IconStyle': ol.format.KML.IconStyleParser_,\n        'LabelStyle': ol.format.KML.LabelStyleParser_,\n        'LineStyle': ol.format.KML.LineStyleParser_,\n        'PolyStyle': ol.format.KML.PolyStyleParser_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.KML.STYLE_MAP_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'Pair': ol.format.KML.PairDataParser_\n      });\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<ol.Feature>|undefined} Features.\n   */\n  ol.format.KML.prototype.readDocumentOrFolder_ = function(node, objectStack) {\n    // FIXME use scope somehow\n    var parsersNS = ol.xml.makeStructureNS(\n        ol.format.KML.NAMESPACE_URIS_, {\n          'Document': ol.xml.makeArrayExtender(this.readDocumentOrFolder_, this),\n          'Folder': ol.xml.makeArrayExtender(this.readDocumentOrFolder_, this),\n          'Placemark': ol.xml.makeArrayPusher(this.readPlacemark_, this),\n          'Style': this.readSharedStyle_.bind(this),\n          'StyleMap': this.readSharedStyleMap_.bind(this)\n        });\n    /** @type {Array.<ol.Feature>} */\n    var features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack, this);\n    if (features) {\n      return features;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {ol.Feature|undefined} Feature.\n   */\n  ol.format.KML.prototype.readPlacemark_ = function(node, objectStack) {\n    var object = ol.xml.pushParseAndPop({'geometry': null},\n        ol.format.KML.PLACEMARK_PARSERS_, node, objectStack);\n    if (!object) {\n      return undefined;\n    }\n    var feature = new ol.Feature();\n    var id = node.getAttribute('id');\n    if (id !== null) {\n      feature.setId(id);\n    }\n    var options = /** @type {olx.format.ReadOptions} */ (objectStack[0]);\n  \n    var geometry = object['geometry'];\n    if (geometry) {\n      ol.format.Feature.transformWithOptions(geometry, false, options);\n    }\n    feature.setGeometry(geometry);\n    delete object['geometry'];\n  \n    if (this.extractStyles_) {\n      var style = object['Style'];\n      var styleUrl = object['styleUrl'];\n      var styleFunction = ol.format.KML.createFeatureStyleFunction_(\n          style, styleUrl, this.defaultStyle_, this.sharedStyles_,\n          this.showPointNames_);\n      feature.setStyle(styleFunction);\n    }\n    delete object['Style'];\n    // we do not remove the styleUrl property from the object, so it\n    // gets stored on feature when setProperties is called\n  \n    feature.setProperties(object);\n  \n    return feature;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.prototype.readSharedStyle_ = function(node, objectStack) {\n    var id = node.getAttribute('id');\n    if (id !== null) {\n      var style = ol.format.KML.readStyle_(node, objectStack);\n      if (style) {\n        var styleUri;\n        var baseURI = node.baseURI;\n        if (!baseURI || baseURI == 'about:blank') {\n          baseURI = window.location.href;\n        }\n        if (baseURI) {\n          var url = new URL('#' + id, baseURI);\n          styleUri = url.href;\n        } else {\n          styleUri = '#' + id;\n        }\n        this.sharedStyles_[styleUri] = style;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.prototype.readSharedStyleMap_ = function(node, objectStack) {\n    var id = node.getAttribute('id');\n    if (id === null) {\n      return;\n    }\n    var styleMapValue = ol.format.KML.readStyleMapValue_(node, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    var styleUri;\n    var baseURI = node.baseURI;\n    if (!baseURI || baseURI == 'about:blank') {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      var url = new URL('#' + id, baseURI);\n      styleUri = url.href;\n    } else {\n      styleUri = '#' + id;\n    }\n    this.sharedStyles_[styleUri] = styleMapValue;\n  };\n  \n  \n  /**\n   * Read the first feature from a KML source. MultiGeometries are converted into\n   * GeometryCollections if they are a mix of geometry types, and into MultiPoint/\n   * MultiLineString/MultiPolygon if they are all of the same type.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   * @api\n   */\n  ol.format.KML.prototype.readFeature;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.KML.prototype.readFeatureFromNode = function(node, opt_options) {\n    if (!ol.array.includes(ol.format.KML.NAMESPACE_URIS_, node.namespaceURI)) {\n      return null;\n    }\n    var feature = this.readPlacemark_(\n        node, [this.getReadOptions(node, opt_options)]);\n    if (feature) {\n      return feature;\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * Read all features from a KML source. MultiGeometries are converted into\n   * GeometryCollections if they are a mix of geometry types, and into MultiPoint/\n   * MultiLineString/MultiPolygon if they are all of the same type.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.KML.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.KML.prototype.readFeaturesFromNode = function(node, opt_options) {\n    if (!ol.array.includes(ol.format.KML.NAMESPACE_URIS_, node.namespaceURI)) {\n      return [];\n    }\n    var features;\n    var localName = node.localName;\n    if (localName == 'Document' || localName == 'Folder') {\n      features = this.readDocumentOrFolder_(\n          node, [this.getReadOptions(node, opt_options)]);\n      if (features) {\n        return features;\n      } else {\n        return [];\n      }\n    } else if (localName == 'Placemark') {\n      var feature = this.readPlacemark_(\n          node, [this.getReadOptions(node, opt_options)]);\n      if (feature) {\n        return [feature];\n      } else {\n        return [];\n      }\n    } else if (localName == 'kml') {\n      features = [];\n      var n;\n      for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n        var fs = this.readFeaturesFromNode(n, opt_options);\n        if (fs) {\n          ol.array.extend(features, fs);\n        }\n      }\n      return features;\n    } else {\n      return [];\n    }\n  };\n  \n  \n  /**\n   * Read the name of the KML.\n   *\n   * @param {Document|Node|string} source Souce.\n   * @return {string|undefined} Name.\n   * @api\n   */\n  ol.format.KML.prototype.readName = function(source) {\n    if (ol.xml.isDocument(source)) {\n      return this.readNameFromDocument(/** @type {Document} */ (source));\n    } else if (ol.xml.isNode(source)) {\n      return this.readNameFromNode(/** @type {Node} */ (source));\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      return this.readNameFromDocument(doc);\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @return {string|undefined} Name.\n   */\n  ol.format.KML.prototype.readNameFromDocument = function(doc) {\n    var n;\n    for (n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        var name = this.readNameFromNode(n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {string|undefined} Name.\n   */\n  ol.format.KML.prototype.readNameFromNode = function(node) {\n    var n;\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) &&\n          n.localName == 'name') {\n        return ol.format.XSD.readString(n);\n      }\n    }\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n      var localName = n.localName;\n      if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) &&\n          (localName == 'Document' ||\n           localName == 'Folder' ||\n           localName == 'Placemark' ||\n           localName == 'kml')) {\n        var name = this.readNameFromNode(n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * Read the network links of the KML.\n   *\n   * @param {Document|Node|string} source Source.\n   * @return {Array.<Object>} Network links.\n   * @api\n   */\n  ol.format.KML.prototype.readNetworkLinks = function(source) {\n    var networkLinks = [];\n    if (ol.xml.isDocument(source)) {\n      ol.array.extend(networkLinks, this.readNetworkLinksFromDocument(\n          /** @type {Document} */ (source)));\n    } else if (ol.xml.isNode(source)) {\n      ol.array.extend(networkLinks, this.readNetworkLinksFromNode(\n          /** @type {Node} */ (source)));\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      ol.array.extend(networkLinks, this.readNetworkLinksFromDocument(doc));\n    }\n    return networkLinks;\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @return {Array.<Object>} Network links.\n   */\n  ol.format.KML.prototype.readNetworkLinksFromDocument = function(doc) {\n    var n, networkLinks = [];\n    for (n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        ol.array.extend(networkLinks, this.readNetworkLinksFromNode(n));\n      }\n    }\n    return networkLinks;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {Array.<Object>} Network links.\n   */\n  ol.format.KML.prototype.readNetworkLinksFromNode = function(node) {\n    var n, networkLinks = [];\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) &&\n          n.localName == 'NetworkLink') {\n        var obj = ol.xml.pushParseAndPop({}, ol.format.KML.NETWORK_LINK_PARSERS_,\n            n, []);\n        networkLinks.push(obj);\n      }\n    }\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n      var localName = n.localName;\n      if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) &&\n          (localName == 'Document' ||\n           localName == 'Folder' ||\n           localName == 'kml')) {\n        ol.array.extend(networkLinks, this.readNetworkLinksFromNode(n));\n      }\n    }\n    return networkLinks;\n  };\n  \n  \n  /**\n   * Read the regions of the KML.\n   *\n   * @param {Document|Node|string} source Source.\n   * @return {Array.<Object>} Regions.\n   * @api\n   */\n  ol.format.KML.prototype.readRegion = function(source) {\n    var regions = [];\n    if (ol.xml.isDocument(source)) {\n      ol.array.extend(regions, this.readRegionFromDocument(\n          /** @type {Document} */ (source)));\n    } else if (ol.xml.isNode(source)) {\n      ol.array.extend(regions, this.readRegionFromNode(\n          /** @type {Node} */ (source)));\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      ol.array.extend(regions, this.readRegionFromDocument(doc));\n    }\n    return regions;\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @return {Array.<Object>} Region.\n   */\n  ol.format.KML.prototype.readRegionFromDocument = function(doc) {\n    var n, regions = [];\n    for (n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        ol.array.extend(regions, this.readRegionFromNode(n));\n      }\n    }\n    return regions;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {Array.<Object>} Region.\n   * @api\n   */\n  ol.format.KML.prototype.readRegionFromNode = function(node) {\n    var n, regions = [];\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) &&\n          n.localName == 'Region') {\n        var obj = ol.xml.pushParseAndPop({}, ol.format.KML.REGION_PARSERS_,\n            n, []);\n        regions.push(obj);\n      }\n    }\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n      var localName = n.localName;\n      if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) &&\n          (localName == 'Document' ||\n           localName == 'Folder' ||\n           localName == 'kml')) {\n        ol.array.extend(regions, this.readRegionFromNode(n));\n      }\n    }\n    return regions;\n  };\n  \n  \n  /**\n   * Read the projection from a KML source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.format.KML.prototype.readProjection;\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the color to.\n   * @param {ol.Color|string} color Color.\n   * @private\n   */\n  ol.format.KML.writeColorTextNode_ = function(node, color) {\n    var rgba = ol.color.asArray(color);\n    var opacity = (rgba.length == 4) ? rgba[3] : 1;\n    var abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];\n    var i;\n    for (i = 0; i < 4; ++i) {\n      var hex = parseInt(abgr[i], 10).toString(16);\n      abgr[i] = (hex.length == 1) ? '0' + hex : hex;\n    }\n    ol.format.XSD.writeStringTextNode(node, abgr.join(''));\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the coordinates to.\n   * @param {Array.<number>} coordinates Coordinates.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeCoordinatesTextNode_ = function(node, coordinates, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n  \n    var layout = context['layout'];\n    var stride = context['stride'];\n  \n    var dimension;\n    if (layout == ol.geom.GeometryLayout.XY ||\n        layout == ol.geom.GeometryLayout.XYM) {\n      dimension = 2;\n    } else if (layout == ol.geom.GeometryLayout.XYZ ||\n        layout == ol.geom.GeometryLayout.XYZM) {\n      dimension = 3;\n    } else {\n      ol.asserts.assert(false, 34); // Invalid geometry layout\n    }\n  \n    var d, i;\n    var ii = coordinates.length;\n    var text = '';\n    if (ii > 0) {\n      text += coordinates[0];\n      for (d = 1; d < dimension; ++d) {\n        text += ',' + coordinates[d];\n      }\n      for (i = stride; i < ii; i += stride) {\n        text += ' ' + coordinates[i];\n        for (d = 1; d < dimension; ++d) {\n          text += ',' + coordinates[i + d];\n        }\n      }\n    }\n    ol.format.XSD.writeStringTextNode(node, text);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {{name: *, value: *}} pair Name value pair.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeDataNode_ = function(node, pair, objectStack) {\n    node.setAttribute('name', pair.name);\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    var value = pair.value;\n  \n    if (typeof value == 'object') {\n      if (value !== null && value.displayName) {\n        ol.xml.pushSerializeAndPop(context, ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_,\n            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ['displayName']);\n      }\n  \n      if (value !== null && value.value) {\n        ol.xml.pushSerializeAndPop(context, ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_,\n            ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ['value']);\n      }\n    } else {\n      ol.xml.pushSerializeAndPop(context, ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_,\n          ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ['value']);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the name to.\n   * @param {string} name DisplayName.\n   * @private\n   */\n  ol.format.KML.writeDataNodeName_ = function(node, name) {\n    ol.format.XSD.writeCDATASection(node, name);\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a CDATA Section with the value to.\n   * @param {string} value Value.\n   * @private\n   */\n  ol.format.KML.writeDataNodeValue_ = function(node, value) {\n    ol.format.XSD.writeStringTextNode(node, value);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {Array.<*>} objectStack Object stack.\n   * @this {ol.format.KML}\n   * @private\n   */\n  ol.format.KML.writeDocument_ = function(node, features, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.DOCUMENT_SERIALIZERS_,\n        ol.format.KML.DOCUMENT_NODE_FACTORY_, features, objectStack, undefined,\n        this);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeExtendedData_ = function(node, namesAndValues, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    var names = namesAndValues.names, values = namesAndValues.values;\n    var length = names.length;\n  \n    for (var i = 0; i < length; i++) {\n      ol.xml.pushSerializeAndPop(context, ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_,\n          ol.format.KML.DATA_NODE_FACTORY_, [{name: names[i], value: values[i]}], objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Object} icon Icon object.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeIcon_ = function(node, icon, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = ol.format.KML.ICON_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(icon, orderedKeys);\n    ol.xml.pushSerializeAndPop(context,\n        ol.format.KML.ICON_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY,\n        values, objectStack, orderedKeys);\n    orderedKeys =\n        ol.format.KML.ICON_SEQUENCE_[ol.format.KML.GX_NAMESPACE_URIS_[0]];\n    values = ol.xml.makeSequence(icon, orderedKeys);\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.ICON_SERIALIZERS_,\n        ol.format.KML.GX_NODE_FACTORY_, values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.style.Icon} style Icon style.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeIconStyle_ = function(node, style, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    var properties = {};\n    var src = style.getSrc();\n    var size = style.getSize();\n    var iconImageSize = style.getImageSize();\n    var iconProperties = {\n      'href': src\n    };\n  \n    if (size) {\n      iconProperties['w'] = size[0];\n      iconProperties['h'] = size[1];\n      var anchor = style.getAnchor(); // top-left\n      var origin = style.getOrigin(); // top-left\n  \n      if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {\n        iconProperties['x'] = origin[0];\n        iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);\n      }\n  \n      if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\n        var /** @type {ol.KMLVec2_} */ hotSpot = {\n          x: anchor[0],\n          xunits: ol.style.IconAnchorUnits.PIXELS,\n          y: size[1] - anchor[1],\n          yunits: ol.style.IconAnchorUnits.PIXELS\n        };\n        properties['hotSpot'] = hotSpot;\n      }\n    }\n  \n    properties['Icon'] = iconProperties;\n  \n    var scale = style.getScale();\n    if (scale !== 1) {\n      properties['scale'] = scale;\n    }\n  \n    var rotation = style.getRotation();\n    if (rotation !== 0) {\n      properties['heading'] = rotation; // 0-360\n    }\n  \n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = ol.format.KML.ICON_STYLE_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.ICON_STYLE_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.style.Text} style style.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeLabelStyle_ = function(node, style, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    var properties = {};\n    var fill = style.getFill();\n    if (fill) {\n      properties['color'] = fill.getColor();\n    }\n    var scale = style.getScale();\n    if (scale && scale !== 1) {\n      properties['scale'] = scale;\n    }\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys =\n        ol.format.KML.LABEL_STYLE_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.LABEL_STYLE_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.style.Stroke} style style.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeLineStyle_ = function(node, style, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    var properties = {\n      'color': style.getColor(),\n      'width': style.getWidth()\n    };\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = ol.format.KML.LINE_STYLE_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.LINE_STYLE_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeMultiGeometry_ = function(node, geometry, objectStack) {\n    /** @type {ol.XmlNodeStackItem} */\n    var context = {node: node};\n    var type = geometry.getType();\n    /** @type {Array.<ol.geom.Geometry>} */\n    var geometries;\n    /** @type {function(*, Array.<*>, string=): (Node|undefined)} */\n    var factory;\n    if (type == ol.geom.GeometryType.GEOMETRY_COLLECTION) {\n      geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();\n      factory = ol.format.KML.GEOMETRY_NODE_FACTORY_;\n    } else if (type == ol.geom.GeometryType.MULTI_POINT) {\n      geometries = /** @type {ol.geom.MultiPoint} */ (geometry).getPoints();\n      factory = ol.format.KML.POINT_NODE_FACTORY_;\n    } else if (type == ol.geom.GeometryType.MULTI_LINE_STRING) {\n      geometries =\n          (/** @type {ol.geom.MultiLineString} */ (geometry)).getLineStrings();\n      factory = ol.format.KML.LINE_STRING_NODE_FACTORY_;\n    } else if (type == ol.geom.GeometryType.MULTI_POLYGON) {\n      geometries =\n          (/** @type {ol.geom.MultiPolygon} */ (geometry)).getPolygons();\n      factory = ol.format.KML.POLYGON_NODE_FACTORY_;\n    } else {\n      ol.asserts.assert(false, 39); // Unknown geometry type\n    }\n    ol.xml.pushSerializeAndPop(context,\n        ol.format.KML.MULTI_GEOMETRY_SERIALIZERS_, factory,\n        geometries, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.LinearRing} linearRing Linear ring.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeBoundaryIs_ = function(node, linearRing, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    ol.xml.pushSerializeAndPop(context,\n        ol.format.KML.BOUNDARY_IS_SERIALIZERS_,\n        ol.format.KML.LINEAR_RING_NODE_FACTORY_, [linearRing], objectStack);\n  };\n  \n  \n  /**\n   * FIXME currently we do serialize arbitrary/custom feature properties\n   * (ExtendedData).\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Object stack.\n   * @this {ol.format.KML}\n   * @private\n   */\n  ol.format.KML.writePlacemark_ = function(node, feature, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n  \n    // set id\n    if (feature.getId()) {\n      node.setAttribute('id', feature.getId());\n    }\n  \n    // serialize properties (properties unknown to KML are not serialized)\n    var properties = feature.getProperties();\n  \n    // don't export these to ExtendedData\n    var filter = {'address': 1, 'description': 1, 'name': 1, 'open': 1,\n      'phoneNumber': 1, 'styleUrl': 1, 'visibility': 1};\n    filter[feature.getGeometryName()] = 1;\n    var keys = Object.keys(properties || {}).sort().filter(function(v) {\n      return !filter[v];\n    });\n  \n    if (keys.length > 0) {\n      var sequence = ol.xml.makeSequence(properties, keys);\n      var namesAndValues = {names: keys, values: sequence};\n      ol.xml.pushSerializeAndPop(context, ol.format.KML.PLACEMARK_SERIALIZERS_,\n          ol.format.KML.EXTENDEDDATA_NODE_FACTORY_, [namesAndValues], objectStack);\n    }\n  \n    var styleFunction = feature.getStyleFunction();\n    if (styleFunction) {\n      // FIXME the styles returned by the style function are supposed to be\n      // resolution-independent here\n      var styles = styleFunction.call(feature, 0);\n      if (styles) {\n        var style = Array.isArray(styles) ? styles[0] : styles;\n        if (this.writeStyles_) {\n          properties['Style'] = style;\n        }\n        var textStyle = style.getText();\n        if (textStyle) {\n          properties['name'] = textStyle.getText();\n        }\n      }\n    }\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = ol.format.KML.PLACEMARK_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.PLACEMARK_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  \n    // serialize geometry\n    var options = /** @type {olx.format.WriteOptions} */ (objectStack[0]);\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      geometry =\n          ol.format.Feature.transformWithOptions(geometry, true, options);\n    }\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.PLACEMARK_SERIALIZERS_,\n        ol.format.KML.GEOMETRY_NODE_FACTORY_, [geometry], objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.SimpleGeometry} geometry Geometry.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writePrimitiveGeometry_ = function(node, geometry, objectStack) {\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    context['layout'] = geometry.getLayout();\n    context['stride'] = geometry.getStride();\n  \n    // serialize properties (properties unknown to KML are not serialized)\n    var properties = geometry.getProperties();\n    properties.coordinates = flatCoordinates;\n  \n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = ol.format.KML.PRIMITIVE_GEOMETRY_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.PRIMITIVE_GEOMETRY_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.geom.Polygon} polygon Polygon.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writePolygon_ = function(node, polygon, objectStack) {\n    var linearRings = polygon.getLinearRings();\n    var outerRing = linearRings.shift();\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    // inner rings\n    ol.xml.pushSerializeAndPop(context,\n        ol.format.KML.POLYGON_SERIALIZERS_,\n        ol.format.KML.INNER_BOUNDARY_NODE_FACTORY_,\n        linearRings, objectStack);\n    // outer ring\n    ol.xml.pushSerializeAndPop(context,\n        ol.format.KML.POLYGON_SERIALIZERS_,\n        ol.format.KML.OUTER_BOUNDARY_NODE_FACTORY_,\n        [outerRing], objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.style.Fill} style Style.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writePolyStyle_ = function(node, style, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.POLY_STYLE_SERIALIZERS_,\n        ol.format.KML.COLOR_NODE_FACTORY_, [style.getColor()], objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the scale to.\n   * @param {number|undefined} scale Scale.\n   * @private\n   */\n  ol.format.KML.writeScaleTextNode_ = function(node, scale) {\n    // the Math is to remove any excess decimals created by float arithmetic\n    ol.format.XSD.writeDecimalTextNode(node,\n        Math.round(scale * 1e6) / 1e6);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.style.Style} style Style.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.KML.writeStyle_ = function(node, style, objectStack) {\n    var /** @type {ol.XmlNodeStackItem} */ context = {node: node};\n    var properties = {};\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    if (imageStyle instanceof ol.style.Icon) {\n      properties['IconStyle'] = imageStyle;\n    }\n    if (textStyle) {\n      properties['LabelStyle'] = textStyle;\n    }\n    if (strokeStyle) {\n      properties['LineStyle'] = strokeStyle;\n    }\n    if (fillStyle) {\n      properties['PolyStyle'] = fillStyle;\n    }\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = ol.format.KML.STYLE_SEQUENCE_[parentNode.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.STYLE_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  };\n  \n  \n  /**\n   * @param {Node} node Node to append a TextNode with the Vec2 to.\n   * @param {ol.KMLVec2_} vec2 Vec2.\n   * @private\n   */\n  ol.format.KML.writeVec2_ = function(node, vec2) {\n    node.setAttribute('x', vec2.x);\n    node.setAttribute('y', vec2.y);\n    node.setAttribute('xunits', vec2.xunits);\n    node.setAttribute('yunits', vec2.yunits);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.KML.KML_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, [\n        'Document', 'Placemark'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.KML_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'Document': ol.xml.makeChildAppender(ol.format.KML.writeDocument_),\n        'Placemark': ol.xml.makeChildAppender(ol.format.KML.writePlacemark_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.DOCUMENT_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'Placemark': ol.xml.makeChildAppender(ol.format.KML.writePlacemark_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'Data': ol.xml.makeChildAppender(ol.format.KML.writeDataNode_),\n        'value': ol.xml.makeChildAppender(ol.format.KML.writeDataNodeValue_),\n        'displayName': ol.xml.makeChildAppender(ol.format.KML.writeDataNodeName_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, string>}\n   * @private\n   */\n  ol.format.KML.GEOMETRY_TYPE_TO_NODENAME_ = {\n    'Point': 'Point',\n    'LineString': 'LineString',\n    'LinearRing': 'LinearRing',\n    'Polygon': 'Polygon',\n    'MultiPoint': 'MultiGeometry',\n    'MultiLineString': 'MultiGeometry',\n    'MultiPolygon': 'MultiGeometry',\n    'GeometryCollection': 'MultiGeometry'\n  };\n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.KML.ICON_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, [\n        'href'\n      ],\n      ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_, [\n        'x', 'y', 'w', 'h'\n      ]));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.ICON_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'href': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)\n      }, ol.xml.makeStructureNS(\n          ol.format.KML.GX_NAMESPACE_URIS_, {\n            'x': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n            'y': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n            'w': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n            'h': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode)\n          }));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.KML.ICON_STYLE_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, [\n        'scale', 'heading', 'Icon', 'hotSpot'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.ICON_STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'Icon': ol.xml.makeChildAppender(ol.format.KML.writeIcon_),\n        'heading': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode),\n        'hotSpot': ol.xml.makeChildAppender(ol.format.KML.writeVec2_),\n        'scale': ol.xml.makeChildAppender(ol.format.KML.writeScaleTextNode_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.KML.LABEL_STYLE_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, [\n        'color', 'scale'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.LABEL_STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'color': ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_),\n        'scale': ol.xml.makeChildAppender(ol.format.KML.writeScaleTextNode_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.KML.LINE_STYLE_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, [\n        'color', 'width'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.LINE_STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'color': ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_),\n        'width': ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.BOUNDARY_IS_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'LinearRing': ol.xml.makeChildAppender(\n            ol.format.KML.writePrimitiveGeometry_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.MULTI_GEOMETRY_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'LineString': ol.xml.makeChildAppender(\n            ol.format.KML.writePrimitiveGeometry_),\n        'Point': ol.xml.makeChildAppender(\n            ol.format.KML.writePrimitiveGeometry_),\n        'Polygon': ol.xml.makeChildAppender(ol.format.KML.writePolygon_),\n        'GeometryCollection': ol.xml.makeChildAppender(\n            ol.format.KML.writeMultiGeometry_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.KML.PLACEMARK_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, [\n        'name', 'open', 'visibility', 'address', 'phoneNumber', 'description',\n        'styleUrl', 'Style'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.PLACEMARK_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'ExtendedData': ol.xml.makeChildAppender(\n            ol.format.KML.writeExtendedData_),\n        'MultiGeometry': ol.xml.makeChildAppender(\n            ol.format.KML.writeMultiGeometry_),\n        'LineString': ol.xml.makeChildAppender(\n            ol.format.KML.writePrimitiveGeometry_),\n        'LinearRing': ol.xml.makeChildAppender(\n            ol.format.KML.writePrimitiveGeometry_),\n        'Point': ol.xml.makeChildAppender(\n            ol.format.KML.writePrimitiveGeometry_),\n        'Polygon': ol.xml.makeChildAppender(ol.format.KML.writePolygon_),\n        'Style': ol.xml.makeChildAppender(ol.format.KML.writeStyle_),\n        'address': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'description': ol.xml.makeChildAppender(\n            ol.format.XSD.writeStringTextNode),\n        'name': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'open': ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode),\n        'phoneNumber': ol.xml.makeChildAppender(\n            ol.format.XSD.writeStringTextNode),\n        'styleUrl': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'visibility': ol.xml.makeChildAppender(\n            ol.format.XSD.writeBooleanTextNode)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.KML.PRIMITIVE_GEOMETRY_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, [\n        'extrude', 'tessellate', 'altitudeMode', 'coordinates'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.PRIMITIVE_GEOMETRY_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'extrude': ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode),\n        'tessellate': ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode),\n        'altitudeMode': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode),\n        'coordinates': ol.xml.makeChildAppender(\n            ol.format.KML.writeCoordinatesTextNode_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.POLYGON_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'outerBoundaryIs': ol.xml.makeChildAppender(\n            ol.format.KML.writeBoundaryIs_),\n        'innerBoundaryIs': ol.xml.makeChildAppender(\n            ol.format.KML.writeBoundaryIs_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.POLY_STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'color': ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Array.<string>>}\n   * @private\n   */\n  ol.format.KML.STYLE_SEQUENCE_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, [\n        'IconStyle', 'LabelStyle', 'LineStyle', 'PolyStyle'\n      ]);\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.KML.STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(\n      ol.format.KML.NAMESPACE_URIS_, {\n        'IconStyle': ol.xml.makeChildAppender(ol.format.KML.writeIconStyle_),\n        'LabelStyle': ol.xml.makeChildAppender(ol.format.KML.writeLabelStyle_),\n        'LineStyle': ol.xml.makeChildAppender(ol.format.KML.writeLineStyle_),\n        'PolyStyle': ol.xml.makeChildAppender(ol.format.KML.writePolyStyle_)\n      });\n  \n  \n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  ol.format.KML.GX_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    return ol.xml.createElementNS(ol.format.KML.GX_NAMESPACE_URIS_[0],\n        'gx:' + opt_nodeName);\n  };\n  \n  \n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  ol.format.KML.DOCUMENT_NODE_FACTORY_ = function(value, objectStack,\n      opt_nodeName) {\n    var parentNode = objectStack[objectStack.length - 1].node;\n    return ol.xml.createElementNS(parentNode.namespaceURI, 'Placemark');\n  };\n  \n  \n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  ol.format.KML.GEOMETRY_NODE_FACTORY_ = function(value, objectStack,\n      opt_nodeName) {\n    if (value) {\n      var parentNode = objectStack[objectStack.length - 1].node;\n      return ol.xml.createElementNS(parentNode.namespaceURI,\n          ol.format.KML.GEOMETRY_TYPE_TO_NODENAME_[/** @type {ol.geom.Geometry} */ (value).getType()]);\n    }\n  };\n  \n  \n  /**\n   * A factory for creating coordinates nodes.\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.COLOR_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory('color');\n  \n  \n  /**\n   * A factory for creating Data nodes.\n   * @const\n   * @type {function(*, Array.<*>): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.DATA_NODE_FACTORY_ =\n      ol.xml.makeSimpleNodeFactory('Data');\n  \n  \n  /**\n   * A factory for creating ExtendedData nodes.\n   * @const\n   * @type {function(*, Array.<*>): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.EXTENDEDDATA_NODE_FACTORY_ =\n      ol.xml.makeSimpleNodeFactory('ExtendedData');\n  \n  \n  /**\n   * A factory for creating innerBoundaryIs nodes.\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.INNER_BOUNDARY_NODE_FACTORY_ =\n      ol.xml.makeSimpleNodeFactory('innerBoundaryIs');\n  \n  \n  /**\n   * A factory for creating Point nodes.\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.POINT_NODE_FACTORY_ =\n      ol.xml.makeSimpleNodeFactory('Point');\n  \n  \n  /**\n   * A factory for creating LineString nodes.\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.LINE_STRING_NODE_FACTORY_ =\n      ol.xml.makeSimpleNodeFactory('LineString');\n  \n  \n  /**\n   * A factory for creating LinearRing nodes.\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.LINEAR_RING_NODE_FACTORY_ =\n      ol.xml.makeSimpleNodeFactory('LinearRing');\n  \n  \n  /**\n   * A factory for creating Polygon nodes.\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.POLYGON_NODE_FACTORY_ =\n      ol.xml.makeSimpleNodeFactory('Polygon');\n  \n  \n  /**\n   * A factory for creating outerBoundaryIs nodes.\n   * @const\n   * @type {function(*, Array.<*>, string=): (Node|undefined)}\n   * @private\n   */\n  ol.format.KML.OUTER_BOUNDARY_NODE_FACTORY_ =\n      ol.xml.makeSimpleNodeFactory('outerBoundaryIs');\n  \n  \n  /**\n   * Encode an array of features in the KML format. GeometryCollections, MultiPoints,\n   * MultiLineStrings, and MultiPolygons are output as MultiGeometries.\n   *\n   * @function\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {string} Result.\n   * @api\n   */\n  ol.format.KML.prototype.writeFeatures;\n  \n  \n  /**\n   * Encode an array of features in the KML format as an XML node. GeometryCollections,\n   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.\n   *\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n  ol.format.KML.prototype.writeFeaturesNode = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var kml = ol.xml.createElementNS(ol.format.KML.NAMESPACE_URIS_[4], 'kml');\n    var xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    var xmlSchemaInstanceUri = 'http://www.w3.org/2001/XMLSchema-instance';\n    ol.xml.setAttributeNS(kml, xmlnsUri, 'xmlns:gx',\n        ol.format.KML.GX_NAMESPACE_URIS_[0]);\n    ol.xml.setAttributeNS(kml, xmlnsUri, 'xmlns:xsi', xmlSchemaInstanceUri);\n    ol.xml.setAttributeNS(kml, xmlSchemaInstanceUri, 'xsi:schemaLocation',\n        ol.format.KML.SCHEMA_LOCATION_);\n  \n    var /** @type {ol.XmlNodeStackItem} */ context = {node: kml};\n    var properties = {};\n    if (features.length > 1) {\n      properties['Document'] = features;\n    } else if (features.length == 1) {\n      properties['Placemark'] = features[0];\n    }\n    var orderedKeys = ol.format.KML.KML_SEQUENCE_[kml.namespaceURI];\n    var values = ol.xml.makeSequence(properties, orderedKeys);\n    ol.xml.pushSerializeAndPop(context, ol.format.KML.KML_SERIALIZERS_,\n        ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, [opt_options], orderedKeys,\n        this);\n    return kml;\n  };\n  \n  \n  /**\n   * @fileoverview\n   * @suppress {accessControls, ambiguousFunctionDecl, checkDebuggerStatement, checkRegExp, checkTypes, checkVars, const, constantProperty, deprecated, duplicate, es5Strict, fileoverviewTags, missingProperties, nonStandardJsDocs, strictModuleDepCheck, suspiciousCode, undefinedNames, undefinedVars, unknownDefines, unusedLocalVariables, uselessCode, visibility}\n   */\n  goog.provide('ol.ext.PBF');\n  \n  /** @typedef {function(*)} */\n  ol.ext.PBF = function() {};\n  \n  (function() {(function (exports) {\n  'use strict';\n  \n  var read = function (buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = (nBytes * 8) - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? (nBytes - 1) : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & ((1 << (-nBits)) - 1);\n    s >>= (-nBits);\n    nBits += eLen;\n    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n    m = e & ((1 << (-nBits)) - 1);\n    e >>= (-nBits);\n    nBits += mLen;\n    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n    if (e === 0) {\n      e = 1 - eBias;\n    } else if (e === eMax) {\n      return m ? NaN : ((s ? -1 : 1) * Infinity)\n    } else {\n      m = m + Math.pow(2, mLen);\n      e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n  };\n  var write = function (buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = (nBytes * 8) - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n    var i = isLE ? 0 : (nBytes - 1);\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n      m = isNaN(value) ? 1 : 0;\n      e = eMax;\n    } else {\n      e = Math.floor(Math.log(value) / Math.LN2);\n      if (value * (c = Math.pow(2, -e)) < 1) {\n        e--;\n        c *= 2;\n      }\n      if (e + eBias >= 1) {\n        value += rt / c;\n      } else {\n        value += rt * Math.pow(2, 1 - eBias);\n      }\n      if (value * c >= 2) {\n        e++;\n        c /= 2;\n      }\n      if (e + eBias >= eMax) {\n        m = 0;\n        e = eMax;\n      } else if (e + eBias >= 1) {\n        m = ((value * c) - 1) * Math.pow(2, mLen);\n        e = e + eBias;\n      } else {\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n        e = 0;\n      }\n    }\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n    e = (e << mLen) | m;\n    eLen += mLen;\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n    buffer[offset + i - d] |= s * 128;\n  };\n  var ieee754 = {\n      read: read,\n      write: write\n  };\n  \n  var pbf = Pbf;\n  function Pbf(buf) {\n      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n      this.pos = 0;\n      this.type = 0;\n      this.length = this.buf.length;\n  }\n  Pbf.Varint  = 0;\n  Pbf.Fixed64 = 1;\n  Pbf.Bytes   = 2;\n  Pbf.Fixed32 = 5;\n  var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\n  var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n  Pbf.prototype = {\n      destroy: function() {\n          this.buf = null;\n      },\n      readFields: function(readField, result, end) {\n          end = end || this.length;\n          while (this.pos < end) {\n              var val = this.readVarint(),\n                  tag = val >> 3,\n                  startPos = this.pos;\n              this.type = val & 0x7;\n              readField(tag, result, this);\n              if (this.pos === startPos) this.skip(val);\n          }\n          return result;\n      },\n      readMessage: function(readField, result) {\n          return this.readFields(readField, result, this.readVarint() + this.pos);\n      },\n      readFixed32: function() {\n          var val = readUInt32(this.buf, this.pos);\n          this.pos += 4;\n          return val;\n      },\n      readSFixed32: function() {\n          var val = readInt32(this.buf, this.pos);\n          this.pos += 4;\n          return val;\n      },\n      readFixed64: function() {\n          var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n          this.pos += 8;\n          return val;\n      },\n      readSFixed64: function() {\n          var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n          this.pos += 8;\n          return val;\n      },\n      readFloat: function() {\n          var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n          this.pos += 4;\n          return val;\n      },\n      readDouble: function() {\n          var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n          this.pos += 8;\n          return val;\n      },\n      readVarint: function(isSigned) {\n          var buf = this.buf,\n              val, b;\n          b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n          b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n          b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n          b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n          b = buf[this.pos];   val |= (b & 0x0f) << 28;\n          return readVarintRemainder(val, isSigned, this);\n      },\n      readVarint64: function() {\n          return this.readVarint(true);\n      },\n      readSVarint: function() {\n          var num = this.readVarint();\n          return num % 2 === 1 ? (num + 1) / -2 : num / 2;\n      },\n      readBoolean: function() {\n          return Boolean(this.readVarint());\n      },\n      readString: function() {\n          var end = this.readVarint() + this.pos,\n              str = readUtf8(this.buf, this.pos, end);\n          this.pos = end;\n          return str;\n      },\n      readBytes: function() {\n          var end = this.readVarint() + this.pos,\n              buffer = this.buf.subarray(this.pos, end);\n          this.pos = end;\n          return buffer;\n      },\n      readPackedVarint: function(arr, isSigned) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readVarint(isSigned));\n          return arr;\n      },\n      readPackedSVarint: function(arr) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readSVarint());\n          return arr;\n      },\n      readPackedBoolean: function(arr) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readBoolean());\n          return arr;\n      },\n      readPackedFloat: function(arr) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readFloat());\n          return arr;\n      },\n      readPackedDouble: function(arr) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readDouble());\n          return arr;\n      },\n      readPackedFixed32: function(arr) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readFixed32());\n          return arr;\n      },\n      readPackedSFixed32: function(arr) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readSFixed32());\n          return arr;\n      },\n      readPackedFixed64: function(arr) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readFixed64());\n          return arr;\n      },\n      readPackedSFixed64: function(arr) {\n          var end = readPackedEnd(this);\n          arr = arr || [];\n          while (this.pos < end) arr.push(this.readSFixed64());\n          return arr;\n      },\n      skip: function(val) {\n          var type = val & 0x7;\n          if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n          else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n          else if (type === Pbf.Fixed32) this.pos += 4;\n          else if (type === Pbf.Fixed64) this.pos += 8;\n          else throw new Error('Unimplemented type: ' + type);\n      },\n      writeTag: function(tag, type) {\n          this.writeVarint((tag << 3) | type);\n      },\n      realloc: function(min) {\n          var length = this.length || 16;\n          while (length < this.pos + min) length *= 2;\n          if (length !== this.length) {\n              var buf = new Uint8Array(length);\n              buf.set(this.buf);\n              this.buf = buf;\n              this.length = length;\n          }\n      },\n      finish: function() {\n          this.length = this.pos;\n          this.pos = 0;\n          return this.buf.subarray(0, this.length);\n      },\n      writeFixed32: function(val) {\n          this.realloc(4);\n          writeInt32(this.buf, val, this.pos);\n          this.pos += 4;\n      },\n      writeSFixed32: function(val) {\n          this.realloc(4);\n          writeInt32(this.buf, val, this.pos);\n          this.pos += 4;\n      },\n      writeFixed64: function(val) {\n          this.realloc(8);\n          writeInt32(this.buf, val & -1, this.pos);\n          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n          this.pos += 8;\n      },\n      writeSFixed64: function(val) {\n          this.realloc(8);\n          writeInt32(this.buf, val & -1, this.pos);\n          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n          this.pos += 8;\n      },\n      writeVarint: function(val) {\n          val = +val || 0;\n          if (val > 0xfffffff || val < 0) {\n              writeBigVarint(val, this);\n              return;\n          }\n          this.realloc(4);\n          this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n          this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n          this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n          this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n      },\n      writeSVarint: function(val) {\n          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n      },\n      writeBoolean: function(val) {\n          this.writeVarint(Boolean(val));\n      },\n      writeString: function(str) {\n          str = String(str);\n          this.realloc(str.length * 4);\n          this.pos++;\n          var startPos = this.pos;\n          this.pos = writeUtf8(this.buf, str, this.pos);\n          var len = this.pos - startPos;\n          if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n          this.pos = startPos - 1;\n          this.writeVarint(len);\n          this.pos += len;\n      },\n      writeFloat: function(val) {\n          this.realloc(4);\n          ieee754.write(this.buf, val, this.pos, true, 23, 4);\n          this.pos += 4;\n      },\n      writeDouble: function(val) {\n          this.realloc(8);\n          ieee754.write(this.buf, val, this.pos, true, 52, 8);\n          this.pos += 8;\n      },\n      writeBytes: function(buffer) {\n          var len = buffer.length;\n          this.writeVarint(len);\n          this.realloc(len);\n          for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n      },\n      writeRawMessage: function(fn, obj) {\n          this.pos++;\n          var startPos = this.pos;\n          fn(obj, this);\n          var len = this.pos - startPos;\n          if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n          this.pos = startPos - 1;\n          this.writeVarint(len);\n          this.pos += len;\n      },\n      writeMessage: function(tag, fn, obj) {\n          this.writeTag(tag, Pbf.Bytes);\n          this.writeRawMessage(fn, obj);\n      },\n      writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },\n      writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },\n      writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },\n      writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },\n      writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },\n      writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },\n      writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },\n      writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },\n      writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },\n      writeBytesField: function(tag, buffer) {\n          this.writeTag(tag, Pbf.Bytes);\n          this.writeBytes(buffer);\n      },\n      writeFixed32Field: function(tag, val) {\n          this.writeTag(tag, Pbf.Fixed32);\n          this.writeFixed32(val);\n      },\n      writeSFixed32Field: function(tag, val) {\n          this.writeTag(tag, Pbf.Fixed32);\n          this.writeSFixed32(val);\n      },\n      writeFixed64Field: function(tag, val) {\n          this.writeTag(tag, Pbf.Fixed64);\n          this.writeFixed64(val);\n      },\n      writeSFixed64Field: function(tag, val) {\n          this.writeTag(tag, Pbf.Fixed64);\n          this.writeSFixed64(val);\n      },\n      writeVarintField: function(tag, val) {\n          this.writeTag(tag, Pbf.Varint);\n          this.writeVarint(val);\n      },\n      writeSVarintField: function(tag, val) {\n          this.writeTag(tag, Pbf.Varint);\n          this.writeSVarint(val);\n      },\n      writeStringField: function(tag, str) {\n          this.writeTag(tag, Pbf.Bytes);\n          this.writeString(str);\n      },\n      writeFloatField: function(tag, val) {\n          this.writeTag(tag, Pbf.Fixed32);\n          this.writeFloat(val);\n      },\n      writeDoubleField: function(tag, val) {\n          this.writeTag(tag, Pbf.Fixed64);\n          this.writeDouble(val);\n      },\n      writeBooleanField: function(tag, val) {\n          this.writeVarintField(tag, Boolean(val));\n      }\n  };\n  function readVarintRemainder(l, s, p) {\n      var buf = p.buf,\n          h, b;\n      b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n      b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n      b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n      b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n      b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n      b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n      throw new Error('Expected varint not more than 10 bytes');\n  }\n  function readPackedEnd(pbf) {\n      return pbf.type === Pbf.Bytes ?\n          pbf.readVarint() + pbf.pos : pbf.pos + 1;\n  }\n  function toNum(low, high, isSigned) {\n      if (isSigned) {\n          return high * 0x100000000 + (low >>> 0);\n      }\n      return ((high >>> 0) * 0x100000000) + (low >>> 0);\n  }\n  function writeBigVarint(val, pbf) {\n      var low, high;\n      if (val >= 0) {\n          low  = (val % 0x100000000) | 0;\n          high = (val / 0x100000000) | 0;\n      } else {\n          low  = ~(-val % 0x100000000);\n          high = ~(-val / 0x100000000);\n          if (low ^ 0xffffffff) {\n              low = (low + 1) | 0;\n          } else {\n              low = 0;\n              high = (high + 1) | 0;\n          }\n      }\n      if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n          throw new Error('Given varint doesn\\'t fit into 10 bytes');\n      }\n      pbf.realloc(10);\n      writeBigVarintLow(low, high, pbf);\n      writeBigVarintHigh(high, pbf);\n  }\n  function writeBigVarintLow(low, high, pbf) {\n      pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n      pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n      pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n      pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n      pbf.buf[pbf.pos]   = low & 0x7f;\n  }\n  function writeBigVarintHigh(high, pbf) {\n      var lsb = (high & 0x07) << 4;\n      pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n      pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n      pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n      pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n      pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n      pbf.buf[pbf.pos++]  = high & 0x7f;\n  }\n  function makeRoomForExtraLength(startPos, len, pbf) {\n      var extraLen =\n          len <= 0x3fff ? 1 :\n          len <= 0x1fffff ? 2 :\n          len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));\n      pbf.realloc(extraLen);\n      for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n  }\n  function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\n  function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\n  function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\n  function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\n  function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\n  function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\n  function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\n  function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\n  function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n  function readUInt32(buf, pos) {\n      return ((buf[pos]) |\n          (buf[pos + 1] << 8) |\n          (buf[pos + 2] << 16)) +\n          (buf[pos + 3] * 0x1000000);\n  }\n  function writeInt32(buf, val, pos) {\n      buf[pos] = val;\n      buf[pos + 1] = (val >>> 8);\n      buf[pos + 2] = (val >>> 16);\n      buf[pos + 3] = (val >>> 24);\n  }\n  function readInt32(buf, pos) {\n      return ((buf[pos]) |\n          (buf[pos + 1] << 8) |\n          (buf[pos + 2] << 16)) +\n          (buf[pos + 3] << 24);\n  }\n  function readUtf8(buf, pos, end) {\n      var str = '';\n      var i = pos;\n      while (i < end) {\n          var b0 = buf[i];\n          var c = null;\n          var bytesPerSequence =\n              b0 > 0xEF ? 4 :\n              b0 > 0xDF ? 3 :\n              b0 > 0xBF ? 2 : 1;\n          if (i + bytesPerSequence > end) break;\n          var b1, b2, b3;\n          if (bytesPerSequence === 1) {\n              if (b0 < 0x80) {\n                  c = b0;\n              }\n          } else if (bytesPerSequence === 2) {\n              b1 = buf[i + 1];\n              if ((b1 & 0xC0) === 0x80) {\n                  c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                  if (c <= 0x7F) {\n                      c = null;\n                  }\n              }\n          } else if (bytesPerSequence === 3) {\n              b1 = buf[i + 1];\n              b2 = buf[i + 2];\n              if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                  c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                  if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                      c = null;\n                  }\n              }\n          } else if (bytesPerSequence === 4) {\n              b1 = buf[i + 1];\n              b2 = buf[i + 2];\n              b3 = buf[i + 3];\n              if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                  c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                  if (c <= 0xFFFF || c >= 0x110000) {\n                      c = null;\n                  }\n              }\n          }\n          if (c === null) {\n              c = 0xFFFD;\n              bytesPerSequence = 1;\n          } else if (c > 0xFFFF) {\n              c -= 0x10000;\n              str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n              c = 0xDC00 | c & 0x3FF;\n          }\n          str += String.fromCharCode(c);\n          i += bytesPerSequence;\n      }\n      return str;\n  }\n  function writeUtf8(buf, str, pos) {\n      for (var i = 0, c, lead; i < str.length; i++) {\n          c = str.charCodeAt(i);\n          if (c > 0xD7FF && c < 0xE000) {\n              if (lead) {\n                  if (c < 0xDC00) {\n                      buf[pos++] = 0xEF;\n                      buf[pos++] = 0xBF;\n                      buf[pos++] = 0xBD;\n                      lead = c;\n                      continue;\n                  } else {\n                      c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                      lead = null;\n                  }\n              } else {\n                  if (c > 0xDBFF || (i + 1 === str.length)) {\n                      buf[pos++] = 0xEF;\n                      buf[pos++] = 0xBF;\n                      buf[pos++] = 0xBD;\n                  } else {\n                      lead = c;\n                  }\n                  continue;\n              }\n          } else if (lead) {\n              buf[pos++] = 0xEF;\n              buf[pos++] = 0xBF;\n              buf[pos++] = 0xBD;\n              lead = null;\n          }\n          if (c < 0x80) {\n              buf[pos++] = c;\n          } else {\n              if (c < 0x800) {\n                  buf[pos++] = c >> 0x6 | 0xC0;\n              } else {\n                  if (c < 0x10000) {\n                      buf[pos++] = c >> 0xC | 0xE0;\n                  } else {\n                      buf[pos++] = c >> 0x12 | 0xF0;\n                      buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                  }\n                  buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n              }\n              buf[pos++] = c & 0x3F | 0x80;\n          }\n      }\n      return pos;\n  }\n  \n  exports['default'] = pbf;\n  \n  }((this.PBF = this.PBF || {})));}).call(ol.ext);\n  ol.ext.PBF = ol.ext.PBF.default;\n  \n  goog.provide('ol.render.Feature');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.flat.center');\n  goog.require('ol.geom.flat.interiorpoint');\n  goog.require('ol.geom.flat.interpolate');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * Lightweight, read-only, {@link ol.Feature} and {@link ol.geom.Geometry} like\n   * structure, optimized for vector tile rendering and styling. Geometry access\n   * through the API is limited to getting the type and extent of the geometry.\n   *\n   * @constructor\n   * @param {ol.geom.GeometryType} type Geometry type.\n   * @param {Array.<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array.<number>|Array.<Array.<number>>} ends Ends or Endss.\n   * @param {Object.<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  ol.render.Feature = function(type, flatCoordinates, ends, properties, id) {\n    /**\n     * @private\n     * @type {ol.Extent|undefined}\n     */\n    this.extent_;\n  \n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n  \n    /**\n     * @private\n     * @type {ol.geom.GeometryType}\n     */\n    this.type_ = type;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.flatInteriorPoints_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.flatMidpoints_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<number>|Array.<Array.<number>>}\n     */\n    this.ends_ = ends;\n  \n    /**\n     * @private\n     * @type {Object.<string, *>}\n     */\n    this.properties_ = properties;\n  \n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.tmpTransform_ = ol.transform.create();\n  };\n  \n  \n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  ol.render.Feature.prototype.get = function(key) {\n    return this.properties_[key];\n  };\n  \n  \n  /**\n   * @return {Array.<number>|Array.<Array.<number>>} Ends or endss.\n   */\n  ol.render.Feature.prototype.getEnds =\n  ol.render.Feature.prototype.getEndss = function() {\n    return this.ends_;\n  };\n  \n  \n  /**\n   * Get the extent of this feature's geometry.\n   * @return {ol.Extent} Extent.\n   * @api\n   */\n  ol.render.Feature.prototype.getExtent = function() {\n    if (!this.extent_) {\n      this.extent_ = this.type_ === ol.geom.GeometryType.POINT ?\n        ol.extent.createOrUpdateFromCoordinate(this.flatCoordinates_) :\n        ol.extent.createOrUpdateFromFlatCoordinates(\n            this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n  \n    }\n    return this.extent_;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat interior points.\n   */\n  ol.render.Feature.prototype.getFlatInteriorPoint = function() {\n    if (!this.flatInteriorPoints_) {\n      var flatCenter = ol.extent.getCenter(this.getExtent());\n      this.flatInteriorPoints_ = ol.geom.flat.interiorpoint.linearRings(\n          this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);\n    }\n    return this.flatInteriorPoints_;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat interior points.\n   */\n  ol.render.Feature.prototype.getFlatInteriorPoints = function() {\n    if (!this.flatInteriorPoints_) {\n      var flatCenters = ol.geom.flat.center.linearRingss(\n          this.flatCoordinates_, 0, this.ends_, 2);\n      this.flatInteriorPoints_ = ol.geom.flat.interiorpoint.linearRingss(\n          this.flatCoordinates_, 0, this.ends_, 2, flatCenters);\n    }\n    return this.flatInteriorPoints_;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat midpoint.\n   */\n  ol.render.Feature.prototype.getFlatMidpoint = function() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = ol.geom.flat.interpolate.lineString(\n          this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n    }\n    return this.flatMidpoints_;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat midpoints.\n   */\n  ol.render.Feature.prototype.getFlatMidpoints = function() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      var flatCoordinates = this.flatCoordinates_;\n      var offset = 0;\n      var ends = this.ends_;\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var midpoint = ol.geom.flat.interpolate.lineString(\n            flatCoordinates, offset, end, 2, 0.5);\n        ol.array.extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  };\n  \n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  ol.render.Feature.prototype.getId = function() {\n    return this.id_;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.render.Feature.prototype.getOrientedFlatCoordinates = function() {\n    return this.flatCoordinates_;\n  };\n  \n  \n  /**\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.render.Feature.prototype.getFlatCoordinates =\n      ol.render.Feature.prototype.getOrientedFlatCoordinates;\n  \n  \n  /**\n   * For API compatibility with {@link ol.Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {ol.render.Feature} Feature.\n   * @api\n   */\n  ol.render.Feature.prototype.getGeometry = function() {\n    return this;\n  };\n  \n  \n  /**\n   * Get the feature properties.\n   * @return {Object.<string, *>} Feature properties.\n   * @api\n   */\n  ol.render.Feature.prototype.getProperties = function() {\n    return this.properties_;\n  };\n  \n  \n  /**\n   * Get the feature for working with its geometry.\n   * @return {ol.render.Feature} Feature.\n   */\n  ol.render.Feature.prototype.getSimplifiedGeometry =\n      ol.render.Feature.prototype.getGeometry;\n  \n  \n  /**\n   * @return {number} Stride.\n   */\n  ol.render.Feature.prototype.getStride = function() {\n    return 2;\n  };\n  \n  \n  /**\n   * @return {undefined}\n   */\n  ol.render.Feature.prototype.getStyleFunction = ol.nullFunction;\n  \n  \n  /**\n   * Get the type of this feature's geometry.\n   * @return {ol.geom.GeometryType} Geometry type.\n   * @api\n   */\n  ol.render.Feature.prototype.getType = function() {\n    return this.type_;\n  };\n  \n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   * The SRS of the source and destination are expected to be the same.\n   *\n   * @param {ol.ProjectionLike} source The current projection\n   * @param {ol.ProjectionLike} destination The desired projection.\n   */\n  ol.render.Feature.prototype.transform = function(source, destination) {\n    var pixelExtent = source.getExtent();\n    var projectedExtent = source.getWorldExtent();\n    var scale = ol.extent.getHeight(projectedExtent) / ol.extent.getHeight(pixelExtent);\n    var transform = this.tmpTransform_;\n    ol.transform.compose(transform,\n        projectedExtent[0], projectedExtent[3],\n        scale, -scale, 0,\n        0, 0);\n    ol.geom.flat.transform.transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2,\n        transform, this.flatCoordinates_);\n  };\n  \n  //FIXME Implement projection handling\n  \n  goog.provide('ol.format.MVT');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.ext.PBF');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.FormatType');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.geom.flat.orient');\n  goog.require('ol.proj.Projection');\n  goog.require('ol.proj.Units');\n  goog.require('ol.render.Feature');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading data in the Mapbox MVT format.\n   *\n   * @constructor\n   * @extends {ol.format.Feature}\n   * @param {olx.format.MVTOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.MVT = function(opt_options) {\n  \n    ol.format.Feature.call(this);\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @type {ol.proj.Projection}\n     */\n    this.defaultDataProjection = new ol.proj.Projection({\n      code: 'EPSG:3857',\n      units: ol.proj.Units.TILE_PIXELS\n    });\n  \n    /**\n     * @private\n     * @type {function((ol.geom.Geometry|Object.<string,*>)=)|\n     *     function(ol.geom.GeometryType,Array.<number>,\n     *         (Array.<number>|Array.<Array.<number>>),Object.<string,*>,number)}\n     */\n    this.featureClass_ = options.featureClass ?\n      options.featureClass : ol.render.Feature;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.geometryName_ = options.geometryName;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.layerName_ = options.layerName ? options.layerName : 'layer';\n  \n    /**\n     * @private\n     * @type {Array.<string>}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.extent_ = null;\n  \n  };\n  ol.inherits(ol.format.MVT, ol.format.Feature);\n  \n  \n  /**\n   * Reader callbacks for parsing the PBF.\n   * @type {Object.<string, function(number, Object, ol.ext.PBF)>}\n   */\n  ol.format.MVT.pbfReaders_ = {\n    layers: function(tag, layers, pbf) {\n      if (tag === 3) {\n        var layer = {\n          keys: [],\n          values: [],\n          features: []\n        };\n        var end = pbf.readVarint() + pbf.pos;\n        pbf.readFields(ol.format.MVT.pbfReaders_.layer, layer, end);\n        layer.length = layer.features.length;\n        if (layer.length) {\n          layers[layer.name] = layer;\n        }\n      }\n    },\n    layer: function(tag, layer, pbf) {\n      if (tag === 15) {\n        layer.version = pbf.readVarint();\n      } else if (tag === 1) {\n        layer.name = pbf.readString();\n      } else if (tag === 5) {\n        layer.extent = pbf.readVarint();\n      } else if (tag === 2) {\n        layer.features.push(pbf.pos);\n      } else if (tag === 3) {\n        layer.keys.push(pbf.readString());\n      } else if (tag === 4) {\n        var value = null;\n        var end = pbf.readVarint() + pbf.pos;\n        while (pbf.pos < end) {\n          tag = pbf.readVarint() >> 3;\n          value = tag === 1 ? pbf.readString() :\n            tag === 2 ? pbf.readFloat() :\n              tag === 3 ? pbf.readDouble() :\n                tag === 4 ? pbf.readVarint64() :\n                  tag === 5 ? pbf.readVarint() :\n                    tag === 6 ? pbf.readSVarint() :\n                      tag === 7 ? pbf.readBoolean() : null;\n        }\n        layer.values.push(value);\n      }\n    },\n    feature: function(tag, feature, pbf) {\n      if (tag == 1) {\n        feature.id = pbf.readVarint();\n      } else if (tag == 2) {\n        var end = pbf.readVarint() + pbf.pos;\n        while (pbf.pos < end) {\n          var key = feature.layer.keys[pbf.readVarint()];\n          var value = feature.layer.values[pbf.readVarint()];\n          feature.properties[key] = value;\n        }\n      } else if (tag == 3) {\n        feature.type = pbf.readVarint();\n      } else if (tag == 4) {\n        feature.geometry = pbf.pos;\n      }\n    }\n  };\n  \n  \n  /**\n   * Read a raw feature from the pbf offset stored at index `i` in the raw layer.\n   * @suppress {missingProperties}\n   * @private\n   * @param {ol.ext.PBF} pbf PBF.\n   * @param {Object} layer Raw layer.\n   * @param {number} i Index of the feature in the raw layer's `features` array.\n   * @return {Object} Raw feature.\n   */\n  ol.format.MVT.readRawFeature_ = function(pbf, layer, i) {\n    pbf.pos = layer.features[i];\n    var end = pbf.readVarint() + pbf.pos;\n  \n    var feature = {\n      layer: layer,\n      type: 0,\n      properties: {}\n    };\n    pbf.readFields(ol.format.MVT.pbfReaders_.feature, feature, end);\n    return feature;\n  };\n  \n  \n  /**\n   * Read the raw geometry from the pbf offset stored in a raw feature's geometry\n   * proeprty.\n   * @suppress {missingProperties}\n   * @private\n   * @param {ol.ext.PBF} pbf PBF.\n   * @param {Object} feature Raw feature.\n   * @param {Array.<number>} flatCoordinates Array to store flat coordinates in.\n   * @param {Array.<number>} ends Array to store ends in.\n   */\n  ol.format.MVT.readRawGeometry_ = function(pbf, feature, flatCoordinates, ends) {\n    pbf.pos = feature.geometry;\n  \n    var end = pbf.readVarint() + pbf.pos;\n    var cmd = 1;\n    var length = 0;\n    var x = 0;\n    var y = 0;\n    var coordsLen = 0;\n    var currentEnd = 0;\n  \n    while (pbf.pos < end) {\n      if (!length) {\n        var cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n  \n      length--;\n  \n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n  \n        if (cmd === 1) { // moveTo\n          if (coordsLen > currentEnd) {\n            ends.push(coordsLen);\n            currentEnd = coordsLen;\n          }\n        }\n  \n        flatCoordinates.push(x, y);\n        coordsLen += 2;\n  \n      } else if (cmd === 7) {\n  \n        if (coordsLen > currentEnd) {\n          // close polygon\n          flatCoordinates.push(\n              flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);\n          coordsLen += 2;\n        }\n  \n      } else {\n        ol.asserts.assert(false, 59); // Invalid command found in the PBF\n      }\n    }\n  \n    if (coordsLen > currentEnd) {\n      ends.push(coordsLen);\n      currentEnd = coordsLen;\n    }\n  \n  };\n  \n  \n  /**\n   * @suppress {missingProperties}\n   * @private\n   * @param {number} type The raw feature's geometry type\n   * @param {number} numEnds Number of ends of the flat coordinates of the\n   * geometry.\n   * @return {ol.geom.GeometryType} The geometry type.\n   */\n  ol.format.MVT.getGeometryType_ = function(type, numEnds) {\n    /** @type {ol.geom.GeometryType} */\n    var geometryType;\n    if (type === 1) {\n      geometryType = numEnds === 1 ?\n        ol.geom.GeometryType.POINT : ol.geom.GeometryType.MULTI_POINT;\n    } else if (type === 2) {\n      geometryType = numEnds === 1 ?\n        ol.geom.GeometryType.LINE_STRING :\n        ol.geom.GeometryType.MULTI_LINE_STRING;\n    } else if (type === 3) {\n      geometryType = ol.geom.GeometryType.POLYGON;\n      // MultiPolygon not relevant for rendering - winding order determines\n      // outer rings of polygons.\n    }\n    return geometryType;\n  };\n  \n  /**\n   * @private\n   * @param {ol.ext.PBF} pbf PBF\n   * @param {Object} rawFeature Raw Mapbox feature.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature|ol.render.Feature} Feature.\n   */\n  ol.format.MVT.prototype.createFeature_ = function(pbf, rawFeature, opt_options) {\n    var type = rawFeature.type;\n    if (type === 0) {\n      return null;\n    }\n  \n    var feature;\n    var id = rawFeature.id;\n    var values = rawFeature.properties;\n    values[this.layerName_] = rawFeature.layer.name;\n  \n    var flatCoordinates = [];\n    var ends = [];\n    ol.format.MVT.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);\n  \n    var geometryType = ol.format.MVT.getGeometryType_(type, ends.length);\n  \n    if (this.featureClass_ === ol.render.Feature) {\n      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);\n    } else {\n      var geom;\n      if (geometryType == ol.geom.GeometryType.POLYGON) {\n        var endss = [];\n        var offset = 0;\n        var prevEndIndex = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i];\n          if (!ol.geom.flat.orient.linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n            endss.push(ends.slice(prevEndIndex, i));\n            prevEndIndex = i;\n          }\n          offset = end;\n        }\n        if (endss.length > 1) {\n          ends = endss;\n          geom = new ol.geom.MultiPolygon(null);\n        } else {\n          geom = new ol.geom.Polygon(null);\n        }\n      } else {\n        geom = geometryType === ol.geom.GeometryType.POINT ? new ol.geom.Point(null) :\n          geometryType === ol.geom.GeometryType.LINE_STRING ? new ol.geom.LineString(null) :\n            geometryType === ol.geom.GeometryType.POLYGON ? new ol.geom.Polygon(null) :\n              geometryType === ol.geom.GeometryType.MULTI_POINT ? new ol.geom.MultiPoint (null) :\n                geometryType === ol.geom.GeometryType.MULTI_LINE_STRING ? new ol.geom.MultiLineString(null) :\n                  null;\n      }\n      geom.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates, ends);\n      feature = new this.featureClass_();\n      if (this.geometryName_) {\n        feature.setGeometryName(this.geometryName_);\n      }\n      var geometry = ol.format.Feature.transformWithOptions(geom, false, this.adaptOptions(opt_options));\n      feature.setGeometry(geometry);\n      feature.setId(id);\n      feature.setProperties(values);\n    }\n  \n    return feature;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.format.MVT.prototype.getLastExtent = function() {\n    return this.extent_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.MVT.prototype.getType = function() {\n    return ol.format.FormatType.ARRAY_BUFFER;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.format.MVT.prototype.readFeatures = function(source, opt_options) {\n    var layers = this.layers_;\n  \n    var pbf = new ol.ext.PBF(/** @type {ArrayBuffer} */ (source));\n    var pbfLayers = pbf.readFields(ol.format.MVT.pbfReaders_.layers, {});\n    /** @type {Array.<ol.Feature|ol.render.Feature>} */\n    var features = [];\n    var pbfLayer;\n    for (var name in pbfLayers) {\n      if (layers && layers.indexOf(name) == -1) {\n        continue;\n      }\n      pbfLayer = pbfLayers[name];\n  \n      var rawFeature;\n      for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {\n        rawFeature = ol.format.MVT.readRawFeature_(pbf, pbfLayer, i);\n        features.push(this.createFeature_(pbf, rawFeature));\n      }\n      this.extent_ = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\n    }\n  \n    return features;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.format.MVT.prototype.readProjection = function(source) {\n    return this.defaultDataProjection;\n  };\n  \n  \n  /**\n   * Sets the layers that features will be read from.\n   * @param {Array.<string>} layers Layers.\n   * @api\n   */\n  ol.format.MVT.prototype.setLayers = function(layers) {\n    this.layers_ = layers;\n  };\n  \n  \n  /**\n   * Not implemented.\n   * @override\n   */\n  ol.format.MVT.prototype.readFeature = function() {};\n  \n  \n  /**\n   * Not implemented.\n   * @override\n   */\n  ol.format.MVT.prototype.readGeometry = function() {};\n  \n  \n  /**\n   * Not implemented.\n   * @override\n   */\n  ol.format.MVT.prototype.writeFeature = function() {};\n  \n  \n  /**\n   * Not implemented.\n   * @override\n   */\n  ol.format.MVT.prototype.writeGeometry = function() {};\n  \n  \n  /**\n   * Not implemented.\n   * @override\n   */\n  ol.format.MVT.prototype.writeFeatures = function() {};\n  \n  // FIXME add typedef for stack state objects\n  goog.provide('ol.format.OSMXML');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.Feature');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.XMLFeature');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading data in the\n   * [OSMXML format](http://wiki.openstreetmap.org/wiki/OSM_XML).\n   *\n   * @constructor\n   * @extends {ol.format.XMLFeature}\n   * @api\n   */\n  ol.format.OSMXML = function() {\n    ol.format.XMLFeature.call(this);\n  \n    /**\n     * @inheritDoc\n     */\n    this.defaultDataProjection = ol.proj.get('EPSG:4326');\n  };\n  ol.inherits(ol.format.OSMXML, ol.format.XMLFeature);\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.OSMXML.readNode_ = function(node, objectStack) {\n    var options = /** @type {olx.format.ReadOptions} */ (objectStack[0]);\n    var state = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var id = node.getAttribute('id');\n    /** @type {ol.Coordinate} */\n    var coordinates = [\n      parseFloat(node.getAttribute('lon')),\n      parseFloat(node.getAttribute('lat'))\n    ];\n    state.nodes[id] = coordinates;\n  \n    var values = ol.xml.pushParseAndPop({\n      tags: {}\n    }, ol.format.OSMXML.NODE_PARSERS_, node, objectStack);\n    if (!ol.obj.isEmpty(values.tags)) {\n      var geometry = new ol.geom.Point(coordinates);\n      ol.format.Feature.transformWithOptions(geometry, false, options);\n      var feature = new ol.Feature(geometry);\n      feature.setId(id);\n      feature.setProperties(values.tags);\n      state.features.push(feature);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.OSMXML.readWay_ = function(node, objectStack) {\n    var id = node.getAttribute('id');\n    var values = ol.xml.pushParseAndPop({\n      id: id,\n      ndrefs: [],\n      tags: {}\n    }, ol.format.OSMXML.WAY_PARSERS_, node, objectStack);\n    var state = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    state.ways.push(values);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.OSMXML.readNd_ = function(node, objectStack) {\n    var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    values.ndrefs.push(node.getAttribute('ref'));\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.OSMXML.readTag_ = function(node, objectStack) {\n    var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    values.tags[node.getAttribute('k')] = node.getAttribute('v');\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Array.<string>}\n   */\n  ol.format.OSMXML.NAMESPACE_URIS_ = [\n    null\n  ];\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OSMXML.WAY_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OSMXML.NAMESPACE_URIS_, {\n        'nd': ol.format.OSMXML.readNd_,\n        'tag': ol.format.OSMXML.readTag_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OSMXML.PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OSMXML.NAMESPACE_URIS_, {\n        'node': ol.format.OSMXML.readNode_,\n        'way': ol.format.OSMXML.readWay_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OSMXML.NODE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OSMXML.NAMESPACE_URIS_, {\n        'tag': ol.format.OSMXML.readTag_\n      });\n  \n  \n  /**\n   * Read all features from an OSM source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.OSMXML.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.OSMXML.prototype.readFeaturesFromNode = function(node, opt_options) {\n    var options = this.getReadOptions(node, opt_options);\n    if (node.localName == 'osm') {\n      var state = ol.xml.pushParseAndPop({\n        nodes: {},\n        ways: [],\n        features: []\n      }, ol.format.OSMXML.PARSERS_, node, [options]);\n      // parse nodes in ways\n      for (var j = 0; j < state.ways.length; j++) {\n        var values = /** @type {Object} */ (state.ways[j]);\n        /** @type {Array.<number>} */\n        var flatCoordinates = [];\n        for (var i = 0, ii = values.ndrefs.length; i < ii; i++) {\n          var point = state.nodes[values.ndrefs[i]];\n          ol.array.extend(flatCoordinates, point);\n        }\n        var geometry;\n        if (values.ndrefs[0] == values.ndrefs[values.ndrefs.length - 1]) {\n          // closed way\n          geometry = new ol.geom.Polygon(null);\n          geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates,\n              [flatCoordinates.length]);\n        } else {\n          geometry = new ol.geom.LineString(null);\n          geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates);\n        }\n        ol.format.Feature.transformWithOptions(geometry, false, options);\n        var feature = new ol.Feature(geometry);\n        feature.setId(values.id);\n        feature.setProperties(values.tags);\n        state.features.push(feature);\n      }\n      if (state.features) {\n        return state.features;\n      }\n    }\n    return [];\n  };\n  \n  \n  /**\n   * Read the projection from an OSM source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.format.OSMXML.prototype.readProjection;\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.OSMXML.prototype.writeFeatureNode = function(feature, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.OSMXML.prototype.writeFeaturesNode = function(features, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.OSMXML.prototype.writeGeometryNode = function(geometry, opt_options) {};\n  \n  goog.provide('ol.format.XLink');\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.XLink.NAMESPACE_URI = 'http://www.w3.org/1999/xlink';\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {boolean|undefined} Boolean.\n   */\n  ol.format.XLink.readHref = function(node) {\n    return node.getAttributeNS(ol.format.XLink.NAMESPACE_URI, 'href');\n  };\n  \n  goog.provide('ol.format.XML');\n  \n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Generic format for reading non-feature XML data\n   *\n   * @constructor\n   * @abstract\n   * @struct\n   */\n  ol.format.XML = function() {\n  };\n  \n  \n  /**\n   * @param {Document|Node|string} source Source.\n   * @return {Object} The parsed result.\n   */\n  ol.format.XML.prototype.read = function(source) {\n    if (ol.xml.isDocument(source)) {\n      return this.readFromDocument(/** @type {Document} */ (source));\n    } else if (ol.xml.isNode(source)) {\n      return this.readFromNode(/** @type {Node} */ (source));\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      return this.readFromDocument(doc);\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {Document} doc Document.\n   * @return {Object} Object\n   */\n  ol.format.XML.prototype.readFromDocument = function(doc) {};\n  \n  \n  /**\n   * @abstract\n   * @param {Node} node Node.\n   * @return {Object} Object\n   */\n  ol.format.XML.prototype.readFromNode = function(node) {};\n  \n  goog.provide('ol.format.OWS');\n  \n  goog.require('ol');\n  goog.require('ol.format.XLink');\n  goog.require('ol.format.XML');\n  goog.require('ol.format.XSD');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.format.XML}\n   */\n  ol.format.OWS = function() {\n    ol.format.XML.call(this);\n  };\n  ol.inherits(ol.format.OWS, ol.format.XML);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.OWS.prototype.readFromDocument = function(doc) {\n    for (var n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFromNode(n);\n      }\n    }\n    return null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.OWS.prototype.readFromNode = function(node) {\n    var owsObject = ol.xml.pushParseAndPop({},\n        ol.format.OWS.PARSERS_, node, []);\n    return owsObject ? owsObject : null;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The address.\n   */\n  ol.format.OWS.readAddress_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.OWS.ADDRESS_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The values.\n   */\n  ol.format.OWS.readAllowedValues_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.OWS.ALLOWED_VALUES_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The constraint.\n   */\n  ol.format.OWS.readConstraint_ = function(node, objectStack) {\n    var name = node.getAttribute('name');\n    if (!name) {\n      return undefined;\n    }\n    return ol.xml.pushParseAndPop({'name': name},\n        ol.format.OWS.CONSTRAINT_PARSERS_, node,\n        objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The contact info.\n   */\n  ol.format.OWS.readContactInfo_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.OWS.CONTACT_INFO_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The DCP.\n   */\n  ol.format.OWS.readDcp_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.OWS.DCP_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The GET object.\n   */\n  ol.format.OWS.readGet_ = function(node, objectStack) {\n    var href = ol.format.XLink.readHref(node);\n    if (!href) {\n      return undefined;\n    }\n    return ol.xml.pushParseAndPop({'href': href},\n        ol.format.OWS.REQUEST_METHOD_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The HTTP object.\n   */\n  ol.format.OWS.readHttp_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({}, ol.format.OWS.HTTP_PARSERS_,\n        node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The operation.\n   */\n  ol.format.OWS.readOperation_ = function(node, objectStack) {\n    var name = node.getAttribute('name');\n    var value = ol.xml.pushParseAndPop({},\n        ol.format.OWS.OPERATION_PARSERS_, node, objectStack);\n    if (!value) {\n      return undefined;\n    }\n    var object = /** @type {Object} */\n        (objectStack[objectStack.length - 1]);\n    object[name] = value;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The operations metadata.\n   */\n  ol.format.OWS.readOperationsMetadata_ = function(node,\n      objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.OWS.OPERATIONS_METADATA_PARSERS_, node,\n        objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The phone.\n   */\n  ol.format.OWS.readPhone_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.OWS.PHONE_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The service identification.\n   */\n  ol.format.OWS.readServiceIdentification_ = function(node,\n      objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.OWS.SERVICE_IDENTIFICATION_PARSERS_, node,\n        objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The service contact.\n   */\n  ol.format.OWS.readServiceContact_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.OWS.SERVICE_CONTACT_PARSERS_, node,\n        objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} The service provider.\n   */\n  ol.format.OWS.readServiceProvider_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.OWS.SERVICE_PROVIDER_PARSERS_, node,\n        objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {string|undefined} The value.\n   */\n  ol.format.OWS.readValue_ = function(node, objectStack) {\n    return ol.format.XSD.readString(node);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Array.<string>}\n   * @private\n   */\n  ol.format.OWS.NAMESPACE_URIS_ = [\n    null,\n    'http://www.opengis.net/ows/1.1'\n  ];\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'ServiceIdentification': ol.xml.makeObjectPropertySetter(\n            ol.format.OWS.readServiceIdentification_),\n        'ServiceProvider': ol.xml.makeObjectPropertySetter(\n            ol.format.OWS.readServiceProvider_),\n        'OperationsMetadata': ol.xml.makeObjectPropertySetter(\n            ol.format.OWS.readOperationsMetadata_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.ADDRESS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'DeliveryPoint': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'City': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'AdministrativeArea': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'PostalCode': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Country': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'ElectronicMailAddress': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.ALLOWED_VALUES_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'Value': ol.xml.makeObjectPropertyPusher(ol.format.OWS.readValue_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.CONSTRAINT_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'AllowedValues': ol.xml.makeObjectPropertySetter(\n            ol.format.OWS.readAllowedValues_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.CONTACT_INFO_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'Phone': ol.xml.makeObjectPropertySetter(ol.format.OWS.readPhone_),\n        'Address': ol.xml.makeObjectPropertySetter(ol.format.OWS.readAddress_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.DCP_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'HTTP': ol.xml.makeObjectPropertySetter(ol.format.OWS.readHttp_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.HTTP_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'Get': ol.xml.makeObjectPropertyPusher(ol.format.OWS.readGet_),\n        'Post': undefined // TODO\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.OPERATION_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'DCP': ol.xml.makeObjectPropertySetter(ol.format.OWS.readDcp_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.OPERATIONS_METADATA_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'Operation': ol.format.OWS.readOperation_\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.PHONE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'Voice': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Facsimile': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.REQUEST_METHOD_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.OWS.NAMESPACE_URIS_, {\n        'Constraint': ol.xml.makeObjectPropertyPusher(\n            ol.format.OWS.readConstraint_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.SERVICE_CONTACT_PARSERS_ =\n      ol.xml.makeStructureNS(\n          ol.format.OWS.NAMESPACE_URIS_, {\n            'IndividualName': ol.xml.makeObjectPropertySetter(\n                ol.format.XSD.readString),\n            'PositionName': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n            'ContactInfo': ol.xml.makeObjectPropertySetter(\n                ol.format.OWS.readContactInfo_)\n          });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.SERVICE_IDENTIFICATION_PARSERS_ =\n      ol.xml.makeStructureNS(\n          ol.format.OWS.NAMESPACE_URIS_, {\n            'Abstract': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n            'AccessConstraints': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n            'Fees': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n            'Title': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n            'ServiceTypeVersion': ol.xml.makeObjectPropertySetter(\n                ol.format.XSD.readString),\n            'ServiceType': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)\n          });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.OWS.SERVICE_PROVIDER_PARSERS_ =\n      ol.xml.makeStructureNS(\n          ol.format.OWS.NAMESPACE_URIS_, {\n            'ProviderName': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n            'ProviderSite': ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref),\n            'ServiceContact': ol.xml.makeObjectPropertySetter(\n                ol.format.OWS.readServiceContact_)\n          });\n  \n  goog.provide('ol.geom.flat.flip');\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {Array.<number>=} opt_dest Destination.\n   * @param {number=} opt_destOffset Destination offset.\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.geom.flat.flip.flipXY = function(flatCoordinates, offset, end, stride, opt_dest, opt_destOffset) {\n    var dest, destOffset;\n    if (opt_dest !== undefined) {\n      dest = opt_dest;\n      destOffset = opt_destOffset !== undefined ? opt_destOffset : 0;\n    } else {\n      dest = [];\n      destOffset = 0;\n    }\n    var j = offset;\n    while (j < end) {\n      var x = flatCoordinates[j++];\n      dest[destOffset++] = flatCoordinates[j++];\n      dest[destOffset++] = x;\n      for (var k = 2; k < stride; ++k) {\n        dest[destOffset++] = flatCoordinates[j++];\n      }\n    }\n    dest.length = destOffset;\n    return dest;\n  };\n  \n  goog.provide('ol.format.Polyline');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.Feature');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.TextFeature');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.flip');\n  goog.require('ol.geom.flat.inflate');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the Encoded\n   * Polyline Algorithm Format.\n   *\n   * @constructor\n   * @extends {ol.format.TextFeature}\n   * @param {olx.format.PolylineOptions=} opt_options\n   *     Optional configuration object.\n   * @api\n   */\n  ol.format.Polyline = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.format.TextFeature.call(this);\n  \n    /**\n     * @inheritDoc\n     */\n    this.defaultDataProjection = ol.proj.get('EPSG:4326');\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.factor_ = options.factor ? options.factor : 1e5;\n  \n    /**\n     * @private\n     * @type {ol.geom.GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout ?\n      options.geometryLayout : ol.geom.GeometryLayout.XY;\n  };\n  ol.inherits(ol.format.Polyline, ol.format.TextFeature);\n  \n  \n  /**\n   * Encode a list of n-dimensional points and return an encoded string\n   *\n   * Attention: This function will modify the passed array!\n   *\n   * @param {Array.<number>} numbers A list of n-dimensional points.\n   * @param {number} stride The number of dimension of the points in the list.\n   * @param {number=} opt_factor The factor by which the numbers will be\n   *     multiplied. The remaining decimal places will get rounded away.\n   *     Default is `1e5`.\n   * @return {string} The encoded string.\n   * @api\n   */\n  ol.format.Polyline.encodeDeltas = function(numbers, stride, opt_factor) {\n    var factor = opt_factor ? opt_factor : 1e5;\n    var d;\n  \n    var lastNumbers = new Array(stride);\n    for (d = 0; d < stride; ++d) {\n      lastNumbers[d] = 0;\n    }\n  \n    var i, ii;\n    for (i = 0, ii = numbers.length; i < ii;) {\n      for (d = 0; d < stride; ++d, ++i) {\n        var num = numbers[i];\n        var delta = num - lastNumbers[d];\n        lastNumbers[d] = num;\n  \n        numbers[i] = delta;\n      }\n    }\n  \n    return ol.format.Polyline.encodeFloats(numbers, factor);\n  };\n  \n  \n  /**\n   * Decode a list of n-dimensional points from an encoded string\n   *\n   * @param {string} encoded An encoded string.\n   * @param {number} stride The number of dimension of the points in the\n   *     encoded string.\n   * @param {number=} opt_factor The factor by which the resulting numbers will\n   *     be divided. Default is `1e5`.\n   * @return {Array.<number>} A list of n-dimensional points.\n   * @api\n   */\n  ol.format.Polyline.decodeDeltas = function(encoded, stride, opt_factor) {\n    var factor = opt_factor ? opt_factor : 1e5;\n    var d;\n  \n    /** @type {Array.<number>} */\n    var lastNumbers = new Array(stride);\n    for (d = 0; d < stride; ++d) {\n      lastNumbers[d] = 0;\n    }\n  \n    var numbers = ol.format.Polyline.decodeFloats(encoded, factor);\n  \n    var i, ii;\n    for (i = 0, ii = numbers.length; i < ii;) {\n      for (d = 0; d < stride; ++d, ++i) {\n        lastNumbers[d] += numbers[i];\n  \n        numbers[i] = lastNumbers[d];\n      }\n    }\n  \n    return numbers;\n  };\n  \n  \n  /**\n   * Encode a list of floating point numbers and return an encoded string\n   *\n   * Attention: This function will modify the passed array!\n   *\n   * @param {Array.<number>} numbers A list of floating point numbers.\n   * @param {number=} opt_factor The factor by which the numbers will be\n   *     multiplied. The remaining decimal places will get rounded away.\n   *     Default is `1e5`.\n   * @return {string} The encoded string.\n   * @api\n   */\n  ol.format.Polyline.encodeFloats = function(numbers, opt_factor) {\n    var factor = opt_factor ? opt_factor : 1e5;\n    var i, ii;\n    for (i = 0, ii = numbers.length; i < ii; ++i) {\n      numbers[i] = Math.round(numbers[i] * factor);\n    }\n  \n    return ol.format.Polyline.encodeSignedIntegers(numbers);\n  };\n  \n  \n  /**\n   * Decode a list of floating point numbers from an encoded string\n   *\n   * @param {string} encoded An encoded string.\n   * @param {number=} opt_factor The factor by which the result will be divided.\n   *     Default is `1e5`.\n   * @return {Array.<number>} A list of floating point numbers.\n   * @api\n   */\n  ol.format.Polyline.decodeFloats = function(encoded, opt_factor) {\n    var factor = opt_factor ? opt_factor : 1e5;\n    var numbers = ol.format.Polyline.decodeSignedIntegers(encoded);\n    var i, ii;\n    for (i = 0, ii = numbers.length; i < ii; ++i) {\n      numbers[i] /= factor;\n    }\n    return numbers;\n  };\n  \n  \n  /**\n   * Encode a list of signed integers and return an encoded string\n   *\n   * Attention: This function will modify the passed array!\n   *\n   * @param {Array.<number>} numbers A list of signed integers.\n   * @return {string} The encoded string.\n   */\n  ol.format.Polyline.encodeSignedIntegers = function(numbers) {\n    var i, ii;\n    for (i = 0, ii = numbers.length; i < ii; ++i) {\n      var num = numbers[i];\n      numbers[i] = (num < 0) ? ~(num << 1) : (num << 1);\n    }\n    return ol.format.Polyline.encodeUnsignedIntegers(numbers);\n  };\n  \n  \n  /**\n   * Decode a list of signed integers from an encoded string\n   *\n   * @param {string} encoded An encoded string.\n   * @return {Array.<number>} A list of signed integers.\n   */\n  ol.format.Polyline.decodeSignedIntegers = function(encoded) {\n    var numbers = ol.format.Polyline.decodeUnsignedIntegers(encoded);\n    var i, ii;\n    for (i = 0, ii = numbers.length; i < ii; ++i) {\n      var num = numbers[i];\n      numbers[i] = (num & 1) ? ~(num >> 1) : (num >> 1);\n    }\n    return numbers;\n  };\n  \n  \n  /**\n   * Encode a list of unsigned integers and return an encoded string\n   *\n   * @param {Array.<number>} numbers A list of unsigned integers.\n   * @return {string} The encoded string.\n   */\n  ol.format.Polyline.encodeUnsignedIntegers = function(numbers) {\n    var encoded = '';\n    var i, ii;\n    for (i = 0, ii = numbers.length; i < ii; ++i) {\n      encoded += ol.format.Polyline.encodeUnsignedInteger(numbers[i]);\n    }\n    return encoded;\n  };\n  \n  \n  /**\n   * Decode a list of unsigned integers from an encoded string\n   *\n   * @param {string} encoded An encoded string.\n   * @return {Array.<number>} A list of unsigned integers.\n   */\n  ol.format.Polyline.decodeUnsignedIntegers = function(encoded) {\n    var numbers = [];\n    var current = 0;\n    var shift = 0;\n    var i, ii;\n    for (i = 0, ii = encoded.length; i < ii; ++i) {\n      var b = encoded.charCodeAt(i) - 63;\n      current |= (b & 0x1f) << shift;\n      if (b < 0x20) {\n        numbers.push(current);\n        current = 0;\n        shift = 0;\n      } else {\n        shift += 5;\n      }\n    }\n    return numbers;\n  };\n  \n  \n  /**\n   * Encode one single unsigned integer and return an encoded string\n   *\n   * @param {number} num Unsigned integer that should be encoded.\n   * @return {string} The encoded string.\n   */\n  ol.format.Polyline.encodeUnsignedInteger = function(num) {\n    var value, encoded = '';\n    while (num >= 0x20) {\n      value = (0x20 | (num & 0x1f)) + 63;\n      encoded += String.fromCharCode(value);\n      num >>= 5;\n    }\n    value = num + 63;\n    encoded += String.fromCharCode(value);\n    return encoded;\n  };\n  \n  \n  /**\n   * Read the feature from the Polyline source. The coordinates are assumed to be\n   * in two dimensions and in latitude, longitude order.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   * @api\n   */\n  ol.format.Polyline.prototype.readFeature;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.Polyline.prototype.readFeatureFromText = function(text, opt_options) {\n    var geometry = this.readGeometryFromText(text, opt_options);\n    return new ol.Feature(geometry);\n  };\n  \n  \n  /**\n   * Read the feature from the source. As Polyline sources contain a single\n   * feature, this will return the feature in an array.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.Polyline.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.Polyline.prototype.readFeaturesFromText = function(text, opt_options) {\n    var feature = this.readFeatureFromText(text, opt_options);\n    return [feature];\n  };\n  \n  \n  /**\n   * Read the geometry from the source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.geom.Geometry} Geometry.\n   * @api\n   */\n  ol.format.Polyline.prototype.readGeometry;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.Polyline.prototype.readGeometryFromText = function(text, opt_options) {\n    var stride = ol.geom.SimpleGeometry.getStrideForLayout(this.geometryLayout_);\n    var flatCoordinates = ol.format.Polyline.decodeDeltas(\n        text, stride, this.factor_);\n    ol.geom.flat.flip.flipXY(\n        flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    var coordinates = ol.geom.flat.inflate.coordinates(\n        flatCoordinates, 0, flatCoordinates.length, stride);\n  \n    return /** @type {ol.geom.Geometry} */ (\n      ol.format.Feature.transformWithOptions(\n          new ol.geom.LineString(coordinates, this.geometryLayout_), false,\n          this.adaptOptions(opt_options)));\n  };\n  \n  \n  /**\n   * Read the projection from a Polyline source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.format.Polyline.prototype.readProjection;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.Polyline.prototype.writeFeatureText = function(feature, opt_options) {\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, opt_options);\n    } else {\n      ol.asserts.assert(false, 40); // Expected `feature` to have a geometry\n      return '';\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.Polyline.prototype.writeFeaturesText = function(features, opt_options) {\n    return this.writeFeatureText(features[0], opt_options);\n  };\n  \n  \n  /**\n   * Write a single geometry in Polyline format.\n   *\n   * @function\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} Geometry.\n   * @api\n   */\n  ol.format.Polyline.prototype.writeGeometry;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.Polyline.prototype.writeGeometryText = function(geometry, opt_options) {\n    geometry = /** @type {ol.geom.LineString} */\n      (ol.format.Feature.transformWithOptions(\n          geometry, true, this.adaptOptions(opt_options)));\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n    ol.geom.flat.flip.flipXY(\n        flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    return ol.format.Polyline.encodeDeltas(flatCoordinates, stride, this.factor_);\n  };\n  \n  goog.provide('ol.format.TopoJSON');\n  \n  goog.require('ol');\n  goog.require('ol.Feature');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.JSONFeature');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading data in the TopoJSON format.\n   *\n   * @constructor\n   * @extends {ol.format.JSONFeature}\n   * @param {olx.format.TopoJSONOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.TopoJSON = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.format.JSONFeature.call(this);\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.layerName_ = options.layerName;\n  \n    /**\n     * @private\n     * @type {Array.<string>}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n  \n    /**\n     * @inheritDoc\n     */\n    this.defaultDataProjection = ol.proj.get(\n        options.defaultDataProjection ?\n          options.defaultDataProjection : 'EPSG:4326');\n  \n  };\n  ol.inherits(ol.format.TopoJSON, ol.format.JSONFeature);\n  \n  \n  /**\n   * Concatenate arcs into a coordinate array.\n   * @param {Array.<number>} indices Indices of arcs to concatenate.  Negative\n   *     values indicate arcs need to be reversed.\n   * @param {Array.<Array.<ol.Coordinate>>} arcs Array of arcs (already\n   *     transformed).\n   * @return {Array.<ol.Coordinate>} Coordinates array.\n   * @private\n   */\n  ol.format.TopoJSON.concatenateArcs_ = function(indices, arcs) {\n    /** @type {Array.<ol.Coordinate>} */\n    var coordinates = [];\n    var index, arc;\n    var i, ii;\n    var j, jj;\n    for (i = 0, ii = indices.length; i < ii; ++i) {\n      index = indices[i];\n      if (i > 0) {\n        // splicing together arcs, discard last point\n        coordinates.pop();\n      }\n      if (index >= 0) {\n        // forward arc\n        arc = arcs[index];\n      } else {\n        // reverse arc\n        arc = arcs[~index].slice().reverse();\n      }\n      coordinates.push.apply(coordinates, arc);\n    }\n    // provide fresh copies of coordinate arrays\n    for (j = 0, jj = coordinates.length; j < jj; ++j) {\n      coordinates[j] = coordinates[j].slice();\n    }\n    return coordinates;\n  };\n  \n  \n  /**\n   * Create a point from a TopoJSON geometry object.\n   *\n   * @param {TopoJSONGeometry} object TopoJSON object.\n   * @param {Array.<number>} scale Scale for each dimension.\n   * @param {Array.<number>} translate Translation for each dimension.\n   * @return {ol.geom.Point} Geometry.\n   * @private\n   */\n  ol.format.TopoJSON.readPointGeometry_ = function(object, scale, translate) {\n    var coordinates = object.coordinates;\n    if (scale && translate) {\n      ol.format.TopoJSON.transformVertex_(coordinates, scale, translate);\n    }\n    return new ol.geom.Point(coordinates);\n  };\n  \n  \n  /**\n   * Create a multi-point from a TopoJSON geometry object.\n   *\n   * @param {TopoJSONGeometry} object TopoJSON object.\n   * @param {Array.<number>} scale Scale for each dimension.\n   * @param {Array.<number>} translate Translation for each dimension.\n   * @return {ol.geom.MultiPoint} Geometry.\n   * @private\n   */\n  ol.format.TopoJSON.readMultiPointGeometry_ = function(object, scale,\n      translate) {\n    var coordinates = object.coordinates;\n    var i, ii;\n    if (scale && translate) {\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        ol.format.TopoJSON.transformVertex_(coordinates[i], scale, translate);\n      }\n    }\n    return new ol.geom.MultiPoint(coordinates);\n  };\n  \n  \n  /**\n   * Create a linestring from a TopoJSON geometry object.\n   *\n   * @param {TopoJSONGeometry} object TopoJSON object.\n   * @param {Array.<Array.<ol.Coordinate>>} arcs Array of arcs.\n   * @return {ol.geom.LineString} Geometry.\n   * @private\n   */\n  ol.format.TopoJSON.readLineStringGeometry_ = function(object, arcs) {\n    var coordinates = ol.format.TopoJSON.concatenateArcs_(object.arcs, arcs);\n    return new ol.geom.LineString(coordinates);\n  };\n  \n  \n  /**\n   * Create a multi-linestring from a TopoJSON geometry object.\n   *\n   * @param {TopoJSONGeometry} object TopoJSON object.\n   * @param {Array.<Array.<ol.Coordinate>>} arcs Array of arcs.\n   * @return {ol.geom.MultiLineString} Geometry.\n   * @private\n   */\n  ol.format.TopoJSON.readMultiLineStringGeometry_ = function(object, arcs) {\n    var coordinates = [];\n    var i, ii;\n    for (i = 0, ii = object.arcs.length; i < ii; ++i) {\n      coordinates[i] = ol.format.TopoJSON.concatenateArcs_(object.arcs[i], arcs);\n    }\n    return new ol.geom.MultiLineString(coordinates);\n  };\n  \n  \n  /**\n   * Create a polygon from a TopoJSON geometry object.\n   *\n   * @param {TopoJSONGeometry} object TopoJSON object.\n   * @param {Array.<Array.<ol.Coordinate>>} arcs Array of arcs.\n   * @return {ol.geom.Polygon} Geometry.\n   * @private\n   */\n  ol.format.TopoJSON.readPolygonGeometry_ = function(object, arcs) {\n    var coordinates = [];\n    var i, ii;\n    for (i = 0, ii = object.arcs.length; i < ii; ++i) {\n      coordinates[i] = ol.format.TopoJSON.concatenateArcs_(object.arcs[i], arcs);\n    }\n    return new ol.geom.Polygon(coordinates);\n  };\n  \n  \n  /**\n   * Create a multi-polygon from a TopoJSON geometry object.\n   *\n   * @param {TopoJSONGeometry} object TopoJSON object.\n   * @param {Array.<Array.<ol.Coordinate>>} arcs Array of arcs.\n   * @return {ol.geom.MultiPolygon} Geometry.\n   * @private\n   */\n  ol.format.TopoJSON.readMultiPolygonGeometry_ = function(object, arcs) {\n    var coordinates = [];\n    var polyArray, ringCoords, j, jj;\n    var i, ii;\n    for (i = 0, ii = object.arcs.length; i < ii; ++i) {\n      // for each polygon\n      polyArray = object.arcs[i];\n      ringCoords = [];\n      for (j = 0, jj = polyArray.length; j < jj; ++j) {\n        // for each ring\n        ringCoords[j] = ol.format.TopoJSON.concatenateArcs_(polyArray[j], arcs);\n      }\n      coordinates[i] = ringCoords;\n    }\n    return new ol.geom.MultiPolygon(coordinates);\n  };\n  \n  \n  /**\n   * Create features from a TopoJSON GeometryCollection object.\n   *\n   * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n   *     object.\n   * @param {Array.<Array.<ol.Coordinate>>} arcs Array of arcs.\n   * @param {Array.<number>} scale Scale for each dimension.\n   * @param {Array.<number>} translate Translation for each dimension.\n   * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n   *     object to.\n   * @param {string} name Name of the `Topology`'s child object.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Array of features.\n   * @private\n   */\n  ol.format.TopoJSON.readFeaturesFromGeometryCollection_ = function(\n      collection, arcs, scale, translate, property, name, opt_options) {\n    var geometries = collection.geometries;\n    var features = [];\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      features[i] = ol.format.TopoJSON.readFeatureFromGeometry_(\n          geometries[i], arcs, scale, translate, property, name, opt_options);\n    }\n    return features;\n  };\n  \n  \n  /**\n   * Create a feature from a TopoJSON geometry object.\n   *\n   * @param {TopoJSONGeometry} object TopoJSON geometry object.\n   * @param {Array.<Array.<ol.Coordinate>>} arcs Array of arcs.\n   * @param {Array.<number>} scale Scale for each dimension.\n   * @param {Array.<number>} translate Translation for each dimension.\n   * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n   *     object to.\n   * @param {string} name Name of the `Topology`'s child object.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   * @private\n   */\n  ol.format.TopoJSON.readFeatureFromGeometry_ = function(object, arcs,\n      scale, translate, property, name, opt_options) {\n    var geometry;\n    var type = object.type;\n    var geometryReader = ol.format.TopoJSON.GEOMETRY_READERS_[type];\n    if ((type === 'Point') || (type === 'MultiPoint')) {\n      geometry = geometryReader(object, scale, translate);\n    } else {\n      geometry = geometryReader(object, arcs);\n    }\n    var feature = new ol.Feature();\n    feature.setGeometry(/** @type {ol.geom.Geometry} */ (\n      ol.format.Feature.transformWithOptions(geometry, false, opt_options)));\n    if (object.id !== undefined) {\n      feature.setId(object.id);\n    }\n    var properties = object.properties;\n    if (property) {\n      if (!properties) {\n        properties = {};\n      }\n      properties[property] = name;\n    }\n    if (properties) {\n      feature.setProperties(properties);\n    }\n    return feature;\n  };\n  \n  \n  /**\n   * Read all features from a TopoJSON source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.TopoJSON.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TopoJSON.prototype.readFeaturesFromObject = function(\n      object, opt_options) {\n    if (object.type == 'Topology') {\n      var topoJSONTopology = /** @type {TopoJSONTopology} */ (object);\n      var transform, scale = null, translate = null;\n      if (topoJSONTopology.transform) {\n        transform = topoJSONTopology.transform;\n        scale = transform.scale;\n        translate = transform.translate;\n      }\n      var arcs = topoJSONTopology.arcs;\n      if (transform) {\n        ol.format.TopoJSON.transformArcs_(arcs, scale, translate);\n      }\n      /** @type {Array.<ol.Feature>} */\n      var features = [];\n      var topoJSONFeatures = topoJSONTopology.objects;\n      var property = this.layerName_;\n      var objectName, feature;\n      for (objectName in topoJSONFeatures) {\n        if (this.layers_ && this.layers_.indexOf(objectName) == -1) {\n          continue;\n        }\n        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n          feature = /** @type {TopoJSONGeometryCollection} */\n            (topoJSONFeatures[objectName]);\n          features.push.apply(features,\n              ol.format.TopoJSON.readFeaturesFromGeometryCollection_(\n                  feature, arcs, scale, translate, property, objectName, opt_options));\n        } else {\n          feature = /** @type {TopoJSONGeometry} */\n            (topoJSONFeatures[objectName]);\n          features.push(ol.format.TopoJSON.readFeatureFromGeometry_(\n              feature, arcs, scale, translate, property, objectName, opt_options));\n        }\n      }\n      return features;\n    } else {\n      return [];\n    }\n  };\n  \n  \n  /**\n   * Apply a linear transform to array of arcs.  The provided array of arcs is\n   * modified in place.\n   *\n   * @param {Array.<Array.<ol.Coordinate>>} arcs Array of arcs.\n   * @param {Array.<number>} scale Scale for each dimension.\n   * @param {Array.<number>} translate Translation for each dimension.\n   * @private\n   */\n  ol.format.TopoJSON.transformArcs_ = function(arcs, scale, translate) {\n    var i, ii;\n    for (i = 0, ii = arcs.length; i < ii; ++i) {\n      ol.format.TopoJSON.transformArc_(arcs[i], scale, translate);\n    }\n  };\n  \n  \n  /**\n   * Apply a linear transform to an arc.  The provided arc is modified in place.\n   *\n   * @param {Array.<ol.Coordinate>} arc Arc.\n   * @param {Array.<number>} scale Scale for each dimension.\n   * @param {Array.<number>} translate Translation for each dimension.\n   * @private\n   */\n  ol.format.TopoJSON.transformArc_ = function(arc, scale, translate) {\n    var x = 0;\n    var y = 0;\n    var vertex;\n    var i, ii;\n    for (i = 0, ii = arc.length; i < ii; ++i) {\n      vertex = arc[i];\n      x += vertex[0];\n      y += vertex[1];\n      vertex[0] = x;\n      vertex[1] = y;\n      ol.format.TopoJSON.transformVertex_(vertex, scale, translate);\n    }\n  };\n  \n  \n  /**\n   * Apply a linear transform to a vertex.  The provided vertex is modified in\n   * place.\n   *\n   * @param {ol.Coordinate} vertex Vertex.\n   * @param {Array.<number>} scale Scale for each dimension.\n   * @param {Array.<number>} translate Translation for each dimension.\n   * @private\n   */\n  ol.format.TopoJSON.transformVertex_ = function(vertex, scale, translate) {\n    vertex[0] = vertex[0] * scale[0] + translate[0];\n    vertex[1] = vertex[1] * scale[1] + translate[1];\n  };\n  \n  \n  /**\n   * Read the projection from a TopoJSON source.\n   *\n   * @param {Document|Node|Object|string} object Source.\n   * @return {ol.proj.Projection} Projection.\n   * @override\n   * @api\n   */\n  ol.format.TopoJSON.prototype.readProjection;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.TopoJSON.prototype.readProjectionFromObject = function(object) {\n    return this.defaultDataProjection;\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Object.<string, function(TopoJSONGeometry, Array, ...Array): ol.geom.Geometry>}\n   */\n  ol.format.TopoJSON.GEOMETRY_READERS_ = {\n    'Point': ol.format.TopoJSON.readPointGeometry_,\n    'LineString': ol.format.TopoJSON.readLineStringGeometry_,\n    'Polygon': ol.format.TopoJSON.readPolygonGeometry_,\n    'MultiPoint': ol.format.TopoJSON.readMultiPointGeometry_,\n    'MultiLineString': ol.format.TopoJSON.readMultiLineStringGeometry_,\n    'MultiPolygon': ol.format.TopoJSON.readMultiPolygonGeometry_\n  };\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.TopoJSON.prototype.writeFeatureObject = function(feature, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.TopoJSON.prototype.writeFeaturesObject = function(features, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.TopoJSON.prototype.writeGeometryObject = function(geometry, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @override\n   */\n  ol.format.TopoJSON.prototype.readGeometryFromObject = function() {};\n  \n  \n  /**\n   * Not implemented.\n   * @override\n   */\n  ol.format.TopoJSON.prototype.readFeatureFromObject = function() {};\n  \n  goog.provide('ol.format.WFS');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.format.GML2');\n  goog.require('ol.format.GML3');\n  goog.require('ol.format.GMLBase');\n  goog.require('ol.format.filter');\n  goog.require('ol.format.XMLFeature');\n  goog.require('ol.format.XSD');\n  goog.require('ol.geom.Geometry');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Feature format for reading and writing data in the WFS format.\n   * By default, supports WFS version 1.1.0. You can pass a GML format\n   * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n   * Also see {@link ol.format.GMLBase} which is used by this format.\n   *\n   * @constructor\n   * @param {olx.format.WFSOptions=} opt_options\n   *     Optional configuration object.\n   * @extends {ol.format.XMLFeature}\n   * @api\n   */\n  ol.format.WFS = function(opt_options) {\n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {Array.<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n  \n    /**\n     * @private\n     * @type {Object.<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n  \n    /**\n     * @private\n     * @type {ol.format.GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat ?\n      options.gmlFormat : new ol.format.GML3();\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation ?\n      options.schemaLocation :\n      ol.format.WFS.SCHEMA_LOCATIONS[ol.format.WFS.DEFAULT_VERSION];\n  \n    ol.format.XMLFeature.call(this);\n  };\n  ol.inherits(ol.format.WFS, ol.format.XMLFeature);\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WFS.FEATURE_PREFIX = 'feature';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WFS.XMLNS = 'http://www.w3.org/2000/xmlns/';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WFS.OGCNS = 'http://www.opengis.net/ogc';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WFS.WFSNS = 'http://www.opengis.net/wfs';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WFS.FESNS = 'http://www.opengis.net/fes';\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, string>}\n   */\n  ol.format.WFS.SCHEMA_LOCATIONS = {\n    '1.1.0': 'http://www.opengis.net/wfs ' +\n        'http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n    '1.0.0': 'http://www.opengis.net/wfs ' +\n        'http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n  };\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WFS.DEFAULT_VERSION = '1.1.0';\n  \n  \n  /**\n   * @return {Array.<string>|string|undefined} featureType\n   */\n  ol.format.WFS.prototype.getFeatureType = function() {\n    return this.featureType_;\n  };\n  \n  \n  /**\n   * @param {Array.<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  ol.format.WFS.prototype.setFeatureType = function(featureType) {\n    this.featureType_ = featureType;\n  };\n  \n  \n  /**\n   * Read all features from a WFS FeatureCollection.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.WFS.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WFS.prototype.readFeaturesFromNode = function(node, opt_options) {\n    var context = /** @type {ol.XmlNodeStackItem} */ ({\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_\n    });\n    ol.obj.assign(context, this.getReadOptions(node,\n        opt_options ? opt_options : {}));\n    var objectStack = [context];\n    this.gmlFormat_.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS][\n        'featureMember'] =\n        ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFeaturesInternal);\n    var features = ol.xml.pushParseAndPop([],\n        this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node,\n        objectStack, this.gmlFormat_);\n    if (!features) {\n      features = [];\n    }\n    return features;\n  };\n  \n  \n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.WFSTransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  ol.format.WFS.prototype.readTransactionResponse = function(source) {\n    if (ol.xml.isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n          /** @type {Document} */ (source));\n    } else if (ol.xml.isNode(source)) {\n      return this.readTransactionResponseFromNode(/** @type {Node} */ (source));\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Node|Object|string} source Source.\n   * @return {ol.WFSFeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  ol.format.WFS.prototype.readFeatureCollectionMetadata = function(source) {\n    if (ol.xml.isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n          /** @type {Document} */ (source));\n    } else if (ol.xml.isNode(source)) {\n      return this.readFeatureCollectionMetadataFromNode(\n          /** @type {Node} */ (source));\n    } else if (typeof source === 'string') {\n      var doc = ol.xml.parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @return {ol.WFSFeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  ol.format.WFS.prototype.readFeatureCollectionMetadataFromDocument = function(doc) {\n    for (var n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(n);\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WFS.FEATURE_COLLECTION_PARSERS_ = {\n    'http://www.opengis.net/gml': {\n      'boundedBy': ol.xml.makeObjectPropertySetter(\n          ol.format.GMLBase.prototype.readGeometryElement, 'bounds')\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {ol.WFSFeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  ol.format.WFS.prototype.readFeatureCollectionMetadataFromNode = function(node) {\n    var result = {};\n    var value = ol.format.XSD.readNonNegativeIntegerString(\n        node.getAttribute('numberOfFeatures'));\n    result['numberOfFeatures'] = value;\n    return ol.xml.pushParseAndPop(\n        /** @type {ol.WFSFeatureCollectionMetadata} */ (result),\n        ol.format.WFS.FEATURE_COLLECTION_PARSERS_, node, [], this.gmlFormat_);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WFS.TRANSACTION_SUMMARY_PARSERS_ = {\n    'http://www.opengis.net/wfs': {\n      'totalInserted': ol.xml.makeObjectPropertySetter(\n          ol.format.XSD.readNonNegativeInteger),\n      'totalUpdated': ol.xml.makeObjectPropertySetter(\n          ol.format.XSD.readNonNegativeInteger),\n      'totalDeleted': ol.xml.makeObjectPropertySetter(\n          ol.format.XSD.readNonNegativeInteger)\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Transaction Summary.\n   * @private\n   */\n  ol.format.WFS.readTransactionSummary_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WFS.TRANSACTION_SUMMARY_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WFS.OGC_FID_PARSERS_ = {\n    'http://www.opengis.net/ogc': {\n      'FeatureId': ol.xml.makeArrayPusher(function(node, objectStack) {\n        return node.getAttribute('fid');\n      })\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  ol.format.WFS.fidParser_ = function(node, objectStack) {\n    ol.xml.parseNode(ol.format.WFS.OGC_FID_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WFS.INSERT_RESULTS_PARSERS_ = {\n    'http://www.opengis.net/wfs': {\n      'Feature': ol.format.WFS.fidParser_\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Array.<string>|undefined} Insert results.\n   * @private\n   */\n  ol.format.WFS.readInsertResults_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        [], ol.format.WFS.INSERT_RESULTS_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WFS.TRANSACTION_RESPONSE_PARSERS_ = {\n    'http://www.opengis.net/wfs': {\n      'TransactionSummary': ol.xml.makeObjectPropertySetter(\n          ol.format.WFS.readTransactionSummary_, 'transactionSummary'),\n      'InsertResults': ol.xml.makeObjectPropertySetter(\n          ol.format.WFS.readInsertResults_, 'insertIds')\n    }\n  };\n  \n  \n  /**\n   * @param {Document} doc Document.\n   * @return {ol.WFSTransactionResponse|undefined} Transaction response.\n   */\n  ol.format.WFS.prototype.readTransactionResponseFromDocument = function(doc) {\n    for (var n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(n);\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @return {ol.WFSTransactionResponse|undefined} Transaction response.\n   */\n  ol.format.WFS.prototype.readTransactionResponseFromNode = function(node) {\n    return ol.xml.pushParseAndPop(\n        /** @type {ol.WFSTransactionResponse} */({}),\n        ol.format.WFS.TRANSACTION_RESPONSE_PARSERS_, node, []);\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.WFS.QUERY_SERIALIZERS_ = {\n    'http://www.opengis.net/wfs': {\n      'PropertyName': ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeFeature_ = function(node, feature, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var featureType = context['featureType'];\n    var featureNS = context['featureNS'];\n    var gmlVersion = context['gmlVersion'];\n    var child = ol.xml.createElementNS(featureNS, featureType);\n    node.appendChild(child);\n    if (gmlVersion === 2) {\n      ol.format.GML2.prototype.writeFeatureElement(child, feature, objectStack);\n    } else {\n      ol.format.GML3.prototype.writeFeatureElement(child, feature, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {number|string} fid Feature identifier.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeOgcFidFilter_ = function(node, fid, objectStack) {\n    var filter = ol.xml.createElementNS(ol.format.WFS.OGCNS, 'Filter');\n    var child = ol.xml.createElementNS(ol.format.WFS.OGCNS, 'FeatureId');\n    filter.appendChild(child);\n    child.setAttribute('fid', fid);\n    node.appendChild(filter);\n  };\n  \n  \n  /**\n   * @param {string|undefined} featurePrefix The prefix of the feature.\n   * @param {string} featureType The type of the feature.\n   * @returns {string} The value of the typeName property.\n   * @private\n   */\n  ol.format.WFS.getTypeName_ = function(featurePrefix, featureType) {\n    featurePrefix = featurePrefix ? featurePrefix :\n      ol.format.WFS.FEATURE_PREFIX;\n    var prefix = featurePrefix + ':';\n    // The featureType already contains the prefix.\n    if (featureType.indexOf(prefix) === 0) {\n      return featureType;\n    } else {\n      return prefix + featureType;\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeDelete_ = function(node, feature, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    ol.asserts.assert(feature.getId() !== undefined, 26); // Features must have an id set\n    var featureType = context['featureType'];\n    var featurePrefix = context['featurePrefix'];\n    var featureNS = context['featureNS'];\n    var typeName = ol.format.WFS.getTypeName_(featurePrefix, featureType);\n    node.setAttribute('typeName', typeName);\n    ol.xml.setAttributeNS(node, ol.format.WFS.XMLNS, 'xmlns:' + featurePrefix,\n        featureNS);\n    var fid = feature.getId();\n    if (fid !== undefined) {\n      ol.format.WFS.writeOgcFidFilter_(node, fid, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.Feature} feature Feature.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeUpdate_ = function(node, feature, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    ol.asserts.assert(feature.getId() !== undefined, 27); // Features must have an id set\n    var featureType = context['featureType'];\n    var featurePrefix = context['featurePrefix'];\n    var featureNS = context['featureNS'];\n    var typeName = ol.format.WFS.getTypeName_(featurePrefix, featureType);\n    var geometryName = feature.getGeometryName();\n    node.setAttribute('typeName', typeName);\n    ol.xml.setAttributeNS(node, ol.format.WFS.XMLNS, 'xmlns:' + featurePrefix,\n        featureNS);\n    var fid = feature.getId();\n    if (fid !== undefined) {\n      var keys = feature.getKeys();\n      var values = [];\n      for (var i = 0, ii = keys.length; i < ii; i++) {\n        var value = feature.get(keys[i]);\n        if (value !== undefined) {\n          var name = keys[i];\n          if (value instanceof ol.geom.Geometry) {\n            name = geometryName;\n          }\n          values.push({name: name, value: value});\n        }\n      }\n      ol.xml.pushSerializeAndPop(/** @type {ol.XmlNodeStackItem} */ (\n        {'gmlVersion': context['gmlVersion'], node: node,\n          'hasZ': context['hasZ'], 'srsName': context['srsName']}),\n      ol.format.WFS.TRANSACTION_SERIALIZERS_,\n      ol.xml.makeSimpleNodeFactory('Property'), values,\n      objectStack);\n      ol.format.WFS.writeOgcFidFilter_(node, fid, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Object} pair Property name and value.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeProperty_ = function(node, pair, objectStack) {\n    var name = ol.xml.createElementNS(ol.format.WFS.WFSNS, 'Name');\n    var context = objectStack[objectStack.length - 1];\n    var gmlVersion = context['gmlVersion'];\n    node.appendChild(name);\n    ol.format.XSD.writeStringTextNode(name, pair.name);\n    if (pair.value !== undefined && pair.value !== null) {\n      var value = ol.xml.createElementNS(ol.format.WFS.WFSNS, 'Value');\n      node.appendChild(value);\n      if (pair.value instanceof ol.geom.Geometry) {\n        if (gmlVersion === 2) {\n          ol.format.GML2.prototype.writeGeometryElement(value,\n              pair.value, objectStack);\n        } else {\n          ol.format.GML3.prototype.writeGeometryElement(value,\n              pair.value, objectStack);\n        }\n      } else {\n        ol.format.XSD.writeStringTextNode(value, pair.value);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {{vendorId: string, safeToIgnore: boolean, value: string}}\n   *     nativeElement The native element.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeNative_ = function(node, nativeElement, objectStack) {\n    if (nativeElement.vendorId) {\n      node.setAttribute('vendorId', nativeElement.vendorId);\n    }\n    if (nativeElement.safeToIgnore !== undefined) {\n      node.setAttribute('safeToIgnore', nativeElement.safeToIgnore);\n    }\n    if (nativeElement.value !== undefined) {\n      ol.format.XSD.writeStringTextNode(node, nativeElement.value);\n    }\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.WFS.TRANSACTION_SERIALIZERS_ = {\n    'http://www.opengis.net/wfs': {\n      'Insert': ol.xml.makeChildAppender(ol.format.WFS.writeFeature_),\n      'Update': ol.xml.makeChildAppender(ol.format.WFS.writeUpdate_),\n      'Delete': ol.xml.makeChildAppender(ol.format.WFS.writeDelete_),\n      'Property': ol.xml.makeChildAppender(ol.format.WFS.writeProperty_),\n      'Native': ol.xml.makeChildAppender(ol.format.WFS.writeNative_)\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {string} featureType Feature type.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeQuery_ = function(node, featureType, objectStack) {\n    var context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var featurePrefix = context['featurePrefix'];\n    var featureNS = context['featureNS'];\n    var propertyNames = context['propertyNames'];\n    var srsName = context['srsName'];\n    var typeName;\n    // If feature prefix is not defined, we must not use the default prefix.\n    if (featurePrefix) {\n      typeName = ol.format.WFS.getTypeName_(featurePrefix, featureType);\n    } else {\n      typeName = featureType;\n    }\n    node.setAttribute('typeName', typeName);\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (featureNS) {\n      ol.xml.setAttributeNS(node, ol.format.WFS.XMLNS, 'xmlns:' + featurePrefix,\n          featureNS);\n    }\n    var item = /** @type {ol.XmlNodeStackItem} */ (ol.obj.assign({}, context));\n    item.node = node;\n    ol.xml.pushSerializeAndPop(item,\n        ol.format.WFS.QUERY_SERIALIZERS_,\n        ol.xml.makeSimpleNodeFactory('PropertyName'), propertyNames,\n        objectStack);\n    var filter = context['filter'];\n    if (filter) {\n      var child = ol.xml.createElementNS(ol.format.WFS.OGCNS, 'Filter');\n      node.appendChild(child);\n      ol.format.WFS.writeFilterCondition_(child, filter, objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.Filter} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeFilterCondition_ = function(node, filter, objectStack) {\n    /** @type {ol.XmlNodeStackItem} */\n    var item = {node: node};\n    ol.xml.pushSerializeAndPop(item,\n        ol.format.WFS.GETFEATURE_SERIALIZERS_,\n        ol.xml.makeSimpleNodeFactory(filter.getTagName()),\n        [filter], objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.Bbox} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeBboxFilter_ = function(node, filter, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    context['srsName'] = filter.srsName;\n  \n    ol.format.WFS.writeOgcPropertyName_(node, filter.geometryName);\n    ol.format.GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.Contains} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeContainsFilter_ = function(node, filter, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    context['srsName'] = filter.srsName;\n  \n    ol.format.WFS.writeOgcPropertyName_(node, filter.geometryName);\n    ol.format.GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.Intersects} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeIntersectsFilter_ = function(node, filter, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    context['srsName'] = filter.srsName;\n  \n    ol.format.WFS.writeOgcPropertyName_(node, filter.geometryName);\n    ol.format.GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.Within} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeWithinFilter_ = function(node, filter, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    context['srsName'] = filter.srsName;\n  \n    ol.format.WFS.writeOgcPropertyName_(node, filter.geometryName);\n    ol.format.GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.During} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeDuringFilter_ = function(node, filter, objectStack) {\n  \n    var valueReference = ol.xml.createElementNS(ol.format.WFS.FESNS, 'ValueReference');\n    ol.format.XSD.writeStringTextNode(valueReference, filter.propertyName);\n    node.appendChild(valueReference);\n  \n    var timePeriod = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, 'TimePeriod');\n  \n    node.appendChild(timePeriod);\n  \n    var begin = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, 'begin');\n    timePeriod.appendChild(begin);\n    ol.format.WFS.writeTimeInstant_(begin, filter.begin);\n  \n    var end = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, 'end');\n    timePeriod.appendChild(end);\n    ol.format.WFS.writeTimeInstant_(end, filter.end);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.LogicalNary} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeLogicalFilter_ = function(node, filter, objectStack) {\n    /** @type {ol.XmlNodeStackItem} */\n    var item = {node: node};\n    var conditions = filter.conditions;\n    for (var i = 0, ii = conditions.length; i < ii; ++i) {\n      var condition = conditions[i];\n      ol.xml.pushSerializeAndPop(item,\n          ol.format.WFS.GETFEATURE_SERIALIZERS_,\n          ol.xml.makeSimpleNodeFactory(condition.getTagName()),\n          [condition], objectStack);\n    }\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.Not} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeNotFilter_ = function(node, filter, objectStack) {\n    /** @type {ol.XmlNodeStackItem} */\n    var item = {node: node};\n    var condition = filter.condition;\n    ol.xml.pushSerializeAndPop(item,\n        ol.format.WFS.GETFEATURE_SERIALIZERS_,\n        ol.xml.makeSimpleNodeFactory(condition.getTagName()),\n        [condition], objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.ComparisonBinary} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeComparisonFilter_ = function(node, filter, objectStack) {\n    if (filter.matchCase !== undefined) {\n      node.setAttribute('matchCase', filter.matchCase.toString());\n    }\n    ol.format.WFS.writeOgcPropertyName_(node, filter.propertyName);\n    ol.format.WFS.writeOgcLiteral_(node, '' + filter.expression);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.IsNull} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeIsNullFilter_ = function(node, filter, objectStack) {\n    ol.format.WFS.writeOgcPropertyName_(node, filter.propertyName);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.IsBetween} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeIsBetweenFilter_ = function(node, filter, objectStack) {\n    ol.format.WFS.writeOgcPropertyName_(node, filter.propertyName);\n  \n    var lowerBoundary = ol.xml.createElementNS(ol.format.WFS.OGCNS, 'LowerBoundary');\n    node.appendChild(lowerBoundary);\n    ol.format.WFS.writeOgcLiteral_(lowerBoundary, '' + filter.lowerBoundary);\n  \n    var upperBoundary = ol.xml.createElementNS(ol.format.WFS.OGCNS, 'UpperBoundary');\n    node.appendChild(upperBoundary);\n    ol.format.WFS.writeOgcLiteral_(upperBoundary, '' + filter.upperBoundary);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {ol.format.filter.IsLike} filter Filter.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeIsLikeFilter_ = function(node, filter, objectStack) {\n    node.setAttribute('wildCard', filter.wildCard);\n    node.setAttribute('singleChar', filter.singleChar);\n    node.setAttribute('escapeChar', filter.escapeChar);\n    if (filter.matchCase !== undefined) {\n      node.setAttribute('matchCase', filter.matchCase.toString());\n    }\n    ol.format.WFS.writeOgcPropertyName_(node, filter.propertyName);\n    ol.format.WFS.writeOgcLiteral_(node, '' + filter.pattern);\n  };\n  \n  \n  /**\n   * @param {string} tagName Tag name.\n   * @param {Node} node Node.\n   * @param {string} value Value.\n   * @private\n   */\n  ol.format.WFS.writeOgcExpression_ = function(tagName, node, value) {\n    var property = ol.xml.createElementNS(ol.format.WFS.OGCNS, tagName);\n    ol.format.XSD.writeStringTextNode(property, value);\n    node.appendChild(property);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {string} value PropertyName value.\n   * @private\n   */\n  ol.format.WFS.writeOgcPropertyName_ = function(node, value) {\n    ol.format.WFS.writeOgcExpression_('PropertyName', node, value);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {string} value PropertyName value.\n   * @private\n   */\n  ol.format.WFS.writeOgcLiteral_ = function(node, value) {\n    ol.format.WFS.writeOgcExpression_('Literal', node, value);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {string} time PropertyName value.\n   * @private\n   */\n  ol.format.WFS.writeTimeInstant_ = function(node, time) {\n    var timeInstant = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, 'TimeInstant');\n    node.appendChild(timeInstant);\n  \n    var timePosition = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, 'timePosition');\n    timeInstant.appendChild(timePosition);\n    ol.format.XSD.writeStringTextNode(timePosition, time);\n  };\n  \n  \n  /**\n   * @type {Object.<string, Object.<string, ol.XmlSerializer>>}\n   * @private\n   */\n  ol.format.WFS.GETFEATURE_SERIALIZERS_ = {\n    'http://www.opengis.net/wfs': {\n      'Query': ol.xml.makeChildAppender(ol.format.WFS.writeQuery_)\n    },\n    'http://www.opengis.net/ogc': {\n      'During': ol.xml.makeChildAppender(ol.format.WFS.writeDuringFilter_),\n      'And': ol.xml.makeChildAppender(ol.format.WFS.writeLogicalFilter_),\n      'Or': ol.xml.makeChildAppender(ol.format.WFS.writeLogicalFilter_),\n      'Not': ol.xml.makeChildAppender(ol.format.WFS.writeNotFilter_),\n      'BBOX': ol.xml.makeChildAppender(ol.format.WFS.writeBboxFilter_),\n      'Contains': ol.xml.makeChildAppender(ol.format.WFS.writeContainsFilter_),\n      'Intersects': ol.xml.makeChildAppender(ol.format.WFS.writeIntersectsFilter_),\n      'Within': ol.xml.makeChildAppender(ol.format.WFS.writeWithinFilter_),\n      'PropertyIsEqualTo': ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),\n      'PropertyIsNotEqualTo': ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),\n      'PropertyIsLessThan': ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),\n      'PropertyIsLessThanOrEqualTo': ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),\n      'PropertyIsGreaterThan': ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),\n      'PropertyIsGreaterThanOrEqualTo': ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_),\n      'PropertyIsNull': ol.xml.makeChildAppender(ol.format.WFS.writeIsNullFilter_),\n      'PropertyIsBetween': ol.xml.makeChildAppender(ol.format.WFS.writeIsBetweenFilter_),\n      'PropertyIsLike': ol.xml.makeChildAppender(ol.format.WFS.writeIsLikeFilter_)\n    }\n  };\n  \n  \n  /**\n   * Encode filter as WFS `Filter` and return the Node.\n   *\n   * @param {ol.format.filter.Filter} filter Filter.\n   * @return {Node} Result.\n   * @api\n   */\n  ol.format.WFS.writeFilter = function(filter) {\n    var child = ol.xml.createElementNS(ol.format.WFS.OGCNS, 'Filter');\n    ol.format.WFS.writeFilterCondition_(child, filter, []);\n    return child;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<string>} featureTypes Feature types.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  ol.format.WFS.writeGetFeature_ = function(node, featureTypes, objectStack) {\n    var context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var item = /** @type {ol.XmlNodeStackItem} */ (ol.obj.assign({}, context));\n    item.node = node;\n    ol.xml.pushSerializeAndPop(item,\n        ol.format.WFS.GETFEATURE_SERIALIZERS_,\n        ol.xml.makeSimpleNodeFactory('Query'), featureTypes,\n        objectStack);\n  };\n  \n  \n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {olx.format.WFSWriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  ol.format.WFS.prototype.writeGetFeature = function(options) {\n    var node = ol.xml.createElementNS(ol.format.WFS.WFSNS, 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', '1.1.0');\n    var filter;\n    if (options) {\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n      if (options.outputFormat) {\n        node.setAttribute('outputFormat', options.outputFormat);\n      }\n      if (options.maxFeatures !== undefined) {\n        node.setAttribute('maxFeatures', options.maxFeatures);\n      }\n      if (options.resultType) {\n        node.setAttribute('resultType', options.resultType);\n      }\n      if (options.startIndex !== undefined) {\n        node.setAttribute('startIndex', options.startIndex);\n      }\n      if (options.count !== undefined) {\n        node.setAttribute('count', options.count);\n      }\n      filter = options.filter;\n      if (options.bbox) {\n        ol.asserts.assert(options.geometryName,\n            12); // `options.geometryName` must also be provided when `options.bbox` is set\n        var bbox = ol.format.filter.bbox(\n            /** @type {string} */ (options.geometryName), options.bbox, options.srsName);\n        if (filter) {\n          // if bbox and filter are both set, combine the two into a single filter\n          filter = ol.format.filter.and(filter, bbox);\n        } else {\n          filter = bbox;\n        }\n      }\n    }\n    ol.xml.setAttributeNS(node, 'http://www.w3.org/2001/XMLSchema-instance',\n        'xsi:schemaLocation', this.schemaLocation_);\n    /** @type {ol.XmlNodeStackItem} */\n    var context = {\n      node: node,\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'geometryName': options.geometryName,\n      'filter': filter,\n      'propertyNames': options.propertyNames ? options.propertyNames : []\n    };\n    ol.asserts.assert(Array.isArray(options.featureTypes),\n        11); // `options.featureTypes` should be an Array\n    ol.format.WFS.writeGetFeature_(node, /** @type {!Array.<string>} */ (options.featureTypes), [context]);\n    return node;\n  };\n  \n  \n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array.<ol.Feature>} inserts The features to insert.\n   * @param {Array.<ol.Feature>} updates The features to update.\n   * @param {Array.<ol.Feature>} deletes The features to delete.\n   * @param {olx.format.WFSWriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  ol.format.WFS.prototype.writeTransaction = function(inserts, updates, deletes,\n      options) {\n    var objectStack = [];\n    var node = ol.xml.createElementNS(ol.format.WFS.WFSNS, 'Transaction');\n    var version = options.version ?\n      options.version : ol.format.WFS.DEFAULT_VERSION;\n    var gmlVersion = version === '1.0.0' ? 2 : 3;\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    var baseObj;\n    /** @type {ol.XmlNodeStackItem} */\n    var obj;\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    var schemaLocation = ol.format.WFS.SCHEMA_LOCATIONS[version];\n    ol.xml.setAttributeNS(node, 'http://www.w3.org/2001/XMLSchema-instance',\n        'xsi:schemaLocation', schemaLocation);\n    var featurePrefix = options.featurePrefix ? options.featurePrefix : ol.format.WFS.FEATURE_PREFIX;\n    if (inserts) {\n      obj = {node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName};\n      ol.obj.assign(obj, baseObj);\n      ol.xml.pushSerializeAndPop(obj,\n          ol.format.WFS.TRANSACTION_SERIALIZERS_,\n          ol.xml.makeSimpleNodeFactory('Insert'), inserts,\n          objectStack);\n    }\n    if (updates) {\n      obj = {node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName};\n      ol.obj.assign(obj, baseObj);\n      ol.xml.pushSerializeAndPop(obj,\n          ol.format.WFS.TRANSACTION_SERIALIZERS_,\n          ol.xml.makeSimpleNodeFactory('Update'), updates,\n          objectStack);\n    }\n    if (deletes) {\n      ol.xml.pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'srsName': options.srsName},\n      ol.format.WFS.TRANSACTION_SERIALIZERS_,\n      ol.xml.makeSimpleNodeFactory('Delete'), deletes,\n      objectStack);\n    }\n    if (options.nativeElements) {\n      ol.xml.pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'srsName': options.srsName},\n      ol.format.WFS.TRANSACTION_SERIALIZERS_,\n      ol.xml.makeSimpleNodeFactory('Native'), options.nativeElements,\n      objectStack);\n    }\n    return node;\n  };\n  \n  \n  /**\n   * Read the projection from a WFS source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @return {?ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.format.WFS.prototype.readProjection;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WFS.prototype.readProjectionFromDocument = function(doc) {\n    for (var n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(n);\n      }\n    }\n    return null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WFS.prototype.readProjectionFromNode = function(node) {\n    if (node.firstElementChild &&\n        node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (var n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (!(n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 &&\n            n.firstChild.nodeType === 3))) {\n          var objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return ol.proj.get(objectStack.pop().srsName);\n        }\n      }\n    }\n  \n    return null;\n  };\n  \n  goog.provide('ol.format.WKT');\n  \n  goog.require('ol');\n  goog.require('ol.Feature');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.TextFeature');\n  goog.require('ol.geom.GeometryCollection');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.geom.SimpleGeometry');\n  \n  \n  /**\n   * @classdesc\n   * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n   * format.\n   *\n   * @constructor\n   * @extends {ol.format.TextFeature}\n   * @param {olx.format.WKTOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.WKT = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.format.TextFeature.call(this);\n  \n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n    this.splitCollection_ = options.splitCollection !== undefined ?\n      options.splitCollection : false;\n  \n  };\n  ol.inherits(ol.format.WKT, ol.format.TextFeature);\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WKT.EMPTY = 'EMPTY';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WKT.Z = 'Z';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WKT.M = 'M';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.format.WKT.ZM = 'ZM';\n  \n  \n  /**\n   * @param {ol.geom.Point} geom Point geometry.\n   * @return {string} Coordinates part of Point as WKT.\n   * @private\n   */\n  ol.format.WKT.encodePointGeometry_ = function(geom) {\n    var coordinates = geom.getCoordinates();\n    if (coordinates.length === 0) {\n      return '';\n    }\n    return coordinates.join(' ');\n  };\n  \n  \n  /**\n   * @param {ol.geom.MultiPoint} geom MultiPoint geometry.\n   * @return {string} Coordinates part of MultiPoint as WKT.\n   * @private\n   */\n  ol.format.WKT.encodeMultiPointGeometry_ = function(geom) {\n    var array = [];\n    var components = geom.getPoints();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n      array.push('(' + ol.format.WKT.encodePointGeometry_(components[i]) + ')');\n    }\n    return array.join(',');\n  };\n  \n  \n  /**\n   * @param {ol.geom.GeometryCollection} geom GeometryCollection geometry.\n   * @return {string} Coordinates part of GeometryCollection as WKT.\n   * @private\n   */\n  ol.format.WKT.encodeGeometryCollectionGeometry_ = function(geom) {\n    var array = [];\n    var geoms = geom.getGeometries();\n    for (var i = 0, ii = geoms.length; i < ii; ++i) {\n      array.push(ol.format.WKT.encode_(geoms[i]));\n    }\n    return array.join(',');\n  };\n  \n  \n  /**\n   * @param {ol.geom.LineString|ol.geom.LinearRing} geom LineString geometry.\n   * @return {string} Coordinates part of LineString as WKT.\n   * @private\n   */\n  ol.format.WKT.encodeLineStringGeometry_ = function(geom) {\n    var coordinates = geom.getCoordinates();\n    var array = [];\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n      array.push(coordinates[i].join(' '));\n    }\n    return array.join(',');\n  };\n  \n  \n  /**\n   * @param {ol.geom.MultiLineString} geom MultiLineString geometry.\n   * @return {string} Coordinates part of MultiLineString as WKT.\n   * @private\n   */\n  ol.format.WKT.encodeMultiLineStringGeometry_ = function(geom) {\n    var array = [];\n    var components = geom.getLineStrings();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n      array.push('(' + ol.format.WKT.encodeLineStringGeometry_(\n          components[i]) + ')');\n    }\n    return array.join(',');\n  };\n  \n  \n  /**\n   * @param {ol.geom.Polygon} geom Polygon geometry.\n   * @return {string} Coordinates part of Polygon as WKT.\n   * @private\n   */\n  ol.format.WKT.encodePolygonGeometry_ = function(geom) {\n    var array = [];\n    var rings = geom.getLinearRings();\n    for (var i = 0, ii = rings.length; i < ii; ++i) {\n      array.push('(' + ol.format.WKT.encodeLineStringGeometry_(\n          rings[i]) + ')');\n    }\n    return array.join(',');\n  };\n  \n  \n  /**\n   * @param {ol.geom.MultiPolygon} geom MultiPolygon geometry.\n   * @return {string} Coordinates part of MultiPolygon as WKT.\n   * @private\n   */\n  ol.format.WKT.encodeMultiPolygonGeometry_ = function(geom) {\n    var array = [];\n    var components = geom.getPolygons();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n      array.push('(' + ol.format.WKT.encodePolygonGeometry_(\n          components[i]) + ')');\n    }\n    return array.join(',');\n  };\n  \n  /**\n   * @param {ol.geom.SimpleGeometry} geom SimpleGeometry geometry.\n   * @return {string} Potential dimensional information for WKT type.\n   * @private\n   */\n  ol.format.WKT.encodeGeometryLayout_ = function(geom) {\n    var layout = geom.getLayout();\n    var dimInfo = '';\n    if (layout === ol.geom.GeometryLayout.XYZ || layout === ol.geom.GeometryLayout.XYZM) {\n      dimInfo += ol.format.WKT.Z;\n    }\n    if (layout === ol.geom.GeometryLayout.XYM || layout === ol.geom.GeometryLayout.XYZM) {\n      dimInfo += ol.format.WKT.M;\n    }\n    return dimInfo;\n  };\n  \n  \n  /**\n   * Encode a geometry as WKT.\n   * @param {ol.geom.Geometry} geom The geometry to encode.\n   * @return {string} WKT string for the geometry.\n   * @private\n   */\n  ol.format.WKT.encode_ = function(geom) {\n    var type = geom.getType();\n    var geometryEncoder = ol.format.WKT.GeometryEncoder_[type];\n    var enc = geometryEncoder(geom);\n    type = type.toUpperCase();\n    if (geom instanceof ol.geom.SimpleGeometry) {\n      var dimInfo = ol.format.WKT.encodeGeometryLayout_(geom);\n      if (dimInfo.length > 0) {\n        type += ' ' + dimInfo;\n      }\n    }\n    if (enc.length === 0) {\n      return type + ' ' + ol.format.WKT.EMPTY;\n    }\n    return type + '(' + enc + ')';\n  };\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, function(ol.geom.Geometry): string>}\n   * @private\n   */\n  ol.format.WKT.GeometryEncoder_ = {\n    'Point': ol.format.WKT.encodePointGeometry_,\n    'LineString': ol.format.WKT.encodeLineStringGeometry_,\n    'Polygon': ol.format.WKT.encodePolygonGeometry_,\n    'MultiPoint': ol.format.WKT.encodeMultiPointGeometry_,\n    'MultiLineString': ol.format.WKT.encodeMultiLineStringGeometry_,\n    'MultiPolygon': ol.format.WKT.encodeMultiPolygonGeometry_,\n    'GeometryCollection': ol.format.WKT.encodeGeometryCollectionGeometry_\n  };\n  \n  \n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {ol.geom.Geometry|undefined}\n   *     The geometry created.\n   * @private\n   */\n  ol.format.WKT.prototype.parse_ = function(wkt) {\n    var lexer = new ol.format.WKT.Lexer(wkt);\n    var parser = new ol.format.WKT.Parser(lexer);\n    return parser.parse();\n  };\n  \n  \n  /**\n   * Read a feature from a WKT source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.Feature} Feature.\n   * @api\n   */\n  ol.format.WKT.prototype.readFeature;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WKT.prototype.readFeatureFromText = function(text, opt_options) {\n    var geom = this.readGeometryFromText(text, opt_options);\n    if (geom) {\n      var feature = new ol.Feature();\n      feature.setGeometry(geom);\n      return feature;\n    }\n    return null;\n  };\n  \n  \n  /**\n   * Read all features from a WKT source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.WKT.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WKT.prototype.readFeaturesFromText = function(text, opt_options) {\n    var geometries = [];\n    var geometry = this.readGeometryFromText(text, opt_options);\n    if (this.splitCollection_ &&\n        geometry.getType() == ol.geom.GeometryType.GEOMETRY_COLLECTION) {\n      geometries = (/** @type {ol.geom.GeometryCollection} */ (geometry))\n          .getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    var feature, features = [];\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      feature = new ol.Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n    return features;\n  };\n  \n  \n  /**\n   * Read a single geometry from a WKT source.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Read options.\n   * @return {ol.geom.Geometry} Geometry.\n   * @api\n   */\n  ol.format.WKT.prototype.readGeometry;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WKT.prototype.readGeometryFromText = function(text, opt_options) {\n    var geometry = this.parse_(text);\n    if (geometry) {\n      return /** @type {ol.geom.Geometry} */ (\n        ol.format.Feature.transformWithOptions(geometry, false, opt_options));\n    } else {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * Encode a feature as a WKT string.\n   *\n   * @function\n   * @param {ol.Feature} feature Feature.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} WKT string.\n   * @api\n   */\n  ol.format.WKT.prototype.writeFeature;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WKT.prototype.writeFeatureText = function(feature, opt_options) {\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, opt_options);\n    }\n    return '';\n  };\n  \n  \n  /**\n   * Encode an array of features as a WKT string.\n   *\n   * @function\n   * @param {Array.<ol.Feature>} features Features.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} WKT string.\n   * @api\n   */\n  ol.format.WKT.prototype.writeFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WKT.prototype.writeFeaturesText = function(features, opt_options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], opt_options);\n    }\n    var geometries = [];\n    for (var i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n    var collection = new ol.geom.GeometryCollection(geometries);\n    return this.writeGeometryText(collection, opt_options);\n  };\n  \n  \n  /**\n   * Write a single geometry as a WKT string.\n   *\n   * @function\n   * @param {ol.geom.Geometry} geometry Geometry.\n   * @param {olx.format.WriteOptions=} opt_options Write options.\n   * @return {string} WKT string.\n   * @api\n   */\n  ol.format.WKT.prototype.writeGeometry;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WKT.prototype.writeGeometryText = function(geometry, opt_options) {\n    return ol.format.WKT.encode_(/** @type {ol.geom.Geometry} */ (\n      ol.format.Feature.transformWithOptions(geometry, true, opt_options)));\n  };\n  \n  \n  /**\n   * @const\n   * @enum {number}\n   * @private\n   */\n  ol.format.WKT.TokenType_ = {\n    TEXT: 1,\n    LEFT_PAREN: 2,\n    RIGHT_PAREN: 3,\n    NUMBER: 4,\n    COMMA: 5,\n    EOF: 6\n  };\n  \n  \n  /**\n   * Class to tokenize a WKT string.\n   * @param {string} wkt WKT string.\n   * @constructor\n   * @protected\n   */\n  ol.format.WKT.Lexer = function(wkt) {\n  \n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1;\n  };\n  \n  \n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  ol.format.WKT.Lexer.prototype.isAlpha_ = function(c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n  };\n  \n  \n  /**\n   * @param {string} c Character.\n   * @param {boolean=} opt_decimal Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  ol.format.WKT.Lexer.prototype.isNumeric_ = function(c, opt_decimal) {\n    var decimal = opt_decimal !== undefined ? opt_decimal : false;\n    return c >= '0' && c <= '9' || c == '.' && !decimal;\n  };\n  \n  \n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  ol.format.WKT.Lexer.prototype.isWhiteSpace_ = function(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  };\n  \n  \n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  ol.format.WKT.Lexer.prototype.nextChar_ = function() {\n    return this.wkt.charAt(++this.index_);\n  };\n  \n  \n  /**\n   * Fetch and return the next token.\n   * @return {!ol.WKTToken} Next string token.\n   */\n  ol.format.WKT.Lexer.prototype.nextToken = function() {\n    var c = this.nextChar_();\n    var token = {position: this.index_, value: c};\n  \n    if (c == '(') {\n      token.type = ol.format.WKT.TokenType_.LEFT_PAREN;\n    } else if (c == ',') {\n      token.type = ol.format.WKT.TokenType_.COMMA;\n    } else if (c == ')') {\n      token.type = ol.format.WKT.TokenType_.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      token.type = ol.format.WKT.TokenType_.NUMBER;\n      token.value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      token.type = ol.format.WKT.TokenType_.TEXT;\n      token.value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      token.type = ol.format.WKT.TokenType_.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n  \n    return token;\n  };\n  \n  \n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  ol.format.WKT.Lexer.prototype.readNumber_ = function() {\n    var c, index = this.index_;\n    var decimal = false;\n    var scientificNotation = false;\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n      c = this.nextChar_();\n    } while (\n      this.isNumeric_(c, decimal) ||\n        // if we haven't detected a scientific number before, 'e' or 'E'\n        // hint that we should continue to read\n        !scientificNotation && (c == 'e' || c == 'E') ||\n        // once we know that we have a scientific number, both '-' and '+'\n        // are allowed\n        scientificNotation && (c == '-' || c == '+')\n    );\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  };\n  \n  \n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  ol.format.WKT.Lexer.prototype.readText_ = function() {\n    var c, index = this.index_;\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  };\n  \n  \n  /**\n   * Class to parse the tokens from the WKT string.\n   * @param {ol.format.WKT.Lexer} lexer The lexer.\n   * @constructor\n   * @protected\n   */\n  ol.format.WKT.Parser = function(lexer) {\n  \n    /**\n     * @type {ol.format.WKT.Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n  \n    /**\n     * @type {ol.WKTToken}\n     * @private\n     */\n    this.token_;\n  \n    /**\n     * @type {ol.geom.GeometryLayout}\n     * @private\n     */\n    this.layout_ = ol.geom.GeometryLayout.XY;\n  };\n  \n  \n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.consume_ = function() {\n    this.token_ = this.lexer_.nextToken();\n  };\n  \n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {ol.format.WKT.TokenType_} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  ol.format.WKT.Parser.prototype.isTokenType = function(type) {\n    var isMatch = this.token_.type == type;\n    return isMatch;\n  };\n  \n  \n  /**\n   * If the given type matches the current token, consume it.\n   * @param {ol.format.WKT.TokenType_} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  ol.format.WKT.Parser.prototype.match = function(type) {\n    var isMatch = this.isTokenType(type);\n    if (isMatch) {\n      this.consume_();\n    }\n    return isMatch;\n  };\n  \n  \n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {ol.geom.Geometry} The geometry.\n   */\n  ol.format.WKT.Parser.prototype.parse = function() {\n    this.consume_();\n    var geometry = this.parseGeometry_();\n    return geometry;\n  };\n  \n  \n  /**\n   * Try to parse the dimensional info.\n   * @return {ol.geom.GeometryLayout} The layout.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parseGeometryLayout_ = function() {\n    var layout = ol.geom.GeometryLayout.XY;\n    var dimToken = this.token_;\n    if (this.isTokenType(ol.format.WKT.TokenType_.TEXT)) {\n      var dimInfo = dimToken.value;\n      if (dimInfo === ol.format.WKT.Z) {\n        layout = ol.geom.GeometryLayout.XYZ;\n      } else if (dimInfo === ol.format.WKT.M) {\n        layout = ol.geom.GeometryLayout.XYM;\n      } else if (dimInfo === ol.format.WKT.ZM) {\n        layout = ol.geom.GeometryLayout.XYZM;\n      }\n      if (layout !== ol.geom.GeometryLayout.XY) {\n        this.consume_();\n      }\n    }\n    return layout;\n  };\n  \n  \n  /**\n   * @return {!ol.geom.Geometry} The geometry.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parseGeometry_ = function() {\n    var token = this.token_;\n    if (this.match(ol.format.WKT.TokenType_.TEXT)) {\n      var geomType = token.value;\n      this.layout_ = this.parseGeometryLayout_();\n      if (geomType == ol.geom.GeometryType.GEOMETRY_COLLECTION.toUpperCase()) {\n        var geometries = this.parseGeometryCollectionText_();\n        return new ol.geom.GeometryCollection(geometries);\n      } else {\n        var parser = ol.format.WKT.Parser.GeometryParser_[geomType];\n        var ctor = ol.format.WKT.Parser.GeometryConstructor_[geomType];\n        if (!parser || !ctor) {\n          throw new Error('Invalid geometry type: ' + geomType);\n        }\n        var coordinates = parser.call(this);\n        return new ctor(coordinates, this.layout_);\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {!Array.<ol.geom.Geometry>} A collection of geometries.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parseGeometryCollectionText_ = function() {\n    if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {\n      var geometries = [];\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(ol.format.WKT.TokenType_.COMMA));\n      if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {\n        return geometries;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {Array.<number>} All values in a point.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parsePointText_ = function() {\n    if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {\n      var coordinates = this.parsePoint_();\n      if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return null;\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} All points in a linestring.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parseLineStringText_ = function() {\n    if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {\n      var coordinates = this.parsePointList_();\n      if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} All points in a polygon.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parsePolygonText_ = function() {\n    if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {\n      var coordinates = this.parseLineStringTextList_();\n      if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} All points in a multipoint.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parseMultiPointText_ = function() {\n    if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {\n      var coordinates;\n      if (this.token_.type == ol.format.WKT.TokenType_.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n      if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} All linestring points\n   *                                        in a multilinestring.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parseMultiLineStringText_ = function() {\n    if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {\n      var coordinates = this.parseLineStringTextList_();\n      if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} All polygon points in a multipolygon.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parseMultiPolygonText_ = function() {\n    if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {\n      var coordinates = this.parsePolygonTextList_();\n      if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    } else if (this.isEmptyGeometry_()) {\n      return [];\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {!Array.<number>} A point.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parsePoint_ = function() {\n    var coordinates = [];\n    var dimensions = this.layout_.length;\n    for (var i = 0; i < dimensions; ++i) {\n      var token = this.token_;\n      if (this.match(ol.format.WKT.TokenType_.NUMBER)) {\n        coordinates.push(token.value);\n      } else {\n        break;\n      }\n    }\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} An array of points.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parsePointList_ = function() {\n    var coordinates = [this.parsePoint_()];\n    while (this.match(ol.format.WKT.TokenType_.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n    return coordinates;\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} An array of points.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parsePointTextList_ = function() {\n    var coordinates = [this.parsePointText_()];\n    while (this.match(ol.format.WKT.TokenType_.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n    return coordinates;\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} An array of points.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parseLineStringTextList_ = function() {\n    var coordinates = [this.parseLineStringText_()];\n    while (this.match(ol.format.WKT.TokenType_.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n    return coordinates;\n  };\n  \n  \n  /**\n   * @return {!Array.<!Array.<number>>} An array of points.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.parsePolygonTextList_ = function() {\n    var coordinates = [this.parsePolygonText_()];\n    while (this.match(ol.format.WKT.TokenType_.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n    return coordinates;\n  };\n  \n  \n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.isEmptyGeometry_ = function() {\n    var isEmpty = this.isTokenType(ol.format.WKT.TokenType_.TEXT) &&\n        this.token_.value == ol.format.WKT.EMPTY;\n    if (isEmpty) {\n      this.consume_();\n    }\n    return isEmpty;\n  };\n  \n  \n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  ol.format.WKT.Parser.prototype.formatErrorMessage_ = function() {\n    return 'Unexpected `' + this.token_.value + '` at position ' +\n        this.token_.position + ' in `' + this.lexer_.wkt + '`';\n  };\n  \n  \n  /**\n   * @enum {function (new:ol.geom.Geometry, Array, ol.geom.GeometryLayout)}\n   * @private\n   */\n  ol.format.WKT.Parser.GeometryConstructor_ = {\n    'POINT': ol.geom.Point,\n    'LINESTRING': ol.geom.LineString,\n    'POLYGON': ol.geom.Polygon,\n    'MULTIPOINT': ol.geom.MultiPoint,\n    'MULTILINESTRING': ol.geom.MultiLineString,\n    'MULTIPOLYGON': ol.geom.MultiPolygon\n  };\n  \n  \n  /**\n   * @enum {(function(): Array)}\n   * @private\n   */\n  ol.format.WKT.Parser.GeometryParser_ = {\n    'POINT': ol.format.WKT.Parser.prototype.parsePointText_,\n    'LINESTRING': ol.format.WKT.Parser.prototype.parseLineStringText_,\n    'POLYGON': ol.format.WKT.Parser.prototype.parsePolygonText_,\n    'MULTIPOINT': ol.format.WKT.Parser.prototype.parseMultiPointText_,\n    'MULTILINESTRING': ol.format.WKT.Parser.prototype.parseMultiLineStringText_,\n    'MULTIPOLYGON': ol.format.WKT.Parser.prototype.parseMultiPolygonText_\n  };\n  \n  goog.provide('ol.format.WMSCapabilities');\n  \n  goog.require('ol');\n  goog.require('ol.format.XLink');\n  goog.require('ol.format.XML');\n  goog.require('ol.format.XSD');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Format for reading WMS capabilities data\n   *\n   * @constructor\n   * @extends {ol.format.XML}\n   * @api\n   */\n  ol.format.WMSCapabilities = function() {\n  \n    ol.format.XML.call(this);\n  \n    /**\n     * @type {string|undefined}\n     */\n    this.version = undefined;\n  };\n  ol.inherits(ol.format.WMSCapabilities, ol.format.XML);\n  \n  \n  /**\n   * Read a WMS capabilities document.\n   *\n   * @function\n   * @param {Document|Node|string} source The XML source.\n   * @return {Object} An object representing the WMS capabilities.\n   * @api\n   */\n  ol.format.WMSCapabilities.prototype.read;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WMSCapabilities.prototype.readFromDocument = function(doc) {\n    for (var n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFromNode(n);\n      }\n    }\n    return null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WMSCapabilities.prototype.readFromNode = function(node) {\n    this.version = node.getAttribute('version').trim();\n    var wmsCapabilityObject = ol.xml.pushParseAndPop({\n      'version': this.version\n    }, ol.format.WMSCapabilities.PARSERS_, node, []);\n    return wmsCapabilityObject ? wmsCapabilityObject : null;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Attribution object.\n   */\n  ol.format.WMSCapabilities.readAttribution_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.ATTRIBUTION_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object} Bounding box object.\n   */\n  ol.format.WMSCapabilities.readBoundingBox_ = function(node, objectStack) {\n    var extent = [\n      ol.format.XSD.readDecimalString(node.getAttribute('minx')),\n      ol.format.XSD.readDecimalString(node.getAttribute('miny')),\n      ol.format.XSD.readDecimalString(node.getAttribute('maxx')),\n      ol.format.XSD.readDecimalString(node.getAttribute('maxy'))\n    ];\n  \n    var resolutions = [\n      ol.format.XSD.readDecimalString(node.getAttribute('resx')),\n      ol.format.XSD.readDecimalString(node.getAttribute('resy'))\n    ];\n  \n    return {\n      'crs': node.getAttribute('CRS'),\n      'extent': extent,\n      'res': resolutions\n    };\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {ol.Extent|undefined} Bounding box object.\n   */\n  ol.format.WMSCapabilities.readEXGeographicBoundingBox_ = function(node, objectStack) {\n    var geographicBoundingBox = ol.xml.pushParseAndPop(\n        {},\n        ol.format.WMSCapabilities.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS_,\n        node, objectStack);\n    if (!geographicBoundingBox) {\n      return undefined;\n    }\n    var westBoundLongitude = /** @type {number|undefined} */\n          (geographicBoundingBox['westBoundLongitude']);\n    var southBoundLatitude = /** @type {number|undefined} */\n          (geographicBoundingBox['southBoundLatitude']);\n    var eastBoundLongitude = /** @type {number|undefined} */\n          (geographicBoundingBox['eastBoundLongitude']);\n    var northBoundLatitude = /** @type {number|undefined} */\n          (geographicBoundingBox['northBoundLatitude']);\n    if (westBoundLongitude === undefined || southBoundLatitude === undefined ||\n          eastBoundLongitude === undefined || northBoundLatitude === undefined) {\n      return undefined;\n    }\n    return [\n      westBoundLongitude, southBoundLatitude,\n      eastBoundLongitude, northBoundLatitude\n    ];\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} Capability object.\n   */\n  ol.format.WMSCapabilities.readCapability_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.CAPABILITY_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} Service object.\n   */\n  ol.format.WMSCapabilities.readService_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.SERVICE_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} Contact information object.\n   */\n  ol.format.WMSCapabilities.readContactInformation_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.CONTACT_INFORMATION_PARSERS_,\n        node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} Contact person object.\n   */\n  ol.format.WMSCapabilities.readContactPersonPrimary_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.CONTACT_PERSON_PARSERS_,\n        node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} Contact address object.\n   */\n  ol.format.WMSCapabilities.readContactAddress_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.CONTACT_ADDRESS_PARSERS_,\n        node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<string>|undefined} Format array.\n   */\n  ol.format.WMSCapabilities.readException_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        [], ol.format.WMSCapabilities.EXCEPTION_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Object|undefined} Layer object.\n   */\n  ol.format.WMSCapabilities.readCapabilityLayer_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.LAYER_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Layer object.\n   */\n  ol.format.WMSCapabilities.readLayer_ = function(node, objectStack) {\n    var parentLayerObject = /**  @type {Object.<string,*>} */\n          (objectStack[objectStack.length - 1]);\n  \n    var layerObject = ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.LAYER_PARSERS_, node, objectStack);\n  \n    if (!layerObject) {\n      return undefined;\n    }\n    var queryable =\n          ol.format.XSD.readBooleanString(node.getAttribute('queryable'));\n    if (queryable === undefined) {\n      queryable = parentLayerObject['queryable'];\n    }\n    layerObject['queryable'] = queryable !== undefined ? queryable : false;\n  \n    var cascaded = ol.format.XSD.readNonNegativeIntegerString(\n        node.getAttribute('cascaded'));\n    if (cascaded === undefined) {\n      cascaded = parentLayerObject['cascaded'];\n    }\n    layerObject['cascaded'] = cascaded;\n  \n    var opaque = ol.format.XSD.readBooleanString(node.getAttribute('opaque'));\n    if (opaque === undefined) {\n      opaque = parentLayerObject['opaque'];\n    }\n    layerObject['opaque'] = opaque !== undefined ? opaque : false;\n  \n    var noSubsets =\n          ol.format.XSD.readBooleanString(node.getAttribute('noSubsets'));\n    if (noSubsets === undefined) {\n      noSubsets = parentLayerObject['noSubsets'];\n    }\n    layerObject['noSubsets'] = noSubsets !== undefined ? noSubsets : false;\n  \n    var fixedWidth =\n          ol.format.XSD.readDecimalString(node.getAttribute('fixedWidth'));\n    if (!fixedWidth) {\n      fixedWidth = parentLayerObject['fixedWidth'];\n    }\n    layerObject['fixedWidth'] = fixedWidth;\n  \n    var fixedHeight =\n          ol.format.XSD.readDecimalString(node.getAttribute('fixedHeight'));\n    if (!fixedHeight) {\n      fixedHeight = parentLayerObject['fixedHeight'];\n    }\n    layerObject['fixedHeight'] = fixedHeight;\n  \n    // See 7.2.4.8\n    var addKeys = ['Style', 'CRS', 'AuthorityURL'];\n    addKeys.forEach(function(key) {\n      if (key in parentLayerObject) {\n        var childValue = layerObject[key] || [];\n        layerObject[key] = childValue.concat(parentLayerObject[key]);\n      }\n    });\n  \n    var replaceKeys = ['EX_GeographicBoundingBox', 'BoundingBox', 'Dimension',\n      'Attribution', 'MinScaleDenominator', 'MaxScaleDenominator'];\n    replaceKeys.forEach(function(key) {\n      if (!(key in layerObject)) {\n        var parentValue = parentLayerObject[key];\n        layerObject[key] = parentValue;\n      }\n    });\n  \n    return layerObject;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object} Dimension object.\n   */\n  ol.format.WMSCapabilities.readDimension_ = function(node, objectStack) {\n    var dimensionObject = {\n      'name': node.getAttribute('name'),\n      'units': node.getAttribute('units'),\n      'unitSymbol': node.getAttribute('unitSymbol'),\n      'default': node.getAttribute('default'),\n      'multipleValues': ol.format.XSD.readBooleanString(\n          node.getAttribute('multipleValues')),\n      'nearestValue': ol.format.XSD.readBooleanString(\n          node.getAttribute('nearestValue')),\n      'current': ol.format.XSD.readBooleanString(node.getAttribute('current')),\n      'values': ol.format.XSD.readString(node)\n    };\n    return dimensionObject;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Online resource object.\n   */\n  ol.format.WMSCapabilities.readFormatOnlineresource_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.FORMAT_ONLINERESOURCE_PARSERS_,\n        node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Request object.\n   */\n  ol.format.WMSCapabilities.readRequest_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.REQUEST_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} DCP type object.\n   */\n  ol.format.WMSCapabilities.readDCPType_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.DCPTYPE_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} HTTP object.\n   */\n  ol.format.WMSCapabilities.readHTTP_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.HTTP_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Operation type object.\n   */\n  ol.format.WMSCapabilities.readOperationType_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.OPERATIONTYPE_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Online resource object.\n   */\n  ol.format.WMSCapabilities.readSizedFormatOnlineresource_ = function(node, objectStack) {\n    var formatOnlineresource =\n          ol.format.WMSCapabilities.readFormatOnlineresource_(node, objectStack);\n    if (formatOnlineresource) {\n      var size = [\n        ol.format.XSD.readNonNegativeIntegerString(node.getAttribute('width')),\n        ol.format.XSD.readNonNegativeIntegerString(node.getAttribute('height'))\n      ];\n      formatOnlineresource['size'] = size;\n      return formatOnlineresource;\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Authority URL object.\n   */\n  ol.format.WMSCapabilities.readAuthorityURL_ = function(node, objectStack) {\n    var authorityObject =\n          ol.format.WMSCapabilities.readFormatOnlineresource_(node, objectStack);\n    if (authorityObject) {\n      authorityObject['name'] = node.getAttribute('name');\n      return authorityObject;\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Metadata URL object.\n   */\n  ol.format.WMSCapabilities.readMetadataURL_ = function(node, objectStack) {\n    var metadataObject =\n          ol.format.WMSCapabilities.readFormatOnlineresource_(node, objectStack);\n    if (metadataObject) {\n      metadataObject['type'] = node.getAttribute('type');\n      return metadataObject;\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Style object.\n   */\n  ol.format.WMSCapabilities.readStyle_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        {}, ol.format.WMSCapabilities.STYLE_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Array.<string>|undefined} Keyword list.\n   */\n  ol.format.WMSCapabilities.readKeywordList_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop(\n        [], ol.format.WMSCapabilities.KEYWORDLIST_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Array.<string>}\n   */\n  ol.format.WMSCapabilities.NAMESPACE_URIS_ = [\n    null,\n    'http://www.opengis.net/wms'\n  ];\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Service': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readService_),\n        'Capability': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readCapability_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.CAPABILITY_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Request': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readRequest_),\n        'Exception': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readException_),\n        'Layer': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readCapabilityLayer_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.SERVICE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Name': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Title': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Abstract': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'KeywordList': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readKeywordList_),\n        'OnlineResource': ol.xml.makeObjectPropertySetter(\n            ol.format.XLink.readHref),\n        'ContactInformation': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readContactInformation_),\n        'Fees': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'AccessConstraints': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'LayerLimit': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'MaxWidth': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'MaxHeight': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.CONTACT_INFORMATION_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'ContactPersonPrimary': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readContactPersonPrimary_),\n        'ContactPosition': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'ContactAddress': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readContactAddress_),\n        'ContactVoiceTelephone': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'ContactFacsimileTelephone': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'ContactElectronicMailAddress': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.CONTACT_PERSON_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'ContactPerson': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'ContactOrganization': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.CONTACT_ADDRESS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'AddressType': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Address': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'City': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'StateOrProvince': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'PostCode': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Country': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.EXCEPTION_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Format': ol.xml.makeArrayPusher(ol.format.XSD.readString)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.LAYER_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Name': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Title': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Abstract': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'KeywordList': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readKeywordList_),\n        'CRS': ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString),\n        'EX_GeographicBoundingBox': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readEXGeographicBoundingBox_),\n        'BoundingBox': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readBoundingBox_),\n        'Dimension': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readDimension_),\n        'Attribution': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readAttribution_),\n        'AuthorityURL': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readAuthorityURL_),\n        'Identifier': ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString),\n        'MetadataURL': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readMetadataURL_),\n        'DataURL': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readFormatOnlineresource_),\n        'FeatureListURL': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readFormatOnlineresource_),\n        'Style': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readStyle_),\n        'MinScaleDenominator': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readDecimal),\n        'MaxScaleDenominator': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readDecimal),\n        'Layer': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readLayer_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.ATTRIBUTION_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Title': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'OnlineResource': ol.xml.makeObjectPropertySetter(\n            ol.format.XLink.readHref),\n        'LogoURL': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readSizedFormatOnlineresource_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS_ =\n      ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'westBoundLongitude': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readDecimal),\n        'eastBoundLongitude': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readDecimal),\n        'southBoundLatitude': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readDecimal),\n        'northBoundLatitude': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readDecimal)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.REQUEST_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'GetCapabilities': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readOperationType_),\n        'GetMap': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readOperationType_),\n        'GetFeatureInfo': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readOperationType_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.OPERATIONTYPE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Format': ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString),\n        'DCPType': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readDCPType_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.DCPTYPE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'HTTP': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readHTTP_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.HTTP_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Get': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readFormatOnlineresource_),\n        'Post': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readFormatOnlineresource_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.STYLE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Name': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Title': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'Abstract': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'LegendURL': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMSCapabilities.readSizedFormatOnlineresource_),\n        'StyleSheetURL': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readFormatOnlineresource_),\n        'StyleURL': ol.xml.makeObjectPropertySetter(\n            ol.format.WMSCapabilities.readFormatOnlineresource_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.FORMAT_ONLINERESOURCE_PARSERS_ =\n      ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Format': ol.xml.makeObjectPropertySetter(ol.format.XSD.readString),\n        'OnlineResource': ol.xml.makeObjectPropertySetter(\n            ol.format.XLink.readHref)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMSCapabilities.KEYWORDLIST_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMSCapabilities.NAMESPACE_URIS_, {\n        'Keyword': ol.xml.makeArrayPusher(ol.format.XSD.readString)\n      });\n  \n  goog.provide('ol.format.WMSGetFeatureInfo');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.format.GML2');\n  goog.require('ol.format.XMLFeature');\n  goog.require('ol.obj');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Format for reading WMSGetFeatureInfo format. It uses\n   * {@link ol.format.GML2} to read features.\n   *\n   * @constructor\n   * @extends {ol.format.XMLFeature}\n   * @param {olx.format.WMSGetFeatureInfoOptions=} opt_options Options.\n   * @api\n   */\n  ol.format.WMSGetFeatureInfo = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';\n  \n  \n    /**\n     * @private\n     * @type {ol.format.GML2}\n     */\n    this.gmlFormat_ = new ol.format.GML2();\n  \n  \n    /**\n     * @private\n     * @type {Array.<string>}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n  \n    ol.format.XMLFeature.call(this);\n  };\n  ol.inherits(ol.format.WMSGetFeatureInfo, ol.format.XMLFeature);\n  \n  \n  /**\n   * @const\n   * @type {string}\n   * @private\n   */\n  ol.format.WMSGetFeatureInfo.featureIdentifier_ = '_feature';\n  \n  \n  /**\n   * @const\n   * @type {string}\n   * @private\n   */\n  ol.format.WMSGetFeatureInfo.layerIdentifier_ = '_layer';\n  \n  \n  /**\n   * @return {Array.<string>} layers\n   */\n  ol.format.WMSGetFeatureInfo.prototype.getLayers = function() {\n    return this.layers_;\n  };\n  \n  \n  /**\n   * @param {Array.<string>} layers Layers to parse.\n   */\n  ol.format.WMSGetFeatureInfo.prototype.setLayers = function(layers) {\n    this.layers_ = layers;\n  };\n  \n  \n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Array.<ol.Feature>} Features.\n   * @private\n   */\n  ol.format.WMSGetFeatureInfo.prototype.readFeatures_ = function(node, objectStack) {\n    node.setAttribute('namespaceURI', this.featureNS_);\n    var localName = node.localName;\n    /** @type {Array.<ol.Feature>} */\n    var features = [];\n    if (node.childNodes.length === 0) {\n      return features;\n    }\n    if (localName == 'msGMLOutput') {\n      for (var i = 0, ii = node.childNodes.length; i < ii; i++) {\n        var layer = node.childNodes[i];\n        if (layer.nodeType !== Node.ELEMENT_NODE) {\n          continue;\n        }\n        var context = objectStack[0];\n  \n        var toRemove = ol.format.WMSGetFeatureInfo.layerIdentifier_;\n        var layerName = layer.localName.replace(toRemove, '');\n  \n        if (this.layers_ && !ol.array.includes(this.layers_, layerName)) {\n          continue;\n        }\n  \n        var featureType = layerName +\n            ol.format.WMSGetFeatureInfo.featureIdentifier_;\n  \n        context['featureType'] = featureType;\n        context['featureNS'] = this.featureNS_;\n  \n        var parsers = {};\n        parsers[featureType] = ol.xml.makeArrayPusher(\n            this.gmlFormat_.readFeatureElement, this.gmlFormat_);\n        var parsersNS = ol.xml.makeStructureNS(\n            [context['featureNS'], null], parsers);\n        layer.setAttribute('namespaceURI', this.featureNS_);\n        var layerFeatures = ol.xml.pushParseAndPop(\n            [], parsersNS, layer, objectStack, this.gmlFormat_);\n        if (layerFeatures) {\n          ol.array.extend(features, layerFeatures);\n        }\n      }\n    }\n    if (localName == 'FeatureCollection') {\n      var gmlFeatures = ol.xml.pushParseAndPop([],\n          this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node,\n          [{}], this.gmlFormat_);\n      if (gmlFeatures) {\n        features = gmlFeatures;\n      }\n    }\n    return features;\n  };\n  \n  \n  /**\n   * Read all features from a WMSGetFeatureInfo response.\n   *\n   * @function\n   * @param {Document|Node|Object|string} source Source.\n   * @param {olx.format.ReadOptions=} opt_options Options.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.format.WMSGetFeatureInfo.prototype.readFeatures;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WMSGetFeatureInfo.prototype.readFeaturesFromNode = function(node, opt_options) {\n    var options = {};\n    if (opt_options) {\n      ol.obj.assign(options, this.getReadOptions(node, opt_options));\n    }\n    return this.readFeatures_(node, [options]);\n  };\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.WMSGetFeatureInfo.prototype.writeFeatureNode = function(feature, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.WMSGetFeatureInfo.prototype.writeFeaturesNode = function(features, opt_options) {};\n  \n  \n  /**\n   * Not implemented.\n   * @inheritDoc\n   */\n  ol.format.WMSGetFeatureInfo.prototype.writeGeometryNode = function(geometry, opt_options) {};\n  \n  goog.provide('ol.format.WMTSCapabilities');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.format.OWS');\n  goog.require('ol.format.XLink');\n  goog.require('ol.format.XML');\n  goog.require('ol.format.XSD');\n  goog.require('ol.xml');\n  \n  \n  /**\n   * @classdesc\n   * Format for reading WMTS capabilities data.\n   *\n   * @constructor\n   * @extends {ol.format.XML}\n   * @api\n   */\n  ol.format.WMTSCapabilities = function() {\n    ol.format.XML.call(this);\n  \n    /**\n     * @type {ol.format.OWS}\n     * @private\n     */\n    this.owsParser_ = new ol.format.OWS();\n  };\n  ol.inherits(ol.format.WMTSCapabilities, ol.format.XML);\n  \n  \n  /**\n   * Read a WMTS capabilities document.\n   *\n   * @function\n   * @param {Document|Node|string} source The XML source.\n   * @return {Object} An object representing the WMTS capabilities.\n   * @api\n   */\n  ol.format.WMTSCapabilities.prototype.read;\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WMTSCapabilities.prototype.readFromDocument = function(doc) {\n    for (var n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFromNode(n);\n      }\n    }\n    return null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.format.WMTSCapabilities.prototype.readFromNode = function(node) {\n    var version = node.getAttribute('version').trim();\n    var WMTSCapabilityObject = this.owsParser_.readFromNode(node);\n    if (!WMTSCapabilityObject) {\n      return null;\n    }\n    WMTSCapabilityObject['version'] = version;\n    WMTSCapabilityObject = ol.xml.pushParseAndPop(WMTSCapabilityObject,\n        ol.format.WMTSCapabilities.PARSERS_, node, []);\n    return WMTSCapabilityObject ? WMTSCapabilityObject : null;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Attribution object.\n   */\n  ol.format.WMTSCapabilities.readContents_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.WMTSCapabilities.CONTENTS_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Layers object.\n   */\n  ol.format.WMTSCapabilities.readLayer_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.WMTSCapabilities.LAYER_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Tile Matrix Set object.\n   */\n  ol.format.WMTSCapabilities.readTileMatrixSet_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.WMTSCapabilities.TMS_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Style object.\n   */\n  ol.format.WMTSCapabilities.readStyle_ = function(node, objectStack) {\n    var style = ol.xml.pushParseAndPop({},\n        ol.format.WMTSCapabilities.STYLE_PARSERS_, node, objectStack);\n    if (!style) {\n      return undefined;\n    }\n    var isDefault = node.getAttribute('isDefault') === 'true';\n    style['isDefault'] = isDefault;\n    return style;\n  \n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Tile Matrix Set Link object.\n   */\n  ol.format.WMTSCapabilities.readTileMatrixSetLink_ = function(node,\n      objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.WMTSCapabilities.TMS_LINKS_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Dimension object.\n   */\n  ol.format.WMTSCapabilities.readDimensions_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.WMTSCapabilities.DIMENSION_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Resource URL object.\n   */\n  ol.format.WMTSCapabilities.readResourceUrl_ = function(node, objectStack) {\n    var format = node.getAttribute('format');\n    var template = node.getAttribute('template');\n    var resourceType = node.getAttribute('resourceType');\n    var resource = {};\n    if (format) {\n      resource['format'] = format;\n    }\n    if (template) {\n      resource['template'] = template;\n    }\n    if (resourceType) {\n      resource['resourceType'] = resourceType;\n    }\n    return resource;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} WGS84 BBox object.\n   */\n  ol.format.WMTSCapabilities.readWgs84BoundingBox_ = function(node, objectStack) {\n    var coordinates = ol.xml.pushParseAndPop([],\n        ol.format.WMTSCapabilities.WGS84_BBOX_READERS_, node, objectStack);\n    if (coordinates.length != 2) {\n      return undefined;\n    }\n    return ol.extent.boundingExtent(coordinates);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Legend object.\n   */\n  ol.format.WMTSCapabilities.readLegendUrl_ = function(node, objectStack) {\n    var legend = {};\n    legend['format'] = node.getAttribute('format');\n    legend['href'] = ol.format.XLink.readHref(node);\n    return legend;\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} Coordinates object.\n   */\n  ol.format.WMTSCapabilities.readCoordinates_ = function(node, objectStack) {\n    var coordinates = ol.format.XSD.readString(node).split(' ');\n    if (!coordinates || coordinates.length != 2) {\n      return undefined;\n    }\n    var x = +coordinates[0];\n    var y = +coordinates[1];\n    if (isNaN(x) || isNaN(y)) {\n      return undefined;\n    }\n    return [x, y];\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} TileMatrix object.\n   */\n  ol.format.WMTSCapabilities.readTileMatrix_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.WMTSCapabilities.TM_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} TileMatrixSetLimits Object.\n   */\n  ol.format.WMTSCapabilities.readTileMatrixLimitsList_ = function(node,\n      objectStack) {\n    return ol.xml.pushParseAndPop([],\n        ol.format.WMTSCapabilities.TMS_LIMITS_LIST_PARSERS_, node,\n        objectStack);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @return {Object|undefined} TileMatrixLimits Array.\n   */\n  ol.format.WMTSCapabilities.readTileMatrixLimits_ = function(node, objectStack) {\n    return ol.xml.pushParseAndPop({},\n        ol.format.WMTSCapabilities.TMS_LIMITS_PARSERS_, node, objectStack);\n  };\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Array.<string>}\n   */\n  ol.format.WMTSCapabilities.NAMESPACE_URIS_ = [\n    null,\n    'http://www.opengis.net/wmts/1.0'\n  ];\n  \n  \n  /**\n   * @const\n   * @private\n   * @type {Array.<string>}\n   */\n  ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_ = [\n    null,\n    'http://www.opengis.net/ows/1.1'\n  ];\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'Contents': ol.xml.makeObjectPropertySetter(\n            ol.format.WMTSCapabilities.readContents_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.CONTENTS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'Layer': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMTSCapabilities.readLayer_),\n        'TileMatrixSet': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMTSCapabilities.readTileMatrixSet_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.LAYER_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'Style': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMTSCapabilities.readStyle_),\n        'Format': ol.xml.makeObjectPropertyPusher(\n            ol.format.XSD.readString),\n        'TileMatrixSetLink': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMTSCapabilities.readTileMatrixSetLink_),\n        'Dimension': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMTSCapabilities.readDimensions_),\n        'ResourceURL': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMTSCapabilities.readResourceUrl_)\n      }, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {\n        'Title': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'Abstract': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'WGS84BoundingBox': ol.xml.makeObjectPropertySetter(\n            ol.format.WMTSCapabilities.readWgs84BoundingBox_),\n        'Identifier': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString)\n      }));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.STYLE_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'LegendURL': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMTSCapabilities.readLegendUrl_)\n      }, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {\n        'Title': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'Identifier': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString)\n      }));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.TMS_LINKS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'TileMatrixSet': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'TileMatrixSetLimits': ol.xml.makeObjectPropertySetter(\n            ol.format.WMTSCapabilities.readTileMatrixLimitsList_)\n      });\n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.TMS_LIMITS_LIST_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'TileMatrixLimits': ol.xml.makeArrayPusher(\n            ol.format.WMTSCapabilities.readTileMatrixLimits_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.TMS_LIMITS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'TileMatrix': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'MinTileRow': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'MaxTileRow': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'MinTileCol': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'MaxTileCol': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.DIMENSION_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'Default': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'Value': ol.xml.makeObjectPropertyPusher(\n            ol.format.XSD.readString)\n      }, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {\n        'Identifier': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString)\n      }));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.WGS84_BBOX_READERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {\n        'LowerCorner': ol.xml.makeArrayPusher(\n            ol.format.WMTSCapabilities.readCoordinates_),\n        'UpperCorner': ol.xml.makeArrayPusher(\n            ol.format.WMTSCapabilities.readCoordinates_)\n      });\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.TMS_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'WellKnownScaleSet': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'TileMatrix': ol.xml.makeObjectPropertyPusher(\n            ol.format.WMTSCapabilities.readTileMatrix_)\n      }, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {\n        'SupportedCRS': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString),\n        'Identifier': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString)\n      }));\n  \n  \n  /**\n   * @const\n   * @type {Object.<string, Object.<string, ol.XmlParser>>}\n   * @private\n   */\n  ol.format.WMTSCapabilities.TM_PARSERS_ = ol.xml.makeStructureNS(\n      ol.format.WMTSCapabilities.NAMESPACE_URIS_, {\n        'TopLeftCorner': ol.xml.makeObjectPropertySetter(\n            ol.format.WMTSCapabilities.readCoordinates_),\n        'ScaleDenominator': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readDecimal),\n        'TileWidth': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'TileHeight': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'MatrixWidth': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger),\n        'MatrixHeight': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readNonNegativeInteger)\n      }, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {\n        'Identifier': ol.xml.makeObjectPropertySetter(\n            ol.format.XSD.readString)\n      }));\n  \n  goog.provide('ol.GeolocationProperty');\n  \n  \n  /**\n   * @enum {string}\n   */\n  ol.GeolocationProperty = {\n    ACCURACY: 'accuracy',\n    ACCURACY_GEOMETRY: 'accuracyGeometry',\n    ALTITUDE: 'altitude',\n    ALTITUDE_ACCURACY: 'altitudeAccuracy',\n    HEADING: 'heading',\n    POSITION: 'position',\n    PROJECTION: 'projection',\n    SPEED: 'speed',\n    TRACKING: 'tracking',\n    TRACKING_OPTIONS: 'trackingOptions'\n  };\n  \n  // FIXME handle geolocation not supported\n  \n  goog.provide('ol.Geolocation');\n  \n  goog.require('ol');\n  goog.require('ol.GeolocationProperty');\n  goog.require('ol.Object');\n  goog.require('ol.Sphere');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.has');\n  goog.require('ol.math');\n  goog.require('ol.proj');\n  goog.require('ol.proj.EPSG4326');\n  \n  \n  /**\n   * @classdesc\n   * Helper class for providing HTML5 Geolocation capabilities.\n   * The [Geolocation API](http://www.w3.org/TR/geolocation-API/)\n   * is used to locate a user's position.\n   *\n   * To get notified of position changes, register a listener for the generic\n   * `change` event on your instance of `ol.Geolocation`.\n   *\n   * Example:\n   *\n   *     var geolocation = new ol.Geolocation({\n   *       // take the projection to use from the map's view\n   *       projection: view.getProjection()\n   *     });\n   *     // listen to changes in position\n   *     geolocation.on('change', function(evt) {\n   *       window.console.log(geolocation.getPosition());\n   *     });\n   *\n   * @fires error\n   * @constructor\n   * @extends {ol.Object}\n   * @param {olx.GeolocationOptions=} opt_options Options.\n   * @api\n   */\n  ol.Geolocation = function(opt_options) {\n  \n    ol.Object.call(this);\n  \n    var options = opt_options || {};\n  \n    /**\n     * The unprojected (EPSG:4326) device position.\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.position_ = null;\n  \n    /**\n     * @private\n     * @type {ol.TransformFunction}\n     */\n    this.transform_ = ol.proj.identityTransform;\n  \n    /**\n     * @private\n     * @type {ol.Sphere}\n     */\n    this.sphere_ = new ol.Sphere(ol.proj.EPSG4326.RADIUS);\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.watchId_ = undefined;\n  \n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.GeolocationProperty.PROJECTION),\n        this.handleProjectionChanged_, this);\n    ol.events.listen(\n        this, ol.Object.getChangeEventType(ol.GeolocationProperty.TRACKING),\n        this.handleTrackingChanged_, this);\n  \n    if (options.projection !== undefined) {\n      this.setProjection(options.projection);\n    }\n    if (options.trackingOptions !== undefined) {\n      this.setTrackingOptions(options.trackingOptions);\n    }\n  \n    this.setTracking(options.tracking !== undefined ? options.tracking : false);\n  \n  };\n  ol.inherits(ol.Geolocation, ol.Object);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.Geolocation.prototype.disposeInternal = function() {\n    this.setTracking(false);\n    ol.Object.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.Geolocation.prototype.handleProjectionChanged_ = function() {\n    var projection = this.getProjection();\n    if (projection) {\n      this.transform_ = ol.proj.getTransformFromProjections(\n          ol.proj.get('EPSG:4326'), projection);\n      if (this.position_) {\n        this.set(\n            ol.GeolocationProperty.POSITION, this.transform_(this.position_));\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.Geolocation.prototype.handleTrackingChanged_ = function() {\n    if (ol.has.GEOLOCATION) {\n      var tracking = this.getTracking();\n      if (tracking && this.watchId_ === undefined) {\n        this.watchId_ = navigator.geolocation.watchPosition(\n            this.positionChange_.bind(this),\n            this.positionError_.bind(this),\n            this.getTrackingOptions());\n      } else if (!tracking && this.watchId_ !== undefined) {\n        navigator.geolocation.clearWatch(this.watchId_);\n        this.watchId_ = undefined;\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {GeolocationPosition} position position event.\n   */\n  ol.Geolocation.prototype.positionChange_ = function(position) {\n    var coords = position.coords;\n    this.set(ol.GeolocationProperty.ACCURACY, coords.accuracy);\n    this.set(ol.GeolocationProperty.ALTITUDE,\n        coords.altitude === null ? undefined : coords.altitude);\n    this.set(ol.GeolocationProperty.ALTITUDE_ACCURACY,\n        coords.altitudeAccuracy === null ?\n          undefined : coords.altitudeAccuracy);\n    this.set(ol.GeolocationProperty.HEADING, coords.heading === null ?\n      undefined : ol.math.toRadians(coords.heading));\n    if (!this.position_) {\n      this.position_ = [coords.longitude, coords.latitude];\n    } else {\n      this.position_[0] = coords.longitude;\n      this.position_[1] = coords.latitude;\n    }\n    var projectedPosition = this.transform_(this.position_);\n    this.set(ol.GeolocationProperty.POSITION, projectedPosition);\n    this.set(ol.GeolocationProperty.SPEED,\n        coords.speed === null ? undefined : coords.speed);\n    var geometry = ol.geom.Polygon.circular(\n        this.sphere_, this.position_, coords.accuracy);\n    geometry.applyTransform(this.transform_);\n    this.set(ol.GeolocationProperty.ACCURACY_GEOMETRY, geometry);\n    this.changed();\n  };\n  \n  /**\n   * Triggered when the Geolocation returns an error.\n   * @event error\n   * @api\n   */\n  \n  /**\n   * @private\n   * @param {GeolocationPositionError} error error object.\n   */\n  ol.Geolocation.prototype.positionError_ = function(error) {\n    error.type = ol.events.EventType.ERROR;\n    this.setTracking(false);\n    this.dispatchEvent(/** @type {{type: string, target: undefined}} */ (error));\n  };\n  \n  \n  /**\n   * Get the accuracy of the position in meters.\n   * @return {number|undefined} The accuracy of the position measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getAccuracy = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.GeolocationProperty.ACCURACY));\n  };\n  \n  \n  /**\n   * Get a geometry of the position accuracy.\n   * @return {?ol.geom.Polygon} A geometry of the position accuracy.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getAccuracyGeometry = function() {\n    return /** @type {?ol.geom.Polygon} */ (\n      this.get(ol.GeolocationProperty.ACCURACY_GEOMETRY) || null);\n  };\n  \n  \n  /**\n   * Get the altitude associated with the position.\n   * @return {number|undefined} The altitude of the position in meters above mean\n   *     sea level.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getAltitude = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.GeolocationProperty.ALTITUDE));\n  };\n  \n  \n  /**\n   * Get the altitude accuracy of the position.\n   * @return {number|undefined} The accuracy of the altitude measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getAltitudeAccuracy = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.GeolocationProperty.ALTITUDE_ACCURACY));\n  };\n  \n  \n  /**\n   * Get the heading as radians clockwise from North.\n   * @return {number|undefined} The heading of the device in radians from north.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getHeading = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.GeolocationProperty.HEADING));\n  };\n  \n  \n  /**\n   * Get the position of the device.\n   * @return {ol.Coordinate|undefined} The current position of the device reported\n   *     in the current projection.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getPosition = function() {\n    return /** @type {ol.Coordinate|undefined} */ (\n      this.get(ol.GeolocationProperty.POSITION));\n  };\n  \n  \n  /**\n   * Get the projection associated with the position.\n   * @return {ol.proj.Projection|undefined} The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getProjection = function() {\n    return /** @type {ol.proj.Projection|undefined} */ (\n      this.get(ol.GeolocationProperty.PROJECTION));\n  };\n  \n  \n  /**\n   * Get the speed in meters per second.\n   * @return {number|undefined} The instantaneous speed of the device in meters\n   *     per second.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getSpeed = function() {\n    return /** @type {number|undefined} */ (\n      this.get(ol.GeolocationProperty.SPEED));\n  };\n  \n  \n  /**\n   * Determine if the device location is being tracked.\n   * @return {boolean} The device location is being tracked.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getTracking = function() {\n    return /** @type {boolean} */ (\n      this.get(ol.GeolocationProperty.TRACKING));\n  };\n  \n  \n  /**\n   * Get the tracking options.\n   * @see http://www.w3.org/TR/geolocation-API/#position-options\n   * @return {GeolocationPositionOptions|undefined} PositionOptions as defined by\n   *     the [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.getTrackingOptions = function() {\n    return /** @type {GeolocationPositionOptions|undefined} */ (\n      this.get(ol.GeolocationProperty.TRACKING_OPTIONS));\n  };\n  \n  \n  /**\n   * Set the projection to use for transforming the coordinates.\n   * @param {ol.ProjectionLike} projection The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.setProjection = function(projection) {\n    this.set(ol.GeolocationProperty.PROJECTION, ol.proj.get(projection));\n  };\n  \n  \n  /**\n   * Enable or disable tracking.\n   * @param {boolean} tracking Enable tracking.\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.setTracking = function(tracking) {\n    this.set(ol.GeolocationProperty.TRACKING, tracking);\n  };\n  \n  \n  /**\n   * Set the tracking options.\n   * @see http://www.w3.org/TR/geolocation-API/#position-options\n   * @param {GeolocationPositionOptions} options PositionOptions as defined by the\n   *     [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  ol.Geolocation.prototype.setTrackingOptions = function(options) {\n    this.set(ol.GeolocationProperty.TRACKING_OPTIONS, options);\n  };\n  \n  goog.provide('ol.geom.Circle');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.geom.flat.deflate');\n  \n  \n  /**\n   * @classdesc\n   * Circle geometry.\n   *\n   * @constructor\n   * @extends {ol.geom.SimpleGeometry}\n   * @param {ol.Coordinate} center Center.\n   * @param {number=} opt_radius Radius.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.Circle = function(center, opt_radius, opt_layout) {\n    ol.geom.SimpleGeometry.call(this);\n    var radius = opt_radius ? opt_radius : 0;\n    this.setCenterAndRadius(center, radius, opt_layout);\n  };\n  ol.inherits(ol.geom.Circle, ol.geom.SimpleGeometry);\n  \n  \n  /**\n   * Make a complete copy of the geometry.\n   * @return {!ol.geom.Circle} Clone.\n   * @override\n   * @api\n   */\n  ol.geom.Circle.prototype.clone = function() {\n    var circle = new ol.geom.Circle(null);\n    circle.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n    return circle;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Circle.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    var squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      var i;\n      if (squaredDistance === 0) {\n        for (i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        var delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Circle.prototype.containsXY = function(x, y) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  };\n  \n  \n  /**\n   * Return the center of the circle as {@link ol.Coordinate coordinate}.\n   * @return {ol.Coordinate} Center.\n   * @api\n   */\n  ol.geom.Circle.prototype.getCenter = function() {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Circle.prototype.computeExtent = function(extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return ol.extent.createOrUpdate(\n        flatCoordinates[0] - radius, flatCoordinates[1] - radius,\n        flatCoordinates[0] + radius, flatCoordinates[1] + radius,\n        extent);\n  };\n  \n  \n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  ol.geom.Circle.prototype.getRadius = function() {\n    return Math.sqrt(this.getRadiusSquared_());\n  };\n  \n  \n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  ol.geom.Circle.prototype.getRadiusSquared_ = function() {\n    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.Circle.prototype.getType = function() {\n    return ol.geom.GeometryType.CIRCLE;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.geom.Circle.prototype.intersectsExtent = function(extent) {\n    var circleExtent = this.getExtent();\n    if (ol.extent.intersects(extent, circleExtent)) {\n      var center = this.getCenter();\n  \n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n  \n      return ol.extent.forEachCorner(extent, this.intersectsCoordinate, this);\n    }\n    return false;\n  \n  };\n  \n  \n  /**\n   * Set the center of the circle as {@link ol.Coordinate coordinate}.\n   * @param {ol.Coordinate} center Center.\n   * @api\n   */\n  ol.geom.Circle.prototype.setCenter = function(center) {\n    var stride = this.stride;\n    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    var flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    var i;\n    for (i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n  };\n  \n  \n  /**\n   * Set the center (as {@link ol.Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {ol.Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  ol.geom.Circle.prototype.setCenterAndRadius = function(center, radius, opt_layout) {\n    if (!center) {\n      this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);\n    } else {\n      this.setLayout(opt_layout, center, 0);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      /** @type {Array.<number>} */\n      var flatCoordinates = this.flatCoordinates;\n      var offset = ol.geom.flat.deflate.coordinate(\n          flatCoordinates, 0, center, this.stride);\n      flatCoordinates[offset++] = flatCoordinates[0] + radius;\n      var i, ii;\n      for (i = 1, ii = this.stride; i < ii; ++i) {\n        flatCoordinates[offset++] = flatCoordinates[i];\n      }\n      flatCoordinates.length = offset;\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Circle.prototype.getCoordinates = function() {};\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.geom.Circle.prototype.setCoordinates = function(coordinates, opt_layout) {};\n  \n  \n  /**\n   * @param {ol.geom.GeometryLayout} layout Layout.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   */\n  ol.geom.Circle.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n    this.setFlatCoordinatesInternal(layout, flatCoordinates);\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  ol.geom.Circle.prototype.setRadius = function(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  };\n  \n  \n  /**\n   * Transform each coordinate of the circle from one coordinate reference system\n   * to another. The geometry is modified in place.\n   * If you do not want the geometry modified in place, first clone() it and\n   * then use this function on the clone.\n   *\n   * Internally a circle is currently represented by two points: the center of\n   * the circle `[cx, cy]`, and the point to the right of the circle\n   * `[cx + r, cy]`. This `transform` function just transforms these two points.\n   * So the resulting geometry is also a circle, and that circle does not\n   * correspond to the shape that would be obtained by transforming every point\n   * of the original circle.\n   *\n   * @param {ol.ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link ol.proj.Projection} object.\n   * @param {ol.ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link ol.proj.Projection} object.\n   * @return {ol.geom.Circle} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @function\n   * @api\n   */\n  ol.geom.Circle.prototype.transform;\n  \n  goog.provide('ol.geom.flat.geodesic');\n  \n  goog.require('ol.math');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @private\n   * @param {function(number): ol.Coordinate} interpolate Interpolate function.\n   * @param {ol.TransformFunction} transform Transform from longitude/latitude to\n   *     projected coordinates.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.geom.flat.geodesic.line_ = function(interpolate, transform, squaredTolerance) {\n    // FIXME reduce garbage generation\n    // FIXME optimize stack operations\n  \n    /** @type {Array.<number>} */\n    var flatCoordinates = [];\n  \n    var geoA = interpolate(0);\n    var geoB = interpolate(1);\n  \n    var a = transform(geoA);\n    var b = transform(geoB);\n  \n    /** @type {Array.<ol.Coordinate>} */\n    var geoStack = [geoB, geoA];\n    /** @type {Array.<ol.Coordinate>} */\n    var stack = [b, a];\n    /** @type {Array.<number>} */\n    var fractionStack = [1, 0];\n  \n    /** @type {Object.<string, boolean>} */\n    var fractions = {};\n  \n    var maxIterations = 1e5;\n    var geoM, m, fracA, fracB, fracM, key;\n  \n    while (--maxIterations > 0 && fractionStack.length > 0) {\n      // Pop the a coordinate off the stack\n      fracA = fractionStack.pop();\n      geoA = geoStack.pop();\n      a = stack.pop();\n      // Add the a coordinate if it has not been added yet\n      key = fracA.toString();\n      if (!(key in fractions)) {\n        flatCoordinates.push(a[0], a[1]);\n        fractions[key] = true;\n      }\n      // Pop the b coordinate off the stack\n      fracB = fractionStack.pop();\n      geoB = geoStack.pop();\n      b = stack.pop();\n      // Find the m point between the a and b coordinates\n      fracM = (fracA + fracB) / 2;\n      geoM = interpolate(fracM);\n      m = transform(geoM);\n      if (ol.math.squaredSegmentDistance(m[0], m[1], a[0], a[1],\n          b[0], b[1]) < squaredTolerance) {\n        // If the m point is sufficiently close to the straight line, then we\n        // discard it.  Just use the b coordinate and move on to the next line\n        // segment.\n        flatCoordinates.push(b[0], b[1]);\n        key = fracB.toString();\n        fractions[key] = true;\n      } else {\n        // Otherwise, we need to subdivide the current line segment.  Split it\n        // into two and push the two line segments onto the stack.\n        fractionStack.push(fracB, fracM, fracM, fracA);\n        stack.push(b, m, m, a);\n        geoStack.push(geoB, geoM, geoM, geoA);\n      }\n    }\n  \n    return flatCoordinates;\n  };\n  \n  \n  /**\n  * Generate a great-circle arcs between two lat/lon points.\n  * @param {number} lon1 Longitude 1 in degrees.\n  * @param {number} lat1 Latitude 1 in degrees.\n  * @param {number} lon2 Longitude 2 in degrees.\n  * @param {number} lat2 Latitude 2 in degrees.\n   * @param {ol.proj.Projection} projection Projection.\n  * @param {number} squaredTolerance Squared tolerance.\n  * @return {Array.<number>} Flat coordinates.\n  */\n  ol.geom.flat.geodesic.greatCircleArc = function(\n      lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n  \n    var geoProjection = ol.proj.get('EPSG:4326');\n  \n    var cosLat1 = Math.cos(ol.math.toRadians(lat1));\n    var sinLat1 = Math.sin(ol.math.toRadians(lat1));\n    var cosLat2 = Math.cos(ol.math.toRadians(lat2));\n    var sinLat2 = Math.sin(ol.math.toRadians(lat2));\n    var cosDeltaLon = Math.cos(ol.math.toRadians(lon2 - lon1));\n    var sinDeltaLon = Math.sin(ol.math.toRadians(lon2 - lon1));\n    var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n  \n    return ol.geom.flat.geodesic.line_(\n        /**\n         * @param {number} frac Fraction.\n         * @return {ol.Coordinate} Coordinate.\n         */\n        function(frac) {\n          if (1 <= d) {\n            return [lon2, lat2];\n          }\n          var D = frac * Math.acos(d);\n          var cosD = Math.cos(D);\n          var sinD = Math.sin(D);\n          var y = sinDeltaLon * cosLat2;\n          var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n          var theta = Math.atan2(y, x);\n          var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n          var lon = ol.math.toRadians(lon1) +\n              Math.atan2(Math.sin(theta) * sinD * cosLat1,\n                  cosD - sinLat1 * Math.sin(lat));\n          return [ol.math.toDegrees(lon), ol.math.toDegrees(lat)];\n        }, ol.proj.getTransform(geoProjection, projection), squaredTolerance);\n  };\n  \n  \n  /**\n   * Generate a meridian (line at constant longitude).\n   * @param {number} lon Longitude.\n   * @param {number} lat1 Latitude 1.\n   * @param {number} lat2 Latitude 2.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.geom.flat.geodesic.meridian = function(lon, lat1, lat2, projection, squaredTolerance) {\n    var epsg4326Projection = ol.proj.get('EPSG:4326');\n    return ol.geom.flat.geodesic.line_(\n        /**\n         * @param {number} frac Fraction.\n         * @return {ol.Coordinate} Coordinate.\n         */\n        function(frac) {\n          return [lon, lat1 + ((lat2 - lat1) * frac)];\n        },\n        ol.proj.getTransform(epsg4326Projection, projection), squaredTolerance);\n  };\n  \n  \n  /**\n   * Generate a parallel (line at constant latitude).\n   * @param {number} lat Latitude.\n   * @param {number} lon1 Longitude 1.\n   * @param {number} lon2 Longitude 2.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Array.<number>} Flat coordinates.\n   */\n  ol.geom.flat.geodesic.parallel = function(lat, lon1, lon2, projection, squaredTolerance) {\n    var epsg4326Projection = ol.proj.get('EPSG:4326');\n    return ol.geom.flat.geodesic.line_(\n        /**\n         * @param {number} frac Fraction.\n         * @return {ol.Coordinate} Coordinate.\n         */\n        function(frac) {\n          return [lon1 + ((lon2 - lon1) * frac), lat];\n        },\n        ol.proj.getTransform(epsg4326Projection, projection), squaredTolerance);\n  };\n  \n  goog.provide('ol.geom.flat.topology');\n  \n  goog.require('ol.geom.flat.area');\n  \n  /**\n   * Check if the linestring is a boundary.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {boolean} The linestring is a boundary.\n   */\n  ol.geom.flat.topology.lineStringIsClosed = function(flatCoordinates, offset, end, stride) {\n    var lastCoord = end - stride;\n    if (flatCoordinates[offset] === flatCoordinates[lastCoord] &&\n        flatCoordinates[offset + 1] === flatCoordinates[lastCoord + 1] && (end - offset) / stride > 3) {\n      return !!ol.geom.flat.area.linearRing(flatCoordinates, offset, end, stride);\n    }\n    return false;\n  };\n  \n  goog.provide('ol.Graticule');\n  \n  goog.require('ol.coordinate');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryLayout');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.flat.geodesic');\n  goog.require('ol.math');\n  goog.require('ol.proj');\n  goog.require('ol.render.EventType');\n  goog.require('ol.style.Fill');\n  goog.require('ol.style.Stroke');\n  goog.require('ol.style.Text');\n  \n  \n  /**\n   * Render a grid for a coordinate system on a map.\n   * @constructor\n   * @param {olx.GraticuleOptions=} opt_options Options.\n   * @api\n   */\n  ol.Graticule = function(opt_options) {\n    var options = opt_options || {};\n  \n    /**\n     * @type {ol.PluggableMap}\n     * @private\n     */\n    this.map_ = null;\n  \n    /**\n     * @type {ol.proj.Projection}\n     * @private\n     */\n    this.projection_ = null;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLat_ = Infinity;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLon_ = Infinity;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLat_ = -Infinity;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLon_ = -Infinity;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLatP_ = Infinity;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLonP_ = Infinity;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLatP_ = -Infinity;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLonP_ = -Infinity;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.targetSize_ = options.targetSize !== undefined ?\n      options.targetSize : 100;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n  \n    /**\n     * @type {Array.<ol.geom.LineString>}\n     * @private\n     */\n    this.meridians_ = [];\n  \n    /**\n     * @type {Array.<ol.geom.LineString>}\n     * @private\n     */\n    this.parallels_ = [];\n  \n    /**\n     * @type {ol.style.Stroke}\n     * @private\n     */\n    this.strokeStyle_ = options.strokeStyle !== undefined ?\n      options.strokeStyle : ol.Graticule.DEFAULT_STROKE_STYLE_;\n  \n    /**\n     * @type {ol.TransformFunction|undefined}\n     * @private\n     */\n    this.fromLonLatTransform_ = undefined;\n  \n    /**\n     * @type {ol.TransformFunction|undefined}\n     * @private\n     */\n    this.toLonLatTransform_ = undefined;\n  \n    /**\n     * @type {ol.Coordinate}\n     * @private\n     */\n    this.projectionCenterLonLat_ = null;\n  \n    /**\n     * @type {Array.<ol.GraticuleLabelDataType>}\n     * @private\n     */\n    this.meridiansLabels_ = null;\n  \n    /**\n     * @type {Array.<ol.GraticuleLabelDataType>}\n     * @private\n     */\n    this.parallelsLabels_ = null;\n  \n    if (options.showLabels == true) {\n      var degreesToString = ol.coordinate.degreesToStringHDMS;\n  \n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ?\n        degreesToString.bind(this, 'EW') : options.lonLabelFormatter;\n  \n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      this.latLabelFormatter_ = options.latLabelFormatter == undefined ?\n        degreesToString.bind(this, 'NS') : options.latLabelFormatter;\n  \n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 :\n        options.lonLabelPosition;\n  \n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 :\n        options.latLabelPosition;\n  \n      /**\n       * @type {ol.style.Text}\n       * @private\n       */\n      this.lonLabelStyle_ = options.lonLabelStyle !== undefined ? options.lonLabelStyle :\n        new ol.style.Text({\n          font: '12px Calibri,sans-serif',\n          textBaseline: 'bottom',\n          fill: new ol.style.Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new ol.style.Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        });\n  \n      /**\n       * @type {ol.style.Text}\n       * @private\n       */\n      this.latLabelStyle_ = options.latLabelStyle !== undefined ? options.latLabelStyle :\n        new ol.style.Text({\n          font: '12px Calibri,sans-serif',\n          textAlign: 'end',\n          fill: new ol.style.Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new ol.style.Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        });\n  \n      this.meridiansLabels_ = [];\n      this.parallelsLabels_ = [];\n    }\n  \n    this.setMap(options.map !== undefined ? options.map : null);\n  };\n  \n  \n  /**\n   * @type {ol.style.Stroke}\n   * @private\n   * @const\n   */\n  ol.Graticule.DEFAULT_STROKE_STYLE_ = new ol.style.Stroke({\n    color: 'rgba(0,0,0,0.2)'\n  });\n  \n  \n  /**\n   * TODO can be configurable\n   * @type {Array.<number>}\n   * @private\n   */\n  ol.Graticule.intervals_ = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05,\n    0.01, 0.005, 0.002, 0.001];\n  \n  \n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  ol.Graticule.prototype.addMeridian_ = function(lon, minLat, maxLat, squaredTolerance, extent, index) {\n    var lineString = this.getMeridian_(lon, minLat, maxLat,\n        squaredTolerance, index);\n    if (ol.extent.intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        var textPoint = this.getMeridianPoint_(lineString, extent, index);\n        this.meridiansLabels_[index] = {\n          geom: textPoint,\n          text: this.lonLabelFormatter_(lon)\n        };\n      }\n      this.meridians_[index++] = lineString;\n    }\n    return index;\n  };\n  \n  /**\n   * @param {ol.geom.LineString} lineString Meridian\n   * @param {ol.Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {ol.geom.Point} Meridian point.\n   * @private\n   */\n  ol.Graticule.prototype.getMeridianPoint_ = function(lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var clampedBottom = Math.max(extent[1], flatCoordinates[1]);\n    var clampedTop = Math.min(extent[3], flatCoordinates[flatCoordinates.length - 1]);\n    var lat = ol.math.clamp(\n        extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_,\n        clampedBottom, clampedTop);\n    var coordinate = [flatCoordinates[0], lat];\n    var point = this.meridiansLabels_[index] !== undefined ?\n      this.meridiansLabels_[index].geom : new ol.geom.Point(null);\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  \n  \n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  ol.Graticule.prototype.addParallel_ = function(lat, minLon, maxLon, squaredTolerance, extent, index) {\n    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance,\n        index);\n    if (ol.extent.intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        var textPoint = this.getParallelPoint_(lineString, extent, index);\n        this.parallelsLabels_[index] = {\n          geom: textPoint,\n          text: this.latLabelFormatter_(lat)\n        };\n      }\n      this.parallels_[index++] = lineString;\n    }\n    return index;\n  };\n  \n  \n  /**\n   * @param {ol.geom.LineString} lineString Parallels.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {ol.geom.Point} Parallel point.\n   * @private\n   */\n  ol.Graticule.prototype.getParallelPoint_ = function(lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var clampedLeft = Math.max(extent[0], flatCoordinates[0]);\n    var clampedRight = Math.min(extent[2], flatCoordinates[flatCoordinates.length - 2]);\n    var lon = ol.math.clamp(\n        extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_,\n        clampedLeft, clampedRight);\n    var coordinate = [lon, flatCoordinates[1]];\n    var point = this.parallelsLabels_[index] !== undefined ?\n      this.parallelsLabels_[index].geom : new ol.geom.Point(null);\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  ol.Graticule.prototype.createGraticule_ = function(extent, center, resolution, squaredTolerance) {\n  \n    var interval = this.getInterval_(resolution);\n    if (interval == -1) {\n      this.meridians_.length = this.parallels_.length = 0;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n      return;\n    }\n  \n    var centerLonLat = this.toLonLatTransform_(center);\n    var centerLon = centerLonLat[0];\n    var centerLat = centerLonLat[1];\n    var maxLines = this.maxLines_;\n    var cnt, idx, lat, lon;\n  \n    var validExtent = [\n      Math.max(extent[0], this.minLonP_),\n      Math.max(extent[1], this.minLatP_),\n      Math.min(extent[2], this.maxLonP_),\n      Math.min(extent[3], this.maxLatP_)\n    ];\n  \n    validExtent = ol.proj.transformExtent(validExtent, this.projection_,\n        'EPSG:4326');\n    var maxLat = validExtent[3];\n    var maxLon = validExtent[2];\n    var minLat = validExtent[1];\n    var minLon = validExtent[0];\n  \n    // Create meridians\n  \n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = ol.math.clamp(centerLon, this.minLon_, this.maxLon_);\n  \n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n  \n    cnt = 0;\n    while (lon != this.minLon_ && cnt++ < maxLines) {\n      lon = Math.max(lon - interval, this.minLon_);\n      idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n    }\n  \n    lon = ol.math.clamp(centerLon, this.minLon_, this.maxLon_);\n  \n    cnt = 0;\n    while (lon != this.maxLon_ && cnt++ < maxLines) {\n      lon = Math.min(lon + interval, this.maxLon_);\n      idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n    }\n  \n    this.meridians_.length = idx;\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    }\n  \n    // Create parallels\n  \n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = ol.math.clamp(centerLat, this.minLat_, this.maxLat_);\n  \n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n  \n    cnt = 0;\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n  \n    lat = ol.math.clamp(centerLat, this.minLat_, this.maxLat_);\n  \n    cnt = 0;\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n  \n    this.parallels_.length = idx;\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  \n  };\n  \n  \n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n  ol.Graticule.prototype.getInterval_ = function(resolution) {\n    var centerLon = this.projectionCenterLonLat_[0];\n    var centerLat = this.projectionCenterLonLat_[1];\n    var interval = -1;\n    var i, ii, delta, dist;\n    var target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array.<number>} **/\n    var p1 = [];\n    /** @type {Array.<number>} **/\n    var p2 = [];\n    for (i = 0, ii = ol.Graticule.intervals_.length; i < ii; ++i) {\n      delta = ol.Graticule.intervals_[i] / 2;\n      p1[0] = centerLon - delta;\n      p1[1] = centerLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = centerLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n      if (dist <= target) {\n        break;\n      }\n      interval = ol.Graticule.intervals_[i];\n    }\n    return interval;\n  };\n  \n  \n  /**\n   * Get the map associated with this graticule.\n   * @return {ol.PluggableMap} The map.\n   * @api\n   */\n  ol.Graticule.prototype.getMap = function() {\n    return this.map_;\n  };\n  \n  \n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {ol.geom.LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n  ol.Graticule.prototype.getMeridian_ = function(lon, minLat, maxLat,\n      squaredTolerance, index) {\n    var flatCoordinates = ol.geom.flat.geodesic.meridian(lon,\n        minLat, maxLat, this.projection_, squaredTolerance);\n    var lineString = this.meridians_[index] !== undefined ?\n      this.meridians_[index] : new ol.geom.LineString(null);\n    lineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates);\n    return lineString;\n  };\n  \n  \n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array.<ol.geom.LineString>} The meridians.\n   * @api\n   */\n  ol.Graticule.prototype.getMeridians = function() {\n    return this.meridians_;\n  };\n  \n  \n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {ol.geom.LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n  ol.Graticule.prototype.getParallel_ = function(lat, minLon, maxLon,\n      squaredTolerance, index) {\n    var flatCoordinates = ol.geom.flat.geodesic.parallel(lat,\n        minLon, maxLon, this.projection_, squaredTolerance);\n    var lineString = this.parallels_[index] !== undefined ?\n      this.parallels_[index] : new ol.geom.LineString(null);\n    lineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates);\n    return lineString;\n  };\n  \n  \n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array.<ol.geom.LineString>} The parallels.\n   * @api\n   */\n  ol.Graticule.prototype.getParallels = function() {\n    return this.parallels_;\n  };\n  \n  \n  /**\n   * @param {ol.render.Event} e Event.\n   * @private\n   */\n  ol.Graticule.prototype.handlePostCompose_ = function(e) {\n    var vectorContext = e.vectorContext;\n    var frameState = e.frameState;\n    var extent = frameState.extent;\n    var viewState = frameState.viewState;\n    var center = viewState.center;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var squaredTolerance =\n        resolution * resolution / (4 * pixelRatio * pixelRatio);\n  \n    var updateProjectionInfo = !this.projection_ ||\n        !ol.proj.equivalent(this.projection_, projection);\n  \n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n  \n    this.createGraticule_(extent, center, resolution, squaredTolerance);\n  \n    // Draw the lines\n    vectorContext.setFillStrokeStyle(null, this.strokeStyle_);\n    var i, l, line;\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      line = this.meridians_[i];\n      vectorContext.drawGeometry(line);\n    }\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      line = this.parallels_[i];\n      vectorContext.drawGeometry(line);\n    }\n    var labelData;\n    if (this.meridiansLabels_) {\n      for (i = 0, l = this.meridiansLabels_.length; i < l; ++i) {\n        labelData = this.meridiansLabels_[i];\n        this.lonLabelStyle_.setText(labelData.text);\n        vectorContext.setTextStyle(this.lonLabelStyle_);\n        vectorContext.drawGeometry(labelData.geom);\n      }\n    }\n    if (this.parallelsLabels_) {\n      for (i = 0, l = this.parallelsLabels_.length; i < l; ++i) {\n        labelData = this.parallelsLabels_[i];\n        this.latLabelStyle_.setText(labelData.text);\n        vectorContext.setTextStyle(this.latLabelStyle_);\n        vectorContext.drawGeometry(labelData.geom);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.proj.Projection} projection Projection.\n   * @private\n   */\n  ol.Graticule.prototype.updateProjectionInfo_ = function(projection) {\n    var epsg4326Projection = ol.proj.get('EPSG:4326');\n  \n    var extent = projection.getExtent();\n    var worldExtent = projection.getWorldExtent();\n    var worldExtentP = ol.proj.transformExtent(worldExtent,\n        epsg4326Projection, projection);\n  \n    var maxLat = worldExtent[3];\n    var maxLon = worldExtent[2];\n    var minLat = worldExtent[1];\n    var minLon = worldExtent[0];\n  \n    var maxLatP = worldExtentP[3];\n    var maxLonP = worldExtentP[2];\n    var minLatP = worldExtentP[1];\n    var minLonP = worldExtentP[0];\n  \n    this.maxLat_ = maxLat;\n    this.maxLon_ = maxLon;\n    this.minLat_ = minLat;\n    this.minLon_ = minLon;\n  \n    this.maxLatP_ = maxLatP;\n    this.maxLonP_ = maxLonP;\n    this.minLatP_ = minLatP;\n    this.minLonP_ = minLonP;\n  \n  \n    this.fromLonLatTransform_ = ol.proj.getTransform(\n        epsg4326Projection, projection);\n  \n    this.toLonLatTransform_ = ol.proj.getTransform(\n        projection, epsg4326Projection);\n  \n    this.projectionCenterLonLat_ = this.toLonLatTransform_(\n        ol.extent.getCenter(extent));\n  \n    this.projection_ = projection;\n  };\n  \n  \n  /**\n   * Set the map for this graticule.  The graticule will be rendered on the\n   * provided map.\n   * @param {ol.PluggableMap} map Map.\n   * @api\n   */\n  ol.Graticule.prototype.setMap = function(map) {\n    if (this.map_) {\n      this.map_.un(ol.render.EventType.POSTCOMPOSE,\n          this.handlePostCompose_, this);\n      this.map_.render();\n    }\n    if (map) {\n      map.on(ol.render.EventType.POSTCOMPOSE,\n          this.handlePostCompose_, this);\n      map.render();\n    }\n    this.map_ = map;\n  };\n  \n  goog.provide('ol.Image');\n  \n  goog.require('ol');\n  goog.require('ol.ImageBase');\n  goog.require('ol.ImageState');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.ImageBase}\n   * @param {ol.Extent} extent Extent.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.\n   */\n  ol.Image = function(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {\n  \n    ol.ImageBase.call(this, extent, resolution, pixelRatio, ol.ImageState.IDLE);\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement|Image|HTMLVideoElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n  \n    /**\n     * @private\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.imageListenerKeys_ = null;\n  \n    /**\n     * @protected\n     * @type {ol.ImageState}\n     */\n    this.state = ol.ImageState.IDLE;\n  \n    /**\n     * @private\n     * @type {ol.ImageLoadFunctionType}\n     */\n    this.imageLoadFunction_ = imageLoadFunction;\n  \n  };\n  ol.inherits(ol.Image, ol.ImageBase);\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.Image.prototype.getImage = function() {\n    return this.image_;\n  };\n  \n  \n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  ol.Image.prototype.handleImageError_ = function() {\n    this.state = ol.ImageState.ERROR;\n    this.unlistenImage_();\n    this.changed();\n  };\n  \n  \n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  ol.Image.prototype.handleImageLoad_ = function() {\n    if (this.resolution === undefined) {\n      this.resolution = ol.extent.getHeight(this.extent) / this.image_.height;\n    }\n    this.state = ol.ImageState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  };\n  \n  \n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @override\n   * @api\n   */\n  ol.Image.prototype.load = function() {\n    if (this.state == ol.ImageState.IDLE || this.state == ol.ImageState.ERROR) {\n      this.state = ol.ImageState.LOADING;\n      this.changed();\n      this.imageListenerKeys_ = [\n        ol.events.listenOnce(this.image_, ol.events.EventType.ERROR,\n            this.handleImageError_, this),\n        ol.events.listenOnce(this.image_, ol.events.EventType.LOAD,\n            this.handleImageLoad_, this)\n      ];\n      this.imageLoadFunction_(this, this.src_);\n    }\n  };\n  \n  \n  /**\n   * @param {HTMLCanvasElement|Image|HTMLVideoElement} image Image.\n   */\n  ol.Image.prototype.setImage = function(image) {\n    this.image_ = image;\n  };\n  \n  \n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  ol.Image.prototype.unlistenImage_ = function() {\n    this.imageListenerKeys_.forEach(ol.events.unlistenByKey);\n    this.imageListenerKeys_ = null;\n  };\n  \n  goog.provide('ol.Tile');\n  \n  goog.require('ol');\n  goog.require('ol.TileState');\n  goog.require('ol.easing');\n  goog.require('ol.events.EventTarget');\n  goog.require('ol.events.EventType');\n  \n  \n  /**\n   * @classdesc\n   * Base class for tiles.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.events.EventTarget}\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.TileState} state State.\n   * @param {olx.TileOptions=} opt_options Tile options.\n   */\n  ol.Tile = function(tileCoord, state, opt_options) {\n    ol.events.EventTarget.call(this);\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @type {ol.TileCoord}\n     */\n    this.tileCoord = tileCoord;\n  \n    /**\n     * @protected\n     * @type {ol.TileState}\n     */\n    this.state = state;\n  \n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {ol.Tile}\n     */\n    this.interimTile = null;\n  \n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n  \n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ = options.transition === undefined ?\n      250 : options.transition;\n  \n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object.<number, number>}\n     */\n    this.transitionStarts_ = {};\n  \n  };\n  ol.inherits(ol.Tile, ol.events.EventTarget);\n  \n  \n  /**\n   * @protected\n   */\n  ol.Tile.prototype.changed = function() {\n    this.dispatchEvent(ol.events.EventType.CHANGE);\n  };\n  \n  \n  /**\n   * @return {string} Key.\n   */\n  ol.Tile.prototype.getKey = function() {\n    return this.key + '/' + this.tileCoord;\n  };\n  \n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!ol.Tile} Best tile for rendering.\n   */\n  ol.Tile.prototype.getInterimTile = function() {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n    var tile = this.interimTile;\n  \n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == ol.TileState.LOADED) {\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n  \n    // we can not find a better tile\n    return this;\n  };\n  \n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  ol.Tile.prototype.refreshInterimChain = function() {\n    if (!this.interimTile) {\n      return;\n    }\n  \n    var tile = this.interimTile;\n    var prev = this;\n  \n    do {\n      if (tile.getState() == ol.TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == ol.TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == ol.TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  };\n  \n  /**\n   * Get the tile coordinate for this tile.\n   * @return {ol.TileCoord} The tile coordinate.\n   * @api\n   */\n  ol.Tile.prototype.getTileCoord = function() {\n    return this.tileCoord;\n  };\n  \n  \n  /**\n   * @return {ol.TileState} State.\n   */\n  ol.Tile.prototype.getState = function() {\n    return this.state;\n  };\n  \n  /**\n   * @param {ol.TileState} state State.\n   */\n  ol.Tile.prototype.setState = function(state) {\n    this.state = state;\n    this.changed();\n  };\n  \n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  ol.Tile.prototype.load = function() {};\n  \n  /**\n   * Get the alpha value for rendering.\n   * @param {number} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  ol.Tile.prototype.getAlpha = function(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n  \n    var start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n  \n    var delta = time - start + (1000 / 60); // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return ol.easing.easeIn(delta / this.transition_);\n  };\n  \n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {number} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  ol.Tile.prototype.inTransition = function(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  };\n  \n  /**\n   * Mark a transition as complete.\n   * @param {number} id An id for the renderer.\n   */\n  ol.Tile.prototype.endTransition = function(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  };\n  \n  goog.provide('ol.ImageTile');\n  \n  goog.require('ol');\n  goog.require('ol.Tile');\n  goog.require('ol.TileState');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.Tile}\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.TileState} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.\n   * @param {olx.TileOptions=} opt_options Tile options.\n   */\n  ol.ImageTile = function(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {\n  \n    ol.Tile.call(this, tileCoord, state, opt_options);\n  \n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n  \n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n  \n    /**\n     * @private\n     * @type {Image|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n  \n    /**\n     * @private\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.imageListenerKeys_ = null;\n  \n    /**\n     * @private\n     * @type {ol.TileLoadFunctionType}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  \n  };\n  ol.inherits(ol.ImageTile, ol.Tile);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.ImageTile.prototype.disposeInternal = function() {\n    if (this.state == ol.TileState.LOADING) {\n      this.unlistenImage_();\n      this.image_ = ol.ImageTile.getBlankImage();\n    }\n    if (this.interimTile) {\n      this.interimTile.dispose();\n    }\n    this.state = ol.TileState.ABORT;\n    this.changed();\n    ol.Tile.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  ol.ImageTile.prototype.getImage = function() {\n    return this.image_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.ImageTile.prototype.getKey = function() {\n    return this.src_;\n  };\n  \n  \n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  ol.ImageTile.prototype.handleImageError_ = function() {\n    this.state = ol.TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = ol.ImageTile.getBlankImage();\n    this.changed();\n  };\n  \n  \n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  ol.ImageTile.prototype.handleImageLoad_ = function() {\n    if (this.image_.naturalWidth && this.image_.naturalHeight) {\n      this.state = ol.TileState.LOADED;\n    } else {\n      this.state = ol.TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.ImageTile.prototype.load = function() {\n    if (this.state == ol.TileState.ERROR) {\n      this.state = ol.TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == ol.TileState.IDLE) {\n      this.state = ol.TileState.LOADING;\n      this.changed();\n      this.imageListenerKeys_ = [\n        ol.events.listenOnce(this.image_, ol.events.EventType.ERROR,\n            this.handleImageError_, this),\n        ol.events.listenOnce(this.image_, ol.events.EventType.LOAD,\n            this.handleImageLoad_, this)\n      ];\n      this.tileLoadFunction_(this, this.src_);\n    }\n  };\n  \n  \n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  ol.ImageTile.prototype.unlistenImage_ = function() {\n    this.imageListenerKeys_.forEach(ol.events.unlistenByKey);\n    this.imageListenerKeys_ = null;\n  };\n  \n  \n  /**\n   * Get a 1-pixel blank image.\n   * @return {HTMLCanvasElement} Blank image.\n   */\n  ol.ImageTile.getBlankImage = function() {\n    var ctx = ol.dom.createCanvasContext2D(1, 1);\n    ctx.fillStyle = 'rgba(0,0,0,0)';\n    ctx.fillRect(0, 0, 1, 1);\n    return ctx.canvas;\n  };\n  \n  // FIXME should handle all geo-referenced data, not just vector data\n  \n  goog.provide('ol.interaction.DragAndDrop');\n  \n  goog.require('ol');\n  goog.require('ol.functions');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.EventType');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * Handles input of vector data by drag and drop.\n   *\n   * @constructor\n   * @extends {ol.interaction.Interaction}\n   * @fires ol.interaction.DragAndDrop.Event\n   * @param {olx.interaction.DragAndDropOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.DragAndDrop = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.interaction.Interaction.call(this, {\n      handleEvent: ol.interaction.DragAndDrop.handleEvent\n    });\n  \n    /**\n     * @private\n     * @type {Array.<function(new: ol.format.Feature)>}\n     */\n    this.formatConstructors_ = options.formatConstructors ?\n      options.formatConstructors : [];\n  \n    /**\n     * @private\n     * @type {ol.proj.Projection}\n     */\n    this.projection_ = options.projection ?\n      ol.proj.get(options.projection) : null;\n  \n    /**\n     * @private\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.dropListenKeys_ = null;\n  \n    /**\n     * @private\n     * @type {ol.source.Vector}\n     */\n    this.source_ = options.source || null;\n  \n    /**\n     * @private\n     * @type {Element}\n     */\n    this.target = options.target ? options.target : null;\n  \n  };\n  ol.inherits(ol.interaction.DragAndDrop, ol.interaction.Interaction);\n  \n  \n  /**\n   * @param {Event} event Event.\n   * @this {ol.interaction.DragAndDrop}\n   * @private\n   */\n  ol.interaction.DragAndDrop.handleDrop_ = function(event) {\n    var files = event.dataTransfer.files;\n    var i, ii, file;\n    for (i = 0, ii = files.length; i < ii; ++i) {\n      file = files.item(i);\n      var reader = new FileReader();\n      reader.addEventListener(ol.events.EventType.LOAD,\n          this.handleResult_.bind(this, file));\n      reader.readAsText(file);\n    }\n  };\n  \n  \n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  ol.interaction.DragAndDrop.handleStop_ = function(event) {\n    event.stopPropagation();\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'copy';\n  };\n  \n  \n  /**\n   * @param {File} file File.\n   * @param {Event} event Load event.\n   * @private\n   */\n  ol.interaction.DragAndDrop.prototype.handleResult_ = function(file, event) {\n    var result = event.target.result;\n    var map = this.getMap();\n    var projection = this.projection_;\n    if (!projection) {\n      var view = map.getView();\n      projection = view.getProjection();\n    }\n  \n    var formatConstructors = this.formatConstructors_;\n    var features = [];\n    var i, ii;\n    for (i = 0, ii = formatConstructors.length; i < ii; ++i) {\n      /**\n       * Avoid \"cannot instantiate abstract class\" error.\n       * @type {Function}\n       */\n      var formatConstructor = formatConstructors[i];\n      /**\n       * @type {ol.format.Feature}\n       */\n      var format = new formatConstructor();\n      features = this.tryReadFeatures_(format, result, {\n        featureProjection: projection\n      });\n      if (features && features.length > 0) {\n        break;\n      }\n    }\n    if (this.source_) {\n      this.source_.clear();\n      this.source_.addFeatures(features);\n    }\n    this.dispatchEvent(\n        new ol.interaction.DragAndDrop.Event(\n            ol.interaction.DragAndDrop.EventType_.ADD_FEATURES, file,\n            features, projection));\n  };\n  \n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} unconditionally and\n   * neither prevents the browser default nor stops event propagation.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {ol.interaction.DragAndDrop}\n   * @api\n   */\n  ol.interaction.DragAndDrop.handleEvent = ol.functions.TRUE;\n  \n  \n  /**\n   * @private\n   */\n  ol.interaction.DragAndDrop.prototype.registerListeners_ = function() {\n    var map = this.getMap();\n    if (map) {\n      var dropArea = this.target ? this.target : map.getViewport();\n      this.dropListenKeys_ = [\n        ol.events.listen(dropArea, ol.events.EventType.DROP,\n            ol.interaction.DragAndDrop.handleDrop_, this),\n        ol.events.listen(dropArea, ol.events.EventType.DRAGENTER,\n            ol.interaction.DragAndDrop.handleStop_, this),\n        ol.events.listen(dropArea, ol.events.EventType.DRAGOVER,\n            ol.interaction.DragAndDrop.handleStop_, this),\n        ol.events.listen(dropArea, ol.events.EventType.DROP,\n            ol.interaction.DragAndDrop.handleStop_, this)\n      ];\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.DragAndDrop.prototype.setActive = function(active) {\n    ol.interaction.Interaction.prototype.setActive.call(this, active);\n    if (active) {\n      this.registerListeners_();\n    } else {\n      this.unregisterListeners_();\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.DragAndDrop.prototype.setMap = function(map) {\n    this.unregisterListeners_();\n    ol.interaction.Interaction.prototype.setMap.call(this, map);\n    if (this.getActive()) {\n      this.registerListeners_();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.format.Feature} format Format.\n   * @param {string} text Text.\n   * @param {olx.format.ReadOptions} options Read options.\n   * @private\n   * @return {Array.<ol.Feature>} Features.\n   */\n  ol.interaction.DragAndDrop.prototype.tryReadFeatures_ = function(format, text, options) {\n    try {\n      return format.readFeatures(text, options);\n    } catch (e) {\n      return null;\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.interaction.DragAndDrop.prototype.unregisterListeners_ = function() {\n    if (this.dropListenKeys_) {\n      this.dropListenKeys_.forEach(ol.events.unlistenByKey);\n      this.dropListenKeys_ = null;\n    }\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.interaction.DragAndDrop.EventType_ = {\n    /**\n     * Triggered when features are added\n     * @event ol.interaction.DragAndDrop.Event#addfeatures\n     * @api\n     */\n    ADD_FEATURES: 'addfeatures'\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.interaction.DragAndDrop} instances are instances\n   * of this type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.interaction.DragAndDropEvent}\n   * @param {ol.interaction.DragAndDrop.EventType_} type Type.\n   * @param {File} file File.\n   * @param {Array.<ol.Feature>=} opt_features Features.\n   * @param {ol.proj.Projection=} opt_projection Projection.\n   */\n  ol.interaction.DragAndDrop.Event = function(type, file, opt_features, opt_projection) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The features parsed from dropped data.\n     * @type {Array.<ol.Feature>|undefined}\n     * @api\n     */\n    this.features = opt_features;\n  \n    /**\n     * The dropped file.\n     * @type {File}\n     * @api\n     */\n    this.file = file;\n  \n    /**\n     * The feature projection.\n     * @type {ol.proj.Projection|undefined}\n     * @api\n     */\n    this.projection = opt_projection;\n  \n  };\n  ol.inherits(ol.interaction.DragAndDrop.Event, ol.events.Event);\n  \n  goog.provide('ol.interaction.DragRotateAndZoom');\n  \n  goog.require('ol');\n  goog.require('ol.RotationConstraint');\n  goog.require('ol.ViewHint');\n  goog.require('ol.events.condition');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.interaction.Pointer');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to zoom and rotate the map by clicking and dragging\n   * on the map.  By default, this interaction is limited to when the shift\n   * key is held down.\n   *\n   * This interaction is only supported for mouse devices.\n   *\n   * And this interaction is not included in the default interactions.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @param {olx.interaction.DragRotateAndZoomOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.DragRotateAndZoom = function(opt_options) {\n  \n    var options = opt_options ? opt_options : {};\n  \n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.DragRotateAndZoom.handleDownEvent_,\n      handleDragEvent: ol.interaction.DragRotateAndZoom.handleDragEvent_,\n      handleUpEvent: ol.interaction.DragRotateAndZoom.handleUpEvent_\n    });\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition ?\n      options.condition : ol.events.condition.shiftKeyOnly;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastMagnitude_ = undefined;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastScaleDelta_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\n  \n  };\n  ol.inherits(ol.interaction.DragRotateAndZoom, ol.interaction.Pointer);\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @this {ol.interaction.DragRotateAndZoom}\n   * @private\n   */\n  ol.interaction.DragRotateAndZoom.handleDragEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n  \n    var map = mapBrowserEvent.map;\n    var size = map.getSize();\n    var offset = mapBrowserEvent.pixel;\n    var deltaX = offset[0] - size[0] / 2;\n    var deltaY = size[1] / 2 - offset[1];\n    var theta = Math.atan2(deltaY, deltaX);\n    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    var view = map.getView();\n    if (view.getConstraints().rotation !== ol.RotationConstraint.disable && this.lastAngle_ !== undefined) {\n      var angleDelta = theta - this.lastAngle_;\n      ol.interaction.Interaction.rotateWithoutConstraints(\n          view, view.getRotation() - angleDelta);\n    }\n    this.lastAngle_ = theta;\n    if (this.lastMagnitude_ !== undefined) {\n      var resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);\n      ol.interaction.Interaction.zoomWithoutConstraints(view, resolution);\n    }\n    if (this.lastMagnitude_ !== undefined) {\n      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;\n    }\n    this.lastMagnitude_ = magnitude;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.DragRotateAndZoom}\n   * @private\n   */\n  ol.interaction.DragRotateAndZoom.handleUpEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n  \n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    view.setHint(ol.ViewHint.INTERACTING, -1);\n    var direction = this.lastScaleDelta_ - 1;\n    ol.interaction.Interaction.rotate(view, view.getRotation());\n    ol.interaction.Interaction.zoom(view, view.getResolution(),\n        undefined, this.duration_, direction);\n    this.lastScaleDelta_ = 0;\n    return false;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.DragRotateAndZoom}\n   * @private\n   */\n  ol.interaction.DragRotateAndZoom.handleDownEvent_ = function(mapBrowserEvent) {\n    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n  \n    if (this.condition_(mapBrowserEvent)) {\n      mapBrowserEvent.map.getView().setHint(ol.ViewHint.INTERACTING, 1);\n      this.lastAngle_ = undefined;\n      this.lastMagnitude_ = undefined;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  \n  goog.provide('ol.interaction.DrawEventType');\n  \n  \n  /**\n   * @enum {string}\n   */\n  ol.interaction.DrawEventType = {\n    /**\n     * Triggered upon feature draw start\n     * @event ol.interaction.Draw.Event#drawstart\n     * @api\n     */\n    DRAWSTART: 'drawstart',\n    /**\n     * Triggered upon feature draw end\n     * @event ol.interaction.Draw.Event#drawend\n     * @api\n     */\n    DRAWEND: 'drawend'\n  };\n  \n  goog.provide('ol.layer.Vector');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.layer.Layer');\n  goog.require('ol.layer.VectorRenderType');\n  goog.require('ol.obj');\n  goog.require('ol.style.Style');\n  \n  \n  /**\n   * @classdesc\n   * Vector data that is rendered client-side.\n   * Note that any property set in the options is set as a {@link ol.Object}\n   * property on the layer object; for example, setting `title: 'My Title'` in the\n   * options means that `title` is observable, and has get/set accessors.\n   *\n   * @constructor\n   * @extends {ol.layer.Layer}\n   * @fires ol.render.Event\n   * @param {olx.layer.VectorOptions=} opt_options Options.\n   * @api\n   */\n  ol.layer.Vector = function(opt_options) {\n    var options = opt_options ?\n      opt_options : /** @type {olx.layer.VectorOptions} */ ({});\n  \n    var baseOptions = ol.obj.assign({}, options);\n  \n    delete baseOptions.style;\n    delete baseOptions.renderBuffer;\n    delete baseOptions.updateWhileAnimating;\n    delete baseOptions.updateWhileInteracting;\n    ol.layer.Layer.call(this, /** @type {olx.layer.LayerOptions} */ (baseOptions));\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.declutter_ = options.declutter !== undefined ? options.declutter : false;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderBuffer_ = options.renderBuffer !== undefined ?\n      options.renderBuffer : 100;\n  \n    /**\n     * User provided style.\n     * @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}\n     * @private\n     */\n    this.style_ = null;\n  \n    /**\n     * Style function for use within the library.\n     * @type {ol.StyleFunction|undefined}\n     * @private\n     */\n    this.styleFunction_ = undefined;\n  \n    this.setStyle(options.style);\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ?\n      options.updateWhileAnimating : false;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ?\n      options.updateWhileInteracting : false;\n  \n    /**\n     * @private\n     * @type {ol.layer.VectorTileRenderType|string}\n     */\n    this.renderMode_ = options.renderMode || ol.layer.VectorRenderType.VECTOR;\n  \n    /**\n     * The layer type.\n     * @protected\n     * @type {ol.LayerType}\n     */\n    this.type = ol.LayerType.VECTOR;\n  \n  };\n  ol.inherits(ol.layer.Vector, ol.layer.Layer);\n  \n  \n  /**\n   * @return {boolean} Declutter.\n   */\n  ol.layer.Vector.prototype.getDeclutter = function() {\n    return this.declutter_;\n  };\n  \n  \n  /**\n   * @param {boolean} declutter Declutter.\n   */\n  ol.layer.Vector.prototype.setDeclutter = function(declutter) {\n    this.declutter_ = declutter;\n  };\n  \n  \n  /**\n   * @return {number|undefined} Render buffer.\n   */\n  ol.layer.Vector.prototype.getRenderBuffer = function() {\n    return this.renderBuffer_;\n  };\n  \n  \n  /**\n   * @return {function(ol.Feature, ol.Feature): number|null|undefined} Render\n   *     order.\n   */\n  ol.layer.Vector.prototype.getRenderOrder = function() {\n    return /** @type {ol.RenderOrderFunction|null|undefined} */ (\n      this.get(ol.layer.Vector.Property_.RENDER_ORDER));\n  };\n  \n  \n  /**\n   * Return the associated {@link ol.source.Vector vectorsource} of the layer.\n   * @function\n   * @return {ol.source.Vector} Source.\n   * @api\n   */\n  ol.layer.Vector.prototype.getSource;\n  \n  \n  /**\n   * Get the style for features.  This returns whatever was passed to the `style`\n   * option at construction or to the `setStyle` method.\n   * @return {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}\n   *     Layer style.\n   * @api\n   */\n  ol.layer.Vector.prototype.getStyle = function() {\n    return this.style_;\n  };\n  \n  \n  /**\n   * Get the style function.\n   * @return {ol.StyleFunction|undefined} Layer style function.\n   * @api\n   */\n  ol.layer.Vector.prototype.getStyleFunction = function() {\n    return this.styleFunction_;\n  };\n  \n  \n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     animating.\n   */\n  ol.layer.Vector.prototype.getUpdateWhileAnimating = function() {\n    return this.updateWhileAnimating_;\n  };\n  \n  \n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     interacting.\n   */\n  ol.layer.Vector.prototype.getUpdateWhileInteracting = function() {\n    return this.updateWhileInteracting_;\n  };\n  \n  \n  /**\n   * @param {ol.RenderOrderFunction|null|undefined} renderOrder\n   *     Render order.\n   */\n  ol.layer.Vector.prototype.setRenderOrder = function(renderOrder) {\n    this.set(ol.layer.Vector.Property_.RENDER_ORDER, renderOrder);\n  };\n  \n  \n  /**\n   * Set the style for features.  This can be a single style object, an array\n   * of styles, or a function that takes a feature and resolution and returns\n   * an array of styles. If it is `undefined` the default style is used. If\n   * it is `null` the layer has no style (a `null` style), so only features\n   * that have their own styles will be rendered in the layer. See\n   * {@link ol.style} for information on the default style.\n   * @param {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|null|undefined}\n   *     style Layer style.\n   * @api\n   */\n  ol.layer.Vector.prototype.setStyle = function(style) {\n    this.style_ = style !== undefined ? style : ol.style.Style.defaultFunction;\n    this.styleFunction_ = style === null ?\n      undefined : ol.style.Style.createFunction(this.style_);\n    this.changed();\n  };\n  \n  \n  /**\n   * @return {ol.layer.VectorRenderType|string} The render mode.\n   */\n  ol.layer.Vector.prototype.getRenderMode = function() {\n    return this.renderMode_;\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.layer.Vector.Property_ = {\n    RENDER_ORDER: 'renderOrder'\n  };\n  \n  goog.provide('ol.loadingstrategy');\n  \n  \n  /**\n   * Strategy function for loading all features with a single request.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array.<ol.Extent>} Extents.\n   * @api\n   */\n  ol.loadingstrategy.all = function(extent, resolution) {\n    return [[-Infinity, -Infinity, Infinity, Infinity]];\n  };\n  \n  \n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array.<ol.Extent>} Extents.\n   * @api\n   */\n  ol.loadingstrategy.bbox = function(extent, resolution) {\n    return [extent];\n  };\n  \n  \n  /**\n   * Creates a strategy function for loading features based on a tile grid.\n   * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.\n   * @return {function(ol.Extent, number): Array.<ol.Extent>} Loading strategy.\n   * @api\n   */\n  ol.loadingstrategy.tile = function(tileGrid) {\n    return (\n    /**\n         * @param {ol.Extent} extent Extent.\n         * @param {number} resolution Resolution.\n         * @return {Array.<ol.Extent>} Extents.\n         */\n      function(extent, resolution) {\n        var z = tileGrid.getZForResolution(resolution);\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n        /** @type {Array.<ol.Extent>} */\n        var extents = [];\n        /** @type {ol.TileCoord} */\n        var tileCoord = [z, 0, 0];\n        for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX;\n          ++tileCoord[1]) {\n          for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY;\n            ++tileCoord[2]) {\n            extents.push(tileGrid.getTileCoordExtent(tileCoord));\n          }\n        }\n        return extents;\n      });\n  };\n  \n  goog.provide('ol.source.Source');\n  \n  goog.require('ol');\n  goog.require('ol.Attribution');\n  goog.require('ol.Object');\n  goog.require('ol.proj');\n  goog.require('ol.source.State');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Base class for {@link ol.layer.Layer} sources.\n   *\n   * A generic `change` event is triggered when the state of the source changes.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.Object}\n   * @param {ol.SourceSourceOptions} options Source options.\n   * @api\n   */\n  ol.source.Source = function(options) {\n  \n    ol.Object.call(this);\n  \n    /**\n     * @private\n     * @type {ol.proj.Projection}\n     */\n    this.projection_ = ol.proj.get(options.projection);\n  \n    /**\n     * @private\n     * @type {Array.<ol.Attribution>}\n     */\n    this.attributions_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.Attribution2}\n     */\n    this.attributions2_ = this.adaptAttributions_(options.attributions);\n  \n    /**\n     * @private\n     * @type {string|olx.LogoOptions|undefined}\n     */\n    this.logo_ = options.logo;\n  \n    /**\n     * @private\n     * @type {ol.source.State}\n     */\n    this.state_ = options.state !== undefined ?\n      options.state : ol.source.State.READY;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n  \n  };\n  ol.inherits(ol.source.Source, ol.Object);\n  \n  /**\n   * Turns the attributions option into an attributions function.\n   * @suppress {deprecated}\n   * @param {ol.AttributionLike|undefined} attributionLike The attribution option.\n   * @return {?ol.Attribution2} An attribution function (or null).\n   */\n  ol.source.Source.prototype.adaptAttributions_ = function(attributionLike) {\n    if (!attributionLike) {\n      return null;\n    }\n    if (attributionLike instanceof ol.Attribution) {\n  \n      // TODO: remove attributions_ in next major release\n      this.attributions_ = [attributionLike];\n  \n      return function(frameState) {\n        return [attributionLike.getHTML()];\n      };\n    }\n    if (Array.isArray(attributionLike)) {\n      if (attributionLike[0] instanceof ol.Attribution) {\n  \n        // TODO: remove attributions_ in next major release\n        this.attributions_ = attributionLike;\n  \n        var attributions = attributionLike.map(function(attribution) {\n          return attribution.getHTML();\n        });\n        return function(frameState) {\n          return attributions;\n        };\n      }\n  \n      // TODO: remove attributions_ in next major release\n      this.attributions_ = attributionLike.map(function(attribution) {\n        return new ol.Attribution({html: attribution});\n      });\n  \n      return function(frameState) {\n        return attributionLike;\n      };\n    }\n  \n    if (typeof attributionLike === 'function') {\n      return attributionLike;\n    }\n  \n    // TODO: remove attributions_ in next major release\n    this.attributions_ = [\n      new ol.Attribution({html: attributionLike})\n    ];\n  \n    return function(frameState) {\n      return [attributionLike];\n    };\n  };\n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.\n   * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature\n   *     callback.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.source.Source.prototype.forEachFeatureAtCoordinate = ol.nullFunction;\n  \n  \n  /**\n   * Get the attributions of the source.\n   * @return {Array.<ol.Attribution>} Attributions.\n   * @api\n   */\n  ol.source.Source.prototype.getAttributions = function() {\n    return this.attributions_;\n  };\n  \n  \n  /**\n   * Get the attribution function for the source.\n   * @return {?ol.Attribution2} Attribution function.\n   */\n  ol.source.Source.prototype.getAttributions2 = function() {\n    return this.attributions2_;\n  };\n  \n  \n  /**\n   * Get the logo of the source.\n   * @return {string|olx.LogoOptions|undefined} Logo.\n   * @api\n   */\n  ol.source.Source.prototype.getLogo = function() {\n    return this.logo_;\n  };\n  \n  \n  /**\n   * Get the projection of the source.\n   * @return {ol.proj.Projection} Projection.\n   * @api\n   */\n  ol.source.Source.prototype.getProjection = function() {\n    return this.projection_;\n  };\n  \n  \n  /**\n   * @abstract\n   * @return {Array.<number>|undefined} Resolutions.\n   */\n  ol.source.Source.prototype.getResolutions = function() {};\n  \n  \n  /**\n   * Get the state of the source, see {@link ol.source.State} for possible states.\n   * @return {ol.source.State} State.\n   * @api\n   */\n  ol.source.Source.prototype.getState = function() {\n    return this.state_;\n  };\n  \n  \n  /**\n   * @return {boolean|undefined} Wrap X.\n   */\n  ol.source.Source.prototype.getWrapX = function() {\n    return this.wrapX_;\n  };\n  \n  \n  /**\n   * Refreshes the source and finally dispatches a 'change' event.\n   * @api\n   */\n  ol.source.Source.prototype.refresh = function() {\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the attributions of the source.\n   * @param {ol.AttributionLike|undefined} attributions Attributions.\n   *     Can be passed as `string`, `Array<string>`, `{@link ol.Attribution2}`,\n   *     or `undefined`.\n   * @api\n   */\n  ol.source.Source.prototype.setAttributions = function(attributions) {\n    this.attributions2_ = this.adaptAttributions_(attributions);\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the logo of the source.\n   * @param {string|olx.LogoOptions|undefined} logo Logo.\n   */\n  ol.source.Source.prototype.setLogo = function(logo) {\n    this.logo_ = logo;\n  };\n  \n  \n  /**\n   * Set the state of the source.\n   * @param {ol.source.State} state State.\n   * @protected\n   */\n  ol.source.Source.prototype.setState = function(state) {\n    this.state_ = state;\n    this.changed();\n  };\n  \n  goog.provide('ol.source.VectorEventType');\n  \n  /**\n   * @enum {string}\n   */\n  ol.source.VectorEventType = {\n    /**\n     * Triggered when a feature is added to the source.\n     * @event ol.source.Vector.Event#addfeature\n     * @api\n     */\n    ADDFEATURE: 'addfeature',\n  \n    /**\n     * Triggered when a feature is updated.\n     * @event ol.source.Vector.Event#changefeature\n     * @api\n     */\n    CHANGEFEATURE: 'changefeature',\n  \n    /**\n     * Triggered when the clear method is called on the source.\n     * @event ol.source.Vector.Event#clear\n     * @api\n     */\n    CLEAR: 'clear',\n  \n    /**\n     * Triggered when a feature is removed from the source.\n     * See {@link ol.source.Vector#clear source.clear()} for exceptions.\n     * @event ol.source.Vector.Event#removefeature\n     * @api\n     */\n    REMOVEFEATURE: 'removefeature'\n  };\n  \n  goog.provide('ol.structs.RBush');\n  \n  goog.require('ol');\n  goog.require('ol.ext.rbush');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * Wrapper around the RBush by Vladimir Agafonkin.\n   *\n   * @constructor\n   * @param {number=} opt_maxEntries Max entries.\n   * @see https://github.com/mourner/rbush\n   * @struct\n   * @template T\n   */\n  ol.structs.RBush = function(opt_maxEntries) {\n  \n    /**\n     * @private\n     */\n    this.rbush_ = ol.ext.rbush(opt_maxEntries);\n  \n    /**\n     * A mapping between the objects added to this rbush wrapper\n     * and the objects that are actually added to the internal rbush.\n     * @private\n     * @type {Object.<number, ol.RBushEntry>}\n     */\n    this.items_ = {};\n  \n  };\n  \n  \n  /**\n   * Insert a value into the RBush.\n   * @param {ol.Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  ol.structs.RBush.prototype.insert = function(extent, value) {\n    /** @type {ol.RBushEntry} */\n    var item = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n      value: value\n    };\n  \n    this.rbush_.insert(item);\n    this.items_[ol.getUid(value)] = item;\n  };\n  \n  \n  /**\n   * Bulk-insert values into the RBush.\n   * @param {Array.<ol.Extent>} extents Extents.\n   * @param {Array.<T>} values Values.\n   */\n  ol.structs.RBush.prototype.load = function(extents, values) {\n    var items = new Array(values.length);\n    for (var i = 0, l = values.length; i < l; i++) {\n      var extent = extents[i];\n      var value = values[i];\n  \n      /** @type {ol.RBushEntry} */\n      var item = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3],\n        value: value\n      };\n      items[i] = item;\n      this.items_[ol.getUid(value)] = item;\n    }\n    this.rbush_.load(items);\n  };\n  \n  \n  /**\n   * Remove a value from the RBush.\n   * @param {T} value Value.\n   * @return {boolean} Removed.\n   */\n  ol.structs.RBush.prototype.remove = function(value) {\n    var uid = ol.getUid(value);\n  \n    // get the object in which the value was wrapped when adding to the\n    // internal rbush. then use that object to do the removal.\n    var item = this.items_[uid];\n    delete this.items_[uid];\n    return this.rbush_.remove(item) !== null;\n  };\n  \n  \n  /**\n   * Update the extent of a value in the RBush.\n   * @param {ol.Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  ol.structs.RBush.prototype.update = function(extent, value) {\n    var item = this.items_[ol.getUid(value)];\n    var bbox = [item.minX, item.minY, item.maxX, item.maxY];\n    if (!ol.extent.equals(bbox, extent)) {\n      this.remove(value);\n      this.insert(extent, value);\n    }\n  };\n  \n  \n  /**\n   * Return all values in the RBush.\n   * @return {Array.<T>} All.\n   */\n  ol.structs.RBush.prototype.getAll = function() {\n    var items = this.rbush_.all();\n    return items.map(function(item) {\n      return item.value;\n    });\n  };\n  \n  \n  /**\n   * Return all values in the given extent.\n   * @param {ol.Extent} extent Extent.\n   * @return {Array.<T>} All in extent.\n   */\n  ol.structs.RBush.prototype.getInExtent = function(extent) {\n    /** @type {ol.RBushEntry} */\n    var bbox = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3]\n    };\n    var items = this.rbush_.search(bbox);\n    return items.map(function(item) {\n      return item.value;\n    });\n  };\n  \n  \n  /**\n   * Calls a callback function with each value in the tree.\n   * If the callback returns a truthy value, this value is returned without\n   * checking the rest of the tree.\n   * @param {function(this: S, T): *} callback Callback.\n   * @param {S=} opt_this The object to use as `this` in `callback`.\n   * @return {*} Callback return value.\n   * @template S\n   */\n  ol.structs.RBush.prototype.forEach = function(callback, opt_this) {\n    return this.forEach_(this.getAll(), callback, opt_this);\n  };\n  \n  \n  /**\n   * Calls a callback function with each value in the provided extent.\n   * @param {ol.Extent} extent Extent.\n   * @param {function(this: S, T): *} callback Callback.\n   * @param {S=} opt_this The object to use as `this` in `callback`.\n   * @return {*} Callback return value.\n   * @template S\n   */\n  ol.structs.RBush.prototype.forEachInExtent = function(extent, callback, opt_this) {\n    return this.forEach_(this.getInExtent(extent), callback, opt_this);\n  };\n  \n  \n  /**\n   * @param {Array.<T>} values Values.\n   * @param {function(this: S, T): *} callback Callback.\n   * @param {S=} opt_this The object to use as `this` in `callback`.\n   * @private\n   * @return {*} Callback return value.\n   * @template S\n   */\n  ol.structs.RBush.prototype.forEach_ = function(values, callback, opt_this) {\n    var result;\n    for (var i = 0, l = values.length; i < l; i++) {\n      result = callback.call(opt_this, values[i]);\n      if (result) {\n        return result;\n      }\n    }\n    return result;\n  };\n  \n  \n  /**\n   * @return {boolean} Is empty.\n   */\n  ol.structs.RBush.prototype.isEmpty = function() {\n    return ol.obj.isEmpty(this.items_);\n  };\n  \n  \n  /**\n   * Remove all values from the RBush.\n   */\n  ol.structs.RBush.prototype.clear = function() {\n    this.rbush_.clear();\n    this.items_ = {};\n  };\n  \n  \n  /**\n   * @param {ol.Extent=} opt_extent Extent.\n   * @return {ol.Extent} Extent.\n   */\n  ol.structs.RBush.prototype.getExtent = function(opt_extent) {\n    // FIXME add getExtent() to rbush\n    var data = this.rbush_.data;\n    return ol.extent.createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);\n  };\n  \n  \n  /**\n   * @param {ol.structs.RBush} rbush R-Tree.\n   */\n  ol.structs.RBush.prototype.concat = function(rbush) {\n    this.rbush_.load(rbush.rbush_.all());\n    for (var i in rbush.items_) {\n      this.items_[i | 0] = rbush.items_[i | 0];\n    }\n  };\n  \n  // FIXME bulk feature upload - suppress events\n  // FIXME make change-detection more refined (notably, geometry hint)\n  \n  goog.provide('ol.source.Vector');\n  \n  goog.require('ol');\n  goog.require('ol.Collection');\n  goog.require('ol.CollectionEventType');\n  goog.require('ol.ObjectEventType');\n  goog.require('ol.array');\n  goog.require('ol.asserts');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.featureloader');\n  goog.require('ol.functions');\n  goog.require('ol.loadingstrategy');\n  goog.require('ol.obj');\n  goog.require('ol.source.Source');\n  goog.require('ol.source.State');\n  goog.require('ol.source.VectorEventType');\n  goog.require('ol.structs.RBush');\n  \n  \n  /**\n   * @classdesc\n   * Provides a source of features for vector layers. Vector features provided\n   * by this source are suitable for editing. See {@link ol.source.VectorTile} for\n   * vector data that is optimized for rendering.\n   *\n   * @constructor\n   * @extends {ol.source.Source}\n   * @fires ol.source.Vector.Event\n   * @param {olx.source.VectorOptions=} opt_options Vector source options.\n   * @api\n   */\n  ol.source.Vector = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    ol.source.Source.call(this, {\n      attributions: options.attributions,\n      logo: options.logo,\n      projection: undefined,\n      state: ol.source.State.READY,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true\n    });\n  \n    /**\n     * @private\n     * @type {ol.FeatureLoader}\n     */\n    this.loader_ = ol.nullFunction;\n  \n    /**\n     * @private\n     * @type {ol.format.Feature|undefined}\n     */\n    this.format_ = options.format;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n  \n    /**\n     * @private\n     * @type {string|ol.FeatureUrlFunction|undefined}\n     */\n    this.url_ = options.url;\n  \n    if (options.loader !== undefined) {\n      this.loader_ = options.loader;\n    } else if (this.url_ !== undefined) {\n      ol.asserts.assert(this.format_, 7); // `format` must be set when `url` is set\n      // create a XHR feature loader for \"url\" and \"format\"\n      this.loader_ = ol.featureloader.xhr(this.url_, /** @type {ol.format.Feature} */ (this.format_));\n    }\n  \n    /**\n     * @private\n     * @type {ol.LoadingStrategy}\n     */\n    this.strategy_ = options.strategy !== undefined ? options.strategy :\n      ol.loadingstrategy.all;\n  \n    var useSpatialIndex =\n        options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n  \n    /**\n     * @private\n     * @type {ol.structs.RBush.<ol.Feature>}\n     */\n    this.featuresRtree_ = useSpatialIndex ? new ol.structs.RBush() : null;\n  \n    /**\n     * @private\n     * @type {ol.structs.RBush.<{extent: ol.Extent}>}\n     */\n    this.loadedExtentsRtree_ = new ol.structs.RBush();\n  \n    /**\n     * @private\n     * @type {Object.<string, ol.Feature>}\n     */\n    this.nullGeometryFeatures_ = {};\n  \n    /**\n     * A lookup of features by id (the return from feature.getId()).\n     * @private\n     * @type {Object.<string, ol.Feature>}\n     */\n    this.idIndex_ = {};\n  \n    /**\n     * A lookup of features without id (keyed by ol.getUid(feature)).\n     * @private\n     * @type {Object.<string, ol.Feature>}\n     */\n    this.undefIdIndex_ = {};\n  \n    /**\n     * @private\n     * @type {Object.<string, Array.<ol.EventsKey>>}\n     */\n    this.featureChangeKeys_ = {};\n  \n    /**\n     * @private\n     * @type {ol.Collection.<ol.Feature>}\n     */\n    this.featuresCollection_ = null;\n  \n    var collection, features;\n    if (options.features instanceof ol.Collection) {\n      collection = options.features;\n      features = collection.getArray();\n    } else if (Array.isArray(options.features)) {\n      features = options.features;\n    }\n    if (!useSpatialIndex && collection === undefined) {\n      collection = new ol.Collection(features);\n    }\n    if (features !== undefined) {\n      this.addFeaturesInternal(features);\n    }\n    if (collection !== undefined) {\n      this.bindFeaturesCollection_(collection);\n    }\n  \n  };\n  ol.inherits(ol.source.Vector, ol.source.Source);\n  \n  \n  /**\n   * Add a single feature to the source.  If you want to add a batch of features\n   * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}\n   * instead. A feature will not be added to the source if feature with\n   * the same id is already there. The reason for this behavior is to avoid\n   * feature duplication when using bbox or tile loading strategies.\n   * @param {ol.Feature} feature Feature to add.\n   * @api\n   */\n  ol.source.Vector.prototype.addFeature = function(feature) {\n    this.addFeatureInternal(feature);\n    this.changed();\n  };\n  \n  \n  /**\n   * Add a feature without firing a `change` event.\n   * @param {ol.Feature} feature Feature.\n   * @protected\n   */\n  ol.source.Vector.prototype.addFeatureInternal = function(feature) {\n    var featureKey = ol.getUid(feature).toString();\n  \n    if (!this.addToIndex_(featureKey, feature)) {\n      return;\n    }\n  \n    this.setupChangeEvents_(featureKey, feature);\n  \n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var extent = geometry.getExtent();\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent, feature);\n      }\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n  \n    this.dispatchEvent(\n        new ol.source.Vector.Event(ol.source.VectorEventType.ADDFEATURE, feature));\n  };\n  \n  \n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {ol.Feature} feature The feature.\n   * @private\n   */\n  ol.source.Vector.prototype.setupChangeEvents_ = function(featureKey, feature) {\n    this.featureChangeKeys_[featureKey] = [\n      ol.events.listen(feature, ol.events.EventType.CHANGE,\n          this.handleFeatureChange_, this),\n      ol.events.listen(feature, ol.ObjectEventType.PROPERTYCHANGE,\n          this.handleFeatureChange_, this)\n    ];\n  };\n  \n  \n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {ol.Feature} feature The feature.\n   * @return {boolean} The feature is \"valid\", in the sense that it is also a\n   *     candidate for insertion into the Rtree.\n   * @private\n   */\n  ol.source.Vector.prototype.addToIndex_ = function(featureKey, feature) {\n    var valid = true;\n    var id = feature.getId();\n    if (id !== undefined) {\n      if (!(id.toString() in this.idIndex_)) {\n        this.idIndex_[id.toString()] = feature;\n      } else {\n        valid = false;\n      }\n    } else {\n      ol.asserts.assert(!(featureKey in this.undefIdIndex_),\n          30); // The passed `feature` was already added to the source\n      this.undefIdIndex_[featureKey] = feature;\n    }\n    return valid;\n  };\n  \n  \n  /**\n   * Add a batch of features to the source.\n   * @param {Array.<ol.Feature>} features Features to add.\n   * @api\n   */\n  ol.source.Vector.prototype.addFeatures = function(features) {\n    this.addFeaturesInternal(features);\n    this.changed();\n  };\n  \n  \n  /**\n   * Add features without firing a `change` event.\n   * @param {Array.<ol.Feature>} features Features.\n   * @protected\n   */\n  ol.source.Vector.prototype.addFeaturesInternal = function(features) {\n    var featureKey, i, length, feature;\n  \n    var extents = [];\n    var newFeatures = [];\n    var geometryFeatures = [];\n  \n    for (i = 0, length = features.length; i < length; i++) {\n      feature = features[i];\n      featureKey = ol.getUid(feature).toString();\n      if (this.addToIndex_(featureKey, feature)) {\n        newFeatures.push(feature);\n      }\n    }\n  \n    for (i = 0, length = newFeatures.length; i < length; i++) {\n      feature = newFeatures[i];\n      featureKey = ol.getUid(feature).toString();\n      this.setupChangeEvents_(featureKey, feature);\n  \n      var geometry = feature.getGeometry();\n      if (geometry) {\n        var extent = geometry.getExtent();\n        extents.push(extent);\n        geometryFeatures.push(feature);\n      } else {\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.load(extents, geometryFeatures);\n    }\n  \n    for (i = 0, length = newFeatures.length; i < length; i++) {\n      this.dispatchEvent(new ol.source.Vector.Event(\n          ol.source.VectorEventType.ADDFEATURE, newFeatures[i]));\n    }\n  };\n  \n  \n  /**\n   * @param {!ol.Collection.<ol.Feature>} collection Collection.\n   * @private\n   */\n  ol.source.Vector.prototype.bindFeaturesCollection_ = function(collection) {\n    var modifyingCollection = false;\n    ol.events.listen(this, ol.source.VectorEventType.ADDFEATURE,\n        function(evt) {\n          if (!modifyingCollection) {\n            modifyingCollection = true;\n            collection.push(evt.feature);\n            modifyingCollection = false;\n          }\n        });\n    ol.events.listen(this, ol.source.VectorEventType.REMOVEFEATURE,\n        function(evt) {\n          if (!modifyingCollection) {\n            modifyingCollection = true;\n            collection.remove(evt.feature);\n            modifyingCollection = false;\n          }\n        });\n    ol.events.listen(collection, ol.CollectionEventType.ADD,\n        function(evt) {\n          if (!modifyingCollection) {\n            modifyingCollection = true;\n            this.addFeature(/** @type {ol.Feature} */ (evt.element));\n            modifyingCollection = false;\n          }\n        }, this);\n    ol.events.listen(collection, ol.CollectionEventType.REMOVE,\n        function(evt) {\n          if (!modifyingCollection) {\n            modifyingCollection = true;\n            this.removeFeature(/** @type {ol.Feature} */ (evt.element));\n            modifyingCollection = false;\n          }\n        }, this);\n    this.featuresCollection_ = collection;\n  };\n  \n  \n  /**\n   * Remove all features from the source.\n   * @param {boolean=} opt_fast Skip dispatching of {@link removefeature} events.\n   * @api\n   */\n  ol.source.Vector.prototype.clear = function(opt_fast) {\n    if (opt_fast) {\n      for (var featureId in this.featureChangeKeys_) {\n        var keys = this.featureChangeKeys_[featureId];\n        keys.forEach(ol.events.unlistenByKey);\n      }\n      if (!this.featuresCollection_) {\n        this.featureChangeKeys_ = {};\n        this.idIndex_ = {};\n        this.undefIdIndex_ = {};\n      }\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.forEach(this.removeFeatureInternal, this);\n        for (var id in this.nullGeometryFeatures_) {\n          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n        }\n      }\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.clear();\n    }\n  \n    if (this.featuresRtree_) {\n      this.featuresRtree_.clear();\n    }\n    this.loadedExtentsRtree_.clear();\n    this.nullGeometryFeatures_ = {};\n  \n    var clearEvent = new ol.source.Vector.Event(ol.source.VectorEventType.CLEAR);\n    this.dispatchEvent(clearEvent);\n    this.changed();\n  };\n  \n  \n  /**\n   * Iterate through all features on the source, calling the provided callback\n   * with each one.  If the callback returns any \"truthy\" value, iteration will\n   * stop and the function will return the same value.\n   *\n   * @param {function(this: T, ol.Feature): S} callback Called with each feature\n   *     on the source.  Return a truthy value to stop iteration.\n   * @param {T=} opt_this The object to use as `this` in the callback.\n   * @return {S|undefined} The return value from the last call to the callback.\n   * @template T,S\n   * @api\n   */\n  ol.source.Vector.prototype.forEachFeature = function(callback, opt_this) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEach(callback, opt_this);\n    } else if (this.featuresCollection_) {\n      return this.featuresCollection_.forEach(callback, opt_this);\n    }\n  };\n  \n  \n  /**\n   * Iterate through all features whose geometries contain the provided\n   * coordinate, calling the callback with each feature.  If the callback returns\n   * a \"truthy\" value, iteration will stop and the function will return the same\n   * value.\n   *\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {function(this: T, ol.Feature): S} callback Called with each feature\n   *     whose goemetry contains the provided coordinate.\n   * @param {T=} opt_this The object to use as `this` in the callback.\n   * @return {S|undefined} The return value from the last call to the callback.\n   * @template T,S\n   */\n  ol.source.Vector.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback, opt_this) {\n    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n    return this.forEachFeatureInExtent(extent, function(feature) {\n      var geometry = feature.getGeometry();\n      if (geometry.intersectsCoordinate(coordinate)) {\n        return callback.call(opt_this, feature);\n      } else {\n        return undefined;\n      }\n    });\n  };\n  \n  \n  /**\n   * Iterate through all features whose bounding box intersects the provided\n   * extent (note that the feature's geometry may not intersect the extent),\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you are interested in features whose geometry intersects an extent, call\n   * the {@link ol.source.Vector#forEachFeatureIntersectingExtent\n   * source.forEachFeatureIntersectingExtent()} method instead.\n   *\n   * When `useSpatialIndex` is set to false, this method will loop through all\n   * features, equivalent to {@link ol.source.Vector#forEachFeature}.\n   *\n   * @param {ol.Extent} extent Extent.\n   * @param {function(this: T, ol.Feature): S} callback Called with each feature\n   *     whose bounding box intersects the provided extent.\n   * @param {T=} opt_this The object to use as `this` in the callback.\n   * @return {S|undefined} The return value from the last call to the callback.\n   * @template T,S\n   * @api\n   */\n  ol.source.Vector.prototype.forEachFeatureInExtent = function(extent, callback, opt_this) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEachInExtent(extent, callback, opt_this);\n    } else if (this.featuresCollection_) {\n      return this.featuresCollection_.forEach(callback, opt_this);\n    }\n  };\n  \n  \n  /**\n   * Iterate through all features whose geometry intersects the provided extent,\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you only want to test for bounding box intersection, call the\n   * {@link ol.source.Vector#forEachFeatureInExtent\n   * source.forEachFeatureInExtent()} method instead.\n   *\n   * @param {ol.Extent} extent Extent.\n   * @param {function(this: T, ol.Feature): S} callback Called with each feature\n   *     whose geometry intersects the provided extent.\n   * @param {T=} opt_this The object to use as `this` in the callback.\n   * @return {S|undefined} The return value from the last call to the callback.\n   * @template T,S\n   * @api\n   */\n  ol.source.Vector.prototype.forEachFeatureIntersectingExtent = function(extent, callback, opt_this) {\n    return this.forEachFeatureInExtent(extent,\n        /**\n         * @param {ol.Feature} feature Feature.\n         * @return {S|undefined} The return value from the last call to the callback.\n         * @template S\n         */\n        function(feature) {\n          var geometry = feature.getGeometry();\n          if (geometry.intersectsExtent(extent)) {\n            var result = callback.call(opt_this, feature);\n            if (result) {\n              return result;\n            }\n          }\n        });\n  };\n  \n  \n  /**\n   * Get the features collection associated with this source. Will be `null`\n   * unless the source was configured with `useSpatialIndex` set to `false`, or\n   * with an {@link ol.Collection} as `features`.\n   * @return {ol.Collection.<ol.Feature>} The collection of features.\n   * @api\n   */\n  ol.source.Vector.prototype.getFeaturesCollection = function() {\n    return this.featuresCollection_;\n  };\n  \n  \n  /**\n   * Get all features on the source in random order.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.source.Vector.prototype.getFeatures = function() {\n    var features;\n    if (this.featuresCollection_) {\n      features = this.featuresCollection_.getArray();\n    } else if (this.featuresRtree_) {\n      features = this.featuresRtree_.getAll();\n      if (!ol.obj.isEmpty(this.nullGeometryFeatures_)) {\n        ol.array.extend(\n            features, ol.obj.getValues(this.nullGeometryFeatures_));\n      }\n    }\n    return /** @type {Array.<ol.Feature>} */ (features);\n  };\n  \n  \n  /**\n   * Get all features whose geometry intersects the provided coordinate.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.source.Vector.prototype.getFeaturesAtCoordinate = function(coordinate) {\n    var features = [];\n    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {\n      features.push(feature);\n    });\n    return features;\n  };\n  \n  \n  /**\n   * Get all features in the provided extent.  Note that this returns an array of\n   * all features intersecting the given extent in random order (so it may include\n   * features whose geometries do not intersect the extent).\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {ol.Extent} extent Extent.\n   * @return {Array.<ol.Feature>} Features.\n   * @api\n   */\n  ol.source.Vector.prototype.getFeaturesInExtent = function(extent) {\n    return this.featuresRtree_.getInExtent(extent);\n  };\n  \n  \n  /**\n   * Get the closest feature to the provided coordinate.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {function(ol.Feature):boolean=} opt_filter Feature filter function.\n   *     The filter function will receive one argument, the {@link ol.Feature feature}\n   *     and it should return a boolean value. By default, no filtering is made.\n   * @return {ol.Feature} Closest feature.\n   * @api\n   */\n  ol.source.Vector.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {\n    // Find the closest feature using branch and bound.  We start searching an\n    // infinite extent, and find the distance from the first feature found.  This\n    // becomes the closest feature.  We then compute a smaller extent which any\n    // closer feature must intersect.  We continue searching with this smaller\n    // extent, trying to find a closer feature.  Every time we find a closer\n    // feature, we update the extent being searched so that any even closer\n    // feature must intersect it.  We continue until we run out of features.\n    var x = coordinate[0];\n    var y = coordinate[1];\n    var closestFeature = null;\n    var closestPoint = [NaN, NaN];\n    var minSquaredDistance = Infinity;\n    var extent = [-Infinity, -Infinity, Infinity, Infinity];\n    var filter = opt_filter ? opt_filter : ol.functions.TRUE;\n    this.featuresRtree_.forEachInExtent(extent,\n        /**\n         * @param {ol.Feature} feature Feature.\n         */\n        function(feature) {\n          if (filter(feature)) {\n            var geometry = feature.getGeometry();\n            var previousMinSquaredDistance = minSquaredDistance;\n            minSquaredDistance = geometry.closestPointXY(\n                x, y, closestPoint, minSquaredDistance);\n            if (minSquaredDistance < previousMinSquaredDistance) {\n              closestFeature = feature;\n              // This is sneaky.  Reduce the extent that it is currently being\n              // searched while the R-Tree traversal using this same extent object\n              // is still in progress.  This is safe because the new extent is\n              // strictly contained by the old extent.\n              var minDistance = Math.sqrt(minSquaredDistance);\n              extent[0] = x - minDistance;\n              extent[1] = y - minDistance;\n              extent[2] = x + minDistance;\n              extent[3] = y + minDistance;\n            }\n          }\n        });\n    return closestFeature;\n  };\n  \n  \n  /**\n   * Get the extent of the features currently in the source.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {ol.Extent=} opt_extent Destination extent. If provided, no new extent\n   *     will be created. Instead, that extent's coordinates will be overwritten.\n   * @return {ol.Extent} Extent.\n   * @api\n   */\n  ol.source.Vector.prototype.getExtent = function(opt_extent) {\n    return this.featuresRtree_.getExtent(opt_extent);\n  };\n  \n  \n  /**\n   * Get a feature by its identifier (the value returned by feature.getId()).\n   * Note that the index treats string and numeric identifiers as the same.  So\n   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\n   *\n   * @param {string|number} id Feature identifier.\n   * @return {ol.Feature} The feature (or `null` if not found).\n   * @api\n   */\n  ol.source.Vector.prototype.getFeatureById = function(id) {\n    var feature = this.idIndex_[id.toString()];\n    return feature !== undefined ? feature : null;\n  };\n  \n  \n  /**\n   * Get the format associated with this source.\n   *\n   * @return {ol.format.Feature|undefined} The feature format.\n   * @api\n   */\n  ol.source.Vector.prototype.getFormat = function() {\n    return this.format_;\n  };\n  \n  \n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  ol.source.Vector.prototype.getOverlaps = function() {\n    return this.overlaps_;\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.source.Vector.prototype.getResolutions = function() {};\n  \n  \n  /**\n   * Get the url associated with this source.\n   *\n   * @return {string|ol.FeatureUrlFunction|undefined} The url.\n   * @api\n   */\n  ol.source.Vector.prototype.getUrl = function() {\n    return this.url_;\n  };\n  \n  \n  /**\n   * @param {ol.events.Event} event Event.\n   * @private\n   */\n  ol.source.Vector.prototype.handleFeatureChange_ = function(event) {\n    var feature = /** @type {ol.Feature} */ (event.target);\n    var featureKey = ol.getUid(feature).toString();\n    var geometry = feature.getGeometry();\n    if (!geometry) {\n      if (!(featureKey in this.nullGeometryFeatures_)) {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.remove(feature);\n        }\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    } else {\n      var extent = geometry.getExtent();\n      if (featureKey in this.nullGeometryFeatures_) {\n        delete this.nullGeometryFeatures_[featureKey];\n        if (this.featuresRtree_) {\n          this.featuresRtree_.insert(extent, feature);\n        }\n      } else {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.update(extent, feature);\n        }\n      }\n    }\n    var id = feature.getId();\n    if (id !== undefined) {\n      var sid = id.toString();\n      if (featureKey in this.undefIdIndex_) {\n        delete this.undefIdIndex_[featureKey];\n        this.idIndex_[sid] = feature;\n      } else {\n        if (this.idIndex_[sid] !== feature) {\n          this.removeFromIdIndex_(feature);\n          this.idIndex_[sid] = feature;\n        }\n      }\n    } else {\n      if (!(featureKey in this.undefIdIndex_)) {\n        this.removeFromIdIndex_(feature);\n        this.undefIdIndex_[featureKey] = feature;\n      }\n    }\n    this.changed();\n    this.dispatchEvent(new ol.source.Vector.Event(\n        ol.source.VectorEventType.CHANGEFEATURE, feature));\n  };\n  \n  \n  /**\n   * @return {boolean} Is empty.\n   */\n  ol.source.Vector.prototype.isEmpty = function() {\n    return this.featuresRtree_.isEmpty() &&\n        ol.obj.isEmpty(this.nullGeometryFeatures_);\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {ol.proj.Projection} projection Projection.\n   */\n  ol.source.Vector.prototype.loadFeatures = function(\n      extent, resolution, projection) {\n    var loadedExtentsRtree = this.loadedExtentsRtree_;\n    var extentsToLoad = this.strategy_(extent, resolution);\n    var i, ii;\n    for (i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n      var extentToLoad = extentsToLoad[i];\n      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,\n          /**\n           * @param {{extent: ol.Extent}} object Object.\n           * @return {boolean} Contains.\n           */\n          function(object) {\n            return ol.extent.containsExtent(object.extent, extentToLoad);\n          });\n      if (!alreadyLoaded) {\n        this.loader_.call(this, extentToLoad, resolution, projection);\n        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});\n      }\n    }\n  };\n  \n  \n  /**\n   * Remove an extent from the list of loaded extents.\n   * @param {ol.Extent} extent Extent.\n   * @api\n   */\n  ol.source.Vector.prototype.removeLoadedExtent = function(extent) {\n    var loadedExtentsRtree = this.loadedExtentsRtree_;\n    var obj;\n    loadedExtentsRtree.forEachInExtent(extent, function(object) {\n      if (ol.extent.equals(object.extent, extent)) {\n        obj = object;\n        return true;\n      }\n    });\n    if (obj) {\n      loadedExtentsRtree.remove(obj);\n    }\n  };\n  \n  \n  /**\n   * Remove a single feature from the source.  If you want to remove all features\n   * at once, use the {@link ol.source.Vector#clear source.clear()} method\n   * instead.\n   * @param {ol.Feature} feature Feature to remove.\n   * @api\n   */\n  ol.source.Vector.prototype.removeFeature = function(feature) {\n    var featureKey = ol.getUid(feature).toString();\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature);\n      }\n    }\n    this.removeFeatureInternal(feature);\n    this.changed();\n  };\n  \n  \n  /**\n   * Remove feature without firing a `change` event.\n   * @param {ol.Feature} feature Feature.\n   * @protected\n   */\n  ol.source.Vector.prototype.removeFeatureInternal = function(feature) {\n    var featureKey = ol.getUid(feature).toString();\n    this.featureChangeKeys_[featureKey].forEach(ol.events.unlistenByKey);\n    delete this.featureChangeKeys_[featureKey];\n    var id = feature.getId();\n    if (id !== undefined) {\n      delete this.idIndex_[id.toString()];\n    } else {\n      delete this.undefIdIndex_[featureKey];\n    }\n    this.dispatchEvent(new ol.source.Vector.Event(\n        ol.source.VectorEventType.REMOVEFEATURE, feature));\n  };\n  \n  \n  /**\n   * Remove a feature from the id index.  Called internally when the feature id\n   * may have changed.\n   * @param {ol.Feature} feature The feature.\n   * @return {boolean} Removed the feature from the index.\n   * @private\n   */\n  ol.source.Vector.prototype.removeFromIdIndex_ = function(feature) {\n    var removed = false;\n    for (var id in this.idIndex_) {\n      if (this.idIndex_[id] === feature) {\n        delete this.idIndex_[id];\n        removed = true;\n        break;\n      }\n    }\n    return removed;\n  };\n  \n  \n  /**\n   * Set the new loader of the source. The next loadFeatures call will use the\n   * new loader.\n   * @param {ol.FeatureLoader} loader The loader to set.\n   * @api\n   */\n  ol.source.Vector.prototype.setLoader = function(loader) {\n    this.loader_ = loader;\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.source.Vector} instances are instances of this\n   * type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.source.Vector.Event}\n   * @param {string} type Type.\n   * @param {ol.Feature=} opt_feature Feature.\n   */\n  ol.source.Vector.Event = function(type, opt_feature) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The feature being added or removed.\n     * @type {ol.Feature|undefined}\n     * @api\n     */\n    this.feature = opt_feature;\n  \n  };\n  ol.inherits(ol.source.Vector.Event, ol.events.Event);\n  \n  goog.provide('ol.interaction.Draw');\n  \n  goog.require('ol');\n  goog.require('ol.Feature');\n  goog.require('ol.MapBrowserEventType');\n  goog.require('ol.Object');\n  goog.require('ol.coordinate');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.condition');\n  goog.require('ol.extent');\n  goog.require('ol.functions');\n  goog.require('ol.geom.Circle');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.interaction.DrawEventType');\n  goog.require('ol.interaction.Pointer');\n  goog.require('ol.interaction.Property');\n  goog.require('ol.layer.Vector');\n  goog.require('ol.source.Vector');\n  goog.require('ol.style.Style');\n  \n  \n  /**\n   * @classdesc\n   * Interaction for drawing feature geometries.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @fires ol.interaction.Draw.Event\n   * @param {olx.interaction.DrawOptions} options Options.\n   * @api\n   */\n  ol.interaction.Draw = function(options) {\n  \n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.Draw.handleDownEvent_,\n      handleEvent: ol.interaction.Draw.handleEvent,\n      handleUpEvent: ol.interaction.Draw.handleUpEvent_\n    });\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n  \n    /**\n     * @type {ol.Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n  \n    /**\n     * Target source for drawn features.\n     * @type {ol.source.Vector}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n  \n    /**\n     * Target collection for drawn features.\n     * @type {ol.Collection.<ol.Feature>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n  \n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n  \n    /**\n     * Geometry type.\n     * @type {ol.geom.GeometryType}\n     * @private\n     */\n    this.type_ = /** @type {ol.geom.GeometryType} */ (options.type);\n  \n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {ol.interaction.Draw.Mode_}\n     * @private\n     */\n    this.mode_ = ol.interaction.Draw.getMode_(this.type_);\n  \n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n  \n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints ?\n      options.minPoints :\n      (this.mode_ === ol.interaction.Draw.Mode_.POLYGON ? 3 : 2);\n  \n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;\n  \n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.finishCondition_ = options.finishCondition ? options.finishCondition : ol.functions.TRUE;\n  \n    var geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      if (this.type_ === ol.geom.GeometryType.CIRCLE) {\n        /**\n         * @param {!Array.<ol.Coordinate>} coordinates\n         *     The coordinates.\n         * @param {ol.geom.SimpleGeometry=} opt_geometry Optional geometry.\n         * @return {ol.geom.SimpleGeometry} A geometry.\n         */\n        geometryFunction = function(coordinates, opt_geometry) {\n          var circle = opt_geometry ? /** @type {ol.geom.Circle} */ (opt_geometry) :\n            new ol.geom.Circle([NaN, NaN]);\n          var squaredLength = ol.coordinate.squaredDistance(\n              coordinates[0], coordinates[1]);\n          circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));\n          return circle;\n        };\n      } else {\n        var Constructor;\n        var mode = this.mode_;\n        if (mode === ol.interaction.Draw.Mode_.POINT) {\n          Constructor = ol.geom.Point;\n        } else if (mode === ol.interaction.Draw.Mode_.LINE_STRING) {\n          Constructor = ol.geom.LineString;\n        } else if (mode === ol.interaction.Draw.Mode_.POLYGON) {\n          Constructor = ol.geom.Polygon;\n        }\n        /**\n         * @param {!Array.<ol.Coordinate>} coordinates\n         *     The coordinates.\n         * @param {ol.geom.SimpleGeometry=} opt_geometry Optional geometry.\n         * @return {ol.geom.SimpleGeometry} A geometry.\n         */\n        geometryFunction = function(coordinates, opt_geometry) {\n          var geometry = opt_geometry;\n          if (geometry) {\n            if (mode === ol.interaction.Draw.Mode_.POLYGON) {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\n              } else {\n                geometry.setCoordinates([]);\n              }\n            } else {\n              geometry.setCoordinates(coordinates);\n            }\n          } else {\n            geometry = new Constructor(coordinates);\n          }\n          return geometry;\n        };\n      }\n    }\n  \n    /**\n     * @type {ol.DrawGeometryFunctionType}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n  \n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {ol.Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n  \n    /**\n     * Sketch feature.\n     * @type {ol.Feature}\n     * @private\n     */\n    this.sketchFeature_ = null;\n  \n    /**\n     * Sketch point.\n     * @type {ol.Feature}\n     * @private\n     */\n    this.sketchPoint_ = null;\n  \n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>}\n     * @private\n     */\n    this.sketchCoords_ = null;\n  \n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {ol.Feature}\n     * @private\n     */\n    this.sketchLine_ = null;\n  \n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {Array.<ol.Coordinate>}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n  \n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance ?\n      options.clickTolerance * options.clickTolerance : 36;\n  \n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {ol.layer.Vector}\n     * @private\n     */\n    this.overlay_ = new ol.layer.Vector({\n      source: new ol.source.Vector({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false\n      }),\n      style: options.style ? options.style :\n        ol.interaction.Draw.getDefaultStyleFunction()\n    });\n  \n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition ?\n      options.condition : ol.events.condition.noModifierKeys;\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = ol.events.condition.always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition ?\n        options.freehandCondition : ol.events.condition.shiftKeyOnly;\n    }\n  \n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.interaction.Property.ACTIVE),\n        this.updateState_, this);\n  \n  };\n  ol.inherits(ol.interaction.Draw, ol.interaction.Pointer);\n  \n  \n  /**\n   * @return {ol.StyleFunction} Styles.\n   */\n  ol.interaction.Draw.getDefaultStyleFunction = function() {\n    var styles = ol.style.Style.createDefaultEditing();\n    return function(feature, resolution) {\n      return styles[feature.getGeometry().getType()];\n    };\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.Draw.prototype.setMap = function(map) {\n    ol.interaction.Pointer.prototype.setMap.call(this, map);\n    this.updateState_();\n  };\n  \n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} and may actually\n   * draw or finish the drawing.\n   * @param {ol.MapBrowserEvent} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {ol.interaction.Draw}\n   * @api\n   */\n  ol.interaction.Draw.handleEvent = function(event) {\n    this.freehand_ = this.mode_ !== ol.interaction.Draw.Mode_.POINT && this.freehandCondition_(event);\n    var pass = true;\n    if (this.freehand_ &&\n        event.type === ol.MapBrowserEventType.POINTERDRAG &&\n        this.sketchFeature_ !== null) {\n      this.addToDrawing_(event);\n      pass = false;\n    } else if (this.freehand_ &&\n        event.type === ol.MapBrowserEventType.POINTERDOWN) {\n      pass = false;\n    } else if (event.type === ol.MapBrowserEventType.POINTERMOVE) {\n      pass = this.handlePointerMove_(event);\n    } else if (event.type === ol.MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n    return ol.interaction.Pointer.handleEvent.call(this, event) && pass;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} event Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.Draw}\n   * @private\n   */\n  ol.interaction.Draw.handleDownEvent_ = function(event) {\n    this.shouldHandle_ = !this.freehand_;\n  \n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event);\n      }\n      return true;\n    } else if (this.condition_(event)) {\n      this.downPx_ = event.pixel;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} event Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.Draw}\n   * @private\n   */\n  ol.interaction.Draw.handleUpEvent_ = function(event) {\n    var pass = true;\n  \n    this.handlePointerMove_(event);\n  \n    var circleMode = this.mode_ === ol.interaction.Draw.Mode_.CIRCLE;\n  \n    if (this.shouldHandle_) {\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event);\n        if (this.mode_ === ol.interaction.Draw.Mode_.POINT) {\n          this.finishDrawing();\n        }\n      } else if (this.freehand_ || circleMode) {\n        this.finishDrawing();\n      } else if (this.atFinish_(event)) {\n        if (this.finishCondition_(event)) {\n          this.finishDrawing();\n        }\n      } else {\n        this.addToDrawing_(event);\n      }\n      pass = false;\n    } else if (this.freehand_) {\n      this.finishCoordinate_ = null;\n      this.abortDrawing_();\n    }\n    if (!pass && this.stopClick_) {\n      event.stopPropagation();\n    }\n    return pass;\n  };\n  \n  \n  /**\n   * Handle move events.\n   * @param {ol.MapBrowserEvent} event A move event.\n   * @return {boolean} Pass the event to other interactions.\n   * @private\n   */\n  ol.interaction.Draw.prototype.handlePointerMove_ = function(event) {\n    if (this.downPx_ &&\n        ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))) {\n      var downPx = this.downPx_;\n      var clickPx = event.pixel;\n      var dx = downPx[0] - clickPx[0];\n      var dy = downPx[1] - clickPx[1];\n      var squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_ ?\n        squaredDistance > this.squaredClickTolerance_ :\n        squaredDistance <= this.squaredClickTolerance_;\n    }\n  \n    if (this.finishCoordinate_) {\n      this.modifyDrawing_(event);\n    } else {\n      this.createOrUpdateSketchPoint_(event);\n    }\n    return true;\n  };\n  \n  \n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {ol.MapBrowserEvent} event Event.\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  ol.interaction.Draw.prototype.atFinish_ = function(event) {\n    var at = false;\n    if (this.sketchFeature_) {\n      var potentiallyDone = false;\n      var potentiallyFinishCoordinates = [this.finishCoordinate_];\n      if (this.mode_ === ol.interaction.Draw.Mode_.LINE_STRING) {\n        potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n      } else if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {\n        potentiallyDone = this.sketchCoords_[0].length >\n            this.minPoints_;\n        potentiallyFinishCoordinates = [this.sketchCoords_[0][0],\n          this.sketchCoords_[0][this.sketchCoords_[0].length - 2]];\n      }\n      if (potentiallyDone) {\n        var map = event.map;\n        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          var finishCoordinate = potentiallyFinishCoordinates[i];\n          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          var pixel = event.pixel;\n          var dx = pixel[0] - finishPixel[0];\n          var dy = pixel[1] - finishPixel[1];\n          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserEvent} event Event.\n   * @private\n   */\n  ol.interaction.Draw.prototype.createOrUpdateSketchPoint_ = function(event) {\n    var coordinates = event.coordinate.slice();\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new ol.Feature(new ol.geom.Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      var sketchPointGeom = /** @type {ol.geom.Point} */ (this.sketchPoint_.getGeometry());\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  };\n  \n  \n  /**\n   * Start the drawing.\n   * @param {ol.MapBrowserEvent} event Event.\n   * @private\n   */\n  ol.interaction.Draw.prototype.startDrawing_ = function(event) {\n    var start = event.coordinate;\n    this.finishCoordinate_ = start;\n    if (this.mode_ === ol.interaction.Draw.Mode_.POINT) {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n      if (this.mode_ === ol.interaction.Draw.Mode_.CIRCLE) {\n        this.sketchLineCoords_ = this.sketchCoords_;\n      }\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new ol.Feature(\n          new ol.geom.LineString(this.sketchLineCoords_));\n    }\n    var geometry = this.geometryFunction_(this.sketchCoords_);\n    this.sketchFeature_ = new ol.Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new ol.interaction.Draw.Event(\n        ol.interaction.DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  \n  \n  /**\n   * Modify the drawing.\n   * @param {ol.MapBrowserEvent} event Event.\n   * @private\n   */\n  ol.interaction.Draw.prototype.modifyDrawing_ = function(event) {\n    var coordinate = event.coordinate;\n    var geometry = /** @type {ol.geom.SimpleGeometry} */ (this.sketchFeature_.getGeometry());\n    var coordinates, last;\n    if (this.mode_ === ol.interaction.Draw.Mode_.POINT) {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {\n      coordinates = this.sketchCoords_[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(event)) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(/** @type {!Array.<ol.Coordinate>} */ (this.sketchCoords_), geometry);\n    if (this.sketchPoint_) {\n      var sketchPointGeom = /** @type {ol.geom.Point} */ (this.sketchPoint_.getGeometry());\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    var sketchLineGeom;\n    if (geometry instanceof ol.geom.Polygon &&\n        this.mode_ !== ol.interaction.Draw.Mode_.POLYGON) {\n      if (!this.sketchLine_) {\n        this.sketchLine_ = new ol.Feature(new ol.geom.LineString(null));\n      }\n      var ring = geometry.getLinearRing(0);\n      sketchLineGeom = /** @type {ol.geom.LineString} */ (this.sketchLine_.getGeometry());\n      sketchLineGeom.setFlatCoordinates(\n          ring.getLayout(), ring.getFlatCoordinates());\n    } else if (this.sketchLineCoords_) {\n      sketchLineGeom = /** @type {ol.geom.LineString} */ (this.sketchLine_.getGeometry());\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  };\n  \n  \n  /**\n   * Add a new coordinate to the drawing.\n   * @param {ol.MapBrowserEvent} event Event.\n   * @private\n   */\n  ol.interaction.Draw.prototype.addToDrawing_ = function(event) {\n    var coordinate = event.coordinate;\n    var geometry = /** @type {ol.geom.SimpleGeometry} */ (this.sketchFeature_.getGeometry());\n    var done;\n    var coordinates;\n    if (this.mode_ === ol.interaction.Draw.Mode_.LINE_STRING) {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = this.sketchCoords_;\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry);\n    } else if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {\n      coordinates = this.sketchCoords_[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry);\n    }\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  };\n  \n  \n  /**\n   * Remove last point of the feature currently being drawn.\n   * @api\n   */\n  ol.interaction.Draw.prototype.removeLastPoint = function() {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    var geometry = /** @type {ol.geom.SimpleGeometry} */ (this.sketchFeature_.getGeometry());\n    var coordinates, sketchLineGeom;\n    if (this.mode_ === ol.interaction.Draw.Mode_.LINE_STRING) {\n      coordinates = this.sketchCoords_;\n      coordinates.splice(-2, 1);\n      this.geometryFunction_(coordinates, geometry);\n      if (coordinates.length >= 2) {\n        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n      }\n    } else if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {\n      coordinates = this.sketchCoords_[0];\n      coordinates.splice(-2, 1);\n      sketchLineGeom = /** @type {ol.geom.LineString} */ (this.sketchLine_.getGeometry());\n      sketchLineGeom.setCoordinates(coordinates);\n      this.geometryFunction_(this.sketchCoords_, geometry);\n    }\n  \n    if (coordinates.length === 0) {\n      this.finishCoordinate_ = null;\n    }\n  \n    this.updateSketchFeatures_();\n  };\n  \n  \n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link ol.interaction.DrawEventType.DRAWEND} event is dispatched before\n   * inserting the feature.\n   * @api\n   */\n  ol.interaction.Draw.prototype.finishDrawing = function() {\n    var sketchFeature = this.abortDrawing_();\n    var coordinates = this.sketchCoords_;\n    var geometry = /** @type {ol.geom.SimpleGeometry} */ (sketchFeature.getGeometry());\n    if (this.mode_ === ol.interaction.Draw.Mode_.LINE_STRING) {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry);\n    } else if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {\n      // remove the redundant last point in ring\n      coordinates[0].pop();\n      this.geometryFunction_(coordinates, geometry);\n      coordinates = geometry.getCoordinates();\n    }\n  \n    // cast multi-part geometries\n    if (this.type_ === ol.geom.GeometryType.MULTI_POINT) {\n      sketchFeature.setGeometry(new ol.geom.MultiPoint([coordinates]));\n    } else if (this.type_ === ol.geom.GeometryType.MULTI_LINE_STRING) {\n      sketchFeature.setGeometry(new ol.geom.MultiLineString([coordinates]));\n    } else if (this.type_ === ol.geom.GeometryType.MULTI_POLYGON) {\n      sketchFeature.setGeometry(new ol.geom.MultiPolygon([coordinates]));\n    }\n  \n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new ol.interaction.Draw.Event(\n        ol.interaction.DrawEventType.DRAWEND, sketchFeature));\n  \n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  };\n  \n  \n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {ol.Feature} The sketch feature (or null if none).\n   * @private\n   */\n  ol.interaction.Draw.prototype.abortDrawing_ = function() {\n    this.finishCoordinate_ = null;\n    var sketchFeature = this.sketchFeature_;\n    if (sketchFeature) {\n      this.sketchFeature_ = null;\n      this.sketchPoint_ = null;\n      this.sketchLine_ = null;\n      this.overlay_.getSource().clear(true);\n    }\n    return sketchFeature;\n  };\n  \n  \n  /**\n   * Extend an existing geometry by adding additional points. This only works\n   * on features with `LineString` geometries, where the interaction will\n   * extend lines by adding points to the end of the coordinates array.\n   * @param {!ol.Feature} feature Feature to be extended.\n   * @api\n   */\n  ol.interaction.Draw.prototype.extend = function(feature) {\n    var geometry = feature.getGeometry();\n    var lineString = /** @type {ol.geom.LineString} */ (geometry);\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new ol.interaction.Draw.Event(\n        ol.interaction.DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.Draw.prototype.shouldStopEvent = ol.functions.FALSE;\n  \n  \n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  ol.interaction.Draw.prototype.updateSketchFeatures_ = function() {\n    var sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    var overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.interaction.Draw.prototype.updateState_ = function() {\n    var map = this.getMap();\n    var active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing_();\n    }\n    this.overlay_.setMap(active ? map : null);\n  };\n  \n  \n  /**\n   * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n   * polygon with a user specified number of sides and start angle instead of an\n   * `ol.geom.Circle` geometry.\n   * @param {number=} opt_sides Number of sides of the regular polygon. Default is\n   *     32.\n   * @param {number=} opt_angle Angle of the first point in radians. 0 means East.\n   *     Default is the angle defined by the heading from the center of the\n   *     regular polygon to the current pointer position.\n   * @return {ol.DrawGeometryFunctionType} Function that draws a\n   *     polygon.\n   * @api\n   */\n  ol.interaction.Draw.createRegularPolygon = function(opt_sides, opt_angle) {\n    return (\n    /**\n         * @param {ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>} coordinates\n         * @param {ol.geom.SimpleGeometry=} opt_geometry\n         * @return {ol.geom.SimpleGeometry}\n         */\n      function(coordinates, opt_geometry) {\n        var center = coordinates[0];\n        var end = coordinates[1];\n        var radius = Math.sqrt(\n            ol.coordinate.squaredDistance(center, end));\n        var geometry = opt_geometry ? /** @type {ol.geom.Polygon} */ (opt_geometry) :\n          ol.geom.Polygon.fromCircle(new ol.geom.Circle(center), opt_sides);\n        var angle = opt_angle ? opt_angle :\n          Math.atan((end[1] - center[1]) / (end[0] - center[0]));\n        ol.geom.Polygon.makeRegular(geometry, center, radius, angle);\n        return geometry;\n      }\n    );\n  };\n  \n  \n  /**\n   * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n   * with the coordinate system axes).  Use this with the draw interaction and\n   * `type: 'Circle'` to return a box instead of a circle geometry.\n   * @return {ol.DrawGeometryFunctionType} Function that draws a box-shaped polygon.\n   * @api\n   */\n  ol.interaction.Draw.createBox = function() {\n    return (\n      /**\n       * @param {Array.<ol.Coordinate>} coordinates\n       * @param {ol.geom.SimpleGeometry=} opt_geometry\n       * @return {ol.geom.SimpleGeometry}\n       */\n      function(coordinates, opt_geometry) {\n        var extent = ol.extent.boundingExtent(coordinates);\n        var geometry = opt_geometry || new ol.geom.Polygon(null);\n        geometry.setCoordinates([[\n          ol.extent.getBottomLeft(extent),\n          ol.extent.getBottomRight(extent),\n          ol.extent.getTopRight(extent),\n          ol.extent.getTopLeft(extent),\n          ol.extent.getBottomLeft(extent)\n        ]]);\n        return geometry;\n      }\n    );\n  };\n  \n  \n  /**\n   * Get the drawing mode.  The mode for mult-part geometries is the same as for\n   * their single-part cousins.\n   * @param {ol.geom.GeometryType} type Geometry type.\n   * @return {ol.interaction.Draw.Mode_} Drawing mode.\n   * @private\n   */\n  ol.interaction.Draw.getMode_ = function(type) {\n    var mode;\n    if (type === ol.geom.GeometryType.POINT ||\n        type === ol.geom.GeometryType.MULTI_POINT) {\n      mode = ol.interaction.Draw.Mode_.POINT;\n    } else if (type === ol.geom.GeometryType.LINE_STRING ||\n        type === ol.geom.GeometryType.MULTI_LINE_STRING) {\n      mode = ol.interaction.Draw.Mode_.LINE_STRING;\n    } else if (type === ol.geom.GeometryType.POLYGON ||\n        type === ol.geom.GeometryType.MULTI_POLYGON) {\n      mode = ol.interaction.Draw.Mode_.POLYGON;\n    } else if (type === ol.geom.GeometryType.CIRCLE) {\n      mode = ol.interaction.Draw.Mode_.CIRCLE;\n    }\n    return /** @type {!ol.interaction.Draw.Mode_} */ (mode);\n  };\n  \n  \n  /**\n   * Draw mode.  This collapses multi-part geometry types with their single-part\n   * cousins.\n   * @enum {string}\n   * @private\n   */\n  ol.interaction.Draw.Mode_ = {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    POLYGON: 'Polygon',\n    CIRCLE: 'Circle'\n  };\n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.interaction.Draw} instances are instances of\n   * this type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.DrawEvent}\n   * @param {ol.interaction.DrawEventType} type Type.\n   * @param {ol.Feature} feature The feature drawn.\n   */\n  ol.interaction.Draw.Event = function(type, feature) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The feature being drawn.\n     * @type {ol.Feature}\n     * @api\n     */\n    this.feature = feature;\n  \n  };\n  ol.inherits(ol.interaction.Draw.Event, ol.events.Event);\n  \n  goog.provide('ol.interaction.ExtentEventType');\n  \n  \n  /**\n   * @enum {string}\n   */\n  ol.interaction.ExtentEventType = {\n    /**\n     * Triggered after the extent is changed\n     * @event ol.interaction.Extent.Event#extentchanged\n     * @api\n     */\n    EXTENTCHANGED: 'extentchanged'\n  };\n  \n  goog.provide('ol.interaction.Extent');\n  \n  goog.require('ol');\n  goog.require('ol.Feature');\n  goog.require('ol.MapBrowserEventType');\n  goog.require('ol.MapBrowserPointerEvent');\n  goog.require('ol.coordinate');\n  goog.require('ol.events.Event');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.interaction.ExtentEventType');\n  goog.require('ol.interaction.Pointer');\n  goog.require('ol.layer.Vector');\n  goog.require('ol.source.Vector');\n  goog.require('ol.style.Style');\n  \n  \n  /**\n   * @classdesc\n   * Allows the user to draw a vector box by clicking and dragging on the map.\n   * Once drawn, the vector box can be modified by dragging its vertices or edges.\n   * This interaction is only supported for mouse devices.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @fires ol.interaction.Extent.Event\n   * @param {olx.interaction.ExtentOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.Extent = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    /**\n     * Extent of the drawn box\n     * @type {ol.Extent}\n     * @private\n     */\n    this.extent_ = null;\n  \n    /**\n     * Handler for pointer move events\n     * @type {function (ol.Coordinate): ol.Extent|null}\n     * @private\n     */\n    this.pointerHandler_ = null;\n  \n    /**\n     * Pixel threshold to snap to extent\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n      options.pixelTolerance : 10;\n  \n    /**\n     * Is the pointer snapped to an extent vertex\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n  \n    /**\n     * Feature for displaying the visible extent\n     * @type {ol.Feature}\n     * @private\n     */\n    this.extentFeature_ = null;\n  \n    /**\n     * Feature for displaying the visible pointer\n     * @type {ol.Feature}\n     * @private\n     */\n    this.vertexFeature_ = null;\n  \n    if (!opt_options) {\n      opt_options = {};\n    }\n  \n    /* Inherit ol.interaction.Pointer */\n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.Extent.handleDownEvent_,\n      handleDragEvent: ol.interaction.Extent.handleDragEvent_,\n      handleEvent: ol.interaction.Extent.handleEvent_,\n      handleUpEvent: ol.interaction.Extent.handleUpEvent_\n    });\n  \n    /**\n     * Layer for the extentFeature\n     * @type {ol.layer.Vector}\n     * @private\n     */\n    this.extentOverlay_ = new ol.layer.Vector({\n      source: new ol.source.Vector({\n        useSpatialIndex: false,\n        wrapX: !!opt_options.wrapX\n      }),\n      style: opt_options.boxStyle ? opt_options.boxStyle : ol.interaction.Extent.getDefaultExtentStyleFunction_(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true\n    });\n  \n    /**\n     * Layer for the vertexFeature\n     * @type {ol.layer.Vector}\n     * @private\n     */\n    this.vertexOverlay_ = new ol.layer.Vector({\n      source: new ol.source.Vector({\n        useSpatialIndex: false,\n        wrapX: !!opt_options.wrapX\n      }),\n      style: opt_options.pointerStyle ? opt_options.pointerStyle : ol.interaction.Extent.getDefaultPointerStyleFunction_(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true\n    });\n  \n    if (opt_options.extent) {\n      this.setExtent(opt_options.extent);\n    }\n  };\n  \n  ol.inherits(ol.interaction.Extent, ol.interaction.Pointer);\n  \n  /**\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Event.\n   * @return {boolean} Propagate event?\n   * @this {ol.interaction.Extent}\n   * @private\n   */\n  ol.interaction.Extent.handleEvent_ = function(mapBrowserEvent) {\n    if (!(mapBrowserEvent instanceof ol.MapBrowserPointerEvent)) {\n      return true;\n    }\n    //display pointer (if not dragging)\n    if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    //call pointer to determine up/down/drag\n    ol.interaction.Pointer.handleEvent.call(this, mapBrowserEvent);\n    //return false to stop propagation\n    return false;\n  };\n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Event handled?\n   * @this {ol.interaction.Extent}\n   * @private\n   */\n  ol.interaction.Extent.handleDownEvent_ = function(mapBrowserEvent) {\n    var pixel = mapBrowserEvent.pixel;\n    var map = mapBrowserEvent.map;\n  \n    var extent = this.getExtent();\n    var vertex = this.snapToVertex_(pixel, map);\n  \n    //find the extent corner opposite the passed corner\n    var getOpposingPoint = function(point) {\n      var x_ = null;\n      var y_ = null;\n      if (point[0] == extent[0]) {\n        x_ = extent[2];\n      } else if (point[0] == extent[2]) {\n        x_ = extent[0];\n      }\n      if (point[1] == extent[1]) {\n        y_ = extent[3];\n      } else if (point[1] == extent[3]) {\n        y_ = extent[1];\n      }\n      if (x_ !== null && y_ !== null) {\n        return [x_, y_];\n      }\n      return null;\n    };\n    if (vertex && extent) {\n      var x = (vertex[0] == extent[0] || vertex[0] == extent[2]) ? vertex[0] : null;\n      var y = (vertex[1] == extent[1] || vertex[1] == extent[3]) ? vertex[1] : null;\n  \n      //snap to point\n      if (x !== null && y !== null) {\n        this.pointerHandler_ = ol.interaction.Extent.getPointHandler_(getOpposingPoint(vertex));\n      //snap to edge\n      } else if (x !== null) {\n        this.pointerHandler_ = ol.interaction.Extent.getEdgeHandler_(\n            getOpposingPoint([x, extent[1]]),\n            getOpposingPoint([x, extent[3]])\n        );\n      } else if (y !== null) {\n        this.pointerHandler_ = ol.interaction.Extent.getEdgeHandler_(\n            getOpposingPoint([extent[0], y]),\n            getOpposingPoint([extent[2], y])\n        );\n      }\n    //no snap - new bbox\n    } else {\n      vertex = map.getCoordinateFromPixel(pixel);\n      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\n      this.pointerHandler_ = ol.interaction.Extent.getPointHandler_(vertex);\n    }\n    return true; //event handled; start downup sequence\n  };\n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Event handled?\n   * @this {ol.interaction.Extent}\n   * @private\n   */\n  ol.interaction.Extent.handleDragEvent_ = function(mapBrowserEvent) {\n    if (this.pointerHandler_) {\n      var pixelCoordinate = mapBrowserEvent.coordinate;\n      this.setExtent(this.pointerHandler_(pixelCoordinate));\n      this.createOrUpdatePointerFeature_(pixelCoordinate);\n    }\n    return true;\n  };\n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.Extent}\n   * @private\n   */\n  ol.interaction.Extent.handleUpEvent_ = function(mapBrowserEvent) {\n    this.pointerHandler_ = null;\n    //If bbox is zero area, set to null;\n    var extent = this.getExtent();\n    if (!extent || ol.extent.getArea(extent) === 0) {\n      this.setExtent(null);\n    }\n    return false; //Stop handling downup sequence\n  };\n  \n  /**\n   * Returns the default style for the drawn bbox\n   *\n   * @return {ol.StyleFunction} Default Extent style\n   * @private\n   */\n  ol.interaction.Extent.getDefaultExtentStyleFunction_ = function() {\n    var style = ol.style.Style.createDefaultEditing();\n    return function(feature, resolution) {\n      return style[ol.geom.GeometryType.POLYGON];\n    };\n  };\n  \n  /**\n   * Returns the default style for the pointer\n   *\n   * @return {ol.StyleFunction} Default pointer style\n   * @private\n   */\n  ol.interaction.Extent.getDefaultPointerStyleFunction_ = function() {\n    var style = ol.style.Style.createDefaultEditing();\n    return function(feature, resolution) {\n      return style[ol.geom.GeometryType.POINT];\n    };\n  };\n  \n  /**\n   * @param {ol.Coordinate} fixedPoint corner that will be unchanged in the new extent\n   * @returns {function (ol.Coordinate): ol.Extent} event handler\n   * @private\n   */\n  ol.interaction.Extent.getPointHandler_ = function(fixedPoint) {\n    return function(point) {\n      return ol.extent.boundingExtent([fixedPoint, point]);\n    };\n  };\n  \n  /**\n   * @param {ol.Coordinate} fixedP1 first corner that will be unchanged in the new extent\n   * @param {ol.Coordinate} fixedP2 second corner that will be unchanged in the new extent\n   * @returns {function (ol.Coordinate): ol.Extent|null} event handler\n   * @private\n   */\n  ol.interaction.Extent.getEdgeHandler_ = function(fixedP1, fixedP2) {\n    if (fixedP1[0] == fixedP2[0]) {\n      return function(point) {\n        return ol.extent.boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\n      };\n    } else if (fixedP1[1] == fixedP2[1]) {\n      return function(point) {\n        return ol.extent.boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\n      };\n    } else {\n      return null;\n    }\n  };\n  \n  /**\n   * @param {ol.Extent} extent extent\n   * @returns {Array<Array<ol.Coordinate>>} extent line segments\n   * @private\n   */\n  ol.interaction.Extent.getSegments_ = function(extent) {\n    return [\n      [[extent[0], extent[1]], [extent[0], extent[3]]],\n      [[extent[0], extent[3]], [extent[2], extent[3]]],\n      [[extent[2], extent[3]], [extent[2], extent[1]]],\n      [[extent[2], extent[1]], [extent[0], extent[1]]]\n    ];\n  };\n  \n  /**\n   * @param {ol.Pixel} pixel cursor location\n   * @param {ol.PluggableMap} map map\n   * @returns {ol.Coordinate|null} snapped vertex on extent\n   * @private\n   */\n  ol.interaction.Extent.prototype.snapToVertex_ = function(pixel, map) {\n    var pixelCoordinate = map.getCoordinateFromPixel(pixel);\n    var sortByDistance = function(a, b) {\n      return ol.coordinate.squaredDistanceToSegment(pixelCoordinate, a) -\n          ol.coordinate.squaredDistanceToSegment(pixelCoordinate, b);\n    };\n    var extent = this.getExtent();\n    if (extent) {\n      //convert extents to line segments and find the segment closest to pixelCoordinate\n      var segments = ol.interaction.Extent.getSegments_(extent);\n      segments.sort(sortByDistance);\n      var closestSegment = segments[0];\n  \n      var vertex = (ol.coordinate.closestOnSegment(pixelCoordinate,\n          closestSegment));\n      var vertexPixel = map.getPixelFromCoordinate(vertex);\n  \n      //if the distance is within tolerance, snap to the segment\n      if (ol.coordinate.distance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        //test if we should further snap to a vertex\n        var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        var squaredDist1 = ol.coordinate.squaredDistance(vertexPixel, pixel1);\n        var squaredDist2 = ol.coordinate.squaredDistance(vertexPixel, pixel2);\n        var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\n        if (this.snappedToVertex_) {\n          vertex = squaredDist1 > squaredDist2 ?\n            closestSegment[1] : closestSegment[0];\n        }\n        return vertex;\n      }\n    }\n    return null;\n  };\n  \n  /**\n   * @param {ol.MapBrowserEvent} mapBrowserEvent pointer move event\n   * @private\n   */\n  ol.interaction.Extent.prototype.handlePointerMove_ = function(mapBrowserEvent) {\n    var pixel = mapBrowserEvent.pixel;\n    var map = mapBrowserEvent.map;\n  \n    var vertex = this.snapToVertex_(pixel, map);\n    if (!vertex) {\n      vertex = map.getCoordinateFromPixel(pixel);\n    }\n    this.createOrUpdatePointerFeature_(vertex);\n  };\n  \n  /**\n   * @param {ol.Extent} extent extent\n   * @returns {ol.Feature} extent as featrue\n   * @private\n   */\n  ol.interaction.Extent.prototype.createOrUpdateExtentFeature_ = function(extent) {\n    var extentFeature = this.extentFeature_;\n  \n    if (!extentFeature) {\n      if (!extent) {\n        extentFeature = new ol.Feature({});\n      } else {\n        extentFeature = new ol.Feature(ol.geom.Polygon.fromExtent(extent));\n      }\n      this.extentFeature_ = extentFeature;\n      this.extentOverlay_.getSource().addFeature(extentFeature);\n    } else {\n      if (!extent) {\n        extentFeature.setGeometry(undefined);\n      } else {\n        extentFeature.setGeometry(ol.geom.Polygon.fromExtent(extent));\n      }\n    }\n    return extentFeature;\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} vertex location of feature\n   * @returns {ol.Feature} vertex as feature\n   * @private\n   */\n  ol.interaction.Extent.prototype.createOrUpdatePointerFeature_ = function(vertex) {\n    var vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new ol.Feature(new ol.geom.Point(vertex));\n      this.vertexFeature_ = vertexFeature;\n      this.vertexOverlay_.getSource().addFeature(vertexFeature);\n    } else {\n      var geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n      geometry.setCoordinates(vertex);\n    }\n    return vertexFeature;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.Extent.prototype.setMap = function(map) {\n    this.extentOverlay_.setMap(map);\n    this.vertexOverlay_.setMap(map);\n    ol.interaction.Pointer.prototype.setMap.call(this, map);\n  };\n  \n  /**\n   * Returns the current drawn extent in the view projection\n   *\n   * @return {ol.Extent} Drawn extent in the view projection.\n   * @api\n   */\n  ol.interaction.Extent.prototype.getExtent = function() {\n    return this.extent_;\n  };\n  \n  /**\n   * Manually sets the drawn extent, using the view projection.\n   *\n   * @param {ol.Extent} extent Extent\n   * @api\n   */\n  ol.interaction.Extent.prototype.setExtent = function(extent) {\n    //Null extent means no bbox\n    this.extent_ = extent ? extent : null;\n    this.createOrUpdateExtentFeature_(extent);\n    this.dispatchEvent(new ol.interaction.Extent.Event(this.extent_));\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.interaction.Extent} instances are instances of\n   * this type.\n   *\n   * @constructor\n   * @implements {oli.ExtentEvent}\n   * @param {ol.Extent} extent the new extent\n   * @extends {ol.events.Event}\n   */\n  ol.interaction.Extent.Event = function(extent) {\n    ol.events.Event.call(this, ol.interaction.ExtentEventType.EXTENTCHANGED);\n  \n    /**\n     * The current extent.\n     * @type {ol.Extent}\n     * @api\n     */\n    this.extent = extent;\n  \n  };\n  ol.inherits(ol.interaction.Extent.Event, ol.events.Event);\n  \n  goog.provide('ol.interaction.ModifyEventType');\n  \n  \n  /**\n   * @enum {string}\n   */\n  ol.interaction.ModifyEventType = {\n    /**\n     * Triggered upon feature modification start\n     * @event ol.interaction.Modify.Event#modifystart\n     * @api\n     */\n    MODIFYSTART: 'modifystart',\n    /**\n     * Triggered upon feature modification end\n     * @event ol.interaction.Modify.Event#modifyend\n     * @api\n     */\n    MODIFYEND: 'modifyend'\n  };\n  \n  goog.provide('ol.interaction.Modify');\n  \n  goog.require('ol');\n  goog.require('ol.Collection');\n  goog.require('ol.CollectionEventType');\n  goog.require('ol.Feature');\n  goog.require('ol.MapBrowserEventType');\n  goog.require('ol.MapBrowserPointerEvent');\n  goog.require('ol.array');\n  goog.require('ol.coordinate');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.EventType');\n  goog.require('ol.events.condition');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.Point');\n  goog.require('ol.interaction.ModifyEventType');\n  goog.require('ol.interaction.Pointer');\n  goog.require('ol.layer.Vector');\n  goog.require('ol.source.Vector');\n  goog.require('ol.source.VectorEventType');\n  goog.require('ol.structs.RBush');\n  goog.require('ol.style.Style');\n  \n  /**\n   * @classdesc\n   * Interaction for modifying feature geometries.  To modify features that have\n   * been added to an existing source, construct the modify interaction with the\n   * `source` option.  If you want to modify features in a collection (for example,\n   * the collection used by a select interaction), construct the interaction with\n   * the `features` option.  The interaction must be constructed with either a\n   * `source` or `features` option.\n   *\n   * By default, the interaction will allow deletion of vertices when the `alt`\n   * key is pressed.  To configure the interaction with a different condition\n   * for deletion, use the `deleteCondition` option.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @param {olx.interaction.ModifyOptions} options Options.\n   * @fires ol.interaction.Modify.Event\n   * @api\n   */\n  ol.interaction.Modify = function(options) {\n  \n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.Modify.handleDownEvent_,\n      handleDragEvent: ol.interaction.Modify.handleDragEvent_,\n      handleEvent: ol.interaction.Modify.handleEvent,\n      handleUpEvent: ol.interaction.Modify.handleUpEvent_\n    });\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition ?\n      options.condition : ol.events.condition.primaryAction;\n  \n  \n    /**\n     * @private\n     * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultDeleteCondition_ = function(mapBrowserEvent) {\n      return ol.events.condition.altKeyOnly(mapBrowserEvent) &&\n        ol.events.condition.singleClick(mapBrowserEvent);\n    };\n  \n    /**\n     * @type {ol.EventsConditionType}\n     * @private\n     */\n    this.deleteCondition_ = options.deleteCondition ?\n      options.deleteCondition : this.defaultDeleteCondition_;\n  \n    /**\n     * @type {ol.EventsConditionType}\n     * @private\n     */\n    this.insertVertexCondition_ = options.insertVertexCondition ?\n      options.insertVertexCondition : ol.events.condition.always;\n  \n    /**\n     * Editing vertex.\n     * @type {ol.Feature}\n     * @private\n     */\n    this.vertexFeature_ = null;\n  \n    /**\n     * Segments intersecting {@link this.vertexFeature_} by segment uid.\n     * @type {Object.<string, boolean>}\n     * @private\n     */\n    this.vertexSegments_ = null;\n  \n    /**\n     * @type {ol.Pixel}\n     * @private\n     */\n    this.lastPixel_ = [0, 0];\n  \n    /**\n     * Tracks if the next `singleclick` event should be ignored to prevent\n     * accidental deletion right after vertex creation.\n     * @type {boolean}\n     * @private\n     */\n    this.ignoreNextSingleClick_ = false;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.modified_ = false;\n  \n    /**\n     * Segment RTree for each layer\n     * @type {ol.structs.RBush.<ol.ModifySegmentDataType>}\n     * @private\n     */\n    this.rBush_ = new ol.structs.RBush();\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n      options.pixelTolerance : 10;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n  \n    /**\n     * Indicate whether the interaction is currently changing a feature's\n     * coordinates.\n     * @type {boolean}\n     * @private\n     */\n    this.changingFeature_ = false;\n  \n    /**\n     * @type {Array}\n     * @private\n     */\n    this.dragSegments_ = [];\n  \n    /**\n     * Draw overlay where sketch features are drawn.\n     * @type {ol.layer.Vector}\n     * @private\n     */\n    this.overlay_ = new ol.layer.Vector({\n      source: new ol.source.Vector({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX\n      }),\n      style: options.style ? options.style :\n        ol.interaction.Modify.getDefaultStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true\n    });\n  \n    /**\n    * @const\n    * @private\n    * @type {Object.<string, function(ol.Feature, ol.geom.Geometry)>}\n    */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'Circle': this.writeCircleGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_\n    };\n  \n  \n    /**\n     * @type {ol.source.Vector}\n     * @private\n     */\n    this.source_ = null;\n  \n    var features;\n    if (options.source) {\n      this.source_ = options.source;\n      features = new ol.Collection(this.source_.getFeatures());\n      ol.events.listen(this.source_, ol.source.VectorEventType.ADDFEATURE,\n          this.handleSourceAdd_, this);\n      ol.events.listen(this.source_, ol.source.VectorEventType.REMOVEFEATURE,\n          this.handleSourceRemove_, this);\n    } else {\n      features = options.features;\n    }\n    if (!features) {\n      throw new Error('The modify interaction requires features or a source');\n    }\n  \n    /**\n     * @type {ol.Collection.<ol.Feature>}\n     * @private\n     */\n    this.features_ = features;\n  \n    this.features_.forEach(this.addFeature_, this);\n    ol.events.listen(this.features_, ol.CollectionEventType.ADD,\n        this.handleFeatureAdd_, this);\n    ol.events.listen(this.features_, ol.CollectionEventType.REMOVE,\n        this.handleFeatureRemove_, this);\n  \n    /**\n     * @type {ol.MapBrowserPointerEvent}\n     * @private\n     */\n    this.lastPointerEvent_ = null;\n  \n  };\n  ol.inherits(ol.interaction.Modify, ol.interaction.Pointer);\n  \n  \n  /**\n   * @define {number} The segment index assigned to a circle's center when\n   * breaking up a cicrle into ModifySegmentDataType segments.\n   */\n  ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX = 0;\n  \n  /**\n   * @define {number} The segment index assigned to a circle's circumference when\n   * breaking up a circle into ModifySegmentDataType segments.\n   */\n  ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX = 1;\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @private\n   */\n  ol.interaction.Modify.prototype.addFeature_ = function(feature) {\n    var geometry = feature.getGeometry();\n    if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {\n      this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);\n    }\n    var map = this.getMap();\n    if (map && map.isRendered() && this.getActive()) {\n      this.handlePointerAtPixel_(this.lastPixel_, map);\n    }\n    ol.events.listen(feature, ol.events.EventType.CHANGE,\n        this.handleFeatureChange_, this);\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} evt Map browser event\n   * @private\n   */\n  ol.interaction.Modify.prototype.willModifyFeatures_ = function(evt) {\n    if (!this.modified_) {\n      this.modified_ = true;\n      this.dispatchEvent(new ol.interaction.Modify.Event(\n          ol.interaction.ModifyEventType.MODIFYSTART, this.features_, evt));\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @private\n   */\n  ol.interaction.Modify.prototype.removeFeature_ = function(feature) {\n    this.removeFeatureSegmentData_(feature);\n    // Remove the vertex feature if the collection of canditate features\n    // is empty.\n    if (this.vertexFeature_ && this.features_.getLength() === 0) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    ol.events.unlisten(feature, ol.events.EventType.CHANGE,\n        this.handleFeatureChange_, this);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @private\n   */\n  ol.interaction.Modify.prototype.removeFeatureSegmentData_ = function(feature) {\n    var rBush = this.rBush_;\n    var /** @type {Array.<ol.ModifySegmentDataType>} */ nodesToRemove = [];\n    rBush.forEach(\n        /**\n         * @param {ol.ModifySegmentDataType} node RTree node.\n         */\n        function(node) {\n          if (feature === node.feature) {\n            nodesToRemove.push(node);\n          }\n        });\n    for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n      rBush.remove(nodesToRemove[i]);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.Modify.prototype.setActive = function(active) {\n    if (this.vertexFeature_ && !active) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    ol.interaction.Pointer.prototype.setActive.call(this, active);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.Modify.prototype.setMap = function(map) {\n    this.overlay_.setMap(map);\n    ol.interaction.Pointer.prototype.setMap.call(this, map);\n  };\n  \n  \n  /**\n   * @param {ol.source.Vector.Event} event Event.\n   * @private\n   */\n  ol.interaction.Modify.prototype.handleSourceAdd_ = function(event) {\n    if (event.feature) {\n      this.features_.push(event.feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.source.Vector.Event} event Event.\n   * @private\n   */\n  ol.interaction.Modify.prototype.handleSourceRemove_ = function(event) {\n    if (event.feature) {\n      this.features_.remove(event.feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Collection.Event} evt Event.\n   * @private\n   */\n  ol.interaction.Modify.prototype.handleFeatureAdd_ = function(evt) {\n    this.addFeature_(/** @type {ol.Feature} */ (evt.element));\n  };\n  \n  \n  /**\n   * @param {ol.events.Event} evt Event.\n   * @private\n   */\n  ol.interaction.Modify.prototype.handleFeatureChange_ = function(evt) {\n    if (!this.changingFeature_) {\n      var feature = /** @type {ol.Feature} */ (evt.target);\n      this.removeFeature_(feature);\n      this.addFeature_(feature);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Collection.Event} evt Event.\n   * @private\n   */\n  ol.interaction.Modify.prototype.handleFeatureRemove_ = function(evt) {\n    var feature = /** @type {ol.Feature} */ (evt.element);\n    this.removeFeature_(feature);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.Point} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Modify.prototype.writePointGeometry_ = function(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n      feature: feature,\n      geometry: geometry,\n      segment: [coordinates, coordinates]\n    });\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.MultiPoint} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Modify.prototype.writeMultiPointGeometry_ = function(feature, geometry) {\n    var points = geometry.getCoordinates();\n    var coordinates, i, ii, segmentData;\n    for (i = 0, ii = points.length; i < ii; ++i) {\n      coordinates = points[i];\n      segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n        feature: feature,\n        geometry: geometry,\n        depth: [i],\n        index: i,\n        segment: [coordinates, coordinates]\n      });\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.LineString} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Modify.prototype.writeLineStringGeometry_ = function(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var i, ii, segment, segmentData;\n    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segment = coordinates.slice(i, i + 2);\n      segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n        feature: feature,\n        geometry: geometry,\n        index: i,\n        segment: segment\n      });\n      this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.MultiLineString} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Modify.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {\n    var lines = geometry.getCoordinates();\n    var coordinates, i, ii, j, jj, segment, segmentData;\n    for (j = 0, jj = lines.length; j < jj; ++j) {\n      coordinates = lines[j];\n      for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segment = coordinates.slice(i, i + 2);\n        segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment\n        });\n        this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.Polygon} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Modify.prototype.writePolygonGeometry_ = function(feature, geometry) {\n    var rings = geometry.getCoordinates();\n    var coordinates, i, ii, j, jj, segment, segmentData;\n    for (j = 0, jj = rings.length; j < jj; ++j) {\n      coordinates = rings[j];\n      for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segment = coordinates.slice(i, i + 2);\n        segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment\n        });\n        this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.MultiPolygon} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Modify.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {\n    var polygons = geometry.getCoordinates();\n    var coordinates, i, ii, j, jj, k, kk, rings, segment, segmentData;\n    for (k = 0, kk = polygons.length; k < kk; ++k) {\n      rings = polygons[k];\n      for (j = 0, jj = rings.length; j < jj; ++j) {\n        coordinates = rings[j];\n        for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segment = coordinates.slice(i, i + 2);\n          segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n            feature: feature,\n            geometry: geometry,\n            depth: [j, k],\n            index: i,\n            segment: segment\n          });\n          this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * We convert a circle into two segments.  The segment at index\n   * {@link ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX} is the\n   * circle's center (a point).  The segment at index\n   * {@link ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX} is\n   * the circumference, and is not a line segment.\n   *\n   * @param {ol.Feature} feature Feature.\n   * @param {ol.geom.Circle} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Modify.prototype.writeCircleGeometry_ = function(feature, geometry) {\n    var coordinates = geometry.getCenter();\n    var centerSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n      feature: feature,\n      geometry: geometry,\n      index: ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX,\n      segment: [coordinates, coordinates]\n    });\n    var circumferenceSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n      feature: feature,\n      geometry: geometry,\n      index: ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX,\n      segment: [coordinates, coordinates]\n    });\n    var featureSegments = [centerSegmentData, circumferenceSegmentData];\n    centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;\n    this.rBush_.insert(ol.extent.createOrUpdateFromCoordinate(coordinates), centerSegmentData);\n    this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.GeometryCollection} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Modify.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {\n    var i, geometries = geometry.getGeometriesArray();\n    for (i = 0; i < geometries.length; ++i) {\n      this.SEGMENT_WRITERS_[geometries[i].getType()].call(\n          this, feature, geometries[i]);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinates Coordinates.\n   * @return {ol.Feature} Vertex feature.\n   * @private\n   */\n  ol.interaction.Modify.prototype.createOrUpdateVertexFeature_ = function(coordinates) {\n    var vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new ol.Feature(new ol.geom.Point(coordinates));\n      this.vertexFeature_ = vertexFeature;\n      this.overlay_.getSource().addFeature(vertexFeature);\n    } else {\n      var geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n      geometry.setCoordinates(coordinates);\n    }\n    return vertexFeature;\n  };\n  \n  \n  /**\n   * @param {ol.ModifySegmentDataType} a The first segment data.\n   * @param {ol.ModifySegmentDataType} b The second segment data.\n   * @return {number} The difference in indexes.\n   * @private\n   */\n  ol.interaction.Modify.compareIndexes_ = function(a, b) {\n    return a.index - b.index;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} evt Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.Modify}\n   * @private\n   */\n  ol.interaction.Modify.handleDownEvent_ = function(evt) {\n    if (!this.condition_(evt)) {\n      return false;\n    }\n    this.handlePointerAtPixel_(evt.pixel, evt.map);\n    var pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);\n    this.dragSegments_.length = 0;\n    this.modified_ = false;\n    var vertexFeature = this.vertexFeature_;\n    if (vertexFeature) {\n      var insertVertices = [];\n      var geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n      var vertex = geometry.getCoordinates();\n      var vertexExtent = ol.extent.boundingExtent([vertex]);\n      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n      var componentSegments = {};\n      segmentDataMatches.sort(ol.interaction.Modify.compareIndexes_);\n      for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n        var segmentDataMatch = segmentDataMatches[i];\n        var segment = segmentDataMatch.segment;\n        var uid = ol.getUid(segmentDataMatch.feature);\n        var depth = segmentDataMatch.depth;\n        if (depth) {\n          uid += '-' + depth.join('-'); // separate feature components\n        }\n        if (!componentSegments[uid]) {\n          componentSegments[uid] = new Array(2);\n        }\n        if (segmentDataMatch.geometry.getType() === ol.geom.GeometryType.CIRCLE &&\n        segmentDataMatch.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n  \n          var closestVertex = ol.interaction.Modify.closestOnSegmentData_(pixelCoordinate, segmentDataMatch);\n          if (ol.coordinate.equals(closestVertex, vertex) && !componentSegments[uid][0]) {\n            this.dragSegments_.push([segmentDataMatch, 0]);\n            componentSegments[uid][0] = segmentDataMatch;\n          }\n        } else if (ol.coordinate.equals(segment[0], vertex) &&\n            !componentSegments[uid][0]) {\n          this.dragSegments_.push([segmentDataMatch, 0]);\n          componentSegments[uid][0] = segmentDataMatch;\n        } else if (ol.coordinate.equals(segment[1], vertex) &&\n            !componentSegments[uid][1]) {\n  \n          // prevent dragging closed linestrings by the connecting node\n          if ((segmentDataMatch.geometry.getType() ===\n              ol.geom.GeometryType.LINE_STRING ||\n              segmentDataMatch.geometry.getType() ===\n              ol.geom.GeometryType.MULTI_LINE_STRING) &&\n              componentSegments[uid][0] &&\n              componentSegments[uid][0].index === 0) {\n            continue;\n          }\n  \n          this.dragSegments_.push([segmentDataMatch, 1]);\n          componentSegments[uid][1] = segmentDataMatch;\n        } else if (this.insertVertexCondition_(evt) && ol.getUid(segment) in this.vertexSegments_ &&\n            (!componentSegments[uid][0] && !componentSegments[uid][1])) {\n          insertVertices.push([segmentDataMatch, vertex]);\n        }\n      }\n      if (insertVertices.length) {\n        this.willModifyFeatures_(evt);\n      }\n      for (var j = insertVertices.length - 1; j >= 0; --j) {\n        this.insertVertex_.apply(this, insertVertices[j]);\n      }\n    }\n    return !!this.vertexFeature_;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} evt Event.\n   * @this {ol.interaction.Modify}\n   * @private\n   */\n  ol.interaction.Modify.handleDragEvent_ = function(evt) {\n    this.ignoreNextSingleClick_ = false;\n    this.willModifyFeatures_(evt);\n  \n    var vertex = evt.coordinate;\n    for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\n      var dragSegment = this.dragSegments_[i];\n      var segmentData = dragSegment[0];\n      var depth = segmentData.depth;\n      var geometry = segmentData.geometry;\n      var coordinates;\n      var segment = segmentData.segment;\n      var index = dragSegment[1];\n  \n      while (vertex.length < geometry.getStride()) {\n        vertex.push(segment[index][vertex.length]);\n      }\n  \n      switch (geometry.getType()) {\n        case ol.geom.GeometryType.POINT:\n          coordinates = vertex;\n          segment[0] = segment[1] = vertex;\n          break;\n        case ol.geom.GeometryType.MULTI_POINT:\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index] = vertex;\n          segment[0] = segment[1] = vertex;\n          break;\n        case ol.geom.GeometryType.LINE_STRING:\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case ol.geom.GeometryType.MULTI_LINE_STRING:\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case ol.geom.GeometryType.POLYGON:\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case ol.geom.GeometryType.MULTI_POLYGON:\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case ol.geom.GeometryType.CIRCLE:\n          segment[0] = segment[1] = vertex;\n          if (segmentData.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX) {\n            this.changingFeature_ = true;\n            geometry.setCenter(vertex);\n            this.changingFeature_ = false;\n          } else { // We're dragging the circle's circumference:\n            this.changingFeature_ = true;\n            geometry.setRadius(ol.coordinate.distance(geometry.getCenter(), vertex));\n            this.changingFeature_ = false;\n          }\n          break;\n        default:\n          // pass\n      }\n  \n      if (coordinates) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n      }\n    }\n    this.createOrUpdateVertexFeature_(vertex);\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} evt Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.Modify}\n   * @private\n   */\n  ol.interaction.Modify.handleUpEvent_ = function(evt) {\n    var segmentData;\n    var geometry;\n    for (var i = this.dragSegments_.length - 1; i >= 0; --i) {\n      segmentData = this.dragSegments_[i][0];\n      geometry = segmentData.geometry;\n      if (geometry.getType() === ol.geom.GeometryType.CIRCLE) {\n        // Update a circle object in the R* bush:\n        var coordinates = geometry.getCenter();\n        var centerSegmentData = segmentData.featureSegments[0];\n        var circumferenceSegmentData = segmentData.featureSegments[1];\n        centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;\n        circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;\n        this.rBush_.update(ol.extent.createOrUpdateFromCoordinate(coordinates), centerSegmentData);\n        this.rBush_.update(geometry.getExtent(), circumferenceSegmentData);\n      } else {\n        this.rBush_.update(ol.extent.boundingExtent(segmentData.segment),\n            segmentData);\n      }\n    }\n    if (this.modified_) {\n      this.dispatchEvent(new ol.interaction.Modify.Event(\n          ol.interaction.ModifyEventType.MODIFYEND, this.features_, evt));\n      this.modified_ = false;\n    }\n    return false;\n  };\n  \n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} and may modify the\n   * geometry.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {ol.interaction.Modify}\n   * @api\n   */\n  ol.interaction.Modify.handleEvent = function(mapBrowserEvent) {\n    if (!(mapBrowserEvent instanceof ol.MapBrowserPointerEvent)) {\n      return true;\n    }\n    this.lastPointerEvent_ = mapBrowserEvent;\n  \n    var handled;\n    if (!mapBrowserEvent.map.getView().getInteracting() &&\n        mapBrowserEvent.type == ol.MapBrowserEventType.POINTERMOVE &&\n        !this.handlingDownUpSequence) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n      if (mapBrowserEvent.type != ol.MapBrowserEventType.SINGLECLICK ||\n          !this.ignoreNextSingleClick_) {\n        handled = this.removePoint();\n      } else {\n        handled = true;\n      }\n    }\n  \n    if (mapBrowserEvent.type == ol.MapBrowserEventType.SINGLECLICK) {\n      this.ignoreNextSingleClick_ = false;\n    }\n  \n    return ol.interaction.Pointer.handleEvent.call(this, mapBrowserEvent) &&\n        !handled;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserEvent} evt Event.\n   * @private\n   */\n  ol.interaction.Modify.prototype.handlePointerMove_ = function(evt) {\n    this.lastPixel_ = evt.pixel;\n    this.handlePointerAtPixel_(evt.pixel, evt.map);\n  };\n  \n  \n  /**\n   * @param {ol.Pixel} pixel Pixel\n   * @param {ol.PluggableMap} map Map.\n   * @private\n   */\n  ol.interaction.Modify.prototype.handlePointerAtPixel_ = function(pixel, map) {\n    var pixelCoordinate = map.getCoordinateFromPixel(pixel);\n    var sortByDistance = function(a, b) {\n      return ol.interaction.Modify.pointDistanceToSegmentDataSquared_(pixelCoordinate, a) -\n          ol.interaction.Modify.pointDistanceToSegmentDataSquared_(pixelCoordinate, b);\n    };\n  \n    var box = ol.extent.buffer(\n        ol.extent.createOrUpdateFromCoordinate(pixelCoordinate),\n        map.getView().getResolution() * this.pixelTolerance_);\n  \n    var rBush = this.rBush_;\n    var nodes = rBush.getInExtent(box);\n    if (nodes.length > 0) {\n      nodes.sort(sortByDistance);\n      var node = nodes[0];\n      var closestSegment = node.segment;\n      var vertex = ol.interaction.Modify.closestOnSegmentData_(pixelCoordinate, node);\n      var vertexPixel = map.getPixelFromCoordinate(vertex);\n      var dist = ol.coordinate.distance(pixel, vertexPixel);\n      if (dist <= this.pixelTolerance_) {\n        var vertexSegments = {};\n  \n        if (node.geometry.getType() === ol.geom.GeometryType.CIRCLE &&\n        node.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n  \n          this.snappedToVertex_ = true;\n          this.createOrUpdateVertexFeature_(vertex);\n        } else {\n          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          var squaredDist1 = ol.coordinate.squaredDistance(vertexPixel, pixel1);\n          var squaredDist2 = ol.coordinate.squaredDistance(vertexPixel, pixel2);\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          this.snappedToVertex_ = dist <= this.pixelTolerance_;\n          if (this.snappedToVertex_) {\n            vertex = squaredDist1 > squaredDist2 ?\n              closestSegment[1] : closestSegment[0];\n          }\n          this.createOrUpdateVertexFeature_(vertex);\n          var segment;\n          for (var i = 1, ii = nodes.length; i < ii; ++i) {\n            segment = nodes[i].segment;\n            if ((ol.coordinate.equals(closestSegment[0], segment[0]) &&\n                ol.coordinate.equals(closestSegment[1], segment[1]) ||\n                (ol.coordinate.equals(closestSegment[0], segment[1]) &&\n                ol.coordinate.equals(closestSegment[1], segment[0])))) {\n              vertexSegments[ol.getUid(segment)] = true;\n            } else {\n              break;\n            }\n          }\n        }\n  \n        vertexSegments[ol.getUid(closestSegment)] = true;\n        this.vertexSegments_ = vertexSegments;\n        return;\n      }\n    }\n    if (this.vertexFeature_) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n  };\n  \n  \n  /**\n   * Returns the distance from a point to a line segment.\n   *\n   * @param {ol.Coordinate} pointCoordinates The coordinates of the point from\n   *        which to calculate the distance.\n   * @param {ol.ModifySegmentDataType} segmentData The object describing the line\n   *        segment we are calculating the distance to.\n   * @return {number} The square of the distance between a point and a line segment.\n   */\n  ol.interaction.Modify.pointDistanceToSegmentDataSquared_ = function(pointCoordinates, segmentData) {\n    var geometry = segmentData.geometry;\n  \n    if (geometry.getType() === ol.geom.GeometryType.CIRCLE) {\n      var circleGeometry = /** @type {ol.geom.Circle} */ (geometry);\n  \n      if (segmentData.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n        var distanceToCenterSquared =\n              ol.coordinate.squaredDistance(circleGeometry.getCenter(), pointCoordinates);\n        var distanceToCircumference =\n              Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n        return distanceToCircumference * distanceToCircumference;\n      }\n    }\n    return ol.coordinate.squaredDistanceToSegment(pointCoordinates, segmentData.segment);\n  };\n  \n  /**\n   * Returns the point closest to a given line segment.\n   *\n   * @param {ol.Coordinate} pointCoordinates The point to which a closest point\n   *        should be found.\n   * @param {ol.ModifySegmentDataType} segmentData The object describing the line\n   *        segment which should contain the closest point.\n   * @return {ol.Coordinate} The point closest to the specified line segment.\n   */\n  ol.interaction.Modify.closestOnSegmentData_ = function(pointCoordinates, segmentData) {\n    var geometry = segmentData.geometry;\n  \n    if (geometry.getType() === ol.geom.GeometryType.CIRCLE &&\n    segmentData.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n      return geometry.getClosestPoint(pointCoordinates);\n    }\n    return ol.coordinate.closestOnSegment(pointCoordinates, segmentData.segment);\n  };\n  \n  \n  /**\n   * @param {ol.ModifySegmentDataType} segmentData Segment data.\n   * @param {ol.Coordinate} vertex Vertex.\n   * @private\n   */\n  ol.interaction.Modify.prototype.insertVertex_ = function(segmentData, vertex) {\n    var segment = segmentData.segment;\n    var feature = segmentData.feature;\n    var geometry = segmentData.geometry;\n    var depth = segmentData.depth;\n    var index = /** @type {number} */ (segmentData.index);\n    var coordinates;\n  \n    while (vertex.length < geometry.getStride()) {\n      vertex.push(0);\n    }\n  \n    switch (geometry.getType()) {\n      case ol.geom.GeometryType.MULTI_LINE_STRING:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case ol.geom.GeometryType.POLYGON:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case ol.geom.GeometryType.MULTI_POLYGON:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case ol.geom.GeometryType.LINE_STRING:\n        coordinates = geometry.getCoordinates();\n        coordinates.splice(index + 1, 0, vertex);\n        break;\n      default:\n        return;\n    }\n  \n    this.setGeometryCoordinates_(geometry, coordinates);\n    var rTree = this.rBush_;\n    rTree.remove(segmentData);\n    this.updateSegmentIndices_(geometry, index, depth, 1);\n    var newSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n      segment: [segment[0], vertex],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index\n    });\n    rTree.insert(ol.extent.boundingExtent(newSegmentData.segment),\n        newSegmentData);\n    this.dragSegments_.push([newSegmentData, 1]);\n  \n    var newSegmentData2 = /** @type {ol.ModifySegmentDataType} */ ({\n      segment: [vertex, segment[1]],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index + 1\n    });\n    rTree.insert(ol.extent.boundingExtent(newSegmentData2.segment),\n        newSegmentData2);\n    this.dragSegments_.push([newSegmentData2, 0]);\n    this.ignoreNextSingleClick_ = true;\n  };\n  \n  /**\n   * Removes the vertex currently being pointed.\n   * @return {boolean} True when a vertex was removed.\n   * @api\n   */\n  ol.interaction.Modify.prototype.removePoint = function() {\n    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != ol.MapBrowserEventType.POINTERDRAG) {\n      var evt = this.lastPointerEvent_;\n      this.willModifyFeatures_(evt);\n      this.removeVertex_();\n      this.dispatchEvent(new ol.interaction.Modify.Event(\n          ol.interaction.ModifyEventType.MODIFYEND, this.features_, evt));\n      this.modified_ = false;\n      return true;\n    }\n    return false;\n  };\n  \n  /**\n   * Removes a vertex from all matching features.\n   * @return {boolean} True when a vertex was removed.\n   * @private\n   */\n  ol.interaction.Modify.prototype.removeVertex_ = function() {\n    var dragSegments = this.dragSegments_;\n    var segmentsByFeature = {};\n    var deleted = false;\n    var component, coordinates, dragSegment, geometry, i, index, left;\n    var newIndex, right, segmentData, uid;\n    for (i = dragSegments.length - 1; i >= 0; --i) {\n      dragSegment = dragSegments[i];\n      segmentData = dragSegment[0];\n      uid = ol.getUid(segmentData.feature);\n      if (segmentData.depth) {\n        // separate feature components\n        uid += '-' + segmentData.depth.join('-');\n      }\n      if (!(uid in segmentsByFeature)) {\n        segmentsByFeature[uid] = {};\n      }\n      if (dragSegment[1] === 0) {\n        segmentsByFeature[uid].right = segmentData;\n        segmentsByFeature[uid].index = segmentData.index;\n      } else if (dragSegment[1] == 1) {\n        segmentsByFeature[uid].left = segmentData;\n        segmentsByFeature[uid].index = segmentData.index + 1;\n      }\n  \n    }\n    for (uid in segmentsByFeature) {\n      right = segmentsByFeature[uid].right;\n      left = segmentsByFeature[uid].left;\n      index = segmentsByFeature[uid].index;\n      newIndex = index - 1;\n      if (left !== undefined) {\n        segmentData = left;\n      } else {\n        segmentData = right;\n      }\n      if (newIndex < 0) {\n        newIndex = 0;\n      }\n      geometry = segmentData.geometry;\n      coordinates = geometry.getCoordinates();\n      component = coordinates;\n      deleted = false;\n      switch (geometry.getType()) {\n        case ol.geom.GeometryType.MULTI_LINE_STRING:\n          if (coordinates[segmentData.depth[0]].length > 2) {\n            coordinates[segmentData.depth[0]].splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case ol.geom.GeometryType.LINE_STRING:\n          if (coordinates.length > 2) {\n            coordinates.splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case ol.geom.GeometryType.MULTI_POLYGON:\n          component = component[segmentData.depth[1]];\n          /* falls through */\n        case ol.geom.GeometryType.POLYGON:\n          component = component[segmentData.depth[0]];\n          if (component.length > 4) {\n            if (index == component.length - 1) {\n              index = 0;\n            }\n            component.splice(index, 1);\n            deleted = true;\n            if (index === 0) {\n              // close the ring again\n              component.pop();\n              component.push(component[0]);\n              newIndex = component.length - 1;\n            }\n          }\n          break;\n        default:\n          // pass\n      }\n  \n      if (deleted) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n        var segments = [];\n        if (left !== undefined) {\n          this.rBush_.remove(left);\n          segments.push(left.segment[0]);\n        }\n        if (right !== undefined) {\n          this.rBush_.remove(right);\n          segments.push(right.segment[1]);\n        }\n        if (left !== undefined && right !== undefined) {\n          var newSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n            depth: segmentData.depth,\n            feature: segmentData.feature,\n            geometry: segmentData.geometry,\n            index: newIndex,\n            segment: segments\n          });\n          this.rBush_.insert(ol.extent.boundingExtent(newSegmentData.segment),\n              newSegmentData);\n        }\n        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\n        if (this.vertexFeature_) {\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n        dragSegments.length = 0;\n      }\n  \n    }\n    return deleted;\n  };\n  \n  \n  /**\n   * @param {ol.geom.SimpleGeometry} geometry Geometry.\n   * @param {Array} coordinates Coordinates.\n   * @private\n   */\n  ol.interaction.Modify.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {\n    this.changingFeature_ = true;\n    geometry.setCoordinates(coordinates);\n    this.changingFeature_ = false;\n  };\n  \n  \n  /**\n   * @param {ol.geom.SimpleGeometry} geometry Geometry.\n   * @param {number} index Index.\n   * @param {Array.<number>|undefined} depth Depth.\n   * @param {number} delta Delta (1 or -1).\n   * @private\n   */\n  ol.interaction.Modify.prototype.updateSegmentIndices_ = function(\n      geometry, index, depth, delta) {\n    this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {\n      if (segmentDataMatch.geometry === geometry &&\n          (depth === undefined || segmentDataMatch.depth === undefined ||\n          ol.array.equals(segmentDataMatch.depth, depth)) &&\n          segmentDataMatch.index > index) {\n        segmentDataMatch.index += delta;\n      }\n    });\n  };\n  \n  \n  /**\n   * @return {ol.StyleFunction} Styles.\n   */\n  ol.interaction.Modify.getDefaultStyleFunction = function() {\n    var style = ol.style.Style.createDefaultEditing();\n    return function(feature, resolution) {\n      return style[ol.geom.GeometryType.POINT];\n    };\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.interaction.Modify} instances are instances of\n   * this type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.ModifyEvent}\n   * @param {ol.interaction.ModifyEventType} type Type.\n   * @param {ol.Collection.<ol.Feature>} features The features modified.\n   * @param {ol.MapBrowserPointerEvent} mapBrowserPointerEvent Associated\n   *     {@link ol.MapBrowserPointerEvent}.\n   */\n  ol.interaction.Modify.Event = function(type, features, mapBrowserPointerEvent) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The features being modified.\n     * @type {ol.Collection.<ol.Feature>}\n     * @api\n     */\n    this.features = features;\n  \n    /**\n     * Associated {@link ol.MapBrowserEvent}.\n     * @type {ol.MapBrowserEvent}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserPointerEvent;\n  };\n  ol.inherits(ol.interaction.Modify.Event, ol.events.Event);\n  \n  goog.provide('ol.interaction.Select');\n  \n  goog.require('ol');\n  goog.require('ol.CollectionEventType');\n  goog.require('ol.array');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.condition');\n  goog.require('ol.functions');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.layer.Vector');\n  goog.require('ol.obj');\n  goog.require('ol.source.Vector');\n  goog.require('ol.style.Style');\n  \n  \n  /**\n   * @classdesc\n   * Interaction for selecting vector features. By default, selected features are\n   * styled differently, so this interaction can be used for visual highlighting,\n   * as well as selecting features for other actions, such as modification or\n   * output. There are three ways of controlling which features are selected:\n   * using the browser event as defined by the `condition` and optionally the\n   * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n   * further feature filter using the `filter` option.\n   *\n   * Selected features are added to an internal unmanaged layer.\n   *\n   * @constructor\n   * @extends {ol.interaction.Interaction}\n   * @param {olx.interaction.SelectOptions=} opt_options Options.\n   * @fires ol.interaction.Select.Event\n   * @api\n   */\n  ol.interaction.Select = function(opt_options) {\n  \n    ol.interaction.Interaction.call(this, {\n      handleEvent: ol.interaction.Select.handleEvent\n    });\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.condition_ = options.condition ?\n      options.condition : ol.events.condition.singleClick;\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.addCondition_ = options.addCondition ?\n      options.addCondition : ol.events.condition.never;\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.removeCondition_ = options.removeCondition ?\n      options.removeCondition : ol.events.condition.never;\n  \n    /**\n     * @private\n     * @type {ol.EventsConditionType}\n     */\n    this.toggleCondition_ = options.toggleCondition ?\n      options.toggleCondition : ol.events.condition.shiftKeyOnly;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n  \n    /**\n     * @private\n     * @type {ol.SelectFilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter :\n      ol.functions.TRUE;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n  \n    var featureOverlay = new ol.layer.Vector({\n      source: new ol.source.Vector({\n        useSpatialIndex: false,\n        features: options.features,\n        wrapX: options.wrapX\n      }),\n      style: options.style ? options.style :\n        ol.interaction.Select.getDefaultStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true\n    });\n  \n    /**\n     * @private\n     * @type {ol.layer.Vector}\n     */\n    this.featureOverlay_ = featureOverlay;\n  \n    /** @type {function(ol.layer.Layer): boolean} */\n    var layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        var layers = options.layers;\n        layerFilter = function(layer) {\n          return ol.array.includes(layers, layer);\n        };\n      }\n    } else {\n      layerFilter = ol.functions.TRUE;\n    }\n  \n    /**\n     * @private\n     * @type {function(ol.layer.Layer): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n  \n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object.<number, ol.layer.Layer>}\n     */\n    this.featureLayerAssociation_ = {};\n  \n    var features = this.featureOverlay_.getSource().getFeaturesCollection();\n    ol.events.listen(features, ol.CollectionEventType.ADD,\n        this.addFeature_, this);\n    ol.events.listen(features, ol.CollectionEventType.REMOVE,\n        this.removeFeature_, this);\n  \n  };\n  ol.inherits(ol.interaction.Select, ol.interaction.Interaction);\n  \n  \n  /**\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @param {ol.layer.Layer} layer Layer.\n   * @private\n   */\n  ol.interaction.Select.prototype.addFeatureLayerAssociation_ = function(feature, layer) {\n    var key = ol.getUid(feature);\n    this.featureLayerAssociation_[key] = layer;\n  };\n  \n  \n  /**\n   * Get the selected features.\n   * @return {ol.Collection.<ol.Feature>} Features collection.\n   * @api\n   */\n  ol.interaction.Select.prototype.getFeatures = function() {\n    return this.featureOverlay_.getSource().getFeaturesCollection();\n  };\n  \n  \n  /**\n   * Returns the Hit-detection tolerance.\n   * @returns {number} Hit tolerance in pixels.\n   * @api\n   */\n  ol.interaction.Select.prototype.getHitTolerance = function() {\n    return this.hitTolerance_;\n  };\n  \n  \n  /**\n   * Returns the associated {@link ol.layer.Vector vectorlayer} of\n   * the (last) selected feature. Note that this will not work with any\n   * programmatic method like pushing features to\n   * {@link ol.interaction.Select#getFeatures collection}.\n   * @param {ol.Feature|ol.render.Feature} feature Feature\n   * @return {ol.layer.Vector} Layer.\n   * @api\n   */\n  ol.interaction.Select.prototype.getLayer = function(feature) {\n    var key = ol.getUid(feature);\n    return /** @type {ol.layer.Vector} */ (this.featureLayerAssociation_[key]);\n  };\n  \n  \n  /**\n   * Handles the {@link ol.MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {ol.interaction.Select}\n   * @api\n   */\n  ol.interaction.Select.handleEvent = function(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    var add = this.addCondition_(mapBrowserEvent);\n    var remove = this.removeCondition_(mapBrowserEvent);\n    var toggle = this.toggleCondition_(mapBrowserEvent);\n    var set = !add && !remove && !toggle;\n    var map = mapBrowserEvent.map;\n    var features = this.featureOverlay_.getSource().getFeaturesCollection();\n    var deselected = [];\n    var selected = [];\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      ol.obj.clear(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(mapBrowserEvent.pixel,\n          (\n            /**\n             * @param {ol.Feature|ol.render.Feature} feature Feature.\n             * @param {ol.layer.Layer} layer Layer.\n             * @return {boolean|undefined} Continue to iterate over the features.\n             */\n            function(feature, layer) {\n              if (this.filter_(feature, layer)) {\n                selected.push(feature);\n                this.addFeatureLayerAssociation_(feature, layer);\n                return !this.multi_;\n              }\n            }).bind(this), {\n            layerFilter: this.layerFilter_,\n            hitTolerance: this.hitTolerance_\n          });\n      var i;\n      for (i = features.getLength() - 1; i >= 0; --i) {\n        var feature = features.item(i);\n        var index = selected.indexOf(feature);\n        if (index > -1) {\n          // feature is already selected\n          selected.splice(index, 1);\n        } else {\n          features.remove(feature);\n          deselected.push(feature);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(mapBrowserEvent.pixel,\n          (\n            /**\n             * @param {ol.Feature|ol.render.Feature} feature Feature.\n             * @param {ol.layer.Layer} layer Layer.\n             * @return {boolean|undefined} Continue to iterate over the features.\n             */\n            function(feature, layer) {\n              if (this.filter_(feature, layer)) {\n                if ((add || toggle) &&\n                  !ol.array.includes(features.getArray(), feature)) {\n                  selected.push(feature);\n                  this.addFeatureLayerAssociation_(feature, layer);\n                } else if ((remove || toggle) &&\n                  ol.array.includes(features.getArray(), feature)) {\n                  deselected.push(feature);\n                  this.removeFeatureLayerAssociation_(feature);\n                }\n                return !this.multi_;\n              }\n            }).bind(this), {\n            layerFilter: this.layerFilter_,\n            hitTolerance: this.hitTolerance_\n          });\n      var j;\n      for (j = deselected.length - 1; j >= 0; --j) {\n        features.remove(deselected[j]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n          new ol.interaction.Select.Event(ol.interaction.Select.EventType_.SELECT,\n              selected, deselected, mapBrowserEvent));\n    }\n    return ol.events.condition.pointerMove(mapBrowserEvent);\n  };\n  \n  \n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features. This only works for the canvas renderer and\n   * not for WebGL.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  ol.interaction.Select.prototype.setHitTolerance = function(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  };\n  \n  \n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {ol.PluggableMap} map Map.\n   * @override\n   * @api\n   */\n  ol.interaction.Select.prototype.setMap = function(map) {\n    var currentMap = this.getMap();\n    var selectedFeatures =\n        this.featureOverlay_.getSource().getFeaturesCollection();\n    if (currentMap) {\n      selectedFeatures.forEach(currentMap.unskipFeature, currentMap);\n    }\n    ol.interaction.Interaction.prototype.setMap.call(this, map);\n    this.featureOverlay_.setMap(map);\n    if (map) {\n      selectedFeatures.forEach(map.skipFeature, map);\n    }\n  };\n  \n  \n  /**\n   * @return {ol.StyleFunction} Styles.\n   */\n  ol.interaction.Select.getDefaultStyleFunction = function() {\n    var styles = ol.style.Style.createDefaultEditing();\n    ol.array.extend(styles[ol.geom.GeometryType.POLYGON],\n        styles[ol.geom.GeometryType.LINE_STRING]);\n    ol.array.extend(styles[ol.geom.GeometryType.GEOMETRY_COLLECTION],\n        styles[ol.geom.GeometryType.LINE_STRING]);\n  \n    return function(feature, resolution) {\n      if (!feature.getGeometry()) {\n        return null;\n      }\n      return styles[feature.getGeometry().getType()];\n    };\n  };\n  \n  \n  /**\n   * @param {ol.Collection.Event} evt Event.\n   * @private\n   */\n  ol.interaction.Select.prototype.addFeature_ = function(evt) {\n    var map = this.getMap();\n    if (map) {\n      map.skipFeature(/** @type {ol.Feature} */ (evt.element));\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Collection.Event} evt Event.\n   * @private\n   */\n  ol.interaction.Select.prototype.removeFeature_ = function(evt) {\n    var map = this.getMap();\n    if (map) {\n      map.unskipFeature(/** @type {ol.Feature} */ (evt.element));\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @private\n   */\n  ol.interaction.Select.prototype.removeFeatureLayerAssociation_ = function(feature) {\n    var key = ol.getUid(feature);\n    delete this.featureLayerAssociation_[key];\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.interaction.Select} instances are instances of\n   * this type.\n   *\n   * @param {ol.interaction.Select.EventType_} type The event type.\n   * @param {Array.<ol.Feature>} selected Selected features.\n   * @param {Array.<ol.Feature>} deselected Deselected features.\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Associated\n   *     {@link ol.MapBrowserEvent}.\n   * @implements {oli.SelectEvent}\n   * @extends {ol.events.Event}\n   * @constructor\n   */\n  ol.interaction.Select.Event = function(type, selected, deselected, mapBrowserEvent) {\n    ol.events.Event.call(this, type);\n  \n    /**\n     * Selected features array.\n     * @type {Array.<ol.Feature>}\n     * @api\n     */\n    this.selected = selected;\n  \n    /**\n     * Deselected features array.\n     * @type {Array.<ol.Feature>}\n     * @api\n     */\n    this.deselected = deselected;\n  \n    /**\n     * Associated {@link ol.MapBrowserEvent}.\n     * @type {ol.MapBrowserEvent}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  };\n  ol.inherits(ol.interaction.Select.Event, ol.events.Event);\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.interaction.Select.EventType_ = {\n    /**\n     * Triggered when feature(s) has been (de)selected.\n     * @event ol.interaction.Select.Event#select\n     * @api\n     */\n    SELECT: 'select'\n  };\n  \n  goog.provide('ol.interaction.Snap');\n  \n  goog.require('ol');\n  goog.require('ol.Collection');\n  goog.require('ol.CollectionEventType');\n  goog.require('ol.coordinate');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.functions');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.interaction.Pointer');\n  goog.require('ol.obj');\n  goog.require('ol.source.Vector');\n  goog.require('ol.source.VectorEventType');\n  goog.require('ol.structs.RBush');\n  \n  \n  /**\n   * @classdesc\n   * Handles snapping of vector features while modifying or drawing them.  The\n   * features can come from a {@link ol.source.Vector} or {@link ol.Collection}\n   * Any interaction object that allows the user to interact\n   * with the features using the mouse can benefit from the snapping, as long\n   * as it is added before.\n   *\n   * The snap interaction modifies map browser event `coordinate` and `pixel`\n   * properties to force the snap to occur to any interaction that them.\n   *\n   * Example:\n   *\n   *     var snap = new ol.interaction.Snap({\n   *       source: source\n   *     });\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @param {olx.interaction.SnapOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.Snap = function(opt_options) {\n  \n    ol.interaction.Pointer.call(this, {\n      handleEvent: ol.interaction.Snap.handleEvent_,\n      handleDownEvent: ol.functions.TRUE,\n      handleUpEvent: ol.interaction.Snap.handleUpEvent_\n    });\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * @type {ol.source.Vector}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n  \n    /**\n     * @type {ol.Collection.<ol.Feature>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n  \n    /**\n     * @type {Array.<ol.EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n  \n    /**\n     * @type {Object.<number, ol.EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n  \n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object.<number, ol.Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n  \n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {Object.<number, ol.Feature>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n  \n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {ol.Coordinate}\n     * @private\n     */\n    this.pixelCoordinate_ = null;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n      options.pixelTolerance : 10;\n  \n    /**\n     * @type {function(ol.SnapSegmentDataType, ol.SnapSegmentDataType): number}\n     * @private\n     */\n    this.sortByDistance_ = ol.interaction.Snap.sortByDistance.bind(this);\n  \n  \n    /**\n    * Segment RTree for each layer\n    * @type {ol.structs.RBush.<ol.SnapSegmentDataType>}\n    * @private\n    */\n    this.rBush_ = new ol.structs.RBush();\n  \n  \n    /**\n    * @const\n    * @private\n    * @type {Object.<string, function(ol.Feature, ol.geom.Geometry)>}\n    */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  };\n  ol.inherits(ol.interaction.Snap, ol.interaction.Pointer);\n  \n  \n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {ol.Feature} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  ol.interaction.Snap.prototype.addFeature = function(feature, opt_listen) {\n    var listen = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = ol.getUid(feature);\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n            ol.extent.createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n  \n    if (listen) {\n      this.featureChangeListenerKeys_[feature_uid] = ol.events.listen(\n          feature,\n          ol.events.EventType.CHANGE,\n          this.handleFeatureChange_, this);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @private\n   */\n  ol.interaction.Snap.prototype.forEachFeatureAdd_ = function(feature) {\n    this.addFeature(feature);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @private\n   */\n  ol.interaction.Snap.prototype.forEachFeatureRemove_ = function(feature) {\n    this.removeFeature(feature);\n  };\n  \n  \n  /**\n   * @return {ol.Collection.<ol.Feature>|Array.<ol.Feature>} Features.\n   * @private\n   */\n  ol.interaction.Snap.prototype.getFeatures_ = function() {\n    var features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return /** @type {!Array.<ol.Feature>|!ol.Collection.<ol.Feature>} */ (features);\n  };\n  \n  \n  /**\n   * @param {ol.source.Vector.Event|ol.Collection.Event} evt Event.\n   * @private\n   */\n  ol.interaction.Snap.prototype.handleFeatureAdd_ = function(evt) {\n    var feature;\n    if (evt instanceof ol.source.Vector.Event) {\n      feature = evt.feature;\n    } else if (evt instanceof ol.Collection.Event) {\n      feature = evt.element;\n    }\n    this.addFeature(/** @type {ol.Feature} */ (feature));\n  };\n  \n  \n  /**\n   * @param {ol.source.Vector.Event|ol.Collection.Event} evt Event.\n   * @private\n   */\n  ol.interaction.Snap.prototype.handleFeatureRemove_ = function(evt) {\n    var feature;\n    if (evt instanceof ol.source.Vector.Event) {\n      feature = evt.feature;\n    } else if (evt instanceof ol.Collection.Event) {\n      feature = evt.element;\n    }\n    this.removeFeature(/** @type {ol.Feature} */ (feature));\n  };\n  \n  \n  /**\n   * @param {ol.events.Event} evt Event.\n   * @private\n   */\n  ol.interaction.Snap.prototype.handleFeatureChange_ = function(evt) {\n    var feature = /** @type {ol.Feature} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      var uid = ol.getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  \n  \n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {ol.Feature} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  ol.interaction.Snap.prototype.removeFeature = function(feature, opt_unlisten) {\n    var unlisten = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = ol.getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      var rBush = this.rBush_;\n      var i, nodesToRemove = [];\n      rBush.forEachInExtent(extent, function(node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n  \n    if (unlisten) {\n      ol.events.unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.Snap.prototype.setMap = function(map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = this.getFeatures_();\n  \n    if (currentMap) {\n      keys.forEach(ol.events.unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_, this);\n    }\n    ol.interaction.Pointer.prototype.setMap.call(this, map);\n  \n    if (map) {\n      if (this.features_) {\n        keys.push(\n            ol.events.listen(this.features_, ol.CollectionEventType.ADD,\n                this.handleFeatureAdd_, this),\n            ol.events.listen(this.features_, ol.CollectionEventType.REMOVE,\n                this.handleFeatureRemove_, this)\n        );\n      } else if (this.source_) {\n        keys.push(\n            ol.events.listen(this.source_, ol.source.VectorEventType.ADDFEATURE,\n                this.handleFeatureAdd_, this),\n            ol.events.listen(this.source_, ol.source.VectorEventType.REMOVEFEATURE,\n                this.handleFeatureRemove_, this)\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_, this);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.Snap.prototype.shouldStopEvent = ol.functions.FALSE;\n  \n  \n  /**\n   * @param {ol.Pixel} pixel Pixel\n   * @param {ol.Coordinate} pixelCoordinate Coordinate\n   * @param {ol.PluggableMap} map Map.\n   * @return {ol.SnapResultType} Snap result\n   */\n  ol.interaction.Snap.prototype.snapTo = function(pixel, pixelCoordinate, map) {\n  \n    var lowerLeft = map.getCoordinateFromPixel(\n        [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel(\n        [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = ol.extent.boundingExtent([lowerLeft, upperRight]);\n  \n    var segments = this.rBush_.getInExtent(box);\n  \n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function(segment) {\n        return segment.feature.getGeometry().getType() !==\n            ol.geom.GeometryType.CIRCLE;\n      });\n    }\n  \n    var snappedToVertex = false;\n    var snapped = false;\n    var vertex = null;\n    var vertexPixel = null;\n    var dist, pixel1, pixel2, squaredDist1, squaredDist2;\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      var closestSegment = segments[0].segment;\n      var isCircle = segments[0].feature.getGeometry().getType() ===\n          ol.geom.GeometryType.CIRCLE;\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = ol.coordinate.squaredDistance(pixel, pixel1);\n        squaredDist2 = ol.coordinate.squaredDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ?\n            closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = ol.coordinate.closestOnCircle(pixelCoordinate,\n              /** @type {ol.geom.Circle} */ (segments[0].feature.getGeometry()));\n        } else {\n          vertex = (ol.coordinate.closestOnSegment(pixelCoordinate,\n              closestSegment));\n        }\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n        if (ol.coordinate.distance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = ol.coordinate.squaredDistance(vertexPixel, pixel1);\n            squaredDist2 = ol.coordinate.squaredDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ?\n                closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n    return /** @type {ol.SnapResultType} */ ({\n      snapped: snapped,\n      vertex: vertex,\n      vertexPixel: vertexPixel\n    });\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @private\n   */\n  ol.interaction.Snap.prototype.updateFeature_ = function(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.Circle} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Snap.prototype.writeCircleGeometry_ = function(feature, geometry) {\n    var polygon = ol.geom.Polygon.fromCircle(geometry);\n    var coordinates = polygon.getCoordinates()[0];\n    var i, ii, segment, segmentData;\n    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segment = coordinates.slice(i, i + 2);\n      segmentData = /** @type {ol.SnapSegmentDataType} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.GeometryCollection} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Snap.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {\n    var i, geometries = geometry.getGeometriesArray();\n    for (i = 0; i < geometries.length; ++i) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter.call(this, feature, geometries[i]);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.LineString} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Snap.prototype.writeLineStringGeometry_ = function(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var i, ii, segment, segmentData;\n    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segment = coordinates.slice(i, i + 2);\n      segmentData = /** @type {ol.SnapSegmentDataType} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.MultiLineString} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Snap.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {\n    var lines = geometry.getCoordinates();\n    var coordinates, i, ii, j, jj, segment, segmentData;\n    for (j = 0, jj = lines.length; j < jj; ++j) {\n      coordinates = lines[j];\n      for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segment = coordinates.slice(i, i + 2);\n        segmentData = /** @type {ol.SnapSegmentDataType} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.MultiPoint} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Snap.prototype.writeMultiPointGeometry_ = function(feature, geometry) {\n    var points = geometry.getCoordinates();\n    var coordinates, i, ii, segmentData;\n    for (i = 0, ii = points.length; i < ii; ++i) {\n      coordinates = points[i];\n      segmentData = /** @type {ol.SnapSegmentDataType} */ ({\n        feature: feature,\n        segment: [coordinates, coordinates]\n      });\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.MultiPolygon} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Snap.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {\n    var polygons = geometry.getCoordinates();\n    var coordinates, i, ii, j, jj, k, kk, rings, segment, segmentData;\n    for (k = 0, kk = polygons.length; k < kk; ++k) {\n      rings = polygons[k];\n      for (j = 0, jj = rings.length; j < jj; ++j) {\n        coordinates = rings[j];\n        for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segment = coordinates.slice(i, i + 2);\n          segmentData = /** @type {ol.SnapSegmentDataType} */ ({\n            feature: feature,\n            segment: segment\n          });\n          this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.Point} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Snap.prototype.writePointGeometry_ = function(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData = /** @type {ol.SnapSegmentDataType} */ ({\n      feature: feature,\n      segment: [coordinates, coordinates]\n    });\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature\n   * @param {ol.geom.Polygon} geometry Geometry.\n   * @private\n   */\n  ol.interaction.Snap.prototype.writePolygonGeometry_ = function(feature, geometry) {\n    var rings = geometry.getCoordinates();\n    var coordinates, i, ii, j, jj, segment, segmentData;\n    for (j = 0, jj = rings.length; j < jj; ++j) {\n      coordinates = rings[j];\n      for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segment = coordinates.slice(i, i + 2);\n        segmentData = /** @type {ol.SnapSegmentDataType} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  \n  \n  /**\n   * Handle all pointer events events.\n   * @param {ol.MapBrowserEvent} evt A move event.\n   * @return {boolean} Pass the event to other interactions.\n   * @this {ol.interaction.Snap}\n   * @private\n   */\n  ol.interaction.Snap.handleEvent_ = function(evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return ol.interaction.Pointer.handleEvent.call(this, evt);\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} evt Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.Snap}\n   * @private\n   */\n  ol.interaction.Snap.handleUpEvent_ = function(evt) {\n    var featuresToUpdate = ol.obj.getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_, this);\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  };\n  \n  \n  /**\n   * Sort segments by distance, helper function\n   * @param {ol.SnapSegmentDataType} a The first segment data.\n   * @param {ol.SnapSegmentDataType} b The second segment data.\n   * @return {number} The difference in distance.\n   * @this {ol.interaction.Snap}\n   */\n  ol.interaction.Snap.sortByDistance = function(a, b) {\n    return ol.coordinate.squaredDistanceToSegment(\n        this.pixelCoordinate_, a.segment) -\n        ol.coordinate.squaredDistanceToSegment(\n            this.pixelCoordinate_, b.segment);\n  };\n  \n  goog.provide('ol.interaction.TranslateEventType');\n  \n  \n  /**\n   * @enum {string}\n   */\n  ol.interaction.TranslateEventType = {\n    /**\n     * Triggered upon feature translation start.\n     * @event ol.interaction.Translate.Event#translatestart\n     * @api\n     */\n    TRANSLATESTART: 'translatestart',\n    /**\n     * Triggered upon feature translation.\n     * @event ol.interaction.Translate.Event#translating\n     * @api\n     */\n    TRANSLATING: 'translating',\n    /**\n     * Triggered upon feature translation end.\n     * @event ol.interaction.Translate.Event#translateend\n     * @api\n     */\n    TRANSLATEEND: 'translateend'\n  };\n  \n  goog.provide('ol.interaction.Translate');\n  \n  goog.require('ol');\n  goog.require('ol.Collection');\n  goog.require('ol.Object');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.functions');\n  goog.require('ol.array');\n  goog.require('ol.interaction.Pointer');\n  goog.require('ol.interaction.Property');\n  goog.require('ol.interaction.TranslateEventType');\n  \n  \n  /**\n   * @classdesc\n   * Interaction for translating (moving) features.\n   *\n   * @constructor\n   * @extends {ol.interaction.Pointer}\n   * @fires ol.interaction.Translate.Event\n   * @param {olx.interaction.TranslateOptions=} opt_options Options.\n   * @api\n   */\n  ol.interaction.Translate = function(opt_options) {\n    ol.interaction.Pointer.call(this, {\n      handleDownEvent: ol.interaction.Translate.handleDownEvent_,\n      handleDragEvent: ol.interaction.Translate.handleDragEvent_,\n      handleMoveEvent: ol.interaction.Translate.handleMoveEvent_,\n      handleUpEvent: ol.interaction.Translate.handleUpEvent_\n    });\n  \n    var options = opt_options ? opt_options : {};\n  \n    /**\n     * The last position we translated to.\n     * @type {ol.Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = null;\n  \n  \n    /**\n     * @type {ol.Collection.<ol.Feature>}\n     * @private\n     */\n    this.features_ = options.features !== undefined ? options.features : null;\n  \n    /** @type {function(ol.layer.Layer): boolean} */\n    var layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        var layers = options.layers;\n        layerFilter = function(layer) {\n          return ol.array.includes(layers, layer);\n        };\n      }\n    } else {\n      layerFilter = ol.functions.TRUE;\n    }\n  \n    /**\n     * @private\n     * @type {function(ol.layer.Layer): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n  \n    /**\n     * @type {ol.Feature}\n     * @private\n     */\n    this.lastFeature_ = null;\n  \n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.interaction.Property.ACTIVE),\n        this.handleActiveChanged_, this);\n  \n  };\n  ol.inherits(ol.interaction.Translate, ol.interaction.Pointer);\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} event Event.\n   * @return {boolean} Start drag sequence?\n   * @this {ol.interaction.Translate}\n   * @private\n   */\n  ol.interaction.Translate.handleDownEvent_ = function(event) {\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n    if (!this.lastCoordinate_ && this.lastFeature_) {\n      this.lastCoordinate_ = event.coordinate;\n      ol.interaction.Translate.handleMoveEvent_.call(this, event);\n  \n      var features = this.features_ || new ol.Collection([this.lastFeature_]);\n  \n      this.dispatchEvent(\n          new ol.interaction.Translate.Event(\n              ol.interaction.TranslateEventType.TRANSLATESTART, features,\n              event.coordinate));\n      return true;\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} event Event.\n   * @return {boolean} Stop drag sequence?\n   * @this {ol.interaction.Translate}\n   * @private\n   */\n  ol.interaction.Translate.handleUpEvent_ = function(event) {\n    if (this.lastCoordinate_) {\n      this.lastCoordinate_ = null;\n      ol.interaction.Translate.handleMoveEvent_.call(this, event);\n  \n      var features = this.features_ || new ol.Collection([this.lastFeature_]);\n  \n      this.dispatchEvent(\n          new ol.interaction.Translate.Event(\n              ol.interaction.TranslateEventType.TRANSLATEEND, features,\n              event.coordinate));\n      return true;\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserPointerEvent} event Event.\n   * @this {ol.interaction.Translate}\n   * @private\n   */\n  ol.interaction.Translate.handleDragEvent_ = function(event) {\n    if (this.lastCoordinate_) {\n      var newCoordinate = event.coordinate;\n      var deltaX = newCoordinate[0] - this.lastCoordinate_[0];\n      var deltaY = newCoordinate[1] - this.lastCoordinate_[1];\n  \n      var features = this.features_ || new ol.Collection([this.lastFeature_]);\n  \n      features.forEach(function(feature) {\n        var geom = feature.getGeometry();\n        geom.translate(deltaX, deltaY);\n        feature.setGeometry(geom);\n      });\n  \n      this.lastCoordinate_ = newCoordinate;\n      this.dispatchEvent(\n          new ol.interaction.Translate.Event(\n              ol.interaction.TranslateEventType.TRANSLATING, features,\n              newCoordinate));\n    }\n  };\n  \n  \n  /**\n   * @param {ol.MapBrowserEvent} event Event.\n   * @this {ol.interaction.Translate}\n   * @private\n   */\n  ol.interaction.Translate.handleMoveEvent_ = function(event) {\n    var elem = event.map.getViewport();\n  \n    // Change the cursor to grab/grabbing if hovering any of the features managed\n    // by the interaction\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n    } else {\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  };\n  \n  \n  /**\n   * Tests to see if the given coordinates intersects any of our selected\n   * features.\n   * @param {ol.Pixel} pixel Pixel coordinate to test for intersection.\n   * @param {ol.PluggableMap} map Map to test the intersection on.\n   * @return {ol.Feature} Returns the feature found at the specified pixel\n   * coordinates.\n   * @private\n   */\n  ol.interaction.Translate.prototype.featuresAtPixel_ = function(pixel, map) {\n    return map.forEachFeatureAtPixel(pixel,\n        function(feature) {\n          if (!this.features_ ||\n              ol.array.includes(this.features_.getArray(), feature)) {\n            return feature;\n          }\n        }.bind(this), {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_\n        });\n  };\n  \n  \n  /**\n   * Returns the Hit-detection tolerance.\n   * @returns {number} Hit tolerance in pixels.\n   * @api\n   */\n  ol.interaction.Translate.prototype.getHitTolerance = function() {\n    return this.hitTolerance_;\n  };\n  \n  \n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features. This only works for the canvas renderer and\n   * not for WebGL.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  ol.interaction.Translate.prototype.setHitTolerance = function(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.interaction.Translate.prototype.setMap = function(map) {\n    var oldMap = this.getMap();\n    ol.interaction.Pointer.prototype.setMap.call(this, map);\n    this.updateState_(oldMap);\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.interaction.Translate.prototype.handleActiveChanged_ = function() {\n    this.updateState_(null);\n  };\n  \n  \n  /**\n   * @param {ol.PluggableMap} oldMap Old map.\n   * @private\n   */\n  ol.interaction.Translate.prototype.updateState_ = function(oldMap) {\n    var map = this.getMap();\n    var active = this.getActive();\n    if (!map || !active) {\n      map = map || oldMap;\n      if (map) {\n        var elem = map.getViewport();\n        elem.classList.remove('ol-grab', 'ol-grabbing');\n      }\n    }\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.interaction.Translate} instances are instances of\n   * this type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.interaction.TranslateEvent}\n   * @param {ol.interaction.TranslateEventType} type Type.\n   * @param {ol.Collection.<ol.Feature>} features The features translated.\n   * @param {ol.Coordinate} coordinate The event coordinate.\n   */\n  ol.interaction.Translate.Event = function(type, features, coordinate) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The features being translated.\n     * @type {ol.Collection.<ol.Feature>}\n     * @api\n     */\n    this.features = features;\n  \n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {ol.Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n  };\n  ol.inherits(ol.interaction.Translate.Event, ol.events.Event);\n  \n  goog.provide('ol.layer.Heatmap');\n  \n  goog.require('ol.events');\n  goog.require('ol');\n  goog.require('ol.Object');\n  goog.require('ol.dom');\n  goog.require('ol.layer.Vector');\n  goog.require('ol.math');\n  goog.require('ol.obj');\n  goog.require('ol.render.EventType');\n  goog.require('ol.style.Icon');\n  goog.require('ol.style.Style');\n  \n  \n  /**\n   * @classdesc\n   * Layer for rendering vector data as a heatmap.\n   * Note that any property set in the options is set as a {@link ol.Object}\n   * property on the layer object; for example, setting `title: 'My Title'` in the\n   * options means that `title` is observable, and has get/set accessors.\n   *\n   * @constructor\n   * @extends {ol.layer.Vector}\n   * @fires ol.render.Event\n   * @param {olx.layer.HeatmapOptions=} opt_options Options.\n   * @api\n   */\n  ol.layer.Heatmap = function(opt_options) {\n    var options = opt_options ? opt_options : {};\n  \n    var baseOptions = ol.obj.assign({}, options);\n  \n    delete baseOptions.gradient;\n    delete baseOptions.radius;\n    delete baseOptions.blur;\n    delete baseOptions.shadow;\n    delete baseOptions.weight;\n    ol.layer.Vector.call(this, /** @type {olx.layer.VectorOptions} */ (baseOptions));\n  \n    /**\n     * @private\n     * @type {Uint8ClampedArray}\n     */\n    this.gradient_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.shadow_ = options.shadow !== undefined ? options.shadow : 250;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.circleImage_ = undefined;\n  \n    /**\n     * @private\n     * @type {Array.<Array.<ol.style.Style>>}\n     */\n    this.styleCache_ = null;\n  \n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.GRADIENT),\n        this.handleGradientChanged_, this);\n  \n    this.setGradient(options.gradient ?\n      options.gradient : ol.layer.Heatmap.DEFAULT_GRADIENT);\n  \n    this.setBlur(options.blur !== undefined ? options.blur : 15);\n  \n    this.setRadius(options.radius !== undefined ? options.radius : 8);\n  \n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.BLUR),\n        this.handleStyleChanged_, this);\n    ol.events.listen(this,\n        ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.RADIUS),\n        this.handleStyleChanged_, this);\n  \n    this.handleStyleChanged_();\n  \n    var weight = options.weight ? options.weight : 'weight';\n    var weightFunction;\n    if (typeof weight === 'string') {\n      weightFunction = function(feature) {\n        return feature.get(weight);\n      };\n    } else {\n      weightFunction = weight;\n    }\n  \n    this.setStyle(function(feature, resolution) {\n      var weight = weightFunction(feature);\n      var opacity = weight !== undefined ? ol.math.clamp(weight, 0, 1) : 1;\n      // cast to 8 bits\n      var index = (255 * opacity) | 0;\n      var style = this.styleCache_[index];\n      if (!style) {\n        style = [\n          new ol.style.Style({\n            image: new ol.style.Icon({\n              opacity: opacity,\n              src: this.circleImage_\n            })\n          })\n        ];\n        this.styleCache_[index] = style;\n      }\n      return style;\n    }.bind(this));\n  \n    // For performance reasons, don't sort the features before rendering.\n    // The render order is not relevant for a heatmap representation.\n    this.setRenderOrder(null);\n  \n    ol.events.listen(this, ol.render.EventType.RENDER, this.handleRender_, this);\n  };\n  ol.inherits(ol.layer.Heatmap, ol.layer.Vector);\n  \n  \n  /**\n   * @const\n   * @type {Array.<string>}\n   */\n  ol.layer.Heatmap.DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n  \n  \n  /**\n   * @param {Array.<string>} colors A list of colored.\n   * @return {Uint8ClampedArray} An array.\n   * @private\n   */\n  ol.layer.Heatmap.createGradient_ = function(colors) {\n    var width = 1;\n    var height = 256;\n    var context = ol.dom.createCanvasContext2D(width, height);\n  \n    var gradient = context.createLinearGradient(0, 0, width, height);\n    var step = 1 / (colors.length - 1);\n    for (var i = 0, ii = colors.length; i < ii; ++i) {\n      gradient.addColorStop(i * step, colors[i]);\n    }\n  \n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n  \n    return context.getImageData(0, 0, width, height).data;\n  };\n  \n  \n  /**\n   * @return {string} Data URL for a circle.\n   * @private\n   */\n  ol.layer.Heatmap.prototype.createCircle_ = function() {\n    var radius = this.getRadius();\n    var blur = this.getBlur();\n    var halfSize = radius + blur + 1;\n    var size = 2 * halfSize;\n    var context = ol.dom.createCanvasContext2D(size, size);\n    context.shadowOffsetX = context.shadowOffsetY = this.shadow_;\n    context.shadowBlur = blur;\n    context.shadowColor = '#000';\n    context.beginPath();\n    var center = halfSize - this.shadow_;\n    context.arc(center, center, radius, 0, Math.PI * 2, true);\n    context.fill();\n    return context.canvas.toDataURL();\n  };\n  \n  \n  /**\n   * Return the blur size in pixels.\n   * @return {number} Blur size in pixels.\n   * @api\n   * @observable\n   */\n  ol.layer.Heatmap.prototype.getBlur = function() {\n    return /** @type {number} */ (this.get(ol.layer.Heatmap.Property_.BLUR));\n  };\n  \n  \n  /**\n   * Return the gradient colors as array of strings.\n   * @return {Array.<string>} Colors.\n   * @api\n   * @observable\n   */\n  ol.layer.Heatmap.prototype.getGradient = function() {\n    return /** @type {Array.<string>} */ (\n      this.get(ol.layer.Heatmap.Property_.GRADIENT));\n  };\n  \n  \n  /**\n   * Return the size of the radius in pixels.\n   * @return {number} Radius size in pixel.\n   * @api\n   * @observable\n   */\n  ol.layer.Heatmap.prototype.getRadius = function() {\n    return /** @type {number} */ (this.get(ol.layer.Heatmap.Property_.RADIUS));\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.layer.Heatmap.prototype.handleGradientChanged_ = function() {\n    this.gradient_ = ol.layer.Heatmap.createGradient_(this.getGradient());\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.layer.Heatmap.prototype.handleStyleChanged_ = function() {\n    this.circleImage_ = this.createCircle_();\n    this.styleCache_ = new Array(256);\n    this.changed();\n  };\n  \n  \n  /**\n   * @param {ol.render.Event} event Post compose event\n   * @private\n   */\n  ol.layer.Heatmap.prototype.handleRender_ = function(event) {\n    var context = event.context;\n    var canvas = context.canvas;\n    var image = context.getImageData(0, 0, canvas.width, canvas.height);\n    var view8 = image.data;\n    var i, ii, alpha;\n    for (i = 0, ii = view8.length; i < ii; i += 4) {\n      alpha = view8[i + 3] * 4;\n      if (alpha) {\n        view8[i] = this.gradient_[alpha];\n        view8[i + 1] = this.gradient_[alpha + 1];\n        view8[i + 2] = this.gradient_[alpha + 2];\n      }\n    }\n    context.putImageData(image, 0, 0);\n  };\n  \n  \n  /**\n   * Set the blur size in pixels.\n   * @param {number} blur Blur size in pixels.\n   * @api\n   * @observable\n   */\n  ol.layer.Heatmap.prototype.setBlur = function(blur) {\n    this.set(ol.layer.Heatmap.Property_.BLUR, blur);\n  };\n  \n  \n  /**\n   * Set the gradient colors as array of strings.\n   * @param {Array.<string>} colors Gradient.\n   * @api\n   * @observable\n   */\n  ol.layer.Heatmap.prototype.setGradient = function(colors) {\n    this.set(ol.layer.Heatmap.Property_.GRADIENT, colors);\n  };\n  \n  \n  /**\n   * Set the size of the radius in pixels.\n   * @param {number} radius Radius size in pixel.\n   * @api\n   * @observable\n   */\n  ol.layer.Heatmap.prototype.setRadius = function(radius) {\n    this.set(ol.layer.Heatmap.Property_.RADIUS, radius);\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.layer.Heatmap.Property_ = {\n    BLUR: 'blur',\n    GRADIENT: 'gradient',\n    RADIUS: 'radius'\n  };\n  \n  goog.provide('ol.layer.Image');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.layer.Layer');\n  \n  \n  /**\n   * @classdesc\n   * Server-rendered images that are available for arbitrary extents and\n   * resolutions.\n   * Note that any property set in the options is set as a {@link ol.Object}\n   * property on the layer object; for example, setting `title: 'My Title'` in the\n   * options means that `title` is observable, and has get/set accessors.\n   *\n   * @constructor\n   * @extends {ol.layer.Layer}\n   * @fires ol.render.Event\n   * @param {olx.layer.ImageOptions=} opt_options Layer options.\n   * @api\n   */\n  ol.layer.Image = function(opt_options) {\n    var options = opt_options ? opt_options : {};\n    ol.layer.Layer.call(this,  /** @type {olx.layer.LayerOptions} */ (options));\n  \n    /**\n     * The layer type.\n     * @protected\n     * @type {ol.LayerType}\n     */\n    this.type = ol.LayerType.IMAGE;\n  \n  };\n  ol.inherits(ol.layer.Image, ol.layer.Layer);\n  \n  \n  /**\n   * Return the associated {@link ol.source.Image source} of the image layer.\n   * @function\n   * @return {ol.source.Image} Source.\n   * @api\n   */\n  ol.layer.Image.prototype.getSource;\n  \n  goog.provide('ol.layer.TileProperty');\n  \n  /**\n   * @enum {string}\n   */\n  ol.layer.TileProperty = {\n    PRELOAD: 'preload',\n    USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'\n  };\n  \n  goog.provide('ol.layer.Tile');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.layer.Layer');\n  goog.require('ol.layer.TileProperty');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * @classdesc\n   * For layer sources that provide pre-rendered, tiled images in grids that are\n   * organized by zoom levels for specific resolutions.\n   * Note that any property set in the options is set as a {@link ol.Object}\n   * property on the layer object; for example, setting `title: 'My Title'` in the\n   * options means that `title` is observable, and has get/set accessors.\n   *\n   * @constructor\n   * @extends {ol.layer.Layer}\n   * @fires ol.render.Event\n   * @param {olx.layer.TileOptions=} opt_options Tile layer options.\n   * @api\n   */\n  ol.layer.Tile = function(opt_options) {\n    var options = opt_options ? opt_options : {};\n  \n    var baseOptions = ol.obj.assign({}, options);\n  \n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    ol.layer.Layer.call(this,  /** @type {olx.layer.LayerOptions} */ (baseOptions));\n  \n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ?\n      options.useInterimTilesOnError : true);\n  \n    /**\n     * The layer type.\n     * @protected\n     * @type {ol.LayerType}\n     */\n    this.type = ol.LayerType.TILE;\n  \n  };\n  ol.inherits(ol.layer.Tile, ol.layer.Layer);\n  \n  \n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  ol.layer.Tile.prototype.getPreload = function() {\n    return /** @type {number} */ (this.get(ol.layer.TileProperty.PRELOAD));\n  };\n  \n  \n  /**\n   * Return the associated {@link ol.source.Tile tilesource} of the layer.\n   * @function\n   * @return {ol.source.Tile} Source.\n   * @api\n   */\n  ol.layer.Tile.prototype.getSource;\n  \n  \n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  ol.layer.Tile.prototype.setPreload = function(preload) {\n    this.set(ol.layer.TileProperty.PRELOAD, preload);\n  };\n  \n  \n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  ol.layer.Tile.prototype.getUseInterimTilesOnError = function() {\n    return /** @type {boolean} */ (\n      this.get(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR));\n  };\n  \n  \n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  ol.layer.Tile.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {\n    this.set(\n        ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  };\n  \n  goog.provide('ol.layer.VectorTile');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.asserts');\n  goog.require('ol.layer.TileProperty');\n  goog.require('ol.layer.Vector');\n  goog.require('ol.layer.VectorTileRenderType');\n  goog.require('ol.obj');\n  \n  \n  /**\n   * @classdesc\n   * Layer for vector tile data that is rendered client-side.\n   * Note that any property set in the options is set as a {@link ol.Object}\n   * property on the layer object; for example, setting `title: 'My Title'` in the\n   * options means that `title` is observable, and has get/set accessors.\n   *\n   * @constructor\n   * @extends {ol.layer.Vector}\n   * @param {olx.layer.VectorTileOptions=} opt_options Options.\n   * @api\n   */\n  ol.layer.VectorTile = function(opt_options) {\n    var options = opt_options ? opt_options : {};\n  \n    var renderMode = options.renderMode || ol.layer.VectorTileRenderType.HYBRID;\n    ol.asserts.assert(renderMode == undefined ||\n        renderMode == ol.layer.VectorTileRenderType.IMAGE ||\n        renderMode == ol.layer.VectorTileRenderType.HYBRID ||\n        renderMode == ol.layer.VectorTileRenderType.VECTOR,\n    28); // `renderMode` must be `'image'`, `'hybrid'` or `'vector'`\n    if (options.declutter && renderMode == ol.layer.VectorTileRenderType.IMAGE) {\n      renderMode = ol.layer.VectorTileRenderType.HYBRID;\n    }\n    options.renderMode = renderMode;\n  \n    var baseOptions = ol.obj.assign({}, options);\n  \n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    ol.layer.Vector.call(this,  /** @type {olx.layer.VectorOptions} */ (baseOptions));\n  \n    this.setPreload(options.preload ? options.preload : 0);\n    this.setUseInterimTilesOnError(options.useInterimTilesOnError ?\n      options.useInterimTilesOnError : true);\n  \n    /**\n     * The layer type.\n     * @protected\n     * @type {ol.LayerType}\n     */\n    this.type = ol.LayerType.VECTOR_TILE;\n  \n  };\n  ol.inherits(ol.layer.VectorTile, ol.layer.Vector);\n  \n  \n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  ol.layer.VectorTile.prototype.getPreload = function() {\n    return /** @type {number} */ (this.get(ol.layer.TileProperty.PRELOAD));\n  };\n  \n  \n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  ol.layer.VectorTile.prototype.getUseInterimTilesOnError = function() {\n    return /** @type {boolean} */ (\n      this.get(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR));\n  };\n  \n  \n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  ol.layer.VectorTile.prototype.setPreload = function(preload) {\n    this.set(ol.layer.TileProperty.PRELOAD, preload);\n  };\n  \n  \n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  ol.layer.VectorTile.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {\n    this.set(\n        ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  };\n  \n  \n  /**\n   * Return the associated {@link ol.source.VectorTile vectortilesource} of the layer.\n   * @function\n   * @return {ol.source.VectorTile} Source.\n   * @api\n   */\n  ol.layer.VectorTile.prototype.getSource;\n  \n  goog.provide('ol.webgl.Shader');\n  \n  goog.require('ol.functions');\n  \n  \n  /**\n   * @constructor\n   * @abstract\n   * @param {string} source Source.\n   * @struct\n   */\n  ol.webgl.Shader = function(source) {\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.source_ = source;\n  \n  };\n  \n  \n  /**\n   * @abstract\n   * @return {number} Type.\n   */\n  ol.webgl.Shader.prototype.getType = function() {};\n  \n  \n  /**\n   * @return {string} Source.\n   */\n  ol.webgl.Shader.prototype.getSource = function() {\n    return this.source_;\n  };\n  \n  \n  /**\n   * @return {boolean} Is animated?\n   */\n  ol.webgl.Shader.prototype.isAnimated = ol.functions.FALSE;\n  \n  goog.provide('ol.webgl.Fragment');\n  \n  goog.require('ol');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Shader');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.webgl.Shader}\n   * @param {string} source Source.\n   * @struct\n   */\n  ol.webgl.Fragment = function(source) {\n    ol.webgl.Shader.call(this, source);\n  };\n  ol.inherits(ol.webgl.Fragment, ol.webgl.Shader);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.webgl.Fragment.prototype.getType = function() {\n    return ol.webgl.FRAGMENT_SHADER;\n  };\n  \n  goog.provide('ol.webgl.Vertex');\n  \n  goog.require('ol');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Shader');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.webgl.Shader}\n   * @param {string} source Source.\n   * @struct\n   */\n  ol.webgl.Vertex = function(source) {\n    ol.webgl.Shader.call(this, source);\n  };\n  ol.inherits(ol.webgl.Vertex, ol.webgl.Shader);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.webgl.Vertex.prototype.getType = function() {\n    return ol.webgl.VERTEX_SHADER;\n  };\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.render.webgl.circlereplay.defaultshader');\n  \n  goog.require('ol');\n  goog.require('ol.webgl.Fragment');\n  goog.require('ol.webgl.Vertex');\n  \n  \n  ol.render.webgl.circlereplay.defaultshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ?\n    'precision mediump float;\\nvarying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\n\\nuniform float u_opacity;\\nuniform vec4 u_fillColor;\\nuniform vec4 u_strokeColor;\\nuniform vec2 u_size;\\n\\nvoid main(void) {\\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\\n  float radius = length(windowCenter - windowOffset);\\n  float dist = length(windowCenter - gl_FragCoord.xy);\\n  if (dist > radius + v_halfWidth) {\\n    if (u_strokeColor.a == 0.0) {\\n      gl_FragColor = u_fillColor;\\n    } else {\\n      gl_FragColor = u_strokeColor;\\n    }\\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\\n  } else if (u_fillColor.a == 0.0) {\\n    // Hooray, no fill, just stroke. We can use real antialiasing.\\n    gl_FragColor = u_strokeColor;\\n    if (dist < radius - v_halfWidth) {\\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\\n    }\\n  } else {\\n    gl_FragColor = u_fillColor;\\n    float strokeDist = radius - v_halfWidth;\\n    float antialias = 2.0 * v_pixelRatio;\\n    if (dist > strokeDist) {\\n      gl_FragColor = u_strokeColor;\\n    } else if (dist >= strokeDist - antialias) {\\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\\n    }\\n  }\\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\\n  if (gl_FragColor.a <= 0.0) {\\n    discard;\\n  }\\n}\\n' :\n    'precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}');\n  \n  ol.render.webgl.circlereplay.defaultshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ?\n    'varying vec2 v_center;\\nvarying vec2 v_offset;\\nvarying float v_halfWidth;\\nvarying float v_pixelRatio;\\n\\n\\nattribute vec2 a_position;\\nattribute float a_instruction;\\nattribute float a_radius;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_lineWidth;\\nuniform float u_pixelRatio;\\n\\nvoid main(void) {\\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\\n  v_pixelRatio = u_pixelRatio;\\n  float lineWidth = u_lineWidth * u_pixelRatio;\\n  v_halfWidth = lineWidth / 2.0;\\n  if (lineWidth == 0.0) {\\n    lineWidth = 2.0 * u_pixelRatio;\\n  }\\n  vec2 offset;\\n  // Radius with anitaliasing (roughly).\\n  float radius = a_radius + 3.0 * u_pixelRatio;\\n  // Until we get gl_VertexID in WebGL, we store an instruction.\\n  if (a_instruction == 0.0) {\\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\\n    offset = vec2(-1.0, 1.0);\\n  } else if (a_instruction == 1.0) {\\n    offset = vec2(-1.0, -1.0);\\n  } else if (a_instruction == 2.0) {\\n    offset = vec2(1.0, -1.0);\\n  } else {\\n    offset = vec2(1.0, 1.0);\\n  }\\n\\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\\n      0.0, 1.0)).xy;\\n\\n  if (distance(v_center, v_offset) > 20000.0) {\\n    gl_Position = vec4(v_center, 0.0, 1.0);\\n  }\\n}\\n\\n\\n' :\n    'varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;//Until we get gl_VertexID in WebGL,we store an instruction.if(f==0.0){//Offsetting the edges of the triangle by lineWidth/2 is necessary,however//we should also leave some space for the antialiasing,thus we offset by lineWidth.offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}');\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.render.webgl.circlereplay.defaultshader.Locations');\n  \n  goog.require('ol');\n  \n  \n  /**\n   * @constructor\n   * @param {WebGLRenderingContext} gl GL.\n   * @param {WebGLProgram} program Program.\n   * @struct\n   */\n  ol.render.webgl.circlereplay.defaultshader.Locations = function(gl, program) {\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_projectionMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_offsetScaleMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_offsetRotateMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_lineWidth = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_lineWidth' : 'k');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_pixelRatio = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_pixelRatio' : 'l');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_opacity = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_opacity' : 'm');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_fillColor = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_fillColor' : 'n');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_strokeColor = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_strokeColor' : 'o');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_size = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_size' : 'p');\n  \n    /**\n     * @type {number}\n     */\n    this.a_position = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_position' : 'e');\n  \n    /**\n     * @type {number}\n     */\n    this.a_instruction = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_instruction' : 'f');\n  \n    /**\n     * @type {number}\n     */\n    this.a_radius = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_radius' : 'g');\n  };\n  \n  goog.provide('ol.vec.Mat4');\n  \n  \n  /**\n   * @return {Array.<number>} 4x4 matrix representing a 3D identity transform.\n   */\n  ol.vec.Mat4.create = function() {\n    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n  };\n  \n  \n  /**\n   * @param {Array.<number>} mat4 Flattened 4x4 matrix receiving the result.\n   * @param {ol.Transform} transform Transformation matrix.\n   * @return {Array.<number>} 2D transformation matrix as flattened 4x4 matrix.\n   */\n  ol.vec.Mat4.fromTransform = function(mat4, transform) {\n    mat4[0] = transform[0];\n    mat4[1] = transform[1];\n    mat4[4] = transform[2];\n    mat4[5] = transform[3];\n    mat4[12] = transform[4];\n    mat4[13] = transform[5];\n    return mat4;\n  };\n  \n  goog.provide('ol.render.webgl.Replay');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.render.VectorContext');\n  goog.require('ol.transform');\n  goog.require('ol.vec.Mat4');\n  goog.require('ol.webgl');\n  \n  \n  /**\n   * @constructor\n   * @abstract\n   * @extends {ol.render.VectorContext}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @struct\n   */\n  ol.render.webgl.Replay = function(tolerance, maxExtent) {\n    ol.render.VectorContext.call(this);\n  \n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n  \n    /**\n     * @protected\n     * @const\n     * @type {ol.Extent}\n     */\n    this.maxExtent = maxExtent;\n  \n    /**\n     * The origin of the coordinate system for the point coordinates sent to\n     * the GPU. To eliminate jitter caused by precision problems in the GPU\n     * we use the \"Rendering Relative to Eye\" technique described in the \"3D\n     * Engine Design for Virtual Globes\" book.\n     * @protected\n     * @type {ol.Coordinate}\n     */\n    this.origin = ol.extent.getCenter(maxExtent);\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.projectionMatrix_ = ol.transform.create();\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.offsetRotateMatrix_ = ol.transform.create();\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.offsetScaleMatrix_ = ol.transform.create();\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.tmpMat4_ = ol.vec.Mat4.create();\n  \n    /**\n     * @protected\n     * @type {Array.<number>}\n     */\n    this.indices = [];\n  \n    /**\n     * @protected\n     * @type {?ol.webgl.Buffer}\n     */\n    this.indicesBuffer = null;\n  \n    /**\n     * Start index per feature (the index).\n     * @protected\n     * @type {Array.<number>}\n     */\n    this.startIndices = [];\n  \n    /**\n     * Start index per feature (the feature).\n     * @protected\n     * @type {Array.<ol.Feature|ol.render.Feature>}\n     */\n    this.startIndicesFeature = [];\n  \n    /**\n     * @protected\n     * @type {Array.<number>}\n     */\n    this.vertices = [];\n  \n    /**\n     * @protected\n     * @type {?ol.webgl.Buffer}\n     */\n    this.verticesBuffer = null;\n  \n    /**\n     * Optional parameter for PolygonReplay instances.\n     * @protected\n     * @type {ol.render.webgl.LineStringReplay|undefined}\n     */\n    this.lineStringReplay = undefined;\n  \n  };\n  ol.inherits(ol.render.webgl.Replay, ol.render.VectorContext);\n  \n  \n  /**\n   * @abstract\n   * @param {ol.webgl.Context} context WebGL context.\n   * @return {function()} Delete resources function.\n   */\n  ol.render.webgl.Replay.prototype.getDeleteResourcesFunction = function(context) {};\n  \n  \n  /**\n   * @abstract\n   * @param {ol.webgl.Context} context Context.\n   */\n  ol.render.webgl.Replay.prototype.finish = function(context) {};\n  \n  \n  /**\n   * @abstract\n   * @protected\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {ol.Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {ol.render.webgl.circlereplay.defaultshader.Locations|\n              ol.render.webgl.linestringreplay.defaultshader.Locations|\n              ol.render.webgl.polygonreplay.defaultshader.Locations|\n              ol.render.webgl.texturereplay.defaultshader.Locations} Locations.\n   */\n  ol.render.webgl.Replay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {};\n  \n  \n  /**\n   * @abstract\n   * @protected\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.render.webgl.circlereplay.defaultshader.Locations|\n             ol.render.webgl.linestringreplay.defaultshader.Locations|\n             ol.render.webgl.polygonreplay.defaultshader.Locations|\n             ol.render.webgl.texturereplay.defaultshader.Locations} locations Locations.\n   */\n  ol.render.webgl.Replay.prototype.shutDownProgram = function(gl, locations) {};\n  \n  \n  /**\n   * @abstract\n   * @protected\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @param {boolean} hitDetection Hit detection mode.\n   */\n  ol.render.webgl.Replay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {};\n  \n  \n  /**\n   * @abstract\n   * @protected\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.\n   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting\n   *  this extent are checked.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.webgl.Replay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {};\n  \n  \n  /**\n   * @protected\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.\n   * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.\n   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting\n   *  this extent are checked.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.webgl.Replay.prototype.drawHitDetectionReplay = function(gl, context, skippedFeaturesHash,\n      featureCallback, oneByOne, opt_hitExtent) {\n    if (!oneByOne) {\n      // draw all hit-detection features in \"once\" (by texture group)\n      return this.drawHitDetectionReplayAll(gl, context,\n          skippedFeaturesHash, featureCallback);\n    } else {\n      // draw hit-detection features one by one\n      return this.drawHitDetectionReplayOneByOne(gl, context,\n          skippedFeaturesHash, featureCallback, opt_hitExtent);\n    }\n  };\n  \n  \n  /**\n   * @protected\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.webgl.Replay.prototype.drawHitDetectionReplayAll = function(gl, context, skippedFeaturesHash,\n      featureCallback) {\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    this.drawReplay(gl, context, skippedFeaturesHash, true);\n  \n    var result = featureCallback(null);\n    if (result) {\n      return result;\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.webgl.Context} context Context.\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {ol.Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} opacity Global opacity.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.\n   * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.\n   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting\n   *  this extent are checked.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.webgl.Replay.prototype.replay = function(context,\n      center, resolution, rotation, size, pixelRatio,\n      opacity, skippedFeaturesHash,\n      featureCallback, oneByOne, opt_hitExtent) {\n    var gl = context.getGL();\n    var tmpStencil, tmpStencilFunc, tmpStencilMaskVal, tmpStencilRef, tmpStencilMask,\n        tmpStencilOpFail, tmpStencilOpPass, tmpStencilOpZFail;\n  \n    if (this.lineStringReplay) {\n      tmpStencil = gl.isEnabled(gl.STENCIL_TEST);\n      tmpStencilFunc = gl.getParameter(gl.STENCIL_FUNC);\n      tmpStencilMaskVal = gl.getParameter(gl.STENCIL_VALUE_MASK);\n      tmpStencilRef = gl.getParameter(gl.STENCIL_REF);\n      tmpStencilMask = gl.getParameter(gl.STENCIL_WRITEMASK);\n      tmpStencilOpFail = gl.getParameter(gl.STENCIL_FAIL);\n      tmpStencilOpPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);\n      tmpStencilOpZFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);\n  \n      gl.enable(gl.STENCIL_TEST);\n      gl.clear(gl.STENCIL_BUFFER_BIT);\n      gl.stencilMask(255);\n      gl.stencilFunc(gl.ALWAYS, 1, 255);\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n  \n      this.lineStringReplay.replay(context,\n          center, resolution, rotation, size, pixelRatio,\n          opacity, skippedFeaturesHash,\n          featureCallback, oneByOne, opt_hitExtent);\n  \n      gl.stencilMask(0);\n      gl.stencilFunc(gl.NOTEQUAL, 1, 255);\n    }\n  \n    context.bindBuffer(ol.webgl.ARRAY_BUFFER, this.verticesBuffer);\n  \n    context.bindBuffer(ol.webgl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n  \n    var locations = this.setUpProgram(gl, context, size, pixelRatio);\n  \n    // set the \"uniform\" values\n    var projectionMatrix = ol.transform.reset(this.projectionMatrix_);\n    ol.transform.scale(projectionMatrix, 2 / (resolution * size[0]), 2 / (resolution * size[1]));\n    ol.transform.rotate(projectionMatrix, -rotation);\n    ol.transform.translate(projectionMatrix, -(center[0] - this.origin[0]), -(center[1] - this.origin[1]));\n  \n    var offsetScaleMatrix = ol.transform.reset(this.offsetScaleMatrix_);\n    ol.transform.scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n  \n    var offsetRotateMatrix = ol.transform.reset(this.offsetRotateMatrix_);\n    if (rotation !== 0) {\n      ol.transform.rotate(offsetRotateMatrix, -rotation);\n    }\n  \n    gl.uniformMatrix4fv(locations.u_projectionMatrix, false,\n        ol.vec.Mat4.fromTransform(this.tmpMat4_, projectionMatrix));\n    gl.uniformMatrix4fv(locations.u_offsetScaleMatrix, false,\n        ol.vec.Mat4.fromTransform(this.tmpMat4_, offsetScaleMatrix));\n    gl.uniformMatrix4fv(locations.u_offsetRotateMatrix, false,\n        ol.vec.Mat4.fromTransform(this.tmpMat4_, offsetRotateMatrix));\n    gl.uniform1f(locations.u_opacity, opacity);\n  \n    // draw!\n    var result;\n    if (featureCallback === undefined) {\n      this.drawReplay(gl, context, skippedFeaturesHash, false);\n    } else {\n      // draw feature by feature for the hit-detection\n      result = this.drawHitDetectionReplay(gl, context, skippedFeaturesHash,\n          featureCallback, oneByOne, opt_hitExtent);\n    }\n  \n    // disable the vertex attrib arrays\n    this.shutDownProgram(gl, locations);\n  \n    if (this.lineStringReplay) {\n      if (!tmpStencil) {\n        gl.disable(gl.STENCIL_TEST);\n      }\n      gl.clear(gl.STENCIL_BUFFER_BIT);\n      gl.stencilFunc(/** @type {number} */ (tmpStencilFunc),\n          /** @type {number} */ (tmpStencilRef), /** @type {number} */ (tmpStencilMaskVal));\n      gl.stencilMask(/** @type {number} */ (tmpStencilMask));\n      gl.stencilOp(/** @type {number} */ (tmpStencilOpFail),\n          /** @type {number} */ (tmpStencilOpZFail), /** @type {number} */ (tmpStencilOpPass));\n    }\n  \n    return result;\n  };\n  \n  /**\n   * @protected\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {number} start Start index.\n   * @param {number} end End index.\n   */\n  ol.render.webgl.Replay.prototype.drawElements = function(\n      gl, context, start, end) {\n    var elementType = context.hasOESElementIndexUint ?\n      ol.webgl.UNSIGNED_INT : ol.webgl.UNSIGNED_SHORT;\n    var elementSize = context.hasOESElementIndexUint ? 4 : 2;\n  \n    var numItems = end - start;\n    var offsetInBytes = start * elementSize;\n    gl.drawElements(ol.webgl.TRIANGLES, numItems, elementType, offsetInBytes);\n  };\n  \n  goog.provide('ol.render.webgl');\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.render.webgl.defaultFont = '10px sans-serif';\n  \n  \n  /**\n   * @const\n   * @type {ol.Color}\n   */\n  ol.render.webgl.defaultFillStyle = [0.0, 0.0, 0.0, 1.0];\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.render.webgl.defaultLineCap = 'round';\n  \n  \n  /**\n   * @const\n   * @type {Array.<number>}\n   */\n  ol.render.webgl.defaultLineDash = [];\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.webgl.defaultLineDashOffset = 0;\n  \n  \n  /**\n   * @const\n   * @type {string}\n   */\n  ol.render.webgl.defaultLineJoin = 'round';\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.webgl.defaultMiterLimit = 10;\n  \n  /**\n   * @const\n   * @type {ol.Color}\n   */\n  ol.render.webgl.defaultStrokeStyle = [0.0, 0.0, 0.0, 1.0];\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.webgl.defaultTextAlign = 0.5;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.webgl.defaultTextBaseline = 0.5;\n  \n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.webgl.defaultLineWidth = 1;\n  \n  /**\n   * Calculates the orientation of a triangle based on the determinant method.\n   * @param {number} x1 First X coordinate.\n   * @param {number} y1 First Y coordinate.\n   * @param {number} x2 Second X coordinate.\n   * @param {number} y2 Second Y coordinate.\n   * @param {number} x3 Third X coordinate.\n   * @param {number} y3 Third Y coordinate.\n   * @return {boolean|undefined} Triangle is clockwise.\n   */\n  ol.render.webgl.triangleIsCounterClockwise = function(x1, y1, x2, y2, x3, y3) {\n    var area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n    return (area <= ol.render.webgl.EPSILON && area >= -ol.render.webgl.EPSILON) ?\n      undefined : area > 0;\n  };\n  \n  /**\n   * @const\n   * @type {number}\n   */\n  ol.render.webgl.EPSILON = Number.EPSILON || 2.220446049250313e-16;\n  \n  goog.provide('ol.webgl.Buffer');\n  \n  goog.require('ol.webgl');\n  \n  \n  /**\n   * @constructor\n   * @param {Array.<number>=} opt_arr Array.\n   * @param {number=} opt_usage Usage.\n   * @struct\n   */\n  ol.webgl.Buffer = function(opt_arr, opt_usage) {\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.arr_ = opt_arr !== undefined ? opt_arr : [];\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.usage_ = opt_usage !== undefined ?\n      opt_usage : ol.webgl.Buffer.Usage_.STATIC_DRAW;\n  \n  };\n  \n  \n  /**\n   * @return {Array.<number>} Array.\n   */\n  ol.webgl.Buffer.prototype.getArray = function() {\n    return this.arr_;\n  };\n  \n  \n  /**\n   * @return {number} Usage.\n   */\n  ol.webgl.Buffer.prototype.getUsage = function() {\n    return this.usage_;\n  };\n  \n  \n  /**\n   * @enum {number}\n   * @private\n   */\n  ol.webgl.Buffer.Usage_ = {\n    STATIC_DRAW: ol.webgl.STATIC_DRAW,\n    STREAM_DRAW: ol.webgl.STREAM_DRAW,\n    DYNAMIC_DRAW: ol.webgl.DYNAMIC_DRAW\n  };\n  \n  goog.provide('ol.render.webgl.CircleReplay');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.color');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.render.webgl.circlereplay.defaultshader');\n  goog.require('ol.render.webgl.circlereplay.defaultshader.Locations');\n  goog.require('ol.render.webgl.Replay');\n  goog.require('ol.render.webgl');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Buffer');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.webgl.Replay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @struct\n   */\n  ol.render.webgl.CircleReplay = function(tolerance, maxExtent) {\n    ol.render.webgl.Replay.call(this, tolerance, maxExtent);\n  \n    /**\n     * @private\n     * @type {ol.render.webgl.circlereplay.defaultshader.Locations}\n     */\n    this.defaultLocations_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<Array.<Array.<number>|number>>}\n     */\n    this.styles_ = [];\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.styleIndices_ = [];\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.radius_ = 0;\n  \n    /**\n     * @private\n     * @type {{fillColor: (Array.<number>|null),\n     *         strokeColor: (Array.<number>|null),\n     *         lineDash: Array.<number>,\n     *         lineDashOffset: (number|undefined),\n     *         lineWidth: (number|undefined),\n     *         changed: boolean}|null}\n     */\n    this.state_ = {\n      fillColor: null,\n      strokeColor: null,\n      lineDash: null,\n      lineDashOffset: undefined,\n      lineWidth: undefined,\n      changed: false\n    };\n  \n  };\n  ol.inherits(ol.render.webgl.CircleReplay, ol.render.webgl.Replay);\n  \n  \n  /**\n   * @private\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   */\n  ol.render.webgl.CircleReplay.prototype.drawCoordinates_ = function(\n      flatCoordinates, offset, end, stride) {\n    var numVertices = this.vertices.length;\n    var numIndices = this.indices.length;\n    var n = numVertices / 4;\n    var i, ii;\n    for (i = offset, ii = end; i < ii; i += stride) {\n      this.vertices[numVertices++] = flatCoordinates[i];\n      this.vertices[numVertices++] = flatCoordinates[i + 1];\n      this.vertices[numVertices++] = 0;\n      this.vertices[numVertices++] = this.radius_;\n  \n      this.vertices[numVertices++] = flatCoordinates[i];\n      this.vertices[numVertices++] = flatCoordinates[i + 1];\n      this.vertices[numVertices++] = 1;\n      this.vertices[numVertices++] = this.radius_;\n  \n      this.vertices[numVertices++] = flatCoordinates[i];\n      this.vertices[numVertices++] = flatCoordinates[i + 1];\n      this.vertices[numVertices++] = 2;\n      this.vertices[numVertices++] = this.radius_;\n  \n      this.vertices[numVertices++] = flatCoordinates[i];\n      this.vertices[numVertices++] = flatCoordinates[i + 1];\n      this.vertices[numVertices++] = 3;\n      this.vertices[numVertices++] = this.radius_;\n  \n      this.indices[numIndices++] = n;\n      this.indices[numIndices++] = n + 1;\n      this.indices[numIndices++] = n + 2;\n  \n      this.indices[numIndices++] = n + 2;\n      this.indices[numIndices++] = n + 3;\n      this.indices[numIndices++] = n;\n  \n      n += 4;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.CircleReplay.prototype.drawCircle = function(circleGeometry, feature) {\n    var radius = circleGeometry.getRadius();\n    var stride = circleGeometry.getStride();\n    if (radius) {\n      this.startIndices.push(this.indices.length);\n      this.startIndicesFeature.push(feature);\n      if (this.state_.changed) {\n        this.styleIndices_.push(this.indices.length);\n        this.state_.changed = false;\n      }\n  \n      this.radius_ = radius;\n      var flatCoordinates = circleGeometry.getFlatCoordinates();\n      flatCoordinates = ol.geom.flat.transform.translate(flatCoordinates, 0, 2,\n          stride, -this.origin[0], -this.origin[1]);\n      this.drawCoordinates_(flatCoordinates, 0, 2, stride);\n    } else {\n      if (this.state_.changed) {\n        this.styles_.pop();\n        if (this.styles_.length) {\n          var lastState = this.styles_[this.styles_.length - 1];\n          this.state_.fillColor =  /** @type {Array.<number>} */ (lastState[0]);\n          this.state_.strokeColor = /** @type {Array.<number>} */ (lastState[1]);\n          this.state_.lineWidth = /** @type {number} */ (lastState[2]);\n          this.state_.changed = false;\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   **/\n  ol.render.webgl.CircleReplay.prototype.finish = function(context) {\n    // create, bind, and populate the vertices buffer\n    this.verticesBuffer = new ol.webgl.Buffer(this.vertices);\n  \n    // create, bind, and populate the indices buffer\n    this.indicesBuffer = new ol.webgl.Buffer(this.indices);\n  \n    this.startIndices.push(this.indices.length);\n  \n    //Clean up, if there is nothing to draw\n    if (this.styleIndices_.length === 0 && this.styles_.length > 0) {\n      this.styles_ = [];\n    }\n  \n    this.vertices = null;\n    this.indices = null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.CircleReplay.prototype.getDeleteResourcesFunction = function(context) {\n    // We only delete our stuff here. The shaders and the program may\n    // be used by other CircleReplay instances (for other layers). And\n    // they will be deleted when disposing of the ol.webgl.Context\n    // object.\n    var verticesBuffer = this.verticesBuffer;\n    var indicesBuffer = this.indicesBuffer;\n    return function() {\n      context.deleteBuffer(verticesBuffer);\n      context.deleteBuffer(indicesBuffer);\n    };\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.CircleReplay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {\n    // get the program\n    var fragmentShader, vertexShader;\n    fragmentShader = ol.render.webgl.circlereplay.defaultshader.fragment;\n    vertexShader = ol.render.webgl.circlereplay.defaultshader.vertex;\n    var program = context.getProgram(fragmentShader, vertexShader);\n  \n    // get the locations\n    var locations;\n    if (!this.defaultLocations_) {\n      locations = new ol.render.webgl.circlereplay.defaultshader.Locations(gl, program);\n      this.defaultLocations_ = locations;\n    } else {\n      locations = this.defaultLocations_;\n    }\n  \n    context.useProgram(program);\n  \n    // enable the vertex attrib arrays\n    gl.enableVertexAttribArray(locations.a_position);\n    gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT,\n        false, 16, 0);\n  \n    gl.enableVertexAttribArray(locations.a_instruction);\n    gl.vertexAttribPointer(locations.a_instruction, 1, ol.webgl.FLOAT,\n        false, 16, 8);\n  \n    gl.enableVertexAttribArray(locations.a_radius);\n    gl.vertexAttribPointer(locations.a_radius, 1, ol.webgl.FLOAT,\n        false, 16, 12);\n  \n    // Enable renderer specific uniforms.\n    gl.uniform2fv(locations.u_size, size);\n    gl.uniform1f(locations.u_pixelRatio, pixelRatio);\n  \n    return locations;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.CircleReplay.prototype.shutDownProgram = function(gl, locations) {\n    gl.disableVertexAttribArray(locations.a_position);\n    gl.disableVertexAttribArray(locations.a_instruction);\n    gl.disableVertexAttribArray(locations.a_radius);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.CircleReplay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {\n    if (!ol.obj.isEmpty(skippedFeaturesHash)) {\n      this.drawReplaySkipping_(gl, context, skippedFeaturesHash);\n    } else {\n      //Draw by style groups to minimize drawElements() calls.\n      var i, start, end, nextStyle;\n      end = this.startIndices[this.startIndices.length - 1];\n      for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n        start = this.styleIndices_[i];\n        nextStyle = this.styles_[i];\n        this.setFillStyle_(gl, /** @type {Array.<number>} */ (nextStyle[0]));\n        this.setStrokeStyle_(gl, /** @type {Array.<number>} */ (nextStyle[1]),\n            /** @type {number} */ (nextStyle[2]));\n        this.drawElements(gl, context, start, end);\n        end = start;\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.CircleReplay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash,\n      featureCallback, opt_hitExtent) {\n    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;\n    featureIndex = this.startIndices.length - 2;\n    end = this.startIndices[featureIndex + 1];\n    for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n      nextStyle = this.styles_[i];\n      this.setFillStyle_(gl, /** @type {Array.<number>} */ (nextStyle[0]));\n      this.setStrokeStyle_(gl, /** @type {Array.<number>} */ (nextStyle[1]),\n          /** @type {number} */ (nextStyle[2]));\n      groupStart = this.styleIndices_[i];\n  \n      while (featureIndex >= 0 &&\n          this.startIndices[featureIndex] >= groupStart) {\n        start = this.startIndices[featureIndex];\n        feature = this.startIndicesFeature[featureIndex];\n        featureUid = ol.getUid(feature).toString();\n  \n        if (skippedFeaturesHash[featureUid] === undefined &&\n            feature.getGeometry() &&\n            (opt_hitExtent === undefined || ol.extent.intersects(\n                /** @type {Array<number>} */ (opt_hitExtent),\n                feature.getGeometry().getExtent()))) {\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n          this.drawElements(gl, context, start, end);\n  \n          var result = featureCallback(feature);\n  \n          if (result) {\n            return result;\n          }\n  \n        }\n        featureIndex--;\n        end = start;\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @private\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {Object} skippedFeaturesHash Ids of features to skip.\n   */\n  ol.render.webgl.CircleReplay.prototype.drawReplaySkipping_ = function(gl, context, skippedFeaturesHash) {\n    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;\n    featureIndex = this.startIndices.length - 2;\n    end = start = this.startIndices[featureIndex + 1];\n    for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n      nextStyle = this.styles_[i];\n      this.setFillStyle_(gl, /** @type {Array.<number>} */ (nextStyle[0]));\n      this.setStrokeStyle_(gl, /** @type {Array.<number>} */ (nextStyle[1]),\n          /** @type {number} */ (nextStyle[2]));\n      groupStart = this.styleIndices_[i];\n  \n      while (featureIndex >= 0 &&\n          this.startIndices[featureIndex] >= groupStart) {\n        featureStart = this.startIndices[featureIndex];\n        feature = this.startIndicesFeature[featureIndex];\n        featureUid = ol.getUid(feature).toString();\n  \n        if (skippedFeaturesHash[featureUid]) {\n          if (start !== end) {\n            this.drawElements(gl, context, start, end);\n          }\n          end = featureStart;\n        }\n        featureIndex--;\n        start = featureStart;\n      }\n      if (start !== end) {\n        this.drawElements(gl, context, start, end);\n      }\n      start = end = groupStart;\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {Array.<number>} color Color.\n   */\n  ol.render.webgl.CircleReplay.prototype.setFillStyle_ = function(gl, color) {\n    gl.uniform4fv(this.defaultLocations_.u_fillColor, color);\n  };\n  \n  \n  /**\n   * @private\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {Array.<number>} color Color.\n   * @param {number} lineWidth Line width.\n   */\n  ol.render.webgl.CircleReplay.prototype.setStrokeStyle_ = function(gl, color, lineWidth) {\n    gl.uniform4fv(this.defaultLocations_.u_strokeColor, color);\n    gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.CircleReplay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n    var strokeStyleColor, strokeStyleWidth;\n    if (strokeStyle) {\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      this.state_.lineDash = strokeStyleLineDash ?\n        strokeStyleLineDash : ol.render.webgl.defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      this.state_.lineDashOffset = strokeStyleLineDashOffset ?\n        strokeStyleLineDashOffset : ol.render.webgl.defaultLineDashOffset;\n      strokeStyleColor = strokeStyle.getColor();\n      if (!(strokeStyleColor instanceof CanvasGradient) &&\n          !(strokeStyleColor instanceof CanvasPattern)) {\n        strokeStyleColor = ol.color.asArray(strokeStyleColor).map(function(c, i) {\n          return i != 3 ? c / 255 : c;\n        }) || ol.render.webgl.defaultStrokeStyle;\n      } else {\n        strokeStyleColor = ol.render.webgl.defaultStrokeStyle;\n      }\n      strokeStyleWidth = strokeStyle.getWidth();\n      strokeStyleWidth = strokeStyleWidth !== undefined ?\n        strokeStyleWidth : ol.render.webgl.defaultLineWidth;\n    } else {\n      strokeStyleColor = [0, 0, 0, 0];\n      strokeStyleWidth = 0;\n    }\n    var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];\n    if (!(fillStyleColor instanceof CanvasGradient) &&\n        !(fillStyleColor instanceof CanvasPattern)) {\n      fillStyleColor = ol.color.asArray(fillStyleColor).map(function(c, i) {\n        return i != 3 ? c / 255 : c;\n      }) || ol.render.webgl.defaultFillStyle;\n    } else {\n      fillStyleColor = ol.render.webgl.defaultFillStyle;\n    }\n    if (!this.state_.strokeColor || !ol.array.equals(this.state_.strokeColor, strokeStyleColor) ||\n        !this.state_.fillColor || !ol.array.equals(this.state_.fillColor, fillStyleColor) ||\n        this.state_.lineWidth !== strokeStyleWidth) {\n      this.state_.changed = true;\n      this.state_.fillColor = fillStyleColor;\n      this.state_.strokeColor = strokeStyleColor;\n      this.state_.lineWidth = strokeStyleWidth;\n      this.styles_.push([fillStyleColor, strokeStyleColor, strokeStyleWidth]);\n    }\n  };\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.render.webgl.texturereplay.defaultshader');\n  \n  goog.require('ol');\n  goog.require('ol.webgl.Fragment');\n  goog.require('ol.webgl.Vertex');\n  \n  \n  ol.render.webgl.texturereplay.defaultshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ?\n    'precision mediump float;\\nvarying vec2 v_texCoord;\\nvarying float v_opacity;\\n\\nuniform float u_opacity;\\nuniform sampler2D u_image;\\n\\nvoid main(void) {\\n  vec4 texColor = texture2D(u_image, v_texCoord);\\n  gl_FragColor.rgb = texColor.rgb;\\n  float alpha = texColor.a * v_opacity * u_opacity;\\n  if (alpha == 0.0) {\\n    discard;\\n  }\\n  gl_FragColor.a = alpha;\\n}\\n' :\n    'precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');\n  \n  ol.render.webgl.texturereplay.defaultshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ?\n    'varying vec2 v_texCoord;\\nvarying float v_opacity;\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nattribute vec2 a_offsets;\\nattribute float a_opacity;\\nattribute float a_rotateWithView;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\n\\nvoid main(void) {\\n  mat4 offsetMatrix = u_offsetScaleMatrix;\\n  if (a_rotateWithView == 1.0) {\\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  }\\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  v_texCoord = a_texCoord;\\n  v_opacity = a_opacity;\\n}\\n\\n\\n' :\n    'varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.0,0.0);gl_Position=h*vec4(c,0.0,1.0)+offsets;a=d;b=f;}');\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.render.webgl.texturereplay.defaultshader.Locations');\n  \n  goog.require('ol');\n  \n  \n  /**\n   * @constructor\n   * @param {WebGLRenderingContext} gl GL.\n   * @param {WebGLProgram} program Program.\n   * @struct\n   */\n  ol.render.webgl.texturereplay.defaultshader.Locations = function(gl, program) {\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_projectionMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_offsetScaleMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_offsetRotateMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_opacity = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_opacity' : 'k');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_image = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_image' : 'l');\n  \n    /**\n     * @type {number}\n     */\n    this.a_position = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_position' : 'c');\n  \n    /**\n     * @type {number}\n     */\n    this.a_texCoord = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_texCoord' : 'd');\n  \n    /**\n     * @type {number}\n     */\n    this.a_offsets = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_offsets' : 'e');\n  \n    /**\n     * @type {number}\n     */\n    this.a_opacity = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_opacity' : 'f');\n  \n    /**\n     * @type {number}\n     */\n    this.a_rotateWithView = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_rotateWithView' : 'g');\n  };\n  \n  goog.provide('ol.webgl.ContextEventType');\n  \n  \n  /**\n   * @enum {string}\n   */\n  ol.webgl.ContextEventType = {\n    LOST: 'webglcontextlost',\n    RESTORED: 'webglcontextrestored'\n  };\n  \n  goog.provide('ol.webgl.Context');\n  \n  goog.require('ol');\n  goog.require('ol.Disposable');\n  goog.require('ol.array');\n  goog.require('ol.events');\n  goog.require('ol.obj');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.ContextEventType');\n  \n  \n  /**\n   * @classdesc\n   * A WebGL context for accessing low-level WebGL capabilities.\n   *\n   * @constructor\n   * @extends {ol.Disposable}\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {WebGLRenderingContext} gl GL.\n   */\n  ol.webgl.Context = function(canvas, gl) {\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = canvas;\n  \n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = gl;\n  \n    /**\n     * @private\n     * @type {Object.<string, ol.WebglBufferCacheEntry>}\n     */\n    this.bufferCache_ = {};\n  \n    /**\n     * @private\n     * @type {Object.<string, WebGLShader>}\n     */\n    this.shaderCache_ = {};\n  \n    /**\n     * @private\n     * @type {Object.<string, WebGLProgram>}\n     */\n    this.programCache_ = {};\n  \n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.currentProgram_ = null;\n  \n    /**\n     * @private\n     * @type {WebGLFramebuffer}\n     */\n    this.hitDetectionFramebuffer_ = null;\n  \n    /**\n     * @private\n     * @type {WebGLTexture}\n     */\n    this.hitDetectionTexture_ = null;\n  \n    /**\n     * @private\n     * @type {WebGLRenderbuffer}\n     */\n    this.hitDetectionRenderbuffer_ = null;\n  \n    /**\n     * @type {boolean}\n     */\n    this.hasOESElementIndexUint = ol.array.includes(\n        ol.WEBGL_EXTENSIONS, 'OES_element_index_uint');\n  \n    // use the OES_element_index_uint extension if available\n    if (this.hasOESElementIndexUint) {\n      gl.getExtension('OES_element_index_uint');\n    }\n  \n    ol.events.listen(this.canvas_, ol.webgl.ContextEventType.LOST,\n        this.handleWebGLContextLost, this);\n    ol.events.listen(this.canvas_, ol.webgl.ContextEventType.RESTORED,\n        this.handleWebGLContextRestored, this);\n  \n  };\n  ol.inherits(ol.webgl.Context, ol.Disposable);\n  \n  \n  /**\n   * Just bind the buffer if it's in the cache. Otherwise create\n   * the WebGL buffer, bind it, populate it, and add an entry to\n   * the cache.\n   * @param {number} target Target.\n   * @param {ol.webgl.Buffer} buf Buffer.\n   */\n  ol.webgl.Context.prototype.bindBuffer = function(target, buf) {\n    var gl = this.getGL();\n    var arr = buf.getArray();\n    var bufferKey = String(ol.getUid(buf));\n    if (bufferKey in this.bufferCache_) {\n      var bufferCacheEntry = this.bufferCache_[bufferKey];\n      gl.bindBuffer(target, bufferCacheEntry.buffer);\n    } else {\n      var buffer = gl.createBuffer();\n      gl.bindBuffer(target, buffer);\n      var /** @type {ArrayBufferView} */ arrayBuffer;\n      if (target == ol.webgl.ARRAY_BUFFER) {\n        arrayBuffer = new Float32Array(arr);\n      } else if (target == ol.webgl.ELEMENT_ARRAY_BUFFER) {\n        arrayBuffer = this.hasOESElementIndexUint ?\n          new Uint32Array(arr) : new Uint16Array(arr);\n      }\n      gl.bufferData(target, arrayBuffer, buf.getUsage());\n      this.bufferCache_[bufferKey] = {\n        buf: buf,\n        buffer: buffer\n      };\n    }\n  };\n  \n  \n  /**\n   * @param {ol.webgl.Buffer} buf Buffer.\n   */\n  ol.webgl.Context.prototype.deleteBuffer = function(buf) {\n    var gl = this.getGL();\n    var bufferKey = String(ol.getUid(buf));\n    var bufferCacheEntry = this.bufferCache_[bufferKey];\n    if (!gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.buffer);\n    }\n    delete this.bufferCache_[bufferKey];\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.webgl.Context.prototype.disposeInternal = function() {\n    ol.events.unlistenAll(this.canvas_);\n    var gl = this.getGL();\n    if (!gl.isContextLost()) {\n      var key;\n      for (key in this.bufferCache_) {\n        gl.deleteBuffer(this.bufferCache_[key].buffer);\n      }\n      for (key in this.programCache_) {\n        gl.deleteProgram(this.programCache_[key]);\n      }\n      for (key in this.shaderCache_) {\n        gl.deleteShader(this.shaderCache_[key]);\n      }\n      // delete objects for hit-detection\n      gl.deleteFramebuffer(this.hitDetectionFramebuffer_);\n      gl.deleteRenderbuffer(this.hitDetectionRenderbuffer_);\n      gl.deleteTexture(this.hitDetectionTexture_);\n    }\n  };\n  \n  \n  /**\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ol.webgl.Context.prototype.getCanvas = function() {\n    return this.canvas_;\n  };\n  \n  \n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   * @api\n   */\n  ol.webgl.Context.prototype.getGL = function() {\n    return this.gl_;\n  };\n  \n  \n  /**\n   * Get the frame buffer for hit detection.\n   * @return {WebGLFramebuffer} The hit detection frame buffer.\n   */\n  ol.webgl.Context.prototype.getHitDetectionFramebuffer = function() {\n    if (!this.hitDetectionFramebuffer_) {\n      this.initHitDetectionFramebuffer_();\n    }\n    return this.hitDetectionFramebuffer_;\n  };\n  \n  \n  /**\n   * Get shader from the cache if it's in the cache. Otherwise, create\n   * the WebGL shader, compile it, and add entry to cache.\n   * @param {ol.webgl.Shader} shaderObject Shader object.\n   * @return {WebGLShader} Shader.\n   */\n  ol.webgl.Context.prototype.getShader = function(shaderObject) {\n    var shaderKey = String(ol.getUid(shaderObject));\n    if (shaderKey in this.shaderCache_) {\n      return this.shaderCache_[shaderKey];\n    } else {\n      var gl = this.getGL();\n      var shader = gl.createShader(shaderObject.getType());\n      gl.shaderSource(shader, shaderObject.getSource());\n      gl.compileShader(shader);\n      this.shaderCache_[shaderKey] = shader;\n      return shader;\n    }\n  };\n  \n  \n  /**\n   * Get the program from the cache if it's in the cache. Otherwise create\n   * the WebGL program, attach the shaders to it, and add an entry to the\n   * cache.\n   * @param {ol.webgl.Fragment} fragmentShaderObject Fragment shader.\n   * @param {ol.webgl.Vertex} vertexShaderObject Vertex shader.\n   * @return {WebGLProgram} Program.\n   */\n  ol.webgl.Context.prototype.getProgram = function(\n      fragmentShaderObject, vertexShaderObject) {\n    var programKey =\n        ol.getUid(fragmentShaderObject) + '/' + ol.getUid(vertexShaderObject);\n    if (programKey in this.programCache_) {\n      return this.programCache_[programKey];\n    } else {\n      var gl = this.getGL();\n      var program = gl.createProgram();\n      gl.attachShader(program, this.getShader(fragmentShaderObject));\n      gl.attachShader(program, this.getShader(vertexShaderObject));\n      gl.linkProgram(program);\n      this.programCache_[programKey] = program;\n      return program;\n    }\n  };\n  \n  \n  /**\n   * FIXME empy description for jsdoc\n   */\n  ol.webgl.Context.prototype.handleWebGLContextLost = function() {\n    ol.obj.clear(this.bufferCache_);\n    ol.obj.clear(this.shaderCache_);\n    ol.obj.clear(this.programCache_);\n    this.currentProgram_ = null;\n    this.hitDetectionFramebuffer_ = null;\n    this.hitDetectionTexture_ = null;\n    this.hitDetectionRenderbuffer_ = null;\n  };\n  \n  \n  /**\n   * FIXME empy description for jsdoc\n   */\n  ol.webgl.Context.prototype.handleWebGLContextRestored = function() {\n  };\n  \n  \n  /**\n   * Creates a 1x1 pixel framebuffer for the hit-detection.\n   * @private\n   */\n  ol.webgl.Context.prototype.initHitDetectionFramebuffer_ = function() {\n    var gl = this.gl_;\n    var framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n  \n    var texture = ol.webgl.Context.createEmptyTexture(gl, 1, 1);\n    var renderbuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 1, 1);\n    gl.framebufferTexture2D(\n        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,\n        gl.RENDERBUFFER, renderbuffer);\n  \n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  \n    this.hitDetectionFramebuffer_ = framebuffer;\n    this.hitDetectionTexture_ = texture;\n    this.hitDetectionRenderbuffer_ = renderbuffer;\n  };\n  \n  \n  /**\n   * Use a program.  If the program is already in use, this will return `false`.\n   * @param {WebGLProgram} program Program.\n   * @return {boolean} Changed.\n   * @api\n   */\n  ol.webgl.Context.prototype.useProgram = function(program) {\n    if (program == this.currentProgram_) {\n      return false;\n    } else {\n      var gl = this.getGL();\n      gl.useProgram(program);\n      this.currentProgram_ = program;\n      return true;\n    }\n  };\n  \n  \n  /**\n   * @param {WebGLRenderingContext} gl WebGL rendering context.\n   * @param {number=} opt_wrapS wrapS.\n   * @param {number=} opt_wrapT wrapT.\n   * @return {WebGLTexture} The texture.\n   * @private\n   */\n  ol.webgl.Context.createTexture_ = function(gl, opt_wrapS, opt_wrapT) {\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  \n    if (opt_wrapS !== undefined) {\n      gl.texParameteri(\n          ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_WRAP_S, opt_wrapS);\n    }\n    if (opt_wrapT !== undefined) {\n      gl.texParameteri(\n          ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_WRAP_T, opt_wrapT);\n    }\n  \n    return texture;\n  };\n  \n  \n  /**\n   * @param {WebGLRenderingContext} gl WebGL rendering context.\n   * @param {number} width Width.\n   * @param {number} height Height.\n   * @param {number=} opt_wrapS wrapS.\n   * @param {number=} opt_wrapT wrapT.\n   * @return {WebGLTexture} The texture.\n   */\n  ol.webgl.Context.createEmptyTexture = function(\n      gl, width, height, opt_wrapS, opt_wrapT) {\n    var texture = ol.webgl.Context.createTexture_(gl, opt_wrapS, opt_wrapT);\n    gl.texImage2D(\n        gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE,\n        null);\n  \n    return texture;\n  };\n  \n  \n  /**\n   * @param {WebGLRenderingContext} gl WebGL rendering context.\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n   * @param {number=} opt_wrapS wrapS.\n   * @param {number=} opt_wrapT wrapT.\n   * @return {WebGLTexture} The texture.\n   */\n  ol.webgl.Context.createTexture = function(gl, image, opt_wrapS, opt_wrapT) {\n    var texture = ol.webgl.Context.createTexture_(gl, opt_wrapS, opt_wrapT);\n    gl.texImage2D(\n        gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n  \n    return texture;\n  };\n  \n  goog.provide('ol.render.webgl.TextureReplay');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.render.webgl.texturereplay.defaultshader');\n  goog.require('ol.render.webgl.texturereplay.defaultshader.Locations');\n  goog.require('ol.render.webgl.Replay');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Context');\n  \n  /**\n   * @constructor\n   * @abstract\n   * @extends {ol.render.webgl.Replay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @struct\n   */\n  ol.render.webgl.TextureReplay = function(tolerance, maxExtent) {\n    ol.render.webgl.Replay.call(this, tolerance, maxExtent);\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.anchorX = undefined;\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.anchorY = undefined;\n  \n    /**\n     * @type {Array.<number>}\n     * @protected\n     */\n    this.groupIndices = [];\n  \n    /**\n     * @type {Array.<number>}\n     * @protected\n     */\n    this.hitDetectionGroupIndices = [];\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.height = undefined;\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.imageHeight = undefined;\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.imageWidth = undefined;\n  \n    /**\n     * @protected\n     * @type {ol.render.webgl.texturereplay.defaultshader.Locations}\n     */\n    this.defaultLocations = null;\n  \n    /**\n     * @protected\n     * @type {number|undefined}\n     */\n    this.opacity = undefined;\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.originX = undefined;\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.originY = undefined;\n  \n    /**\n     * @protected\n     * @type {boolean|undefined}\n     */\n    this.rotateWithView = undefined;\n  \n    /**\n     * @protected\n     * @type {number|undefined}\n     */\n    this.rotation = undefined;\n  \n    /**\n     * @protected\n     * @type {number|undefined}\n     */\n    this.scale = undefined;\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.width = undefined;\n  };\n  ol.inherits(ol.render.webgl.TextureReplay, ol.render.webgl.Replay);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextureReplay.prototype.getDeleteResourcesFunction = function(context) {\n    var verticesBuffer = this.verticesBuffer;\n    var indicesBuffer = this.indicesBuffer;\n    var textures = this.getTextures(true);\n    var gl = context.getGL();\n    return function() {\n      if (!gl.isContextLost()) {\n        var i, ii;\n        for (i = 0, ii = textures.length; i < ii; ++i) {\n          gl.deleteTexture(textures[i]);\n        }\n      }\n      context.deleteBuffer(verticesBuffer);\n      context.deleteBuffer(indicesBuffer);\n    };\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {number} My end.\n   * @protected\n   */\n  ol.render.webgl.TextureReplay.prototype.drawCoordinates = function(flatCoordinates, offset, end, stride) {\n    var anchorX = /** @type {number} */ (this.anchorX);\n    var anchorY = /** @type {number} */ (this.anchorY);\n    var height = /** @type {number} */ (this.height);\n    var imageHeight = /** @type {number} */ (this.imageHeight);\n    var imageWidth = /** @type {number} */ (this.imageWidth);\n    var opacity = /** @type {number} */ (this.opacity);\n    var originX = /** @type {number} */ (this.originX);\n    var originY = /** @type {number} */ (this.originY);\n    var rotateWithView = this.rotateWithView ? 1.0 : 0.0;\n    // this.rotation_ is anti-clockwise, but rotation is clockwise\n    var rotation = /** @type {number} */ (-this.rotation);\n    var scale = /** @type {number} */ (this.scale);\n    var width = /** @type {number} */ (this.width);\n    var cos = Math.cos(rotation);\n    var sin = Math.sin(rotation);\n    var numIndices = this.indices.length;\n    var numVertices = this.vertices.length;\n    var i, n, offsetX, offsetY, x, y;\n    for (i = offset; i < end; i += stride) {\n      x = flatCoordinates[i] - this.origin[0];\n      y = flatCoordinates[i + 1] - this.origin[1];\n  \n      // There are 4 vertices per [x, y] point, one for each corner of the\n      // rectangle we're going to draw. We'd use 1 vertex per [x, y] point if\n      // WebGL supported Geometry Shaders (which can emit new vertices), but that\n      // is not currently the case.\n      //\n      // And each vertex includes 8 values: the x and y coordinates, the x and\n      // y offsets used to calculate the position of the corner, the u and\n      // v texture coordinates for the corner, the opacity, and whether the\n      // the image should be rotated with the view (rotateWithView).\n  \n      n = numVertices / 8;\n  \n      // bottom-left corner\n      offsetX = -scale * anchorX;\n      offsetY = -scale * (height - anchorY);\n      this.vertices[numVertices++] = x;\n      this.vertices[numVertices++] = y;\n      this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n      this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n      this.vertices[numVertices++] = originX / imageWidth;\n      this.vertices[numVertices++] = (originY + height) / imageHeight;\n      this.vertices[numVertices++] = opacity;\n      this.vertices[numVertices++] = rotateWithView;\n  \n      // bottom-right corner\n      offsetX = scale * (width - anchorX);\n      offsetY = -scale * (height - anchorY);\n      this.vertices[numVertices++] = x;\n      this.vertices[numVertices++] = y;\n      this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n      this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n      this.vertices[numVertices++] = (originX + width) / imageWidth;\n      this.vertices[numVertices++] = (originY + height) / imageHeight;\n      this.vertices[numVertices++] = opacity;\n      this.vertices[numVertices++] = rotateWithView;\n  \n      // top-right corner\n      offsetX = scale * (width - anchorX);\n      offsetY = scale * anchorY;\n      this.vertices[numVertices++] = x;\n      this.vertices[numVertices++] = y;\n      this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n      this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n      this.vertices[numVertices++] = (originX + width) / imageWidth;\n      this.vertices[numVertices++] = originY / imageHeight;\n      this.vertices[numVertices++] = opacity;\n      this.vertices[numVertices++] = rotateWithView;\n  \n      // top-left corner\n      offsetX = -scale * anchorX;\n      offsetY = scale * anchorY;\n      this.vertices[numVertices++] = x;\n      this.vertices[numVertices++] = y;\n      this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n      this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n      this.vertices[numVertices++] = originX / imageWidth;\n      this.vertices[numVertices++] = originY / imageHeight;\n      this.vertices[numVertices++] = opacity;\n      this.vertices[numVertices++] = rotateWithView;\n  \n      this.indices[numIndices++] = n;\n      this.indices[numIndices++] = n + 1;\n      this.indices[numIndices++] = n + 2;\n      this.indices[numIndices++] = n;\n      this.indices[numIndices++] = n + 2;\n      this.indices[numIndices++] = n + 3;\n    }\n  \n    return numVertices;\n  };\n  \n  \n  /**\n   * @protected\n   * @param {Array.<WebGLTexture>} textures Textures.\n   * @param {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>} images\n   *    Images.\n   * @param {Object.<string, WebGLTexture>} texturePerImage Texture cache.\n   * @param {WebGLRenderingContext} gl Gl.\n   */\n  ol.render.webgl.TextureReplay.prototype.createTextures = function(textures, images, texturePerImage, gl) {\n    var texture, image, uid, i;\n    var ii = images.length;\n    for (i = 0; i < ii; ++i) {\n      image = images[i];\n  \n      uid = ol.getUid(image).toString();\n      if (uid in texturePerImage) {\n        texture = texturePerImage[uid];\n      } else {\n        texture = ol.webgl.Context.createTexture(\n            gl, image, ol.webgl.CLAMP_TO_EDGE, ol.webgl.CLAMP_TO_EDGE);\n        texturePerImage[uid] = texture;\n      }\n      textures[i] = texture;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextureReplay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {\n    // get the program\n    var fragmentShader = ol.render.webgl.texturereplay.defaultshader.fragment;\n    var vertexShader = ol.render.webgl.texturereplay.defaultshader.vertex;\n    var program = context.getProgram(fragmentShader, vertexShader);\n  \n    // get the locations\n    var locations;\n    if (!this.defaultLocations) {\n      locations = new ol.render.webgl.texturereplay.defaultshader.Locations(gl, program);\n      this.defaultLocations = locations;\n    } else {\n      locations = this.defaultLocations;\n    }\n  \n    // use the program (FIXME: use the return value)\n    context.useProgram(program);\n  \n    // enable the vertex attrib arrays\n    gl.enableVertexAttribArray(locations.a_position);\n    gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT,\n        false, 32, 0);\n  \n    gl.enableVertexAttribArray(locations.a_offsets);\n    gl.vertexAttribPointer(locations.a_offsets, 2, ol.webgl.FLOAT,\n        false, 32, 8);\n  \n    gl.enableVertexAttribArray(locations.a_texCoord);\n    gl.vertexAttribPointer(locations.a_texCoord, 2, ol.webgl.FLOAT,\n        false, 32, 16);\n  \n    gl.enableVertexAttribArray(locations.a_opacity);\n    gl.vertexAttribPointer(locations.a_opacity, 1, ol.webgl.FLOAT,\n        false, 32, 24);\n  \n    gl.enableVertexAttribArray(locations.a_rotateWithView);\n    gl.vertexAttribPointer(locations.a_rotateWithView, 1, ol.webgl.FLOAT,\n        false, 32, 28);\n  \n    return locations;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextureReplay.prototype.shutDownProgram = function(gl, locations) {\n    gl.disableVertexAttribArray(locations.a_position);\n    gl.disableVertexAttribArray(locations.a_offsets);\n    gl.disableVertexAttribArray(locations.a_texCoord);\n    gl.disableVertexAttribArray(locations.a_opacity);\n    gl.disableVertexAttribArray(locations.a_rotateWithView);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextureReplay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {\n    var textures = hitDetection ? this.getHitDetectionTextures() : this.getTextures();\n    var groupIndices = hitDetection ? this.hitDetectionGroupIndices : this.groupIndices;\n  \n    if (!ol.obj.isEmpty(skippedFeaturesHash)) {\n      this.drawReplaySkipping(\n          gl, context, skippedFeaturesHash, textures, groupIndices);\n    } else {\n      var i, ii, start;\n      for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {\n        gl.bindTexture(ol.webgl.TEXTURE_2D, textures[i]);\n        var end = groupIndices[i];\n        this.drawElements(gl, context, start, end);\n        start = end;\n      }\n    }\n  };\n  \n  \n  /**\n   * Draw the replay while paying attention to skipped features.\n   *\n   * This functions creates groups of features that can be drawn to together,\n   * so that the number of `drawElements` calls is minimized.\n   *\n   * For example given the following texture groups:\n   *\n   *    Group 1: A B C\n   *    Group 2: D [E] F G\n   *\n   * If feature E should be skipped, the following `drawElements` calls will be\n   * made:\n   *\n   *    drawElements with feature A, B and C\n   *    drawElements with feature D\n   *    drawElements with feature F and G\n   *\n   * @protected\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @param {Array.<WebGLTexture>} textures Textures.\n   * @param {Array.<number>} groupIndices Texture group indices.\n   */\n  ol.render.webgl.TextureReplay.prototype.drawReplaySkipping = function(gl, context, skippedFeaturesHash, textures,\n      groupIndices) {\n    var featureIndex = 0;\n  \n    var i, ii;\n    for (i = 0, ii = textures.length; i < ii; ++i) {\n      gl.bindTexture(ol.webgl.TEXTURE_2D, textures[i]);\n      var groupStart = (i > 0) ? groupIndices[i - 1] : 0;\n      var groupEnd = groupIndices[i];\n  \n      var start = groupStart;\n      var end = groupStart;\n      while (featureIndex < this.startIndices.length &&\n          this.startIndices[featureIndex] <= groupEnd) {\n        var feature = this.startIndicesFeature[featureIndex];\n  \n        var featureUid = ol.getUid(feature).toString();\n        if (skippedFeaturesHash[featureUid] !== undefined) {\n          // feature should be skipped\n          if (start !== end) {\n            // draw the features so far\n            this.drawElements(gl, context, start, end);\n          }\n          // continue with the next feature\n          start = (featureIndex === this.startIndices.length - 1) ?\n            groupEnd : this.startIndices[featureIndex + 1];\n          end = start;\n        } else {\n          // the feature is not skipped, augment the end index\n          end = (featureIndex === this.startIndices.length - 1) ?\n            groupEnd : this.startIndices[featureIndex + 1];\n        }\n        featureIndex++;\n      }\n  \n      if (start !== end) {\n        // draw the remaining features (in case there was no skipped feature\n        // in this texture group, all features of a group are drawn together)\n        this.drawElements(gl, context, start, end);\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextureReplay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash,\n      featureCallback, opt_hitExtent) {\n    var i, groupStart, start, end, feature, featureUid;\n    var featureIndex = this.startIndices.length - 1;\n    var hitDetectionTextures = this.getHitDetectionTextures();\n    for (i = hitDetectionTextures.length - 1; i >= 0; --i) {\n      gl.bindTexture(ol.webgl.TEXTURE_2D, hitDetectionTextures[i]);\n      groupStart = (i > 0) ? this.hitDetectionGroupIndices[i - 1] : 0;\n      end = this.hitDetectionGroupIndices[i];\n  \n      // draw all features for this texture group\n      while (featureIndex >= 0 &&\n          this.startIndices[featureIndex] >= groupStart) {\n        start = this.startIndices[featureIndex];\n        feature = this.startIndicesFeature[featureIndex];\n        featureUid = ol.getUid(feature).toString();\n  \n        if (skippedFeaturesHash[featureUid] === undefined &&\n            feature.getGeometry() &&\n            (opt_hitExtent === undefined || ol.extent.intersects(\n                /** @type {Array<number>} */ (opt_hitExtent),\n                feature.getGeometry().getExtent()))) {\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n          this.drawElements(gl, context, start, end);\n  \n          var result = featureCallback(feature);\n          if (result) {\n            return result;\n          }\n        }\n  \n        end = start;\n        featureIndex--;\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextureReplay.prototype.finish = function(context) {\n    this.anchorX = undefined;\n    this.anchorY = undefined;\n    this.height = undefined;\n    this.imageHeight = undefined;\n    this.imageWidth = undefined;\n    this.indices = null;\n    this.opacity = undefined;\n    this.originX = undefined;\n    this.originY = undefined;\n    this.rotateWithView = undefined;\n    this.rotation = undefined;\n    this.scale = undefined;\n    this.vertices = null;\n    this.width = undefined;\n  };\n  \n  \n  /**\n   * @abstract\n   * @protected\n   * @param {boolean=} opt_all Return hit detection textures with regular ones.\n   * @returns {Array.<WebGLTexture>} Textures.\n   */\n  ol.render.webgl.TextureReplay.prototype.getTextures = function(opt_all) {};\n  \n  \n  /**\n   * @abstract\n   * @protected\n   * @returns {Array.<WebGLTexture>} Textures.\n   */\n  ol.render.webgl.TextureReplay.prototype.getHitDetectionTextures = function() {};\n  \n  goog.provide('ol.render.webgl.ImageReplay');\n  \n  goog.require('ol');\n  goog.require('ol.render.webgl.TextureReplay');\n  goog.require('ol.webgl.Buffer');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.webgl.TextureReplay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @struct\n   */\n  ol.render.webgl.ImageReplay = function(tolerance, maxExtent) {\n    ol.render.webgl.TextureReplay.call(this, tolerance, maxExtent);\n  \n    /**\n     * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}\n     * @protected\n     */\n    this.images_ = [];\n  \n    /**\n     * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}\n     * @protected\n     */\n    this.hitDetectionImages_ = [];\n  \n    /**\n     * @type {Array.<WebGLTexture>}\n     * @private\n     */\n    this.textures_ = [];\n  \n    /**\n     * @type {Array.<WebGLTexture>}\n     * @private\n     */\n    this.hitDetectionTextures_ = [];\n  \n  };\n  ol.inherits(ol.render.webgl.ImageReplay, ol.render.webgl.TextureReplay);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.ImageReplay.prototype.drawMultiPoint = function(multiPointGeometry, feature) {\n    this.startIndices.push(this.indices.length);\n    this.startIndicesFeature.push(feature);\n    var flatCoordinates = multiPointGeometry.getFlatCoordinates();\n    var stride = multiPointGeometry.getStride();\n    this.drawCoordinates(\n        flatCoordinates, 0, flatCoordinates.length, stride);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.ImageReplay.prototype.drawPoint = function(pointGeometry, feature) {\n    this.startIndices.push(this.indices.length);\n    this.startIndicesFeature.push(feature);\n    var flatCoordinates = pointGeometry.getFlatCoordinates();\n    var stride = pointGeometry.getStride();\n    this.drawCoordinates(\n        flatCoordinates, 0, flatCoordinates.length, stride);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.ImageReplay.prototype.finish = function(context) {\n    var gl = context.getGL();\n  \n    this.groupIndices.push(this.indices.length);\n    this.hitDetectionGroupIndices.push(this.indices.length);\n  \n    // create, bind, and populate the vertices buffer\n    this.verticesBuffer = new ol.webgl.Buffer(this.vertices);\n  \n    var indices = this.indices;\n  \n    // create, bind, and populate the indices buffer\n    this.indicesBuffer = new ol.webgl.Buffer(indices);\n  \n    // create textures\n    /** @type {Object.<string, WebGLTexture>} */\n    var texturePerImage = {};\n  \n    this.createTextures(this.textures_, this.images_, texturePerImage, gl);\n  \n    this.createTextures(this.hitDetectionTextures_, this.hitDetectionImages_,\n        texturePerImage, gl);\n  \n    this.images_ = null;\n    this.hitDetectionImages_ = null;\n    ol.render.webgl.TextureReplay.prototype.finish.call(this, context);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.ImageReplay.prototype.setImageStyle = function(imageStyle) {\n    var anchor = imageStyle.getAnchor();\n    var image = imageStyle.getImage(1);\n    var imageSize = imageStyle.getImageSize();\n    var hitDetectionImage = imageStyle.getHitDetectionImage(1);\n    var opacity = imageStyle.getOpacity();\n    var origin = imageStyle.getOrigin();\n    var rotateWithView = imageStyle.getRotateWithView();\n    var rotation = imageStyle.getRotation();\n    var size = imageStyle.getSize();\n    var scale = imageStyle.getScale();\n  \n    var currentImage;\n    if (this.images_.length === 0) {\n      this.images_.push(image);\n    } else {\n      currentImage = this.images_[this.images_.length - 1];\n      if (ol.getUid(currentImage) != ol.getUid(image)) {\n        this.groupIndices.push(this.indices.length);\n        this.images_.push(image);\n      }\n    }\n  \n    if (this.hitDetectionImages_.length === 0) {\n      this.hitDetectionImages_.push(hitDetectionImage);\n    } else {\n      currentImage =\n          this.hitDetectionImages_[this.hitDetectionImages_.length - 1];\n      if (ol.getUid(currentImage) != ol.getUid(hitDetectionImage)) {\n        this.hitDetectionGroupIndices.push(this.indices.length);\n        this.hitDetectionImages_.push(hitDetectionImage);\n      }\n    }\n  \n    this.anchorX = anchor[0];\n    this.anchorY = anchor[1];\n    this.height = size[1];\n    this.imageHeight = imageSize[1];\n    this.imageWidth = imageSize[0];\n    this.opacity = opacity;\n    this.originX = origin[0];\n    this.originY = origin[1];\n    this.rotation = rotation;\n    this.rotateWithView = rotateWithView;\n    this.scale = scale;\n    this.width = size[0];\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.ImageReplay.prototype.getTextures = function(opt_all) {\n    return opt_all ? this.textures_.concat(this.hitDetectionTextures_) : this.textures_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.ImageReplay.prototype.getHitDetectionTextures = function() {\n    return this.hitDetectionTextures_;\n  };\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.render.webgl.linestringreplay.defaultshader');\n  \n  goog.require('ol');\n  goog.require('ol.webgl.Fragment');\n  goog.require('ol.webgl.Vertex');\n  \n  \n  ol.render.webgl.linestringreplay.defaultshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ?\n    'precision mediump float;\\nvarying float v_round;\\nvarying vec2 v_roundVertex;\\nvarying float v_halfWidth;\\n\\n\\n\\nuniform float u_opacity;\\nuniform vec4 u_color;\\nuniform vec2 u_size;\\nuniform float u_pixelRatio;\\n\\nvoid main(void) {\\n  if (v_round > 0.0) {\\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\\n      discard;\\n    }\\n  }\\n  gl_FragColor = u_color;\\n  float alpha = u_color.a * u_opacity;\\n  if (alpha == 0.0) {\\n    discard;\\n  }\\n  gl_FragColor.a = alpha;\\n}\\n' :\n    'precision mediump float;varying float a;varying vec2 aVertex;varying float c;uniform float m;uniform vec4 n;uniform vec2 o;uniform float p;void main(void){if(a>0.0){vec2 windowCoords=vec2((aVertex.x+1.0)/2.0*o.x*p,(aVertex.y+1.0)/2.0*o.y*p);if(length(windowCoords-gl_FragCoord.xy)>c*p){discard;}} gl_FragColor=n;float alpha=n.a*m;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');\n  \n  ol.render.webgl.linestringreplay.defaultshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ?\n    'varying float v_round;\\nvarying vec2 v_roundVertex;\\nvarying float v_halfWidth;\\n\\n\\nattribute vec2 a_lastPos;\\nattribute vec2 a_position;\\nattribute vec2 a_nextPos;\\nattribute float a_direction;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_lineWidth;\\nuniform float u_miterLimit;\\n\\nbool nearlyEquals(in float value, in float ref) {\\n  float epsilon = 0.000000000001;\\n  return value >= ref - epsilon && value <= ref + epsilon;\\n}\\n\\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\\n  vec2 dirVect = nextP - a_position;\\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\\n  offset = u_lineWidth / 2.0 * normal * direction;\\n}\\n\\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\\n  float halfWidth = u_lineWidth / 2.0;\\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\\n  vec2 normal = vec2(-tangent.y, tangent.x);\\n  vec2 dirVect = a_nextPos - a_position;\\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\\n  offset = normal * direction * miterLength;\\n  round = 0.0;\\n  if (isRound) {\\n    round = 1.0;\\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\\n    offset = halfWidth * tmpNormal * direction;\\n  }\\n}\\n\\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\\n  bool degenerate = false;\\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\\n  vec2 normal = vec2(-tangent.y, tangent.x);\\n  vec2 dirVect = a_lastPos - a_position;\\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\\n  vec2 longOffset, shortOffset, longVertex;\\n  vec4 shortProjVertex;\\n  float halfWidth = u_lineWidth / 2.0;\\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\\n    longOffset = tmpNormal * direction * halfWidth;\\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\\n    longVertex = a_nextPos;\\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\\n  } else {\\n    shortOffset = tmpNormal * direction * halfWidth;\\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\\n    longVertex = a_lastPos;\\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\\n  }\\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\\n  float epsilon = 0.000000000001;\\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\\n    offset = shortProjVertex.xy;\\n    degenerate = true;\\n  } else {\\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\\n    offset = normal * direction * miterLength;\\n  }\\n  return degenerate;\\n}\\n\\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\\n    in float turnDir, in float direction) {\\n  round = 0.0;\\n  vec2 dirVect = a_position - nextP;\\n  vec2 firstNormal = normalize(dirVect);\\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\\n  offset = normal * length;\\n  if (isRound) {\\n    round = 1.0;\\n  }\\n}\\n\\nvoid main(void) {\\n  bool degenerate = false;\\n  float direction = float(sign(a_direction));\\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\\n  vec2 offset;\\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\\n\\n  v_round = 0.0;\\n  v_halfWidth = u_lineWidth / 2.0;\\n  v_roundVertex = projPos.xy;\\n\\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\\n    alongNormal(offset, a_nextPos, 1.0, direction);\\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\\n    alongNormal(offset, a_lastPos, -1.0, direction);\\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\\n    miterUp(offset, v_round, round, direction);\\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\\n  }\\n  if (!degenerate) {\\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\\n    gl_Position = projPos + offsets;\\n  } else {\\n    gl_Position = vec4(offset, 0.0, 1.0);\\n  }\\n}\\n\\n\\n' :\n    'varying float a;varying vec2 aVertex;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;bool nearlyEquals(in float value,in float ref){float epsilon=0.000000000001;return value>=ref-epsilon&&value<=ref+epsilon;}void alongNormal(out vec2 offset,in vec2 nextP,in float turnDir,in float direction){vec2 dirVect=nextP-e;vec2 normal=normalize(vec2(-turnDir*dirVect.y,turnDir*dirVect.x));offset=k/2.0*normal*direction;}void miterUp(out vec2 offset,out float round,in bool isRound,in float direction){float halfWidth=k/2.0;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;round=0.0;if(isRound){round=1.0;}else if(miterLength>l+k){offset=halfWidth*tmpNormal*direction;}} bool miterDown(out vec2 offset,in vec4 projPos,in mat4 offsetMatrix,in float direction){bool degenerate=false;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=d-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;float halfWidth=k/2.0;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*halfWidth;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=f;shortProjVertex=h*vec4(d,0.0,1.0);}else{shortOffset=tmpNormal*direction*halfWidth;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=d;shortProjVertex=h*vec4(f,0.0,1.0);}vec4 p1=h*vec4(longVertex,0.0,1.0)+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p2=projPos+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p3=shortProjVertex+offsetMatrix*vec4(-shortOffset,0.0,0.0);vec4 p4=shortProjVertex+offsetMatrix*vec4(shortOffset,0.0,0.0);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;float epsilon=0.000000000001;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){shortProjVertex.x=p1.x+firstU*(p2.x-p1.x);shortProjVertex.y=p1.y+firstU*(p2.y-p1.y);offset=shortProjVertex.xy;degenerate=true;}else{float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;}return degenerate;}void squareCap(out vec2 offset,out float round,in bool isRound,in vec2 nextP,in float turnDir,in float direction){round=0.0;vec2 dirVect=e-nextP;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(turnDir*firstNormal.y*direction,-turnDir*firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);vec2 normal=vec2(turnDir*hypotenuse.y*direction,-turnDir*hypotenuse.x*direction);float length=sqrt(c*c*2.0);offset=normal*length;if(isRound){round=1.0;}} void main(void){bool degenerate=false;float direction=float(sign(g));mat4 offsetMatrix=i*j;vec2 offset;vec4 projPos=h*vec4(e,0.0,1.0);bool round=nearlyEquals(mod(g,2.0),0.0);a=0.0;c=k/2.0;aVertex=projPos.xy;if(nearlyEquals(mod(g,3.0),0.0)||nearlyEquals(mod(g,17.0),0.0)){alongNormal(offset,f,1.0,direction);}else if(nearlyEquals(mod(g,5.0),0.0)||nearlyEquals(mod(g,13.0),0.0)){alongNormal(offset,d,-1.0,direction);}else if(nearlyEquals(mod(g,23.0),0.0)){miterUp(offset,a,round,direction);}else if(nearlyEquals(mod(g,19.0),0.0)){degenerate=miterDown(offset,projPos,offsetMatrix,direction);}else if(nearlyEquals(mod(g,7.0),0.0)){squareCap(offset,a,round,f,1.0,direction);}else if(nearlyEquals(mod(g,11.0),0.0)){squareCap(offset,a,round,d,-1.0,direction);}if(!degenerate){vec4 offsets=offsetMatrix*vec4(offset,0.0,0.0);gl_Position=projPos+offsets;}else{gl_Position=vec4(offset,0.0,1.0);}}');\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.render.webgl.linestringreplay.defaultshader.Locations');\n  \n  goog.require('ol');\n  \n  \n  /**\n   * @constructor\n   * @param {WebGLRenderingContext} gl GL.\n   * @param {WebGLProgram} program Program.\n   * @struct\n   */\n  ol.render.webgl.linestringreplay.defaultshader.Locations = function(gl, program) {\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_projectionMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_offsetScaleMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_offsetRotateMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_lineWidth = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_lineWidth' : 'k');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_miterLimit = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_miterLimit' : 'l');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_opacity = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_opacity' : 'm');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_color = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_color' : 'n');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_size = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_size' : 'o');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_pixelRatio = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_pixelRatio' : 'p');\n  \n    /**\n     * @type {number}\n     */\n    this.a_lastPos = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_lastPos' : 'd');\n  \n    /**\n     * @type {number}\n     */\n    this.a_position = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_position' : 'e');\n  \n    /**\n     * @type {number}\n     */\n    this.a_nextPos = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_nextPos' : 'f');\n  \n    /**\n     * @type {number}\n     */\n    this.a_direction = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_direction' : 'g');\n  };\n  \n  goog.provide('ol.render.webgl.LineStringReplay');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.color');\n  goog.require('ol.extent');\n  goog.require('ol.geom.flat.orient');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.geom.flat.topology');\n  goog.require('ol.obj');\n  goog.require('ol.render.webgl');\n  goog.require('ol.render.webgl.Replay');\n  goog.require('ol.render.webgl.linestringreplay.defaultshader');\n  goog.require('ol.render.webgl.linestringreplay.defaultshader.Locations');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Buffer');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.webgl.Replay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @struct\n   */\n  ol.render.webgl.LineStringReplay = function(tolerance, maxExtent) {\n    ol.render.webgl.Replay.call(this, tolerance, maxExtent);\n  \n    /**\n     * @private\n     * @type {ol.render.webgl.linestringreplay.defaultshader.Locations}\n     */\n    this.defaultLocations_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<Array.<?>>}\n     */\n    this.styles_ = [];\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.styleIndices_ = [];\n  \n    /**\n     * @private\n     * @type {{strokeColor: (Array.<number>|null),\n     *         lineCap: (string|undefined),\n     *         lineDash: Array.<number>,\n     *         lineDashOffset: (number|undefined),\n     *         lineJoin: (string|undefined),\n     *         lineWidth: (number|undefined),\n     *         miterLimit: (number|undefined),\n     *         changed: boolean}|null}\n     */\n    this.state_ = {\n      strokeColor: null,\n      lineCap: undefined,\n      lineDash: null,\n      lineDashOffset: undefined,\n      lineJoin: undefined,\n      lineWidth: undefined,\n      miterLimit: undefined,\n      changed: false\n    };\n  \n  };\n  ol.inherits(ol.render.webgl.LineStringReplay, ol.render.webgl.Replay);\n  \n  \n  /**\n   * Draw one segment.\n   * @private\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   */\n  ol.render.webgl.LineStringReplay.prototype.drawCoordinates_ = function(flatCoordinates, offset, end, stride) {\n  \n    var i, ii;\n    var numVertices = this.vertices.length;\n    var numIndices = this.indices.length;\n    //To save a vertex, the direction of a point is a product of the sign (1 or -1), a prime from\n    //ol.render.webgl.LineStringReplay.Instruction_, and a rounding factor (1 or 2). If the product is even,\n    //we round it. If it is odd, we don't.\n    var lineJoin = this.state_.lineJoin === 'bevel' ? 0 :\n      this.state_.lineJoin === 'miter' ? 1 : 2;\n    var lineCap = this.state_.lineCap === 'butt' ? 0 :\n      this.state_.lineCap === 'square' ? 1 : 2;\n    var closed = ol.geom.flat.topology.lineStringIsClosed(flatCoordinates, offset, end, stride);\n    var startCoords, sign, n;\n    var lastIndex = numIndices;\n    var lastSign = 1;\n    //We need the adjacent vertices to define normals in joins. p0 = last, p1 = current, p2 = next.\n    var p0, p1, p2;\n  \n    for (i = offset, ii = end; i < ii; i += stride) {\n  \n      n = numVertices / 7;\n  \n      p0 = p1;\n      p1 = p2 || [flatCoordinates[i], flatCoordinates[i + 1]];\n      //First vertex.\n      if (i === offset) {\n        p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];\n        if (end - offset === stride * 2 && ol.array.equals(p1, p2)) {\n          break;\n        }\n        if (closed) {\n          //A closed line! Complete the circle.\n          p0 = [flatCoordinates[end - stride * 2],\n            flatCoordinates[end - stride * 2 + 1]];\n  \n          startCoords = p2;\n        } else {\n          //Add the first two/four vertices.\n  \n          if (lineCap) {\n            numVertices = this.addVertices_([0, 0], p1, p2,\n                lastSign * ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);\n  \n            numVertices = this.addVertices_([0, 0], p1, p2,\n                -lastSign * ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);\n  \n            this.indices[numIndices++] = n + 2;\n            this.indices[numIndices++] = n;\n            this.indices[numIndices++] = n + 1;\n  \n            this.indices[numIndices++] = n + 1;\n            this.indices[numIndices++] = n + 3;\n            this.indices[numIndices++] = n + 2;\n  \n          }\n  \n          numVertices = this.addVertices_([0, 0], p1, p2,\n              lastSign * ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);\n  \n          numVertices = this.addVertices_([0, 0], p1, p2,\n              -lastSign * ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);\n  \n          lastIndex = numVertices / 7 - 1;\n  \n          continue;\n        }\n      } else if (i === end - stride) {\n        //Last vertex.\n        if (closed) {\n          //Same as the first vertex.\n          p2 = startCoords;\n          break;\n        } else {\n          p0 = p0 || [0, 0];\n  \n          numVertices = this.addVertices_(p0, p1, [0, 0],\n              lastSign * ol.render.webgl.LineStringReplay.Instruction_.END_LINE * (lineCap || 1), numVertices);\n  \n          numVertices = this.addVertices_(p0, p1, [0, 0],\n              -lastSign * ol.render.webgl.LineStringReplay.Instruction_.END_LINE * (lineCap || 1), numVertices);\n  \n          this.indices[numIndices++] = n;\n          this.indices[numIndices++] = lastIndex - 1;\n          this.indices[numIndices++] = lastIndex;\n  \n          this.indices[numIndices++] = lastIndex;\n          this.indices[numIndices++] = n + 1;\n          this.indices[numIndices++] = n;\n  \n          if (lineCap) {\n            numVertices = this.addVertices_(p0, p1, [0, 0],\n                lastSign * ol.render.webgl.LineStringReplay.Instruction_.END_LINE_CAP * lineCap, numVertices);\n  \n            numVertices = this.addVertices_(p0, p1, [0, 0],\n                -lastSign * ol.render.webgl.LineStringReplay.Instruction_.END_LINE_CAP * lineCap, numVertices);\n  \n            this.indices[numIndices++] = n + 2;\n            this.indices[numIndices++] = n;\n            this.indices[numIndices++] = n + 1;\n  \n            this.indices[numIndices++] = n + 1;\n            this.indices[numIndices++] = n + 3;\n            this.indices[numIndices++] = n + 2;\n  \n          }\n  \n          break;\n        }\n      } else {\n        p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];\n      }\n  \n      // We group CW and straight lines, thus the not so inituitive CCW checking function.\n      sign = ol.render.webgl.triangleIsCounterClockwise(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1])\n        ? -1 : 1;\n  \n      numVertices = this.addVertices_(p0, p1, p2,\n          sign * ol.render.webgl.LineStringReplay.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);\n  \n      numVertices = this.addVertices_(p0, p1, p2,\n          sign * ol.render.webgl.LineStringReplay.Instruction_.BEVEL_SECOND * (lineJoin || 1), numVertices);\n  \n      numVertices = this.addVertices_(p0, p1, p2,\n          -sign * ol.render.webgl.LineStringReplay.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);\n  \n      if (i > offset) {\n        this.indices[numIndices++] = n;\n        this.indices[numIndices++] = lastIndex - 1;\n        this.indices[numIndices++] = lastIndex;\n  \n        this.indices[numIndices++] = n + 2;\n        this.indices[numIndices++] = n;\n        this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;\n      }\n  \n      this.indices[numIndices++] = n;\n      this.indices[numIndices++] = n + 2;\n      this.indices[numIndices++] = n + 1;\n  \n      lastIndex = n + 2;\n      lastSign = sign;\n  \n      //Add miter\n      if (lineJoin) {\n        numVertices = this.addVertices_(p0, p1, p2,\n            sign * ol.render.webgl.LineStringReplay.Instruction_.MITER_TOP * lineJoin, numVertices);\n  \n        this.indices[numIndices++] = n + 1;\n        this.indices[numIndices++] = n + 3;\n        this.indices[numIndices++] = n;\n      }\n    }\n  \n    if (closed) {\n      n = n || numVertices / 7;\n      sign = ol.geom.flat.orient.linearRingIsClockwise([p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]], 0, 6, 2)\n        ? 1 : -1;\n  \n      numVertices = this.addVertices_(p0, p1, p2,\n          sign * ol.render.webgl.LineStringReplay.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);\n  \n      numVertices = this.addVertices_(p0, p1, p2,\n          -sign * ol.render.webgl.LineStringReplay.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);\n  \n      this.indices[numIndices++] = n;\n      this.indices[numIndices++] = lastIndex - 1;\n      this.indices[numIndices++] = lastIndex;\n  \n      this.indices[numIndices++] = n + 1;\n      this.indices[numIndices++] = n;\n      this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;\n    }\n  };\n  \n  /**\n   * @param {Array.<number>} p0 Last coordinates.\n   * @param {Array.<number>} p1 Current coordinates.\n   * @param {Array.<number>} p2 Next coordinates.\n   * @param {number} product Sign, instruction, and rounding product.\n   * @param {number} numVertices Vertex counter.\n   * @return {number} Vertex counter.\n   * @private\n   */\n  ol.render.webgl.LineStringReplay.prototype.addVertices_ = function(p0, p1, p2, product, numVertices) {\n    this.vertices[numVertices++] = p0[0];\n    this.vertices[numVertices++] = p0[1];\n    this.vertices[numVertices++] = p1[0];\n    this.vertices[numVertices++] = p1[1];\n    this.vertices[numVertices++] = p2[0];\n    this.vertices[numVertices++] = p2[1];\n    this.vertices[numVertices++] = product;\n  \n    return numVertices;\n  };\n  \n  /**\n   * Check if the linestring can be drawn (i. e. valid).\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @return {boolean} The linestring can be drawn.\n   * @private\n   */\n  ol.render.webgl.LineStringReplay.prototype.isValid_ = function(flatCoordinates, offset, end, stride) {\n    var range = end - offset;\n    if (range < stride * 2) {\n      return false;\n    } else if (range === stride * 2) {\n      var firstP = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n      var lastP = [flatCoordinates[offset + stride], flatCoordinates[offset + stride + 1]];\n      return !ol.array.equals(firstP, lastP);\n    }\n  \n    return true;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.LineStringReplay.prototype.drawLineString = function(lineStringGeometry, feature) {\n    var flatCoordinates = lineStringGeometry.getFlatCoordinates();\n    var stride = lineStringGeometry.getStride();\n    if (this.isValid_(flatCoordinates, 0, flatCoordinates.length, stride)) {\n      flatCoordinates = ol.geom.flat.transform.translate(flatCoordinates, 0, flatCoordinates.length,\n          stride, -this.origin[0], -this.origin[1]);\n      if (this.state_.changed) {\n        this.styleIndices_.push(this.indices.length);\n        this.state_.changed = false;\n      }\n      this.startIndices.push(this.indices.length);\n      this.startIndicesFeature.push(feature);\n      this.drawCoordinates_(\n          flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.LineStringReplay.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {\n    var indexCount = this.indices.length;\n    var ends = multiLineStringGeometry.getEnds();\n    ends.unshift(0);\n    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n    var stride = multiLineStringGeometry.getStride();\n    var i, ii;\n    if (ends.length > 1) {\n      for (i = 1, ii = ends.length; i < ii; ++i) {\n        if (this.isValid_(flatCoordinates, ends[i - 1], ends[i], stride)) {\n          var lineString = ol.geom.flat.transform.translate(flatCoordinates, ends[i - 1], ends[i],\n              stride, -this.origin[0], -this.origin[1]);\n          this.drawCoordinates_(\n              lineString, 0, lineString.length, stride);\n        }\n      }\n    }\n    if (this.indices.length > indexCount) {\n      this.startIndices.push(indexCount);\n      this.startIndicesFeature.push(feature);\n      if (this.state_.changed) {\n        this.styleIndices_.push(indexCount);\n        this.state_.changed = false;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.\n   * @param {number} stride Stride.\n   */\n  ol.render.webgl.LineStringReplay.prototype.drawPolygonCoordinates = function(\n      flatCoordinates, holeFlatCoordinates, stride) {\n    if (!ol.geom.flat.topology.lineStringIsClosed(flatCoordinates, 0,\n        flatCoordinates.length, stride)) {\n      flatCoordinates.push(flatCoordinates[0]);\n      flatCoordinates.push(flatCoordinates[1]);\n    }\n    this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n    if (holeFlatCoordinates.length) {\n      var i, ii;\n      for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {\n        if (!ol.geom.flat.topology.lineStringIsClosed(holeFlatCoordinates[i], 0,\n            holeFlatCoordinates[i].length, stride)) {\n          holeFlatCoordinates[i].push(holeFlatCoordinates[i][0]);\n          holeFlatCoordinates[i].push(holeFlatCoordinates[i][1]);\n        }\n        this.drawCoordinates_(holeFlatCoordinates[i], 0,\n            holeFlatCoordinates[i].length, stride);\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @param {number=} opt_index Index count.\n   */\n  ol.render.webgl.LineStringReplay.prototype.setPolygonStyle = function(feature, opt_index) {\n    var index = opt_index === undefined ? this.indices.length : opt_index;\n    this.startIndices.push(index);\n    this.startIndicesFeature.push(feature);\n    if (this.state_.changed) {\n      this.styleIndices_.push(index);\n      this.state_.changed = false;\n    }\n  };\n  \n  \n  /**\n   * @return {number} Current index.\n   */\n  ol.render.webgl.LineStringReplay.prototype.getCurrentIndex = function() {\n    return this.indices.length;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   **/\n  ol.render.webgl.LineStringReplay.prototype.finish = function(context) {\n    // create, bind, and populate the vertices buffer\n    this.verticesBuffer = new ol.webgl.Buffer(this.vertices);\n  \n    // create, bind, and populate the indices buffer\n    this.indicesBuffer = new ol.webgl.Buffer(this.indices);\n  \n    this.startIndices.push(this.indices.length);\n  \n    //Clean up, if there is nothing to draw\n    if (this.styleIndices_.length === 0 && this.styles_.length > 0) {\n      this.styles_ = [];\n    }\n  \n    this.vertices = null;\n    this.indices = null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.LineStringReplay.prototype.getDeleteResourcesFunction = function(context) {\n    var verticesBuffer = this.verticesBuffer;\n    var indicesBuffer = this.indicesBuffer;\n    return function() {\n      context.deleteBuffer(verticesBuffer);\n      context.deleteBuffer(indicesBuffer);\n    };\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.LineStringReplay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {\n    // get the program\n    var fragmentShader, vertexShader;\n    fragmentShader = ol.render.webgl.linestringreplay.defaultshader.fragment;\n    vertexShader = ol.render.webgl.linestringreplay.defaultshader.vertex;\n    var program = context.getProgram(fragmentShader, vertexShader);\n  \n    // get the locations\n    var locations;\n    if (!this.defaultLocations_) {\n      locations = new ol.render.webgl.linestringreplay.defaultshader.Locations(gl, program);\n      this.defaultLocations_ = locations;\n    } else {\n      locations = this.defaultLocations_;\n    }\n  \n    context.useProgram(program);\n  \n    // enable the vertex attrib arrays\n    gl.enableVertexAttribArray(locations.a_lastPos);\n    gl.vertexAttribPointer(locations.a_lastPos, 2, ol.webgl.FLOAT,\n        false, 28, 0);\n  \n    gl.enableVertexAttribArray(locations.a_position);\n    gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT,\n        false, 28, 8);\n  \n    gl.enableVertexAttribArray(locations.a_nextPos);\n    gl.vertexAttribPointer(locations.a_nextPos, 2, ol.webgl.FLOAT,\n        false, 28, 16);\n  \n    gl.enableVertexAttribArray(locations.a_direction);\n    gl.vertexAttribPointer(locations.a_direction, 1, ol.webgl.FLOAT,\n        false, 28, 24);\n  \n    // Enable renderer specific uniforms.\n    gl.uniform2fv(locations.u_size, size);\n    gl.uniform1f(locations.u_pixelRatio, pixelRatio);\n  \n    return locations;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.LineStringReplay.prototype.shutDownProgram = function(gl, locations) {\n    gl.disableVertexAttribArray(locations.a_lastPos);\n    gl.disableVertexAttribArray(locations.a_position);\n    gl.disableVertexAttribArray(locations.a_nextPos);\n    gl.disableVertexAttribArray(locations.a_direction);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.LineStringReplay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {\n    //Save GL parameters.\n    var tmpDepthFunc = /** @type {number} */ (gl.getParameter(gl.DEPTH_FUNC));\n    var tmpDepthMask = /** @type {boolean} */ (gl.getParameter(gl.DEPTH_WRITEMASK));\n  \n    if (!hitDetection) {\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthMask(true);\n      gl.depthFunc(gl.NOTEQUAL);\n    }\n  \n    if (!ol.obj.isEmpty(skippedFeaturesHash)) {\n      this.drawReplaySkipping_(gl, context, skippedFeaturesHash);\n    } else {\n      //Draw by style groups to minimize drawElements() calls.\n      var i, start, end, nextStyle;\n      end = this.startIndices[this.startIndices.length - 1];\n      for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n        start = this.styleIndices_[i];\n        nextStyle = this.styles_[i];\n        this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);\n        this.drawElements(gl, context, start, end);\n        gl.clear(gl.DEPTH_BUFFER_BIT);\n        end = start;\n      }\n    }\n    if (!hitDetection) {\n      gl.disable(gl.DEPTH_TEST);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n      //Restore GL parameters.\n      gl.depthMask(tmpDepthMask);\n      gl.depthFunc(tmpDepthFunc);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {Object} skippedFeaturesHash Ids of features to skip.\n   */\n  ol.render.webgl.LineStringReplay.prototype.drawReplaySkipping_ = function(gl, context, skippedFeaturesHash) {\n    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;\n    featureIndex = this.startIndices.length - 2;\n    end = start = this.startIndices[featureIndex + 1];\n    for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n      nextStyle = this.styles_[i];\n      this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);\n      groupStart = this.styleIndices_[i];\n  \n      while (featureIndex >= 0 &&\n          this.startIndices[featureIndex] >= groupStart) {\n        featureStart = this.startIndices[featureIndex];\n        feature = this.startIndicesFeature[featureIndex];\n        featureUid = ol.getUid(feature).toString();\n  \n        if (skippedFeaturesHash[featureUid]) {\n          if (start !== end) {\n            this.drawElements(gl, context, start, end);\n            gl.clear(gl.DEPTH_BUFFER_BIT);\n          }\n          end = featureStart;\n        }\n        featureIndex--;\n        start = featureStart;\n      }\n      if (start !== end) {\n        this.drawElements(gl, context, start, end);\n        gl.clear(gl.DEPTH_BUFFER_BIT);\n      }\n      start = end = groupStart;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.LineStringReplay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash,\n      featureCallback, opt_hitExtent) {\n    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;\n    featureIndex = this.startIndices.length - 2;\n    end = this.startIndices[featureIndex + 1];\n    for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n      nextStyle = this.styles_[i];\n      this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);\n      groupStart = this.styleIndices_[i];\n  \n      while (featureIndex >= 0 &&\n          this.startIndices[featureIndex] >= groupStart) {\n        start = this.startIndices[featureIndex];\n        feature = this.startIndicesFeature[featureIndex];\n        featureUid = ol.getUid(feature).toString();\n  \n        if (skippedFeaturesHash[featureUid] === undefined &&\n            feature.getGeometry() &&\n            (opt_hitExtent === undefined || ol.extent.intersects(\n                /** @type {Array<number>} */ (opt_hitExtent),\n                feature.getGeometry().getExtent()))) {\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n          this.drawElements(gl, context, start, end);\n  \n          var result = featureCallback(feature);\n  \n          if (result) {\n            return result;\n          }\n  \n        }\n        featureIndex--;\n        end = start;\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @private\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {Array.<number>} color Color.\n   * @param {number} lineWidth Line width.\n   * @param {number} miterLimit Miter limit.\n   */\n  ol.render.webgl.LineStringReplay.prototype.setStrokeStyle_ = function(gl, color, lineWidth, miterLimit) {\n    gl.uniform4fv(this.defaultLocations_.u_color, color);\n    gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);\n    gl.uniform1f(this.defaultLocations_.u_miterLimit, miterLimit);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.LineStringReplay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n    var strokeStyleLineCap = strokeStyle.getLineCap();\n    this.state_.lineCap = strokeStyleLineCap !== undefined ?\n      strokeStyleLineCap : ol.render.webgl.defaultLineCap;\n    var strokeStyleLineDash = strokeStyle.getLineDash();\n    this.state_.lineDash = strokeStyleLineDash ?\n      strokeStyleLineDash : ol.render.webgl.defaultLineDash;\n    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n    this.state_.lineDashOffset = strokeStyleLineDashOffset ?\n      strokeStyleLineDashOffset : ol.render.webgl.defaultLineDashOffset;\n    var strokeStyleLineJoin = strokeStyle.getLineJoin();\n    this.state_.lineJoin = strokeStyleLineJoin !== undefined ?\n      strokeStyleLineJoin : ol.render.webgl.defaultLineJoin;\n    var strokeStyleColor = strokeStyle.getColor();\n    if (!(strokeStyleColor instanceof CanvasGradient) &&\n        !(strokeStyleColor instanceof CanvasPattern)) {\n      strokeStyleColor = ol.color.asArray(strokeStyleColor).map(function(c, i) {\n        return i != 3 ? c / 255 : c;\n      }) || ol.render.webgl.defaultStrokeStyle;\n    } else {\n      strokeStyleColor = ol.render.webgl.defaultStrokeStyle;\n    }\n    var strokeStyleWidth = strokeStyle.getWidth();\n    strokeStyleWidth = strokeStyleWidth !== undefined ?\n      strokeStyleWidth : ol.render.webgl.defaultLineWidth;\n    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n    strokeStyleMiterLimit = strokeStyleMiterLimit !== undefined ?\n      strokeStyleMiterLimit : ol.render.webgl.defaultMiterLimit;\n    if (!this.state_.strokeColor || !ol.array.equals(this.state_.strokeColor, strokeStyleColor) ||\n        this.state_.lineWidth !== strokeStyleWidth || this.state_.miterLimit !== strokeStyleMiterLimit) {\n      this.state_.changed = true;\n      this.state_.strokeColor = strokeStyleColor;\n      this.state_.lineWidth = strokeStyleWidth;\n      this.state_.miterLimit = strokeStyleMiterLimit;\n      this.styles_.push([strokeStyleColor, strokeStyleWidth, strokeStyleMiterLimit]);\n    }\n  };\n  \n  /**\n   * @enum {number}\n   * @private\n   */\n  ol.render.webgl.LineStringReplay.Instruction_ = {\n    ROUND: 2,\n    BEGIN_LINE: 3,\n    END_LINE: 5,\n    BEGIN_LINE_CAP: 7,\n    END_LINE_CAP: 11,\n    BEVEL_FIRST: 13,\n    BEVEL_SECOND: 17,\n    MITER_BOTTOM: 19,\n    MITER_TOP: 23\n  };\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.render.webgl.polygonreplay.defaultshader');\n  \n  goog.require('ol');\n  goog.require('ol.webgl.Fragment');\n  goog.require('ol.webgl.Vertex');\n  \n  \n  ol.render.webgl.polygonreplay.defaultshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ?\n    'precision mediump float;\\n\\n\\n\\nuniform vec4 u_color;\\nuniform float u_opacity;\\n\\nvoid main(void) {\\n  gl_FragColor = u_color;\\n  float alpha = u_color.a * u_opacity;\\n  if (alpha == 0.0) {\\n    discard;\\n  }\\n  gl_FragColor.a = alpha;\\n}\\n' :\n    'precision mediump float;uniform vec4 e;uniform float f;void main(void){gl_FragColor=e;float alpha=e.a*f;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');\n  \n  ol.render.webgl.polygonreplay.defaultshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ?\n    '\\n\\nattribute vec2 a_position;\\n\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\n\\nvoid main(void) {\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\\n}\\n\\n\\n' :\n    'attribute vec2 a;uniform mat4 b;uniform mat4 c;uniform mat4 d;void main(void){gl_Position=b*vec4(a,0.0,1.0);}');\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.render.webgl.polygonreplay.defaultshader.Locations');\n  \n  goog.require('ol');\n  \n  \n  /**\n   * @constructor\n   * @param {WebGLRenderingContext} gl GL.\n   * @param {WebGLProgram} program Program.\n   * @struct\n   */\n  ol.render.webgl.polygonreplay.defaultshader.Locations = function(gl, program) {\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_projectionMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_projectionMatrix' : 'b');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_offsetScaleMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'c');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_offsetRotateMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'd');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_color = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_color' : 'e');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_opacity = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_opacity' : 'f');\n  \n    /**\n     * @type {number}\n     */\n    this.a_position = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_position' : 'a');\n  };\n  \n  goog.provide('ol.structs.LinkedList');\n  \n  /**\n   * Creates an empty linked list structure.\n   *\n   * @constructor\n   * @struct\n   * @param {boolean=} opt_circular The last item is connected to the first one,\n   * and the first item to the last one. Default is true.\n   */\n  ol.structs.LinkedList = function(opt_circular) {\n  \n    /**\n     * @private\n     * @type {ol.LinkedListItem|undefined}\n     */\n    this.first_ = undefined;\n  \n    /**\n     * @private\n     * @type {ol.LinkedListItem|undefined}\n     */\n    this.last_ = undefined;\n  \n    /**\n     * @private\n     * @type {ol.LinkedListItem|undefined}\n     */\n    this.head_ = undefined;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.circular_ = opt_circular === undefined ? true : opt_circular;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.length_ = 0;\n  };\n  \n  /**\n   * Inserts an item into the linked list right after the current one.\n   *\n   * @param {?} data Item data.\n   */\n  ol.structs.LinkedList.prototype.insertItem = function(data) {\n  \n    /** @type {ol.LinkedListItem} */\n    var item = {\n      prev: undefined,\n      next: undefined,\n      data: data\n    };\n  \n    var head = this.head_;\n  \n    //Initialize the list.\n    if (!head) {\n      this.first_ = item;\n      this.last_ = item;\n      if (this.circular_) {\n        item.next = item;\n        item.prev = item;\n      }\n    } else {\n      //Link the new item to the adjacent ones.\n      var next = head.next;\n      item.prev = head;\n      item.next = next;\n      head.next = item;\n      if (next) {\n        next.prev = item;\n      }\n  \n      if (head === this.last_) {\n        this.last_ = item;\n      }\n    }\n    this.head_ = item;\n    this.length_++;\n  };\n  \n  /**\n   * Removes the current item from the list. Sets the cursor to the next item,\n   * if possible.\n   */\n  ol.structs.LinkedList.prototype.removeItem = function() {\n    var head = this.head_;\n    if (head) {\n      var next = head.next;\n      var prev = head.prev;\n      if (next) {\n        next.prev = prev;\n      }\n      if (prev) {\n        prev.next = next;\n      }\n      this.head_ = next || prev;\n  \n      if (this.first_ === this.last_) {\n        this.head_ = undefined;\n        this.first_ = undefined;\n        this.last_ = undefined;\n      } else if (this.first_ === head) {\n        this.first_ = this.head_;\n      } else if (this.last_ === head) {\n        this.last_ = prev ? this.head_.prev : this.head_;\n      }\n      this.length_--;\n    }\n  };\n  \n  /**\n   * Sets the cursor to the first item, and returns the associated data.\n   *\n   * @return {?} Item data.\n   */\n  ol.structs.LinkedList.prototype.firstItem = function() {\n    this.head_ = this.first_;\n    if (this.head_) {\n      return this.head_.data;\n    }\n    return undefined;\n  };\n  \n  /**\n  * Sets the cursor to the last item, and returns the associated data.\n  *\n  * @return {?} Item data.\n  */\n  ol.structs.LinkedList.prototype.lastItem = function() {\n    this.head_ = this.last_;\n    if (this.head_) {\n      return this.head_.data;\n    }\n    return undefined;\n  };\n  \n  /**\n   * Sets the cursor to the next item, and returns the associated data.\n   *\n   * @return {?} Item data.\n   */\n  ol.structs.LinkedList.prototype.nextItem = function() {\n    if (this.head_ && this.head_.next) {\n      this.head_ = this.head_.next;\n      return this.head_.data;\n    }\n    return undefined;\n  };\n  \n  /**\n   * Returns the next item's data without moving the cursor.\n   *\n   * @return {?} Item data.\n   */\n  ol.structs.LinkedList.prototype.getNextItem = function() {\n    if (this.head_ && this.head_.next) {\n      return this.head_.next.data;\n    }\n    return undefined;\n  };\n  \n  /**\n   * Sets the cursor to the previous item, and returns the associated data.\n   *\n   * @return {?} Item data.\n   */\n  ol.structs.LinkedList.prototype.prevItem = function() {\n    if (this.head_ && this.head_.prev) {\n      this.head_ = this.head_.prev;\n      return this.head_.data;\n    }\n    return undefined;\n  };\n  \n  /**\n   * Returns the previous item's data without moving the cursor.\n   *\n   * @return {?} Item data.\n   */\n  ol.structs.LinkedList.prototype.getPrevItem = function() {\n    if (this.head_ && this.head_.prev) {\n      return this.head_.prev.data;\n    }\n    return undefined;\n  };\n  \n  /**\n   * Returns the current item's data.\n   *\n   * @return {?} Item data.\n   */\n  ol.structs.LinkedList.prototype.getCurrItem = function() {\n    if (this.head_) {\n      return this.head_.data;\n    }\n    return undefined;\n  };\n  \n  /**\n   * Sets the first item of the list. This only works for circular lists, and sets\n   * the last item accordingly.\n   */\n  ol.structs.LinkedList.prototype.setFirstItem = function() {\n    if (this.circular_ && this.head_) {\n      this.first_ = this.head_;\n      this.last_ = this.head_.prev;\n    }\n  };\n  \n  /**\n   * Concatenates two lists.\n   * @param {ol.structs.LinkedList} list List to merge into the current list.\n   */\n  ol.structs.LinkedList.prototype.concat = function(list) {\n    if (list.head_) {\n      if (this.head_) {\n        var end = this.head_.next;\n        this.head_.next = list.first_;\n        list.first_.prev = this.head_;\n        end.prev = list.last_;\n        list.last_.next = end;\n        this.length_ += list.length_;\n      } else {\n        this.head_ = list.head_;\n        this.first_ = list.first_;\n        this.last_ = list.last_;\n        this.length_ = list.length_;\n      }\n      list.head_ = undefined;\n      list.first_ = undefined;\n      list.last_ = undefined;\n      list.length_ = 0;\n    }\n  };\n  \n  /**\n   * Returns the current length of the list.\n   *\n   * @return {number} Length.\n   */\n  ol.structs.LinkedList.prototype.getLength = function() {\n    return this.length_;\n  };\n  \n  goog.provide('ol.render.webgl.PolygonReplay');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.color');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.geom.flat.contains');\n  goog.require('ol.geom.flat.orient');\n  goog.require('ol.geom.flat.transform');\n  goog.require('ol.render.webgl.polygonreplay.defaultshader');\n  goog.require('ol.render.webgl.polygonreplay.defaultshader.Locations');\n  goog.require('ol.render.webgl.LineStringReplay');\n  goog.require('ol.render.webgl.Replay');\n  goog.require('ol.render.webgl');\n  goog.require('ol.style.Stroke');\n  goog.require('ol.structs.LinkedList');\n  goog.require('ol.structs.RBush');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Buffer');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.webgl.Replay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @struct\n   */\n  ol.render.webgl.PolygonReplay = function(tolerance, maxExtent) {\n    ol.render.webgl.Replay.call(this, tolerance, maxExtent);\n  \n    this.lineStringReplay = new ol.render.webgl.LineStringReplay(\n        tolerance, maxExtent);\n  \n    /**\n     * @private\n     * @type {ol.render.webgl.polygonreplay.defaultshader.Locations}\n     */\n    this.defaultLocations_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<Array.<number>>}\n     */\n    this.styles_ = [];\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.styleIndices_ = [];\n  \n    /**\n     * @private\n     * @type {{fillColor: (Array.<number>|null),\n     *         changed: boolean}|null}\n     */\n    this.state_ = {\n      fillColor: null,\n      changed: false\n    };\n  \n  };\n  ol.inherits(ol.render.webgl.PolygonReplay, ol.render.webgl.Replay);\n  \n  \n  /**\n   * Draw one polygon.\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.\n   * @param {number} stride Stride.\n   * @private\n   */\n  ol.render.webgl.PolygonReplay.prototype.drawCoordinates_ = function(\n      flatCoordinates, holeFlatCoordinates, stride) {\n    // Triangulate the polygon\n    var outerRing = new ol.structs.LinkedList();\n    var rtree = new ol.structs.RBush();\n    // Initialize the outer ring\n    this.processFlatCoordinates_(flatCoordinates, stride, outerRing, rtree, true);\n    var maxCoords = this.getMaxCoords_(outerRing);\n  \n    // Eliminate holes, if there are any\n    if (holeFlatCoordinates.length) {\n      var i, ii;\n      var holeLists = [];\n      for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {\n        var holeList = {\n          list: new ol.structs.LinkedList(),\n          maxCoords: undefined,\n          rtree: new ol.structs.RBush()\n        };\n        holeLists.push(holeList);\n        this.processFlatCoordinates_(holeFlatCoordinates[i],\n            stride, holeList.list, holeList.rtree, false);\n        this.classifyPoints_(holeList.list, holeList.rtree, true);\n        holeList.maxCoords = this.getMaxCoords_(holeList.list);\n      }\n      holeLists.sort(function(a, b) {\n        return b.maxCoords[0] === a.maxCoords[0] ?\n          a.maxCoords[1] - b.maxCoords[1] : b.maxCoords[0] - a.maxCoords[0];\n      });\n      for (i = 0; i < holeLists.length; ++i) {\n        var currList = holeLists[i].list;\n        var start = currList.firstItem();\n        var currItem = start;\n        var intersection;\n        do {\n          //TODO: Triangulate holes when they intersect the outer ring.\n          if (this.getIntersections_(currItem, rtree).length) {\n            intersection = true;\n            break;\n          }\n          currItem = currList.nextItem();\n        } while (start !== currItem);\n        if (!intersection) {\n          if (this.bridgeHole_(currList, holeLists[i].maxCoords[0], outerRing, maxCoords[0], rtree)) {\n            rtree.concat(holeLists[i].rtree);\n            this.classifyPoints_(outerRing, rtree, false);\n          }\n        }\n      }\n    } else {\n      this.classifyPoints_(outerRing, rtree, false);\n    }\n    this.triangulate_(outerRing, rtree);\n  };\n  \n  \n  /**\n   * Inserts flat coordinates in a linked list and adds them to the vertex buffer.\n   * @private\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @param {ol.structs.LinkedList} list Linked list.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   * @param {boolean} clockwise Coordinate order should be clockwise.\n   */\n  ol.render.webgl.PolygonReplay.prototype.processFlatCoordinates_ = function(\n      flatCoordinates, stride, list, rtree, clockwise) {\n    var isClockwise = ol.geom.flat.orient.linearRingIsClockwise(flatCoordinates,\n        0, flatCoordinates.length, stride);\n    var i, ii;\n    var n = this.vertices.length / 2;\n    /** @type {ol.WebglPolygonVertex} */\n    var start;\n    /** @type {ol.WebglPolygonVertex} */\n    var p0;\n    /** @type {ol.WebglPolygonVertex} */\n    var p1;\n    var extents = [];\n    var segments = [];\n    if (clockwise === isClockwise) {\n      start = this.createPoint_(flatCoordinates[0], flatCoordinates[1], n++);\n      p0 = start;\n      for (i = stride, ii = flatCoordinates.length; i < ii; i += stride) {\n        p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);\n        segments.push(this.insertItem_(p0, p1, list));\n        extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x),\n          Math.max(p0.y, p1.y)]);\n        p0 = p1;\n      }\n      segments.push(this.insertItem_(p1, start, list));\n      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x),\n        Math.max(p0.y, p1.y)]);\n    } else {\n      var end = flatCoordinates.length - stride;\n      start = this.createPoint_(flatCoordinates[end], flatCoordinates[end + 1], n++);\n      p0 = start;\n      for (i = end - stride, ii = 0; i >= ii; i -= stride) {\n        p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);\n        segments.push(this.insertItem_(p0, p1, list));\n        extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x),\n          Math.max(p0.y, p1.y)]);\n        p0 = p1;\n      }\n      segments.push(this.insertItem_(p1, start, list));\n      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x),\n        Math.max(p0.y, p1.y)]);\n    }\n    rtree.load(extents, segments);\n  };\n  \n  \n  /**\n   * Returns the rightmost coordinates of a polygon on the X axis.\n   * @private\n   * @param {ol.structs.LinkedList} list Polygons ring.\n   * @return {Array.<number>} Max X coordinates.\n   */\n  ol.render.webgl.PolygonReplay.prototype.getMaxCoords_ = function(list) {\n    var start = list.firstItem();\n    var seg = start;\n    var maxCoords = [seg.p0.x, seg.p0.y];\n  \n    do {\n      seg = list.nextItem();\n      if (seg.p0.x > maxCoords[0]) {\n        maxCoords = [seg.p0.x, seg.p0.y];\n      }\n    } while (seg !== start);\n  \n    return maxCoords;\n  };\n  \n  \n  /**\n   * Classifies the points of a polygon list as convex, reflex. Removes collinear vertices.\n   * @private\n   * @param {ol.structs.LinkedList} list Polygon ring.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   * @param {boolean} ccw The orientation of the polygon is counter-clockwise.\n   * @return {boolean} There were reclassified points.\n   */\n  ol.render.webgl.PolygonReplay.prototype.classifyPoints_ = function(list, rtree, ccw) {\n    var start = list.firstItem();\n    var s0 = start;\n    var s1 = list.nextItem();\n    var pointsReclassified = false;\n    do {\n      var reflex = ccw ? ol.render.webgl.triangleIsCounterClockwise(s1.p1.x,\n          s1.p1.y, s0.p1.x, s0.p1.y, s0.p0.x, s0.p0.y) :\n        ol.render.webgl.triangleIsCounterClockwise(s0.p0.x, s0.p0.y, s0.p1.x,\n            s0.p1.y, s1.p1.x, s1.p1.y);\n      if (reflex === undefined) {\n        this.removeItem_(s0, s1, list, rtree);\n        pointsReclassified = true;\n        if (s1 === start) {\n          start = list.getNextItem();\n        }\n        s1 = s0;\n        list.prevItem();\n      } else if (s0.p1.reflex !== reflex) {\n        s0.p1.reflex = reflex;\n        pointsReclassified = true;\n      }\n      s0 = s1;\n      s1 = list.nextItem();\n    } while (s0 !== start);\n    return pointsReclassified;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.structs.LinkedList} hole Linked list of the hole.\n   * @param {number} holeMaxX Maximum X value of the hole.\n   * @param {ol.structs.LinkedList} list Linked list of the polygon.\n   * @param {number} listMaxX Maximum X value of the polygon.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   * @return {boolean} Bridging was successful.\n   */\n  ol.render.webgl.PolygonReplay.prototype.bridgeHole_ = function(hole, holeMaxX,\n      list, listMaxX, rtree) {\n    var seg = hole.firstItem();\n    while (seg.p1.x !== holeMaxX) {\n      seg = hole.nextItem();\n    }\n  \n    var p1 = seg.p1;\n    /** @type {ol.WebglPolygonVertex} */\n    var p2 = {x: listMaxX, y: p1.y, i: -1};\n    var minDist = Infinity;\n    var i, ii, bestPoint;\n    /** @type {ol.WebglPolygonVertex} */\n    var p5;\n  \n    var intersectingSegments = this.getIntersections_({p0: p1, p1: p2}, rtree, true);\n    for (i = 0, ii = intersectingSegments.length; i < ii; ++i) {\n      var currSeg = intersectingSegments[i];\n      var intersection = this.calculateIntersection_(p1, p2, currSeg.p0,\n          currSeg.p1, true);\n      var dist = Math.abs(p1.x - intersection[0]);\n      if (dist < minDist && ol.render.webgl.triangleIsCounterClockwise(p1.x, p1.y,\n          currSeg.p0.x, currSeg.p0.y, currSeg.p1.x, currSeg.p1.y) !== undefined) {\n        minDist = dist;\n        p5 = {x: intersection[0], y: intersection[1], i: -1};\n        seg = currSeg;\n      }\n    }\n    if (minDist === Infinity) {\n      return false;\n    }\n    bestPoint = seg.p1;\n  \n    if (minDist > 0) {\n      var pointsInTriangle = this.getPointsInTriangle_(p1, p5, seg.p1, rtree);\n      if (pointsInTriangle.length) {\n        var theta = Infinity;\n        for (i = 0, ii = pointsInTriangle.length; i < ii; ++i) {\n          var currPoint = pointsInTriangle[i];\n          var currTheta = Math.atan2(p1.y - currPoint.y, p2.x - currPoint.x);\n          if (currTheta < theta || (currTheta === theta && currPoint.x < bestPoint.x)) {\n            theta = currTheta;\n            bestPoint = currPoint;\n          }\n        }\n      }\n    }\n  \n    seg = list.firstItem();\n    while (seg.p1.x !== bestPoint.x || seg.p1.y !== bestPoint.y) {\n      seg = list.nextItem();\n    }\n  \n    //We clone the bridge points as they can have different convexity.\n    var p0Bridge = {x: p1.x, y: p1.y, i: p1.i, reflex: undefined};\n    var p1Bridge = {x: seg.p1.x, y: seg.p1.y, i: seg.p1.i, reflex: undefined};\n  \n    hole.getNextItem().p0 = p0Bridge;\n    this.insertItem_(p1, seg.p1, hole, rtree);\n    this.insertItem_(p1Bridge, p0Bridge, hole, rtree);\n    seg.p1 = p1Bridge;\n    hole.setFirstItem();\n    list.concat(hole);\n  \n    return true;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.structs.LinkedList} list Linked list of the polygon.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   */\n  ol.render.webgl.PolygonReplay.prototype.triangulate_ = function(list, rtree) {\n    var ccw = false;\n    var simple = this.isSimple_(list, rtree);\n  \n    // Start clipping ears\n    while (list.getLength() > 3) {\n      if (simple) {\n        if (!this.clipEars_(list, rtree, simple, ccw)) {\n          if (!this.classifyPoints_(list, rtree, ccw)) {\n            // Due to the behavior of OL's PIP algorithm, the ear clipping cannot\n            // introduce touching segments. However, the original data may have some.\n            if (!this.resolveSelfIntersections_(list, rtree, true)) {\n              break;\n            }\n          }\n        }\n      } else {\n        if (!this.clipEars_(list, rtree, simple, ccw)) {\n          // We ran out of ears, try to reclassify.\n          if (!this.classifyPoints_(list, rtree, ccw)) {\n            // We have a bad polygon, try to resolve local self-intersections.\n            if (!this.resolveSelfIntersections_(list, rtree)) {\n              simple = this.isSimple_(list, rtree);\n              if (!simple) {\n                // We have a really bad polygon, try more time consuming methods.\n                this.splitPolygon_(list, rtree);\n                break;\n              } else {\n                ccw = !this.isClockwise_(list);\n                this.classifyPoints_(list, rtree, ccw);\n              }\n            }\n          }\n        }\n      }\n    }\n    if (list.getLength() === 3) {\n      var numIndices = this.indices.length;\n      this.indices[numIndices++] = list.getPrevItem().p0.i;\n      this.indices[numIndices++] = list.getCurrItem().p0.i;\n      this.indices[numIndices++] = list.getNextItem().p0.i;\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.structs.LinkedList} list Linked list of the polygon.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   * @param {boolean} simple The polygon is simple.\n   * @param {boolean} ccw Orientation of the polygon is counter-clockwise.\n   * @return {boolean} There were processed ears.\n   */\n  ol.render.webgl.PolygonReplay.prototype.clipEars_ = function(list, rtree, simple, ccw) {\n    var numIndices = this.indices.length;\n    var start = list.firstItem();\n    var s0 = list.getPrevItem();\n    var s1 = start;\n    var s2 = list.nextItem();\n    var s3 = list.getNextItem();\n    var p0, p1, p2;\n    var processedEars = false;\n    do {\n      p0 = s1.p0;\n      p1 = s1.p1;\n      p2 = s2.p1;\n      if (p1.reflex === false) {\n        // We might have a valid ear\n        var variableCriterion;\n        if (simple) {\n          variableCriterion = this.getPointsInTriangle_(p0, p1, p2, rtree, true).length === 0;\n        } else {\n          variableCriterion = ccw ? this.diagonalIsInside_(s3.p1, p2, p1, p0,\n              s0.p0) : this.diagonalIsInside_(s0.p0, p0, p1, p2, s3.p1);\n        }\n        if ((simple || this.getIntersections_({p0: p0, p1: p2}, rtree).length === 0) &&\n            variableCriterion) {\n          //The diagonal is completely inside the polygon\n          if (simple || p0.reflex === false || p2.reflex === false ||\n              ol.geom.flat.orient.linearRingIsClockwise([s0.p0.x, s0.p0.y, p0.x,\n                p0.y, p1.x, p1.y, p2.x, p2.y, s3.p1.x, s3.p1.y], 0, 10, 2) === !ccw) {\n            //The diagonal is persumably valid, we have an ear\n            this.indices[numIndices++] = p0.i;\n            this.indices[numIndices++] = p1.i;\n            this.indices[numIndices++] = p2.i;\n            this.removeItem_(s1, s2, list, rtree);\n            if (s2 === start) {\n              start = s3;\n            }\n            processedEars = true;\n          }\n        }\n      }\n      // Else we have a reflex point.\n      s0 = list.getPrevItem();\n      s1 = list.getCurrItem();\n      s2 = list.nextItem();\n      s3 = list.getNextItem();\n    } while (s1 !== start && list.getLength() > 3);\n  \n    return processedEars;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.structs.LinkedList} list Linked list of the polygon.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   * @param {boolean=} opt_touch Resolve touching segments.\n   * @return {boolean} There were resolved intersections.\n  */\n  ol.render.webgl.PolygonReplay.prototype.resolveSelfIntersections_ = function(\n      list, rtree, opt_touch) {\n    var start = list.firstItem();\n    list.nextItem();\n    var s0 = start;\n    var s1 = list.nextItem();\n    var resolvedIntersections = false;\n  \n    do {\n      var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1,\n          opt_touch);\n      if (intersection) {\n        var breakCond = false;\n        var numVertices = this.vertices.length;\n        var numIndices = this.indices.length;\n        var n = numVertices / 2;\n        var seg = list.prevItem();\n        list.removeItem();\n        rtree.remove(seg);\n        breakCond = (seg === start);\n        var p;\n        if (opt_touch) {\n          if (intersection[0] === s0.p0.x && intersection[1] === s0.p0.y) {\n            list.prevItem();\n            p = s0.p0;\n            s1.p0 = p;\n            rtree.remove(s0);\n            breakCond = breakCond || (s0 === start);\n          } else {\n            p = s1.p1;\n            s0.p1 = p;\n            rtree.remove(s1);\n            breakCond = breakCond || (s1 === start);\n          }\n          list.removeItem();\n        } else {\n          p = this.createPoint_(intersection[0], intersection[1], n);\n          s0.p1 = p;\n          s1.p0 = p;\n          rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y),\n            Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);\n          rtree.update([Math.min(s1.p0.x, s1.p1.x), Math.min(s1.p0.y, s1.p1.y),\n            Math.max(s1.p0.x, s1.p1.x), Math.max(s1.p0.y, s1.p1.y)], s1);\n        }\n  \n        this.indices[numIndices++] = seg.p0.i;\n        this.indices[numIndices++] = seg.p1.i;\n        this.indices[numIndices++] = p.i;\n  \n        resolvedIntersections = true;\n        if (breakCond) {\n          break;\n        }\n      }\n  \n      s0 = list.getPrevItem();\n      s1 = list.nextItem();\n    } while (s0 !== start);\n    return resolvedIntersections;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.structs.LinkedList} list Linked list of the polygon.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   * @return {boolean} The polygon is simple.\n   */\n  ol.render.webgl.PolygonReplay.prototype.isSimple_ = function(list, rtree) {\n    var start = list.firstItem();\n    var seg = start;\n    do {\n      if (this.getIntersections_(seg, rtree).length) {\n        return false;\n      }\n      seg = list.nextItem();\n    } while (seg !== start);\n    return true;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.structs.LinkedList} list Linked list of the polygon.\n   * @return {boolean} Orientation is clockwise.\n   */\n  ol.render.webgl.PolygonReplay.prototype.isClockwise_ = function(list) {\n    var length = list.getLength() * 2;\n    var flatCoordinates = new Array(length);\n    var start = list.firstItem();\n    var seg = start;\n    var i = 0;\n    do {\n      flatCoordinates[i++] = seg.p0.x;\n      flatCoordinates[i++] = seg.p0.y;\n      seg = list.nextItem();\n    } while (seg !== start);\n    return ol.geom.flat.orient.linearRingIsClockwise(flatCoordinates, 0, length, 2);\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.structs.LinkedList} list Linked list of the polygon.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   */\n  ol.render.webgl.PolygonReplay.prototype.splitPolygon_ = function(list, rtree) {\n    var start = list.firstItem();\n    var s0 = start;\n    do {\n      var intersections = this.getIntersections_(s0, rtree);\n      if (intersections.length) {\n        var s1 = intersections[0];\n        var n = this.vertices.length / 2;\n        var intersection = this.calculateIntersection_(s0.p0,\n            s0.p1, s1.p0, s1.p1);\n        var p = this.createPoint_(intersection[0], intersection[1], n);\n        var newPolygon = new ol.structs.LinkedList();\n        var newRtree = new ol.structs.RBush();\n        this.insertItem_(p, s0.p1, newPolygon, newRtree);\n        s0.p1 = p;\n        rtree.update([Math.min(s0.p0.x, p.x), Math.min(s0.p0.y, p.y),\n          Math.max(s0.p0.x, p.x), Math.max(s0.p0.y, p.y)], s0);\n        var currItem = list.nextItem();\n        while (currItem !== s1) {\n          this.insertItem_(currItem.p0, currItem.p1, newPolygon, newRtree);\n          rtree.remove(currItem);\n          list.removeItem();\n          currItem = list.getCurrItem();\n        }\n        this.insertItem_(s1.p0, p, newPolygon, newRtree);\n        s1.p0 = p;\n        rtree.update([Math.min(s1.p1.x, p.x), Math.min(s1.p1.y, p.y),\n          Math.max(s1.p1.x, p.x), Math.max(s1.p1.y, p.y)], s1);\n        this.classifyPoints_(list, rtree, false);\n        this.triangulate_(list, rtree);\n        this.classifyPoints_(newPolygon, newRtree, false);\n        this.triangulate_(newPolygon, newRtree);\n        break;\n      }\n      s0 = list.nextItem();\n    } while (s0 !== start);\n  };\n  \n  \n  /**\n   * @private\n   * @param {number} x X coordinate.\n   * @param {number} y Y coordinate.\n   * @param {number} i Index.\n   * @return {ol.WebglPolygonVertex} List item.\n   */\n  ol.render.webgl.PolygonReplay.prototype.createPoint_ = function(x, y, i) {\n    var numVertices = this.vertices.length;\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    /** @type {ol.WebglPolygonVertex} */\n    var p = {\n      x: x,\n      y: y,\n      i: i,\n      reflex: undefined\n    };\n    return p;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.WebglPolygonVertex} p0 First point of segment.\n   * @param {ol.WebglPolygonVertex} p1 Second point of segment.\n   * @param {ol.structs.LinkedList} list Polygon ring.\n   * @param {ol.structs.RBush=} opt_rtree Insert the segment into the R-Tree.\n   * @return {ol.WebglPolygonSegment} segment.\n   */\n  ol.render.webgl.PolygonReplay.prototype.insertItem_ = function(p0, p1, list, opt_rtree) {\n    var seg = {\n      p0: p0,\n      p1: p1\n    };\n    list.insertItem(seg);\n    if (opt_rtree) {\n      opt_rtree.insert([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y),\n        Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)], seg);\n    }\n    return seg;\n  };\n  \n  \n  /**\n    * @private\n    * @param {ol.WebglPolygonSegment} s0 Segment before the remove candidate.\n    * @param {ol.WebglPolygonSegment} s1 Remove candidate segment.\n    * @param {ol.structs.LinkedList} list Polygon ring.\n    * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n    */\n  ol.render.webgl.PolygonReplay.prototype.removeItem_ = function(s0, s1, list, rtree) {\n    if (list.getCurrItem() === s1) {\n      list.removeItem();\n      s0.p1 = s1.p1;\n      rtree.remove(s1);\n      rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y),\n        Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.WebglPolygonVertex} p0 First point.\n   * @param {ol.WebglPolygonVertex} p1 Second point.\n   * @param {ol.WebglPolygonVertex} p2 Third point.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   * @param {boolean=} opt_reflex Only include reflex points.\n   * @return {Array.<ol.WebglPolygonVertex>} Points in the triangle.\n   */\n  ol.render.webgl.PolygonReplay.prototype.getPointsInTriangle_ = function(p0, p1,\n      p2, rtree, opt_reflex) {\n    var i, ii, j, p;\n    var result = [];\n    var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x, p2.x),\n      Math.min(p0.y, p1.y, p2.y), Math.max(p0.x, p1.x, p2.x), Math.max(p0.y,\n          p1.y, p2.y)]);\n    for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {\n      for (j in segmentsInExtent[i]) {\n        p = segmentsInExtent[i][j];\n        if (typeof p === 'object' && (!opt_reflex || p.reflex)) {\n          if ((p.x !== p0.x || p.y !== p0.y) && (p.x !== p1.x || p.y !== p1.y) &&\n              (p.x !== p2.x || p.y !== p2.y) && result.indexOf(p) === -1 &&\n              ol.geom.flat.contains.linearRingContainsXY([p0.x, p0.y, p1.x, p1.y,\n                p2.x, p2.y], 0, 6, 2, p.x, p.y)) {\n            result.push(p);\n          }\n        }\n      }\n    }\n    return result;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.WebglPolygonSegment} segment Segment.\n   * @param {ol.structs.RBush} rtree R-Tree of the polygon.\n   * @param {boolean=} opt_touch Touching segments should be considered an intersection.\n   * @return {Array.<ol.WebglPolygonSegment>} Intersecting segments.\n   */\n  ol.render.webgl.PolygonReplay.prototype.getIntersections_ = function(segment, rtree, opt_touch) {\n    var p0 = segment.p0;\n    var p1 = segment.p1;\n    var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x),\n      Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);\n    var result = [];\n    var i, ii;\n    for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {\n      var currSeg = segmentsInExtent[i];\n      if (segment !== currSeg && (opt_touch || currSeg.p0 !== p1 || currSeg.p1 !== p0) &&\n          this.calculateIntersection_(p0, p1, currSeg.p0, currSeg.p1, opt_touch)) {\n        result.push(currSeg);\n      }\n    }\n    return result;\n  };\n  \n  \n  /**\n   * Line intersection algorithm by Paul Bourke.\n   * @see http://paulbourke.net/geometry/pointlineplane/\n   *\n   * @private\n   * @param {ol.WebglPolygonVertex} p0 First point.\n   * @param {ol.WebglPolygonVertex} p1 Second point.\n   * @param {ol.WebglPolygonVertex} p2 Third point.\n   * @param {ol.WebglPolygonVertex} p3 Fourth point.\n   * @param {boolean=} opt_touch Touching segments should be considered an intersection.\n   * @return {Array.<number>|undefined} Intersection coordinates.\n   */\n  ol.render.webgl.PolygonReplay.prototype.calculateIntersection_ = function(p0,\n      p1, p2, p3, opt_touch) {\n    var denom = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y);\n    if (denom !== 0) {\n      var ua = ((p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x)) / denom;\n      var ub = ((p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x)) / denom;\n      if ((!opt_touch && ua > ol.render.webgl.EPSILON && ua < 1 - ol.render.webgl.EPSILON &&\n          ub > ol.render.webgl.EPSILON && ub < 1 - ol.render.webgl.EPSILON) || (opt_touch &&\n          ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)) {\n        return [p0.x + ua * (p1.x - p0.x), p0.y + ua * (p1.y - p0.y)];\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.WebglPolygonVertex} p0 Point before the start of the diagonal.\n   * @param {ol.WebglPolygonVertex} p1 Start point of the diagonal.\n   * @param {ol.WebglPolygonVertex} p2 Ear candidate.\n   * @param {ol.WebglPolygonVertex} p3 End point of the diagonal.\n   * @param {ol.WebglPolygonVertex} p4 Point after the end of the diagonal.\n   * @return {boolean} Diagonal is inside the polygon.\n   */\n  ol.render.webgl.PolygonReplay.prototype.diagonalIsInside_ = function(p0, p1, p2, p3, p4) {\n    if (p1.reflex === undefined || p3.reflex === undefined) {\n      return false;\n    }\n    var p1IsLeftOf = (p2.x - p3.x) * (p1.y - p3.y) > (p2.y - p3.y) * (p1.x - p3.x);\n    var p1IsRightOf = (p4.x - p3.x) * (p1.y - p3.y) < (p4.y - p3.y) * (p1.x - p3.x);\n    var p3IsLeftOf = (p0.x - p1.x) * (p3.y - p1.y) > (p0.y - p1.y) * (p3.x - p1.x);\n    var p3IsRightOf = (p2.x - p1.x) * (p3.y - p1.y) < (p2.y - p1.y) * (p3.x - p1.x);\n    var p1InCone = p3.reflex ? p1IsRightOf || p1IsLeftOf : p1IsRightOf && p1IsLeftOf;\n    var p3InCone = p1.reflex ? p3IsRightOf || p3IsLeftOf : p3IsRightOf && p3IsLeftOf;\n    return p1InCone && p3InCone;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.PolygonReplay.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {\n    var endss = multiPolygonGeometry.getEndss();\n    var stride = multiPolygonGeometry.getStride();\n    var currIndex = this.indices.length;\n    var currLineIndex = this.lineStringReplay.getCurrentIndex();\n    var flatCoordinates = multiPolygonGeometry.getFlatCoordinates();\n    var i, ii, j, jj;\n    var start = 0;\n    for (i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i];\n      if (ends.length > 0) {\n        var outerRing = ol.geom.flat.transform.translate(flatCoordinates, start, ends[0],\n            stride, -this.origin[0], -this.origin[1]);\n        if (outerRing.length) {\n          var holes = [];\n          var holeFlatCoords;\n          for (j = 1, jj = ends.length; j < jj; ++j) {\n            if (ends[j] !== ends[j - 1]) {\n              holeFlatCoords = ol.geom.flat.transform.translate(flatCoordinates, ends[j - 1],\n                  ends[j], stride, -this.origin[0], -this.origin[1]);\n              holes.push(holeFlatCoords);\n            }\n          }\n          this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);\n          this.drawCoordinates_(outerRing, holes, stride);\n        }\n      }\n      start = ends[ends.length - 1];\n    }\n    if (this.indices.length > currIndex) {\n      this.startIndices.push(currIndex);\n      this.startIndicesFeature.push(feature);\n      if (this.state_.changed) {\n        this.styleIndices_.push(currIndex);\n        this.state_.changed = false;\n      }\n    }\n    if (this.lineStringReplay.getCurrentIndex() > currLineIndex) {\n      this.lineStringReplay.setPolygonStyle(feature, currLineIndex);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.PolygonReplay.prototype.drawPolygon = function(polygonGeometry, feature) {\n    var ends = polygonGeometry.getEnds();\n    var stride = polygonGeometry.getStride();\n    if (ends.length > 0) {\n      var flatCoordinates = polygonGeometry.getFlatCoordinates().map(Number);\n      var outerRing = ol.geom.flat.transform.translate(flatCoordinates, 0, ends[0],\n          stride, -this.origin[0], -this.origin[1]);\n      if (outerRing.length) {\n        var holes = [];\n        var i, ii, holeFlatCoords;\n        for (i = 1, ii = ends.length; i < ii; ++i) {\n          if (ends[i] !== ends[i - 1]) {\n            holeFlatCoords = ol.geom.flat.transform.translate(flatCoordinates, ends[i - 1],\n                ends[i], stride, -this.origin[0], -this.origin[1]);\n            holes.push(holeFlatCoords);\n          }\n        }\n  \n        this.startIndices.push(this.indices.length);\n        this.startIndicesFeature.push(feature);\n        if (this.state_.changed) {\n          this.styleIndices_.push(this.indices.length);\n          this.state_.changed = false;\n        }\n        this.lineStringReplay.setPolygonStyle(feature);\n  \n        this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);\n        this.drawCoordinates_(outerRing, holes, stride);\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   **/\n  ol.render.webgl.PolygonReplay.prototype.finish = function(context) {\n    // create, bind, and populate the vertices buffer\n    this.verticesBuffer = new ol.webgl.Buffer(this.vertices);\n  \n    // create, bind, and populate the indices buffer\n    this.indicesBuffer = new ol.webgl.Buffer(this.indices);\n  \n    this.startIndices.push(this.indices.length);\n  \n    this.lineStringReplay.finish(context);\n  \n    //Clean up, if there is nothing to draw\n    if (this.styleIndices_.length === 0 && this.styles_.length > 0) {\n      this.styles_ = [];\n    }\n  \n    this.vertices = null;\n    this.indices = null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.PolygonReplay.prototype.getDeleteResourcesFunction = function(context) {\n    var verticesBuffer = this.verticesBuffer;\n    var indicesBuffer = this.indicesBuffer;\n    var lineDeleter = this.lineStringReplay.getDeleteResourcesFunction(context);\n    return function() {\n      context.deleteBuffer(verticesBuffer);\n      context.deleteBuffer(indicesBuffer);\n      lineDeleter();\n    };\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.PolygonReplay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {\n    // get the program\n    var fragmentShader, vertexShader;\n    fragmentShader = ol.render.webgl.polygonreplay.defaultshader.fragment;\n    vertexShader = ol.render.webgl.polygonreplay.defaultshader.vertex;\n    var program = context.getProgram(fragmentShader, vertexShader);\n  \n    // get the locations\n    var locations;\n    if (!this.defaultLocations_) {\n      locations = new ol.render.webgl.polygonreplay.defaultshader.Locations(gl, program);\n      this.defaultLocations_ = locations;\n    } else {\n      locations = this.defaultLocations_;\n    }\n  \n    context.useProgram(program);\n  \n    // enable the vertex attrib arrays\n    gl.enableVertexAttribArray(locations.a_position);\n    gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT,\n        false, 8, 0);\n  \n    return locations;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.PolygonReplay.prototype.shutDownProgram = function(gl, locations) {\n    gl.disableVertexAttribArray(locations.a_position);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.PolygonReplay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {\n    //Save GL parameters.\n    var tmpDepthFunc = /** @type {number} */ (gl.getParameter(gl.DEPTH_FUNC));\n    var tmpDepthMask = /** @type {boolean} */ (gl.getParameter(gl.DEPTH_WRITEMASK));\n  \n    if (!hitDetection) {\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthMask(true);\n      gl.depthFunc(gl.NOTEQUAL);\n    }\n  \n    if (!ol.obj.isEmpty(skippedFeaturesHash)) {\n      this.drawReplaySkipping_(gl, context, skippedFeaturesHash);\n    } else {\n      //Draw by style groups to minimize drawElements() calls.\n      var i, start, end, nextStyle;\n      end = this.startIndices[this.startIndices.length - 1];\n      for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n        start = this.styleIndices_[i];\n        nextStyle = this.styles_[i];\n        this.setFillStyle_(gl, nextStyle);\n        this.drawElements(gl, context, start, end);\n        end = start;\n      }\n    }\n    if (!hitDetection) {\n      gl.disable(gl.DEPTH_TEST);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n      //Restore GL parameters.\n      gl.depthMask(tmpDepthMask);\n      gl.depthFunc(tmpDepthFunc);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.PolygonReplay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash,\n      featureCallback, opt_hitExtent) {\n    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;\n    featureIndex = this.startIndices.length - 2;\n    end = this.startIndices[featureIndex + 1];\n    for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n      nextStyle = this.styles_[i];\n      this.setFillStyle_(gl, nextStyle);\n      groupStart = this.styleIndices_[i];\n  \n      while (featureIndex >= 0 &&\n          this.startIndices[featureIndex] >= groupStart) {\n        start = this.startIndices[featureIndex];\n        feature = this.startIndicesFeature[featureIndex];\n        featureUid = ol.getUid(feature).toString();\n  \n        if (skippedFeaturesHash[featureUid] === undefined &&\n            feature.getGeometry() &&\n            (opt_hitExtent === undefined || ol.extent.intersects(\n                /** @type {Array<number>} */ (opt_hitExtent),\n                feature.getGeometry().getExtent()))) {\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n          this.drawElements(gl, context, start, end);\n  \n          var result = featureCallback(feature);\n  \n          if (result) {\n            return result;\n          }\n  \n        }\n        featureIndex--;\n        end = start;\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @private\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {ol.webgl.Context} context Context.\n   * @param {Object} skippedFeaturesHash Ids of features to skip.\n   */\n  ol.render.webgl.PolygonReplay.prototype.drawReplaySkipping_ = function(gl, context, skippedFeaturesHash) {\n    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;\n    featureIndex = this.startIndices.length - 2;\n    end = start = this.startIndices[featureIndex + 1];\n    for (i = this.styleIndices_.length - 1; i >= 0; --i) {\n      nextStyle = this.styles_[i];\n      this.setFillStyle_(gl, nextStyle);\n      groupStart = this.styleIndices_[i];\n  \n      while (featureIndex >= 0 &&\n          this.startIndices[featureIndex] >= groupStart) {\n        featureStart = this.startIndices[featureIndex];\n        feature = this.startIndicesFeature[featureIndex];\n        featureUid = ol.getUid(feature).toString();\n  \n        if (skippedFeaturesHash[featureUid]) {\n          if (start !== end) {\n            this.drawElements(gl, context, start, end);\n            gl.clear(gl.DEPTH_BUFFER_BIT);\n          }\n          end = featureStart;\n        }\n        featureIndex--;\n        start = featureStart;\n      }\n      if (start !== end) {\n        this.drawElements(gl, context, start, end);\n        gl.clear(gl.DEPTH_BUFFER_BIT);\n      }\n      start = end = groupStart;\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {WebGLRenderingContext} gl gl.\n   * @param {Array.<number>} color Color.\n   */\n  ol.render.webgl.PolygonReplay.prototype.setFillStyle_ = function(gl, color) {\n    gl.uniform4fv(this.defaultLocations_.u_color, color);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.PolygonReplay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n    var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];\n    if (!(fillStyleColor instanceof CanvasGradient) &&\n        !(fillStyleColor instanceof CanvasPattern)) {\n      fillStyleColor = ol.color.asArray(fillStyleColor).map(function(c, i) {\n        return i != 3 ? c / 255 : c;\n      }) || ol.render.webgl.defaultFillStyle;\n    } else {\n      fillStyleColor = ol.render.webgl.defaultFillStyle;\n    }\n    if (!this.state_.fillColor || !ol.array.equals(fillStyleColor, this.state_.fillColor)) {\n      this.state_.fillColor = fillStyleColor;\n      this.state_.changed = true;\n      this.styles_.push(fillStyleColor);\n    }\n    //Provide a null stroke style, if no strokeStyle is provided. Required for the draw interaction to work.\n    if (strokeStyle) {\n      this.lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    } else {\n      var nullStrokeStyle = new ol.style.Stroke({\n        color: [0, 0, 0, 0],\n        lineWidth: 0\n      });\n      this.lineStringReplay.setFillStrokeStyle(null, nullStrokeStyle);\n    }\n  };\n  \n  goog.provide('ol.style.Atlas');\n  \n  goog.require('ol.dom');\n  \n  \n  /**\n   * This class facilitates the creation of image atlases.\n   *\n   * Images added to an atlas will be rendered onto a single\n   * atlas canvas. The distribution of images on the canvas is\n   * managed with the bin packing algorithm described in:\n   * http://www.blackpawn.com/texts/lightmaps/\n   *\n   * @constructor\n   * @struct\n   * @param {number} size The size in pixels of the sprite image.\n   * @param {number} space The space in pixels between images.\n   *    Because texture coordinates are float values, the edges of\n   *    images might not be completely correct (in a way that the\n   *    edges overlap when being rendered). To avoid this we add a\n   *    padding around each image.\n   */\n  ol.style.Atlas = function(size, space) {\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.space_ = space;\n  \n    /**\n     * @private\n     * @type {Array.<ol.AtlasBlock>}\n     */\n    this.emptyBlocks_ = [{x: 0, y: 0, width: size, height: size}];\n  \n    /**\n     * @private\n     * @type {Object.<string, ol.AtlasInfo>}\n     */\n    this.entries_ = {};\n  \n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context_ = ol.dom.createCanvasContext2D(size, size);\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = this.context_.canvas;\n  };\n  \n  \n  /**\n   * @param {string} id The identifier of the entry to check.\n   * @return {?ol.AtlasInfo} The atlas info.\n   */\n  ol.style.Atlas.prototype.get = function(id) {\n    return this.entries_[id] || null;\n  };\n  \n  \n  /**\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback`.\n   * @return {?ol.AtlasInfo} The position and atlas image for the entry.\n   */\n  ol.style.Atlas.prototype.add = function(id, width, height, renderCallback, opt_this) {\n    var block, i, ii;\n    for (i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\n      block = this.emptyBlocks_[i];\n      if (block.width >= width + this.space_ &&\n          block.height >= height + this.space_) {\n        // we found a block that is big enough for our entry\n        var entry = {\n          offsetX: block.x + this.space_,\n          offsetY: block.y + this.space_,\n          image: this.canvas_\n        };\n        this.entries_[id] = entry;\n  \n        // render the image on the atlas image\n        renderCallback.call(opt_this, this.context_,\n            block.x + this.space_, block.y + this.space_);\n  \n        // split the block after the insertion, either horizontally or vertically\n        this.split_(i, block, width + this.space_, height + this.space_);\n  \n        return entry;\n      }\n    }\n  \n    // there is no space for the new entry in this atlas\n    return null;\n  };\n  \n  \n  /**\n   * @private\n   * @param {number} index The index of the block.\n   * @param {ol.AtlasBlock} block The block to split.\n   * @param {number} width The width of the entry to insert.\n   * @param {number} height The height of the entry to insert.\n   */\n  ol.style.Atlas.prototype.split_ = function(index, block, width, height) {\n    var deltaWidth = block.width - width;\n    var deltaHeight = block.height - height;\n  \n    /** @type {ol.AtlasBlock} */\n    var newBlock1;\n    /** @type {ol.AtlasBlock} */\n    var newBlock2;\n  \n    if (deltaWidth > deltaHeight) {\n      // split vertically\n      // block right of the inserted entry\n      newBlock1 = {\n        x: block.x + width,\n        y: block.y,\n        width: block.width - width,\n        height: block.height\n      };\n  \n      // block below the inserted entry\n      newBlock2 = {\n        x: block.x,\n        y: block.y + height,\n        width: width,\n        height: block.height - height\n      };\n      this.updateBlocks_(index, newBlock1, newBlock2);\n    } else {\n      // split horizontally\n      // block right of the inserted entry\n      newBlock1 = {\n        x: block.x + width,\n        y: block.y,\n        width: block.width - width,\n        height: height\n      };\n  \n      // block below the inserted entry\n      newBlock2 = {\n        x: block.x,\n        y: block.y + height,\n        width: block.width,\n        height: block.height - height\n      };\n      this.updateBlocks_(index, newBlock1, newBlock2);\n    }\n  };\n  \n  \n  /**\n   * Remove the old block and insert new blocks at the same array position.\n   * The new blocks are inserted at the same position, so that splitted\n   * blocks (that are potentially smaller) are filled first.\n   * @private\n   * @param {number} index The index of the block to remove.\n   * @param {ol.AtlasBlock} newBlock1 The 1st block to add.\n   * @param {ol.AtlasBlock} newBlock2 The 2nd block to add.\n   */\n  ol.style.Atlas.prototype.updateBlocks_ = function(index, newBlock1, newBlock2) {\n    var args = [index, 1];\n    if (newBlock1.width > 0 && newBlock1.height > 0) {\n      args.push(newBlock1);\n    }\n    if (newBlock2.width > 0 && newBlock2.height > 0) {\n      args.push(newBlock2);\n    }\n    this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\n  };\n  \n  goog.provide('ol.style.AtlasManager');\n  \n  goog.require('ol');\n  goog.require('ol.style.Atlas');\n  \n  \n  /**\n   * Manages the creation of image atlases.\n   *\n   * Images added to this manager will be inserted into an atlas, which\n   * will be used for rendering.\n   * The `size` given in the constructor is the size for the first\n   * atlas. After that, when new atlases are created, they will have\n   * twice the size as the latest atlas (until `maxSize` is reached).\n   *\n   * If an application uses many images or very large images, it is recommended\n   * to set a higher `size` value to avoid the creation of too many atlases.\n   *\n   * @constructor\n   * @struct\n   * @api\n   * @param {olx.style.AtlasManagerOptions=} opt_options Options.\n   */\n  ol.style.AtlasManager = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    /**\n     * The size in pixels of the latest atlas image.\n     * @private\n     * @type {number}\n     */\n    this.currentSize_ = options.initialSize !== undefined ?\n      options.initialSize : ol.INITIAL_ATLAS_SIZE;\n  \n    /**\n     * The maximum size in pixels of atlas images.\n     * @private\n     * @type {number}\n     */\n    this.maxSize_ = options.maxSize !== undefined ?\n      options.maxSize : ol.MAX_ATLAS_SIZE != -1 ?\n        ol.MAX_ATLAS_SIZE : ol.WEBGL_MAX_TEXTURE_SIZE !== undefined ?\n          ol.WEBGL_MAX_TEXTURE_SIZE : 2048;\n  \n    /**\n     * The size in pixels between images.\n     * @private\n     * @type {number}\n     */\n    this.space_ = options.space !== undefined ? options.space : 1;\n  \n    /**\n     * @private\n     * @type {Array.<ol.style.Atlas>}\n     */\n    this.atlases_ = [new ol.style.Atlas(this.currentSize_, this.space_)];\n  \n    /**\n     * The size in pixels of the latest atlas image for hit-detection images.\n     * @private\n     * @type {number}\n     */\n    this.currentHitSize_ = this.currentSize_;\n  \n    /**\n     * @private\n     * @type {Array.<ol.style.Atlas>}\n     */\n    this.hitAtlases_ = [new ol.style.Atlas(this.currentHitSize_, this.space_)];\n  };\n  \n  \n  /**\n   * @param {string} id The identifier of the entry to check.\n   * @return {?ol.AtlasManagerInfo} The position and atlas image for the\n   *    entry, or `null` if the entry is not part of the atlas manager.\n   */\n  ol.style.AtlasManager.prototype.getInfo = function(id) {\n    /** @type {?ol.AtlasInfo} */\n    var info = this.getInfo_(this.atlases_, id);\n  \n    if (!info) {\n      return null;\n    }\n    var hitInfo = /** @type {ol.AtlasInfo} */ (this.getInfo_(this.hitAtlases_, id));\n  \n    return this.mergeInfos_(info, hitInfo);\n  };\n  \n  \n  /**\n   * @private\n   * @param {Array.<ol.style.Atlas>} atlases The atlases to search.\n   * @param {string} id The identifier of the entry to check.\n   * @return {?ol.AtlasInfo} The position and atlas image for the entry,\n   *    or `null` if the entry is not part of the atlases.\n   */\n  ol.style.AtlasManager.prototype.getInfo_ = function(atlases, id) {\n    var atlas, info, i, ii;\n    for (i = 0, ii = atlases.length; i < ii; ++i) {\n      atlas = atlases[i];\n      info = atlas.get(id);\n      if (info) {\n        return info;\n      }\n    }\n    return null;\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.AtlasInfo} info The info for the real image.\n   * @param {ol.AtlasInfo} hitInfo The info for the hit-detection\n   *    image.\n   * @return {?ol.AtlasManagerInfo} The position and atlas image for the\n   *    entry, or `null` if the entry is not part of the atlases.\n   */\n  ol.style.AtlasManager.prototype.mergeInfos_ = function(info, hitInfo) {\n    return /** @type {ol.AtlasManagerInfo} */ ({\n      offsetX: info.offsetX,\n      offsetY: info.offsetY,\n      image: info.image,\n      hitImage: hitInfo.image\n    });\n  };\n  \n  \n  /**\n   * Add an image to the atlas manager.\n   *\n   * If an entry for the given id already exists, the entry will\n   * be overridden (but the space on the atlas graphic will not be freed).\n   *\n   * If `renderHitCallback` is provided, the image (or the hit-detection version\n   * of the image) will be rendered into a separate hit-detection atlas image.\n   *\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {function(CanvasRenderingContext2D, number, number)=}\n   *    opt_renderHitCallback Called to render a hit-detection image onto a hit\n   *    detection atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback` and `renderHitCallback`.\n   * @return {?ol.AtlasManagerInfo}  The position and atlas image for the\n   *    entry, or `null` if the image is too big.\n   */\n  ol.style.AtlasManager.prototype.add = function(id, width, height,\n      renderCallback, opt_renderHitCallback, opt_this) {\n    if (width + this.space_ > this.maxSize_ ||\n        height + this.space_ > this.maxSize_) {\n      return null;\n    }\n  \n    /** @type {?ol.AtlasInfo} */\n    var info = this.add_(false,\n        id, width, height, renderCallback, opt_this);\n    if (!info) {\n      return null;\n    }\n  \n    // even if no hit-detection entry is requested, we insert a fake entry into\n    // the hit-detection atlas, to make sure that the offset is the same for\n    // the original image and the hit-detection image.\n    var renderHitCallback = opt_renderHitCallback !== undefined ?\n      opt_renderHitCallback : ol.nullFunction;\n  \n    var hitInfo = /** @type {ol.AtlasInfo} */ (this.add_(true,\n        id, width, height, renderHitCallback, opt_this));\n  \n    return this.mergeInfos_(info, hitInfo);\n  };\n  \n  \n  /**\n   * @private\n   * @param {boolean} isHitAtlas If the hit-detection atlases are used.\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback` and `renderHitCallback`.\n   * @return {?ol.AtlasInfo}  The position and atlas image for the entry,\n   *    or `null` if the image is too big.\n   */\n  ol.style.AtlasManager.prototype.add_ = function(isHitAtlas, id, width, height,\n      renderCallback, opt_this) {\n    var atlases = (isHitAtlas) ? this.hitAtlases_ : this.atlases_;\n    var atlas, info, i, ii;\n    for (i = 0, ii = atlases.length; i < ii; ++i) {\n      atlas = atlases[i];\n      info = atlas.add(id, width, height, renderCallback, opt_this);\n      if (info) {\n        return info;\n      } else if (!info && i === ii - 1) {\n        // the entry could not be added to one of the existing atlases,\n        // create a new atlas that is twice as big and try to add to this one.\n        var size;\n        if (isHitAtlas) {\n          size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\n          this.currentHitSize_ = size;\n        } else {\n          size = Math.min(this.currentSize_ * 2, this.maxSize_);\n          this.currentSize_ = size;\n        }\n        atlas = new ol.style.Atlas(size, this.space_);\n        atlases.push(atlas);\n        // run the loop another time\n        ++ii;\n      }\n    }\n    return null;\n  };\n  \n  goog.provide('ol.render.webgl.TextReplay');\n  \n  goog.require('ol');\n  goog.require('ol.colorlike');\n  goog.require('ol.dom');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.has');\n  goog.require('ol.render.replay');\n  goog.require('ol.render.webgl');\n  goog.require('ol.render.webgl.TextureReplay');\n  goog.require('ol.style.AtlasManager');\n  goog.require('ol.webgl.Buffer');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.webgl.TextureReplay}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @struct\n   */\n  ol.render.webgl.TextReplay = function(tolerance, maxExtent) {\n    ol.render.webgl.TextureReplay.call(this, tolerance, maxExtent);\n  \n    /**\n     * @private\n     * @type {Array.<HTMLCanvasElement>}\n     */\n    this.images_ = [];\n  \n    /**\n     * @private\n     * @type {Array.<WebGLTexture>}\n     */\n    this.textures_ = [];\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.measureCanvas_ = ol.dom.createCanvasContext2D(0, 0).canvas;\n  \n    /**\n     * @private\n     * @type {{strokeColor: (ol.ColorLike|null),\n     *         lineCap: (string|undefined),\n     *         lineDash: Array.<number>,\n     *         lineDashOffset: (number|undefined),\n     *         lineJoin: (string|undefined),\n     *         lineWidth: number,\n     *         miterLimit: (number|undefined),\n     *         fillColor: (ol.ColorLike|null),\n     *         font: (string|undefined),\n     *         scale: (number|undefined)}}\n     */\n    this.state_ = {\n      strokeColor: null,\n      lineCap: undefined,\n      lineDash: null,\n      lineDashOffset: undefined,\n      lineJoin: undefined,\n      lineWidth: 0,\n      miterLimit: undefined,\n      fillColor: null,\n      font: undefined,\n      scale: undefined\n    };\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.text_ = '';\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.textAlign_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.textBaseline_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.offsetX_ = undefined;\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.offsetY_ = undefined;\n  \n    /**\n     * @private\n     * @type {Object.<string, ol.WebglGlyphAtlas>}\n     */\n    this.atlases_ = {};\n  \n    /**\n     * @private\n     * @type {ol.WebglGlyphAtlas|undefined}\n     */\n    this.currAtlas_ = undefined;\n  \n    this.scale = 1;\n  \n    this.opacity = 1;\n  \n  };\n  ol.inherits(ol.render.webgl.TextReplay, ol.render.webgl.TextureReplay);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextReplay.prototype.drawText = function(geometry, feature) {\n    if (this.text_) {\n      var flatCoordinates = null;\n      var offset = 0;\n      var end = 2;\n      var stride = 2;\n      switch (geometry.getType()) {\n        case ol.geom.GeometryType.POINT:\n        case ol.geom.GeometryType.MULTI_POINT:\n          flatCoordinates = geometry.getFlatCoordinates();\n          end = flatCoordinates.length;\n          stride = geometry.getStride();\n          break;\n        case ol.geom.GeometryType.CIRCLE:\n          flatCoordinates = /** @type {ol.geom.Circle} */ (geometry).getCenter();\n          break;\n        case ol.geom.GeometryType.LINE_STRING:\n          flatCoordinates = /** @type {ol.geom.LineString} */ (geometry).getFlatMidpoint();\n          break;\n        case ol.geom.GeometryType.MULTI_LINE_STRING:\n          flatCoordinates = /** @type {ol.geom.MultiLineString} */ (geometry).getFlatMidpoints();\n          end = flatCoordinates.length;\n          break;\n        case ol.geom.GeometryType.POLYGON:\n          flatCoordinates = /** @type {ol.geom.Polygon} */ (geometry).getFlatInteriorPoint();\n          break;\n        case ol.geom.GeometryType.MULTI_POLYGON:\n          flatCoordinates = /** @type {ol.geom.MultiPolygon} */ (geometry).getFlatInteriorPoints();\n          end = flatCoordinates.length;\n          break;\n        default:\n      }\n      this.startIndices.push(this.indices.length);\n      this.startIndicesFeature.push(feature);\n  \n      var glyphAtlas = this.currAtlas_;\n      var lines = this.text_.split('\\n');\n      var textSize = this.getTextSize_(lines);\n      var i, ii, j, jj, currX, currY, charArr, charInfo;\n      var anchorX = Math.round(textSize[0] * this.textAlign_ - this.offsetX_);\n      var anchorY = Math.round(textSize[1] * this.textBaseline_ - this.offsetY_);\n      var lineWidth = (this.state_.lineWidth / 2) * this.state_.scale;\n  \n      for (i = 0, ii = lines.length; i < ii; ++i) {\n        currX = 0;\n        currY = glyphAtlas.height * i;\n        charArr = lines[i].split('');\n  \n        for (j = 0, jj = charArr.length; j < jj; ++j) {\n          charInfo = glyphAtlas.atlas.getInfo(charArr[j]);\n  \n          if (charInfo) {\n            var image = charInfo.image;\n  \n            this.anchorX = anchorX - currX;\n            this.anchorY = anchorY - currY;\n            this.originX = j === 0 ? charInfo.offsetX - lineWidth : charInfo.offsetX;\n            this.originY = charInfo.offsetY;\n            this.height = glyphAtlas.height;\n            this.width = j === 0 || j === charArr.length - 1 ?\n              glyphAtlas.width[charArr[j]] + lineWidth : glyphAtlas.width[charArr[j]];\n            this.imageHeight = image.height;\n            this.imageWidth = image.width;\n  \n            var currentImage;\n            if (this.images_.length === 0) {\n              this.images_.push(image);\n            } else {\n              currentImage = this.images_[this.images_.length - 1];\n              if (ol.getUid(currentImage) != ol.getUid(image)) {\n                this.groupIndices.push(this.indices.length);\n                this.images_.push(image);\n              }\n            }\n  \n            this.drawText_(flatCoordinates, offset, end, stride);\n          }\n          currX += this.width;\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Array.<string>} lines Label to draw split to lines.\n   * @return {Array.<number>} Size of the label in pixels.\n   */\n  ol.render.webgl.TextReplay.prototype.getTextSize_ = function(lines) {\n    var self = this;\n    var glyphAtlas = this.currAtlas_;\n    var textHeight = lines.length * glyphAtlas.height;\n    //Split every line to an array of chars, sum up their width, and select the longest.\n    var textWidth = lines.map(function(str) {\n      var sum = 0;\n      var i, ii;\n      for (i = 0, ii = str.length; i < ii; ++i) {\n        var curr = str[i];\n        if (!glyphAtlas.width[curr]) {\n          self.addCharToAtlas_(curr);\n        }\n        sum += glyphAtlas.width[curr] ? glyphAtlas.width[curr] : 0;\n      }\n      return sum;\n    }).reduce(function(max, curr) {\n      return Math.max(max, curr);\n    });\n  \n    return [textWidth, textHeight];\n  };\n  \n  \n  /**\n   * @private\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   */\n  ol.render.webgl.TextReplay.prototype.drawText_ = function(flatCoordinates, offset,\n      end, stride) {\n    var i, ii;\n    for (i = offset, ii = end; i < ii; i += stride) {\n      this.drawCoordinates(flatCoordinates, offset, end, stride);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {string} char Character.\n   */\n  ol.render.webgl.TextReplay.prototype.addCharToAtlas_ = function(char) {\n    if (char.length === 1) {\n      var glyphAtlas = this.currAtlas_;\n      var state = this.state_;\n      var mCtx = this.measureCanvas_.getContext('2d');\n      mCtx.font = state.font;\n      var width = Math.ceil(mCtx.measureText(char).width * state.scale);\n  \n      var info = glyphAtlas.atlas.add(char, width, glyphAtlas.height,\n          function(ctx, x, y) {\n            //Parameterize the canvas\n            ctx.font = /** @type {string} */ (state.font);\n            ctx.fillStyle = state.fillColor;\n            ctx.strokeStyle = state.strokeColor;\n            ctx.lineWidth = state.lineWidth;\n            ctx.lineCap = /*** @type {string} */ (state.lineCap);\n            ctx.lineJoin = /** @type {string} */ (state.lineJoin);\n            ctx.miterLimit = /** @type {number} */ (state.miterLimit);\n            ctx.textAlign = 'left';\n            ctx.textBaseline = 'top';\n            if (ol.has.CANVAS_LINE_DASH && state.lineDash) {\n              //FIXME: use pixelRatio\n              ctx.setLineDash(state.lineDash);\n              ctx.lineDashOffset = /** @type {number} */ (state.lineDashOffset);\n            }\n            if (state.scale !== 1) {\n              //FIXME: use pixelRatio\n              ctx.setTransform(/** @type {number} */ (state.scale), 0, 0,\n                  /** @type {number} */ (state.scale), 0, 0);\n            }\n  \n            //Draw the character on the canvas\n            if (state.strokeColor) {\n              ctx.strokeText(char, x, y);\n            }\n            if (state.fillColor) {\n              ctx.fillText(char, x, y);\n            }\n          });\n  \n      if (info) {\n        glyphAtlas.width[char] = width;\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextReplay.prototype.finish = function(context) {\n    var gl = context.getGL();\n  \n    this.groupIndices.push(this.indices.length);\n    this.hitDetectionGroupIndices = this.groupIndices;\n  \n    // create, bind, and populate the vertices buffer\n    this.verticesBuffer = new ol.webgl.Buffer(this.vertices);\n  \n    // create, bind, and populate the indices buffer\n    this.indicesBuffer = new ol.webgl.Buffer(this.indices);\n  \n    // create textures\n    /** @type {Object.<string, WebGLTexture>} */\n    var texturePerImage = {};\n  \n    this.createTextures(this.textures_, this.images_, texturePerImage, gl);\n  \n    this.state_ = {\n      strokeColor: null,\n      lineCap: undefined,\n      lineDash: null,\n      lineDashOffset: undefined,\n      lineJoin: undefined,\n      lineWidth: 0,\n      miterLimit: undefined,\n      fillColor: null,\n      font: undefined,\n      scale: undefined\n    };\n    this.text_ = '';\n    this.textAlign_ = undefined;\n    this.textBaseline_ = undefined;\n    this.offsetX_ = undefined;\n    this.offsetY_ = undefined;\n    this.images_ = null;\n    this.atlases_ = {};\n    this.currAtlas_ = undefined;\n    ol.render.webgl.TextureReplay.prototype.finish.call(this, context);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextReplay.prototype.setTextStyle = function(textStyle) {\n    var state = this.state_;\n    var textFillStyle = textStyle.getFill();\n    var textStrokeStyle = textStyle.getStroke();\n    if (!textStyle || !textStyle.getText() || (!textFillStyle && !textStrokeStyle)) {\n      this.text_ = '';\n    } else {\n      if (!textFillStyle) {\n        state.fillColor = null;\n      } else {\n        var textFillStyleColor = textFillStyle.getColor();\n        state.fillColor = ol.colorlike.asColorLike(textFillStyleColor ?\n          textFillStyleColor : ol.render.webgl.defaultFillStyle);\n      }\n      if (!textStrokeStyle) {\n        state.strokeColor = null;\n        state.lineWidth = 0;\n      } else {\n        var textStrokeStyleColor = textStrokeStyle.getColor();\n        state.strokeColor = ol.colorlike.asColorLike(textStrokeStyleColor ?\n          textStrokeStyleColor : ol.render.webgl.defaultStrokeStyle);\n        state.lineWidth = textStrokeStyle.getWidth() || ol.render.webgl.defaultLineWidth;\n        state.lineCap = textStrokeStyle.getLineCap() || ol.render.webgl.defaultLineCap;\n        state.lineDashOffset = textStrokeStyle.getLineDashOffset() || ol.render.webgl.defaultLineDashOffset;\n        state.lineJoin = textStrokeStyle.getLineJoin() || ol.render.webgl.defaultLineJoin;\n        state.miterLimit = textStrokeStyle.getMiterLimit() || ol.render.webgl.defaultMiterLimit;\n        var lineDash = textStrokeStyle.getLineDash();\n        state.lineDash = lineDash ? lineDash.slice() : ol.render.webgl.defaultLineDash;\n      }\n      state.font = textStyle.getFont() || ol.render.webgl.defaultFont;\n      state.scale = textStyle.getScale() || 1;\n      this.text_ = /** @type {string} */ (textStyle.getText());\n      var textAlign = ol.render.replay.TEXT_ALIGN[textStyle.getTextAlign()];\n      var textBaseline = ol.render.replay.TEXT_ALIGN[textStyle.getTextBaseline()];\n      this.textAlign_ = textAlign === undefined ?\n        ol.render.webgl.defaultTextAlign : textAlign;\n      this.textBaseline_ = textBaseline === undefined ?\n        ol.render.webgl.defaultTextBaseline : textBaseline;\n      this.offsetX_ = textStyle.getOffsetX() || 0;\n      this.offsetY_ = textStyle.getOffsetY() || 0;\n      this.rotateWithView = !!textStyle.getRotateWithView();\n      this.rotation = textStyle.getRotation() || 0;\n  \n      this.currAtlas_ = this.getAtlas_(state);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Object} state Font attributes.\n   * @return {ol.WebglGlyphAtlas} Glyph atlas.\n   */\n  ol.render.webgl.TextReplay.prototype.getAtlas_ = function(state) {\n    var params = [];\n    var i;\n    for (i in state) {\n      if (state[i] || state[i] === 0) {\n        if (Array.isArray(state[i])) {\n          params = params.concat(state[i]);\n        } else {\n          params.push(state[i]);\n        }\n      }\n    }\n    var hash = this.calculateHash_(params);\n    if (!this.atlases_[hash]) {\n      var mCtx = this.measureCanvas_.getContext('2d');\n      mCtx.font = state.font;\n      var height = Math.ceil((mCtx.measureText('M').width * 1.5 +\n          state.lineWidth / 2) * state.scale);\n  \n      this.atlases_[hash] = {\n        atlas: new ol.style.AtlasManager({\n          space: state.lineWidth + 1\n        }),\n        width: {},\n        height: height\n      };\n    }\n    return this.atlases_[hash];\n  };\n  \n  \n  /**\n   * @private\n   * @param {Array.<string|number>} params Array of parameters.\n   * @return {string} Hash string.\n   */\n  ol.render.webgl.TextReplay.prototype.calculateHash_ = function(params) {\n    //TODO: Create a more performant, reliable, general hash function.\n    var i, ii;\n    var hash = '';\n    for (i = 0, ii = params.length; i < ii; ++i) {\n      hash += params[i];\n    }\n    return hash;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextReplay.prototype.getTextures = function(opt_all) {\n    return this.textures_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.TextReplay.prototype.getHitDetectionTextures = function() {\n    return this.textures_;\n  };\n  \n  goog.provide('ol.render.webgl.ReplayGroup');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.render.replay');\n  goog.require('ol.render.ReplayGroup');\n  goog.require('ol.render.webgl.CircleReplay');\n  goog.require('ol.render.webgl.ImageReplay');\n  goog.require('ol.render.webgl.LineStringReplay');\n  goog.require('ol.render.webgl.PolygonReplay');\n  goog.require('ol.render.webgl.TextReplay');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.ReplayGroup}\n   * @param {number} tolerance Tolerance.\n   * @param {ol.Extent} maxExtent Max extent.\n   * @param {number=} opt_renderBuffer Render buffer.\n   * @struct\n   */\n  ol.render.webgl.ReplayGroup = function(tolerance, maxExtent, opt_renderBuffer) {\n    ol.render.ReplayGroup.call(this);\n  \n    /**\n     * @type {ol.Extent}\n     * @private\n     */\n    this.maxExtent_ = maxExtent;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.tolerance_ = tolerance;\n  \n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n  \n    /**\n     * @private\n     * @type {!Object.<string,\n     *        Object.<ol.render.ReplayType, ol.render.webgl.Replay>>}\n     */\n    this.replaysByZIndex_ = {};\n  \n  };\n  ol.inherits(ol.render.webgl.ReplayGroup, ol.render.ReplayGroup);\n  \n  \n  /**\n   * @param {ol.style.Style} style Style.\n   * @param {boolean} group Group with previous replay.\n   */\n  ol.render.webgl.ReplayGroup.prototype.addDeclutter = function(style, group) {};\n  \n  \n  /**\n   * @param {ol.webgl.Context} context WebGL context.\n   * @return {function()} Delete resources function.\n   */\n  ol.render.webgl.ReplayGroup.prototype.getDeleteResourcesFunction = function(context) {\n    var functions = [];\n    var zKey;\n    for (zKey in this.replaysByZIndex_) {\n      var replays = this.replaysByZIndex_[zKey];\n      var replayKey;\n      for (replayKey in replays) {\n        functions.push(\n            replays[replayKey].getDeleteResourcesFunction(context));\n      }\n    }\n    return function() {\n      var length = functions.length;\n      var result;\n      for (var i = 0; i < length; i++) {\n        result = functions[i].apply(this, arguments);\n      }\n      return result;\n    };\n  };\n  \n  \n  /**\n   * @param {ol.webgl.Context} context Context.\n   */\n  ol.render.webgl.ReplayGroup.prototype.finish = function(context) {\n    var zKey;\n    for (zKey in this.replaysByZIndex_) {\n      var replays = this.replaysByZIndex_[zKey];\n      var replayKey;\n      for (replayKey in replays) {\n        replays[replayKey].finish(context);\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.ReplayGroup.prototype.getReplay = function(zIndex, replayType) {\n    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n    var replays = this.replaysByZIndex_[zIndexKey];\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n    var replay = replays[replayType];\n    if (replay === undefined) {\n      /**\n       * @type {Function}\n       */\n      var Constructor = ol.render.webgl.ReplayGroup.BATCH_CONSTRUCTORS_[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_);\n      replays[replayType] = replay;\n    }\n    return replay;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.ReplayGroup.prototype.isEmpty = function() {\n    return ol.obj.isEmpty(this.replaysByZIndex_);\n  };\n  \n  \n  /**\n   * @param {ol.webgl.Context} context Context.\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {ol.Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} opacity Global opacity.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   */\n  ol.render.webgl.ReplayGroup.prototype.replay = function(context,\n      center, resolution, rotation, size, pixelRatio,\n      opacity, skippedFeaturesHash) {\n    /** @type {Array.<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(ol.array.numberSafeCompareFunction);\n  \n    var i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      replays = this.replaysByZIndex_[zs[i].toString()];\n      for (j = 0, jj = ol.render.replay.ORDER.length; j < jj; ++j) {\n        replay = replays[ol.render.replay.ORDER[j]];\n        if (replay !== undefined) {\n          replay.replay(context,\n              center, resolution, rotation, size, pixelRatio,\n              opacity, skippedFeaturesHash,\n              undefined, false);\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {ol.webgl.Context} context Context.\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {ol.Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} opacity Global opacity.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.\n   * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.\n   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting\n   *  this extent are checked.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.webgl.ReplayGroup.prototype.replayHitDetection_ = function(context,\n      center, resolution, rotation, size, pixelRatio, opacity,\n      skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {\n    /** @type {Array.<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(function(a, b) {\n      return b - a;\n    });\n  \n    var i, ii, j, replays, replay, result;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      replays = this.replaysByZIndex_[zs[i].toString()];\n      for (j = ol.render.replay.ORDER.length - 1; j >= 0; --j) {\n        replay = replays[ol.render.replay.ORDER[j]];\n        if (replay !== undefined) {\n          result = replay.replay(context,\n              center, resolution, rotation, size, pixelRatio, opacity,\n              skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {ol.webgl.Context} context Context.\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {ol.Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} opacity Global opacity.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} callback Feature callback.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ol.render.webgl.ReplayGroup.prototype.forEachFeatureAtCoordinate = function(\n      coordinate, context, center, resolution, rotation, size, pixelRatio,\n      opacity, skippedFeaturesHash,\n      callback) {\n    var gl = context.getGL();\n    gl.bindFramebuffer(\n        gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());\n  \n  \n    /**\n     * @type {ol.Extent}\n     */\n    var hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      // build an extent around the coordinate, so that only features that\n      // intersect this extent are checked\n      hitExtent = ol.extent.buffer(\n          ol.extent.createOrUpdateFromCoordinate(coordinate),\n          resolution * this.renderBuffer_);\n    }\n  \n    return this.replayHitDetection_(context,\n        coordinate, resolution, rotation, ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_,\n        pixelRatio, opacity, skippedFeaturesHash,\n        /**\n         * @param {ol.Feature|ol.render.Feature} feature Feature.\n         * @return {?} Callback result.\n         */\n        function(feature) {\n          var imageData = new Uint8Array(4);\n          gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n  \n          if (imageData[3] > 0) {\n            var result = callback(feature);\n            if (result) {\n              return result;\n            }\n          }\n        }, true, hitExtent);\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {ol.webgl.Context} context Context.\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {ol.Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} opacity Global opacity.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *  to skip.\n   * @return {boolean} Is there a feature at the given coordinate?\n   */\n  ol.render.webgl.ReplayGroup.prototype.hasFeatureAtCoordinate = function(\n      coordinate, context, center, resolution, rotation, size, pixelRatio,\n      opacity, skippedFeaturesHash) {\n    var gl = context.getGL();\n    gl.bindFramebuffer(\n        gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());\n  \n    var hasFeature = this.replayHitDetection_(context,\n        coordinate, resolution, rotation, ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_,\n        pixelRatio, opacity, skippedFeaturesHash,\n        /**\n         * @param {ol.Feature|ol.render.Feature} feature Feature.\n         * @return {boolean} Is there a feature?\n         */\n        function(feature) {\n          var imageData = new Uint8Array(4);\n          gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n          return imageData[3] > 0;\n        }, false);\n  \n    return hasFeature !== undefined;\n  };\n  \n  /**\n   * @const\n   * @private\n   * @type {Array.<number>}\n   */\n  ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_ = [1, 1];\n  \n  /**\n   * @const\n   * @private\n   * @type {Object.<ol.render.ReplayType,\n   *                function(new: ol.render.webgl.Replay, number,\n   *                ol.Extent)>}\n   */\n  ol.render.webgl.ReplayGroup.BATCH_CONSTRUCTORS_ = {\n    'Circle': ol.render.webgl.CircleReplay,\n    'Image': ol.render.webgl.ImageReplay,\n    'LineString': ol.render.webgl.LineStringReplay,\n    'Polygon': ol.render.webgl.PolygonReplay,\n    'Text': ol.render.webgl.TextReplay\n  };\n  \n  goog.provide('ol.render.webgl.Immediate');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.geom.GeometryType');\n  goog.require('ol.render.ReplayType');\n  goog.require('ol.render.VectorContext');\n  goog.require('ol.render.webgl.ReplayGroup');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.render.VectorContext}\n   * @param {ol.webgl.Context} context Context.\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {ol.Size} size Size.\n   * @param {ol.Extent} extent Extent.\n   * @param {number} pixelRatio Pixel ratio.\n   * @struct\n   */\n  ol.render.webgl.Immediate = function(context, center, resolution, rotation, size, extent, pixelRatio) {\n    ol.render.VectorContext.call(this);\n  \n    /**\n     * @private\n     */\n    this.context_ = context;\n  \n    /**\n     * @private\n     */\n    this.center_ = center;\n  \n    /**\n     * @private\n     */\n    this.extent_ = extent;\n  \n    /**\n     * @private\n     */\n    this.pixelRatio_ = pixelRatio;\n  \n    /**\n     * @private\n     */\n    this.size_ = size;\n  \n    /**\n     * @private\n     */\n    this.rotation_ = rotation;\n  \n    /**\n     * @private\n     */\n    this.resolution_ = resolution;\n  \n    /**\n     * @private\n     * @type {ol.style.Image}\n     */\n    this.imageStyle_ = null;\n  \n    /**\n     * @private\n     * @type {ol.style.Fill}\n     */\n    this.fillStyle_ = null;\n  \n    /**\n     * @private\n     * @type {ol.style.Stroke}\n     */\n    this.strokeStyle_ = null;\n  \n    /**\n     * @private\n     * @type {ol.style.Text}\n     */\n    this.textStyle_ = null;\n  \n  };\n  ol.inherits(ol.render.webgl.Immediate, ol.render.VectorContext);\n  \n  \n  /**\n   * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n   * @private\n   */\n  ol.render.webgl.Immediate.prototype.drawText_ = function(replayGroup, geometry) {\n    var context = this.context_;\n    var replay = /** @type {ol.render.webgl.TextReplay} */ (\n      replayGroup.getReplay(0, ol.render.ReplayType.TEXT));\n    replay.setTextStyle(this.textStyle_);\n    replay.drawText(geometry, null);\n    replay.finish(context);\n    // default colors\n    var opacity = 1;\n    var skippedFeatures = {};\n    var featureCallback;\n    var oneByOne = false;\n    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_,\n        this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback,\n        oneByOne);\n    replay.getDeleteResourcesFunction(context)();\n  };\n  \n  \n  /**\n   * Set the rendering style.  Note that since this is an immediate rendering API,\n   * any `zIndex` on the provided style will be ignored.\n   *\n   * @param {ol.style.Style} style The rendering style.\n   * @override\n   * @api\n   */\n  ol.render.webgl.Immediate.prototype.setStyle = function(style) {\n    this.setFillStrokeStyle(style.getFill(), style.getStroke());\n    this.setImageStyle(style.getImage());\n    this.setTextStyle(style.getText());\n  };\n  \n  \n  /**\n   * Render a geometry into the canvas.  Call\n   * {@link ol.render.webgl.Immediate#setStyle} first to set the rendering style.\n   *\n   * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.\n   * @override\n   * @api\n   */\n  ol.render.webgl.Immediate.prototype.drawGeometry = function(geometry) {\n    var type = geometry.getType();\n    switch (type) {\n      case ol.geom.GeometryType.POINT:\n        this.drawPoint(/** @type {ol.geom.Point} */ (geometry), null);\n        break;\n      case ol.geom.GeometryType.LINE_STRING:\n        this.drawLineString(/** @type {ol.geom.LineString} */ (geometry), null);\n        break;\n      case ol.geom.GeometryType.POLYGON:\n        this.drawPolygon(/** @type {ol.geom.Polygon} */ (geometry), null);\n        break;\n      case ol.geom.GeometryType.MULTI_POINT:\n        this.drawMultiPoint(/** @type {ol.geom.MultiPoint} */ (geometry), null);\n        break;\n      case ol.geom.GeometryType.MULTI_LINE_STRING:\n        this.drawMultiLineString(/** @type {ol.geom.MultiLineString} */ (geometry), null);\n        break;\n      case ol.geom.GeometryType.MULTI_POLYGON:\n        this.drawMultiPolygon(/** @type {ol.geom.MultiPolygon} */ (geometry), null);\n        break;\n      case ol.geom.GeometryType.GEOMETRY_COLLECTION:\n        this.drawGeometryCollection(/** @type {ol.geom.GeometryCollection} */ (geometry), null);\n        break;\n      case ol.geom.GeometryType.CIRCLE:\n        this.drawCircle(/** @type {ol.geom.Circle} */ (geometry), null);\n        break;\n      default:\n        // pass\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   * @api\n   */\n  ol.render.webgl.Immediate.prototype.drawFeature = function(feature, style) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry ||\n        !ol.extent.intersects(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    this.setStyle(style);\n    this.drawGeometry(geometry);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.drawGeometryCollection = function(geometry, data) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n      this.drawGeometry(geometries[i]);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.drawPoint = function(geometry, data) {\n    var context = this.context_;\n    var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);\n    var replay = /** @type {ol.render.webgl.ImageReplay} */ (\n      replayGroup.getReplay(0, ol.render.ReplayType.IMAGE));\n    replay.setImageStyle(this.imageStyle_);\n    replay.drawPoint(geometry, data);\n    replay.finish(context);\n    // default colors\n    var opacity = 1;\n    var skippedFeatures = {};\n    var featureCallback;\n    var oneByOne = false;\n    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_,\n        this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback,\n        oneByOne);\n    replay.getDeleteResourcesFunction(context)();\n  \n    if (this.textStyle_) {\n      this.drawText_(replayGroup, geometry);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.drawMultiPoint = function(geometry, data) {\n    var context = this.context_;\n    var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);\n    var replay = /** @type {ol.render.webgl.ImageReplay} */ (\n      replayGroup.getReplay(0, ol.render.ReplayType.IMAGE));\n    replay.setImageStyle(this.imageStyle_);\n    replay.drawMultiPoint(geometry, data);\n    replay.finish(context);\n    var opacity = 1;\n    var skippedFeatures = {};\n    var featureCallback;\n    var oneByOne = false;\n    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_,\n        this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback,\n        oneByOne);\n    replay.getDeleteResourcesFunction(context)();\n  \n    if (this.textStyle_) {\n      this.drawText_(replayGroup, geometry);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.drawLineString = function(geometry, data) {\n    var context = this.context_;\n    var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);\n    var replay = /** @type {ol.render.webgl.LineStringReplay} */ (\n      replayGroup.getReplay(0, ol.render.ReplayType.LINE_STRING));\n    replay.setFillStrokeStyle(null, this.strokeStyle_);\n    replay.drawLineString(geometry, data);\n    replay.finish(context);\n    var opacity = 1;\n    var skippedFeatures = {};\n    var featureCallback;\n    var oneByOne = false;\n    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_,\n        this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback,\n        oneByOne);\n    replay.getDeleteResourcesFunction(context)();\n  \n    if (this.textStyle_) {\n      this.drawText_(replayGroup, geometry);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.drawMultiLineString = function(geometry, data) {\n    var context = this.context_;\n    var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);\n    var replay = /** @type {ol.render.webgl.LineStringReplay} */ (\n      replayGroup.getReplay(0, ol.render.ReplayType.LINE_STRING));\n    replay.setFillStrokeStyle(null, this.strokeStyle_);\n    replay.drawMultiLineString(geometry, data);\n    replay.finish(context);\n    var opacity = 1;\n    var skippedFeatures = {};\n    var featureCallback;\n    var oneByOne = false;\n    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_,\n        this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback,\n        oneByOne);\n    replay.getDeleteResourcesFunction(context)();\n  \n    if (this.textStyle_) {\n      this.drawText_(replayGroup, geometry);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.drawPolygon = function(geometry, data) {\n    var context = this.context_;\n    var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);\n    var replay = /** @type {ol.render.webgl.PolygonReplay} */ (\n      replayGroup.getReplay(0, ol.render.ReplayType.POLYGON));\n    replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);\n    replay.drawPolygon(geometry, data);\n    replay.finish(context);\n    var opacity = 1;\n    var skippedFeatures = {};\n    var featureCallback;\n    var oneByOne = false;\n    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_,\n        this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback,\n        oneByOne);\n    replay.getDeleteResourcesFunction(context)();\n  \n    if (this.textStyle_) {\n      this.drawText_(replayGroup, geometry);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.drawMultiPolygon = function(geometry, data) {\n    var context = this.context_;\n    var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);\n    var replay = /** @type {ol.render.webgl.PolygonReplay} */ (\n      replayGroup.getReplay(0, ol.render.ReplayType.POLYGON));\n    replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);\n    replay.drawMultiPolygon(geometry, data);\n    replay.finish(context);\n    var opacity = 1;\n    var skippedFeatures = {};\n    var featureCallback;\n    var oneByOne = false;\n    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_,\n        this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback,\n        oneByOne);\n    replay.getDeleteResourcesFunction(context)();\n  \n    if (this.textStyle_) {\n      this.drawText_(replayGroup, geometry);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.drawCircle = function(geometry, data) {\n    var context = this.context_;\n    var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);\n    var replay = /** @type {ol.render.webgl.CircleReplay} */ (\n      replayGroup.getReplay(0, ol.render.ReplayType.CIRCLE));\n    replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);\n    replay.drawCircle(geometry, data);\n    replay.finish(context);\n    var opacity = 1;\n    var skippedFeatures = {};\n    var featureCallback;\n    var oneByOne = false;\n    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_,\n        this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback,\n        oneByOne);\n    replay.getDeleteResourcesFunction(context)();\n  \n    if (this.textStyle_) {\n      this.drawText_(replayGroup, geometry);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.setImageStyle = function(imageStyle) {\n    this.imageStyle_ = imageStyle;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n    this.fillStyle_ = fillStyle;\n    this.strokeStyle_ = strokeStyle;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.render.webgl.Immediate.prototype.setTextStyle = function(textStyle) {\n    this.textStyle_ = textStyle;\n  };\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.renderer.webgl.defaultmapshader');\n  \n  goog.require('ol');\n  goog.require('ol.webgl.Fragment');\n  goog.require('ol.webgl.Vertex');\n  \n  \n  ol.renderer.webgl.defaultmapshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ?\n    'precision mediump float;\\nvarying vec2 v_texCoord;\\n\\n\\nuniform float u_opacity;\\nuniform sampler2D u_texture;\\n\\nvoid main(void) {\\n  vec4 texColor = texture2D(u_texture, v_texCoord);\\n  gl_FragColor.rgb = texColor.rgb;\\n  gl_FragColor.a = texColor.a * u_opacity;\\n}\\n' :\n    'precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}');\n  \n  ol.renderer.webgl.defaultmapshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ?\n    'varying vec2 v_texCoord;\\n\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\n\\nuniform mat4 u_texCoordMatrix;\\nuniform mat4 u_projectionMatrix;\\n\\nvoid main(void) {\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\\n}\\n\\n\\n' :\n    'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}');\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.renderer.webgl.defaultmapshader.Locations');\n  \n  goog.require('ol');\n  \n  \n  /**\n   * @constructor\n   * @param {WebGLRenderingContext} gl GL.\n   * @param {WebGLProgram} program Program.\n   * @struct\n   */\n  ol.renderer.webgl.defaultmapshader.Locations = function(gl, program) {\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_texCoordMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_texCoordMatrix' : 'd');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_projectionMatrix = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_projectionMatrix' : 'e');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_opacity = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_opacity' : 'f');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_texture = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_texture' : 'g');\n  \n    /**\n     * @type {number}\n     */\n    this.a_position = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_position' : 'b');\n  \n    /**\n     * @type {number}\n     */\n    this.a_texCoord = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_texCoord' : 'c');\n  };\n  \n  goog.provide('ol.renderer.webgl.Layer');\n  \n  goog.require('ol');\n  goog.require('ol.render.Event');\n  goog.require('ol.render.EventType');\n  goog.require('ol.render.webgl.Immediate');\n  goog.require('ol.renderer.Layer');\n  goog.require('ol.renderer.webgl.defaultmapshader');\n  goog.require('ol.renderer.webgl.defaultmapshader.Locations');\n  goog.require('ol.transform');\n  goog.require('ol.vec.Mat4');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Buffer');\n  goog.require('ol.webgl.Context');\n  \n  \n  /**\n   * @constructor\n   * @abstract\n   * @extends {ol.renderer.Layer}\n   * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.\n   * @param {ol.layer.Layer} layer Layer.\n   */\n  ol.renderer.webgl.Layer = function(mapRenderer, layer) {\n  \n    ol.renderer.Layer.call(this, layer);\n  \n    /**\n     * @protected\n     * @type {ol.renderer.webgl.Map}\n     */\n    this.mapRenderer = mapRenderer;\n  \n    /**\n     * @private\n     * @type {ol.webgl.Buffer}\n     */\n    this.arrayBuffer_ = new ol.webgl.Buffer([\n      -1, -1, 0, 0,\n      1, -1, 1, 0,\n      -1, 1, 0, 1,\n      1, 1, 1, 1\n    ]);\n  \n    /**\n     * @protected\n     * @type {WebGLTexture}\n     */\n    this.texture = null;\n  \n    /**\n     * @protected\n     * @type {WebGLFramebuffer}\n     */\n    this.framebuffer = null;\n  \n    /**\n     * @protected\n     * @type {number|undefined}\n     */\n    this.framebufferDimension = undefined;\n  \n    /**\n     * @protected\n     * @type {ol.Transform}\n     */\n    this.texCoordMatrix = ol.transform.create();\n  \n    /**\n     * @protected\n     * @type {ol.Transform}\n     */\n    this.projectionMatrix = ol.transform.create();\n  \n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n    this.tmpMat4_ = ol.vec.Mat4.create();\n  \n    /**\n     * @private\n     * @type {ol.renderer.webgl.defaultmapshader.Locations}\n     */\n    this.defaultLocations_ = null;\n  \n  };\n  ol.inherits(ol.renderer.webgl.Layer, ol.renderer.Layer);\n  \n  \n  /**\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {number} framebufferDimension Framebuffer dimension.\n   * @protected\n   */\n  ol.renderer.webgl.Layer.prototype.bindFramebuffer = function(frameState, framebufferDimension) {\n  \n    var gl = this.mapRenderer.getGL();\n  \n    if (this.framebufferDimension === undefined ||\n        this.framebufferDimension != framebufferDimension) {\n      /**\n       * @param {WebGLRenderingContext} gl GL.\n       * @param {WebGLFramebuffer} framebuffer Framebuffer.\n       * @param {WebGLTexture} texture Texture.\n       */\n      var postRenderFunction = function(gl, framebuffer, texture) {\n        if (!gl.isContextLost()) {\n          gl.deleteFramebuffer(framebuffer);\n          gl.deleteTexture(texture);\n        }\n      }.bind(null, gl, this.framebuffer, this.texture);\n  \n      frameState.postRenderFunctions.push(\n          /** @type {ol.PostRenderFunction} */ (postRenderFunction)\n      );\n  \n      var texture = ol.webgl.Context.createEmptyTexture(\n          gl, framebufferDimension, framebufferDimension);\n  \n      var framebuffer = gl.createFramebuffer();\n      gl.bindFramebuffer(ol.webgl.FRAMEBUFFER, framebuffer);\n      gl.framebufferTexture2D(ol.webgl.FRAMEBUFFER,\n          ol.webgl.COLOR_ATTACHMENT0, ol.webgl.TEXTURE_2D, texture, 0);\n  \n      this.texture = texture;\n      this.framebuffer = framebuffer;\n      this.framebufferDimension = framebufferDimension;\n  \n    } else {\n      gl.bindFramebuffer(ol.webgl.FRAMEBUFFER, this.framebuffer);\n    }\n  \n  };\n  \n  \n  /**\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.LayerState} layerState Layer state.\n   * @param {ol.webgl.Context} context Context.\n   */\n  ol.renderer.webgl.Layer.prototype.composeFrame = function(frameState, layerState, context) {\n  \n    this.dispatchComposeEvent_(\n        ol.render.EventType.PRECOMPOSE, context, frameState);\n  \n    context.bindBuffer(ol.webgl.ARRAY_BUFFER, this.arrayBuffer_);\n  \n    var gl = context.getGL();\n  \n    var fragmentShader = ol.renderer.webgl.defaultmapshader.fragment;\n    var vertexShader = ol.renderer.webgl.defaultmapshader.vertex;\n  \n    var program = context.getProgram(fragmentShader, vertexShader);\n  \n    var locations;\n    if (!this.defaultLocations_) {\n      locations = new ol.renderer.webgl.defaultmapshader.Locations(gl, program);\n      this.defaultLocations_ = locations;\n    } else {\n      locations = this.defaultLocations_;\n    }\n  \n    if (context.useProgram(program)) {\n      gl.enableVertexAttribArray(locations.a_position);\n      gl.vertexAttribPointer(\n          locations.a_position, 2, ol.webgl.FLOAT, false, 16, 0);\n      gl.enableVertexAttribArray(locations.a_texCoord);\n      gl.vertexAttribPointer(\n          locations.a_texCoord, 2, ol.webgl.FLOAT, false, 16, 8);\n      gl.uniform1i(locations.u_texture, 0);\n    }\n  \n    gl.uniformMatrix4fv(locations.u_texCoordMatrix, false,\n        ol.vec.Mat4.fromTransform(this.tmpMat4_, this.getTexCoordMatrix()));\n    gl.uniformMatrix4fv(locations.u_projectionMatrix, false,\n        ol.vec.Mat4.fromTransform(this.tmpMat4_, this.getProjectionMatrix()));\n    gl.uniform1f(locations.u_opacity, layerState.opacity);\n    gl.bindTexture(ol.webgl.TEXTURE_2D, this.getTexture());\n    gl.drawArrays(ol.webgl.TRIANGLE_STRIP, 0, 4);\n  \n    this.dispatchComposeEvent_(\n        ol.render.EventType.POSTCOMPOSE, context, frameState);\n  \n  };\n  \n  \n  /**\n   * @param {ol.render.EventType} type Event type.\n   * @param {ol.webgl.Context} context WebGL context.\n   * @param {olx.FrameState} frameState Frame state.\n   * @private\n   */\n  ol.renderer.webgl.Layer.prototype.dispatchComposeEvent_ = function(type, context, frameState) {\n    var layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      var viewState = frameState.viewState;\n      var resolution = viewState.resolution;\n      var pixelRatio = frameState.pixelRatio;\n      var extent = frameState.extent;\n      var center = viewState.center;\n      var rotation = viewState.rotation;\n      var size = frameState.size;\n  \n      var render = new ol.render.webgl.Immediate(\n          context, center, resolution, rotation, size, extent, pixelRatio);\n      var composeEvent = new ol.render.Event(\n          type, render, frameState, null, context);\n      layer.dispatchEvent(composeEvent);\n    }\n  };\n  \n  \n  /**\n   * @return {!ol.Transform} Matrix.\n   */\n  ol.renderer.webgl.Layer.prototype.getTexCoordMatrix = function() {\n    return this.texCoordMatrix;\n  };\n  \n  \n  /**\n   * @return {WebGLTexture} Texture.\n   */\n  ol.renderer.webgl.Layer.prototype.getTexture = function() {\n    return this.texture;\n  };\n  \n  \n  /**\n   * @return {!ol.Transform} Matrix.\n   */\n  ol.renderer.webgl.Layer.prototype.getProjectionMatrix = function() {\n    return this.projectionMatrix;\n  };\n  \n  \n  /**\n   * Handle webglcontextlost.\n   */\n  ol.renderer.webgl.Layer.prototype.handleWebGLContextLost = function() {\n    this.texture = null;\n    this.framebuffer = null;\n    this.framebufferDimension = undefined;\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {olx.FrameState} frameState Frame state.\n   * @param {ol.LayerState} layerState Layer state.\n   * @param {ol.webgl.Context} context Context.\n   * @return {boolean} whether composeFrame should be called.\n   */\n  ol.renderer.webgl.Layer.prototype.prepareFrame = function(frameState, layerState, context) {};\n  \n  \n  /**\n   * @abstract\n   * @param {ol.Pixel} pixel Pixel.\n   * @param {olx.FrameState} frameState FrameState.\n   * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n   *     callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  ol.renderer.webgl.Layer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {};\n  \n  goog.provide('ol.renderer.webgl.ImageLayer');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.ViewHint');\n  goog.require('ol.dom');\n  goog.require('ol.extent');\n  goog.require('ol.functions');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.renderer.webgl.Layer');\n  goog.require('ol.transform');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Context');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.webgl.Layer}\n   * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.\n   * @param {ol.layer.Image} imageLayer Tile layer.\n   * @api\n   */\n  ol.renderer.webgl.ImageLayer = function(mapRenderer, imageLayer) {\n  \n    ol.renderer.webgl.Layer.call(this, mapRenderer, imageLayer);\n  \n    /**\n     * The last rendered image.\n     * @private\n     * @type {?ol.ImageBase}\n     */\n    this.image_ = null;\n  \n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitCanvasContext_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.Transform}\n     */\n    this.hitTransformationMatrix_ = null;\n  \n  };\n  ol.inherits(ol.renderer.webgl.ImageLayer, ol.renderer.webgl.Layer);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @param {ol.layer.Layer} layer The candidate layer.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.webgl.ImageLayer['handles'] = function(type, layer) {\n    return type === ol.renderer.Type.WEBGL && layer.getType() === ol.LayerType.IMAGE;\n  };\n  \n  \n  /**\n   * Create a layer renderer.\n   * @param {ol.renderer.Map} mapRenderer The map renderer.\n   * @param {ol.layer.Layer} layer The layer to be rendererd.\n   * @return {ol.renderer.webgl.ImageLayer} The layer renderer.\n   */\n  ol.renderer.webgl.ImageLayer['create'] = function(mapRenderer, layer) {\n    return new ol.renderer.webgl.ImageLayer(\n        /** @type {ol.renderer.webgl.Map} */ (mapRenderer),\n        /** @type {ol.layer.Image} */ (layer)\n    );\n  };\n  \n  \n  /**\n   * @param {ol.ImageBase} image Image.\n   * @private\n   * @return {WebGLTexture} Texture.\n   */\n  ol.renderer.webgl.ImageLayer.prototype.createTexture_ = function(image) {\n  \n    // We meet the conditions to work with non-power of two textures.\n    // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support\n    // http://learningwebgl.com/blog/?p=2101\n  \n    var imageElement = image.getImage();\n    var gl = this.mapRenderer.getGL();\n  \n    return ol.webgl.Context.createTexture(\n        gl, imageElement, ol.webgl.CLAMP_TO_EDGE, ol.webgl.CLAMP_TO_EDGE);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.ImageLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\n    var layer = this.getLayer();\n    var source = layer.getSource();\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    var skippedFeatureUids = frameState.skippedFeatureUids;\n    return source.forEachFeatureAtCoordinate(\n        coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,\n  \n        /**\n         * @param {ol.Feature|ol.render.Feature} feature Feature.\n         * @return {?} Callback result.\n         */\n        function(feature) {\n          return callback.call(thisArg, feature, layer);\n        });\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.ImageLayer.prototype.prepareFrame = function(frameState, layerState, context) {\n  \n    var gl = this.mapRenderer.getGL();\n  \n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var viewCenter = viewState.center;\n    var viewResolution = viewState.resolution;\n    var viewRotation = viewState.rotation;\n  \n    var image = this.image_;\n    var texture = this.texture;\n    var imageLayer = /** @type {ol.layer.Image} */ (this.getLayer());\n    var imageSource = imageLayer.getSource();\n  \n    var hints = frameState.viewHints;\n  \n    var renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = ol.extent.getIntersection(\n          renderedExtent, layerState.extent);\n    }\n    if (!hints[ol.ViewHint.ANIMATING] && !hints[ol.ViewHint.INTERACTING] &&\n        !ol.extent.isEmpty(renderedExtent)) {\n      var projection = viewState.projection;\n      if (!ol.ENABLE_RASTER_REPROJECTION) {\n        var sourceProjection = imageSource.getProjection();\n        if (sourceProjection) {\n          projection = sourceProjection;\n        }\n      }\n      var image_ = imageSource.getImage(renderedExtent, viewResolution,\n          pixelRatio, projection);\n      if (image_) {\n        var loaded = this.loadImage(image_);\n        if (loaded) {\n          image = image_;\n          texture = this.createTexture_(image_);\n          if (this.texture) {\n            /**\n             * @param {WebGLRenderingContext} gl GL.\n             * @param {WebGLTexture} texture Texture.\n             */\n            var postRenderFunction = function(gl, texture) {\n              if (!gl.isContextLost()) {\n                gl.deleteTexture(texture);\n              }\n            }.bind(null, gl, this.texture);\n            frameState.postRenderFunctions.push(\n                /** @type {ol.PostRenderFunction} */ (postRenderFunction)\n            );\n          }\n        }\n      }\n    }\n  \n    if (image) {\n      var canvas = this.mapRenderer.getContext().getCanvas();\n  \n      this.updateProjectionMatrix_(canvas.width, canvas.height,\n          pixelRatio, viewCenter, viewResolution, viewRotation,\n          image.getExtent());\n      this.hitTransformationMatrix_ = null;\n  \n      // Translate and scale to flip the Y coord.\n      var texCoordMatrix = this.texCoordMatrix;\n      ol.transform.reset(texCoordMatrix);\n      ol.transform.scale(texCoordMatrix, 1, -1);\n      ol.transform.translate(texCoordMatrix, 0, -1);\n  \n      this.image_ = image;\n      this.texture = texture;\n  \n      this.updateLogos(frameState, imageSource);\n    }\n  \n    return !!image;\n  };\n  \n  \n  /**\n   * @param {number} canvasWidth Canvas width.\n   * @param {number} canvasHeight Canvas height.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.Coordinate} viewCenter View center.\n   * @param {number} viewResolution View resolution.\n   * @param {number} viewRotation View rotation.\n   * @param {ol.Extent} imageExtent Image extent.\n   * @private\n   */\n  ol.renderer.webgl.ImageLayer.prototype.updateProjectionMatrix_ = function(canvasWidth, canvasHeight, pixelRatio,\n      viewCenter, viewResolution, viewRotation, imageExtent) {\n  \n    var canvasExtentWidth = canvasWidth * viewResolution;\n    var canvasExtentHeight = canvasHeight * viewResolution;\n  \n    var projectionMatrix = this.projectionMatrix;\n    ol.transform.reset(projectionMatrix);\n    ol.transform.scale(projectionMatrix,\n        pixelRatio * 2 / canvasExtentWidth,\n        pixelRatio * 2 / canvasExtentHeight);\n    ol.transform.rotate(projectionMatrix, -viewRotation);\n    ol.transform.translate(projectionMatrix,\n        imageExtent[0] - viewCenter[0],\n        imageExtent[1] - viewCenter[1]);\n    ol.transform.scale(projectionMatrix,\n        (imageExtent[2] - imageExtent[0]) / 2,\n        (imageExtent[3] - imageExtent[1]) / 2);\n    ol.transform.translate(projectionMatrix, 1, 1);\n  \n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.ImageLayer.prototype.hasFeatureAtCoordinate = function(coordinate, frameState) {\n    var hasFeature = this.forEachFeatureAtCoordinate(\n        coordinate, frameState, 0, ol.functions.TRUE, this);\n    return hasFeature !== undefined;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.ImageLayer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {\n    if (!this.image_ || !this.image_.getImage()) {\n      return undefined;\n    }\n  \n    if (this.getLayer().getSource().forEachFeatureAtCoordinate !== ol.nullFunction) {\n      // for ImageCanvas sources use the original hit-detection logic,\n      // so that for example also transparent polygons are detected\n      var coordinate = ol.transform.apply(\n          frameState.pixelToCoordinateTransform, pixel.slice());\n      var hasFeature = this.forEachFeatureAtCoordinate(\n          coordinate, frameState, 0, ol.functions.TRUE, this);\n  \n      if (hasFeature) {\n        return callback.call(thisArg, this.getLayer(), null);\n      } else {\n        return undefined;\n      }\n    } else {\n      var imageSize =\n          [this.image_.getImage().width, this.image_.getImage().height];\n  \n      if (!this.hitTransformationMatrix_) {\n        this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(\n            frameState.size, imageSize);\n      }\n  \n      var pixelOnFrameBuffer = ol.transform.apply(\n          this.hitTransformationMatrix_, pixel.slice());\n  \n      if (pixelOnFrameBuffer[0] < 0 || pixelOnFrameBuffer[0] > imageSize[0] ||\n          pixelOnFrameBuffer[1] < 0 || pixelOnFrameBuffer[1] > imageSize[1]) {\n        // outside the image, no need to check\n        return undefined;\n      }\n  \n      if (!this.hitCanvasContext_) {\n        this.hitCanvasContext_ = ol.dom.createCanvasContext2D(1, 1);\n      }\n  \n      this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n      this.hitCanvasContext_.drawImage(this.image_.getImage(),\n          pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, 0, 0, 1, 1);\n  \n      var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n      if (imageData[3] > 0) {\n        return callback.call(thisArg, this.getLayer(),  imageData);\n      } else {\n        return undefined;\n      }\n    }\n  };\n  \n  \n  /**\n   * The transformation matrix to get the pixel on the image for a\n   * pixel on the map.\n   * @param {ol.Size} mapSize The map size.\n   * @param {ol.Size} imageSize The image size.\n   * @return {ol.Transform} The transformation matrix.\n   * @private\n   */\n  ol.renderer.webgl.ImageLayer.prototype.getHitTransformationMatrix_ = function(mapSize, imageSize) {\n    // the first matrix takes a map pixel, flips the y-axis and scales to\n    // a range between -1 ... 1\n    var mapCoordTransform = ol.transform.create();\n    ol.transform.translate(mapCoordTransform, -1, -1);\n    ol.transform.scale(mapCoordTransform, 2 / mapSize[0], 2 / mapSize[1]);\n    ol.transform.translate(mapCoordTransform, 0, mapSize[1]);\n    ol.transform.scale(mapCoordTransform, 1, -1);\n  \n    // the second matrix is the inverse of the projection matrix used in the\n    // shader for drawing\n    var projectionMatrixInv = ol.transform.invert(this.projectionMatrix.slice());\n  \n    // the third matrix scales to the image dimensions and flips the y-axis again\n    var transform = ol.transform.create();\n    ol.transform.translate(transform, 0, imageSize[1]);\n    ol.transform.scale(transform, 1, -1);\n    ol.transform.scale(transform, imageSize[0] / 2, imageSize[1] / 2);\n    ol.transform.translate(transform, 1, 1);\n  \n    ol.transform.multiply(transform, projectionMatrixInv);\n    ol.transform.multiply(transform, mapCoordTransform);\n  \n    return transform;\n  };\n  \n  // FIXME check against gl.getParameter(webgl.MAX_TEXTURE_SIZE)\n  \n  goog.provide('ol.renderer.webgl.Map');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.css');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.has');\n  goog.require('ol.layer.Layer');\n  goog.require('ol.render.Event');\n  goog.require('ol.render.EventType');\n  goog.require('ol.render.webgl.Immediate');\n  goog.require('ol.renderer.Map');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.source.State');\n  goog.require('ol.structs.LRUCache');\n  goog.require('ol.structs.PriorityQueue');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Context');\n  goog.require('ol.webgl.ContextEventType');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.Map}\n   * @param {Element} container Container.\n   * @param {ol.PluggableMap} map Map.\n   * @api\n   */\n  ol.renderer.webgl.Map = function(container, map) {\n    ol.renderer.Map.call(this, container, map);\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = /** @type {HTMLCanvasElement} */\n      (document.createElement('CANVAS'));\n    this.canvas_.style.width = '100%';\n    this.canvas_.style.height = '100%';\n    this.canvas_.style.display = 'block';\n    this.canvas_.className = ol.css.CLASS_UNSELECTABLE;\n    container.insertBefore(this.canvas_, container.childNodes[0] || null);\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.clipTileCanvasWidth_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.clipTileCanvasHeight_ = 0;\n  \n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.clipTileContext_ = ol.dom.createCanvasContext2D();\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n  \n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = ol.webgl.getContext(this.canvas_, {\n      antialias: true,\n      depth: true,\n      failIfMajorPerformanceCaveat: true,\n      preserveDrawingBuffer: false,\n      stencil: true\n    });\n  \n    /**\n     * @private\n     * @type {ol.webgl.Context}\n     */\n    this.context_ = new ol.webgl.Context(this.canvas_, this.gl_);\n  \n    ol.events.listen(this.canvas_, ol.webgl.ContextEventType.LOST,\n        this.handleWebGLContextLost, this);\n    ol.events.listen(this.canvas_, ol.webgl.ContextEventType.RESTORED,\n        this.handleWebGLContextRestored, this);\n  \n    /**\n     * @private\n     * @type {ol.structs.LRUCache.<ol.WebglTextureCacheEntry|null>}\n     */\n    this.textureCache_ = new ol.structs.LRUCache();\n  \n    /**\n     * @private\n     * @type {ol.Coordinate}\n     */\n    this.focus_ = null;\n  \n    /**\n     * @private\n     * @type {ol.structs.PriorityQueue.<Array>}\n     */\n    this.tileTextureQueue_ = new ol.structs.PriorityQueue(\n        /**\n         * @param {Array.<*>} element Element.\n         * @return {number} Priority.\n         * @this {ol.renderer.webgl.Map}\n         */\n        (function(element) {\n          var tileCenter = /** @type {ol.Coordinate} */ (element[1]);\n          var tileResolution = /** @type {number} */ (element[2]);\n          var deltaX = tileCenter[0] - this.focus_[0];\n          var deltaY = tileCenter[1] - this.focus_[1];\n          return 65536 * Math.log(tileResolution) +\n              Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n        }).bind(this),\n        /**\n         * @param {Array.<*>} element Element.\n         * @return {string} Key.\n         */\n        function(element) {\n          return /** @type {ol.Tile} */ (element[0]).getKey();\n        });\n  \n  \n    /**\n     * @param {ol.PluggableMap} map Map.\n     * @param {?olx.FrameState} frameState Frame state.\n     * @return {boolean} false.\n     * @this {ol.renderer.webgl.Map}\n     */\n    this.loadNextTileTexture_ =\n        function(map, frameState) {\n          if (!this.tileTextureQueue_.isEmpty()) {\n            this.tileTextureQueue_.reprioritize();\n            var element = this.tileTextureQueue_.dequeue();\n            var tile = /** @type {ol.Tile} */ (element[0]);\n            var tileSize = /** @type {ol.Size} */ (element[3]);\n            var tileGutter = /** @type {number} */ (element[4]);\n            this.bindTileTexture(\n                tile, tileSize, tileGutter, ol.webgl.LINEAR, ol.webgl.LINEAR);\n          }\n          return false;\n        }.bind(this);\n  \n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.textureCacheFrameMarkerCount_ = 0;\n  \n    this.initializeGL_();\n  };\n  ol.inherits(ol.renderer.webgl.Map, ol.renderer.Map);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.webgl.Map['handles'] = function(type) {\n    return ol.has.WEBGL && type === ol.renderer.Type.WEBGL;\n  };\n  \n  \n  /**\n   * Create the map renderer.\n   * @param {Element} container Container.\n   * @param {ol.PluggableMap} map Map.\n   * @return {ol.renderer.webgl.Map} The map renderer.\n   */\n  ol.renderer.webgl.Map['create'] = function(container, map) {\n    return new ol.renderer.webgl.Map(container, map);\n  };\n  \n  \n  /**\n   * @param {ol.Tile} tile Tile.\n   * @param {ol.Size} tileSize Tile size.\n   * @param {number} tileGutter Tile gutter.\n   * @param {number} magFilter Mag filter.\n   * @param {number} minFilter Min filter.\n   */\n  ol.renderer.webgl.Map.prototype.bindTileTexture = function(tile, tileSize, tileGutter, magFilter, minFilter) {\n    var gl = this.getGL();\n    var tileKey = tile.getKey();\n    if (this.textureCache_.containsKey(tileKey)) {\n      var textureCacheEntry = this.textureCache_.get(tileKey);\n      gl.bindTexture(ol.webgl.TEXTURE_2D, textureCacheEntry.texture);\n      if (textureCacheEntry.magFilter != magFilter) {\n        gl.texParameteri(\n            ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_MAG_FILTER, magFilter);\n        textureCacheEntry.magFilter = magFilter;\n      }\n      if (textureCacheEntry.minFilter != minFilter) {\n        gl.texParameteri(\n            ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_MIN_FILTER, minFilter);\n        textureCacheEntry.minFilter = minFilter;\n      }\n    } else {\n      var texture = gl.createTexture();\n      gl.bindTexture(ol.webgl.TEXTURE_2D, texture);\n      if (tileGutter > 0) {\n        var clipTileCanvas = this.clipTileContext_.canvas;\n        var clipTileContext = this.clipTileContext_;\n        if (this.clipTileCanvasWidth_ !== tileSize[0] ||\n            this.clipTileCanvasHeight_ !== tileSize[1]) {\n          clipTileCanvas.width = tileSize[0];\n          clipTileCanvas.height = tileSize[1];\n          this.clipTileCanvasWidth_ = tileSize[0];\n          this.clipTileCanvasHeight_ = tileSize[1];\n        } else {\n          clipTileContext.clearRect(0, 0, tileSize[0], tileSize[1]);\n        }\n        clipTileContext.drawImage(tile.getImage(), tileGutter, tileGutter,\n            tileSize[0], tileSize[1], 0, 0, tileSize[0], tileSize[1]);\n        gl.texImage2D(ol.webgl.TEXTURE_2D, 0,\n            ol.webgl.RGBA, ol.webgl.RGBA,\n            ol.webgl.UNSIGNED_BYTE, clipTileCanvas);\n      } else {\n        gl.texImage2D(ol.webgl.TEXTURE_2D, 0,\n            ol.webgl.RGBA, ol.webgl.RGBA,\n            ol.webgl.UNSIGNED_BYTE, tile.getImage());\n      }\n      gl.texParameteri(\n          ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_MAG_FILTER, magFilter);\n      gl.texParameteri(\n          ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_MIN_FILTER, minFilter);\n      gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_WRAP_S,\n          ol.webgl.CLAMP_TO_EDGE);\n      gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_WRAP_T,\n          ol.webgl.CLAMP_TO_EDGE);\n      this.textureCache_.set(tileKey, {\n        texture: texture,\n        magFilter: magFilter,\n        minFilter: minFilter\n      });\n    }\n  };\n  \n  \n  /**\n   * @param {ol.render.EventType} type Event type.\n   * @param {olx.FrameState} frameState Frame state.\n   * @private\n   */\n  ol.renderer.webgl.Map.prototype.dispatchComposeEvent_ = function(type, frameState) {\n    var map = this.getMap();\n    if (map.hasListener(type)) {\n      var context = this.context_;\n  \n      var extent = frameState.extent;\n      var size = frameState.size;\n      var viewState = frameState.viewState;\n      var pixelRatio = frameState.pixelRatio;\n  \n      var resolution = viewState.resolution;\n      var center = viewState.center;\n      var rotation = viewState.rotation;\n  \n      var vectorContext = new ol.render.webgl.Immediate(context,\n          center, resolution, rotation, size, extent, pixelRatio);\n      var composeEvent = new ol.render.Event(type, vectorContext,\n          frameState, null, context);\n      map.dispatchEvent(composeEvent);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.Map.prototype.disposeInternal = function() {\n    var gl = this.getGL();\n    if (!gl.isContextLost()) {\n      this.textureCache_.forEach(\n          /**\n           * @param {?ol.WebglTextureCacheEntry} textureCacheEntry\n           *     Texture cache entry.\n           */\n          function(textureCacheEntry) {\n            if (textureCacheEntry) {\n              gl.deleteTexture(textureCacheEntry.texture);\n            }\n          });\n    }\n    this.context_.dispose();\n    ol.renderer.Map.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @param {ol.PluggableMap} map Map.\n   * @param {olx.FrameState} frameState Frame state.\n   * @private\n   */\n  ol.renderer.webgl.Map.prototype.expireCache_ = function(map, frameState) {\n    var gl = this.getGL();\n    var textureCacheEntry;\n    while (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ >\n        ol.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {\n      textureCacheEntry = this.textureCache_.peekLast();\n      if (!textureCacheEntry) {\n        if (+this.textureCache_.peekLastKey() == frameState.index) {\n          break;\n        } else {\n          --this.textureCacheFrameMarkerCount_;\n        }\n      } else {\n        gl.deleteTexture(textureCacheEntry.texture);\n      }\n      this.textureCache_.pop();\n    }\n  };\n  \n  \n  /**\n   * @return {ol.webgl.Context} The context.\n   */\n  ol.renderer.webgl.Map.prototype.getContext = function() {\n    return this.context_;\n  };\n  \n  \n  /**\n   * @return {WebGLRenderingContext} GL.\n   */\n  ol.renderer.webgl.Map.prototype.getGL = function() {\n    return this.gl_;\n  };\n  \n  \n  /**\n   * @return {ol.structs.PriorityQueue.<Array>} Tile texture queue.\n   */\n  ol.renderer.webgl.Map.prototype.getTileTextureQueue = function() {\n    return this.tileTextureQueue_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.Map.prototype.getType = function() {\n    return ol.renderer.Type.WEBGL;\n  };\n  \n  \n  /**\n   * @param {ol.events.Event} event Event.\n   * @protected\n   */\n  ol.renderer.webgl.Map.prototype.handleWebGLContextLost = function(event) {\n    event.preventDefault();\n    this.textureCache_.clear();\n    this.textureCacheFrameMarkerCount_ = 0;\n  \n    var renderers = this.getLayerRenderers();\n    for (var id in renderers) {\n      var renderer = /** @type {ol.renderer.webgl.Layer} */ (renderers[id]);\n      renderer.handleWebGLContextLost();\n    }\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.renderer.webgl.Map.prototype.handleWebGLContextRestored = function() {\n    this.initializeGL_();\n    this.getMap().render();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.renderer.webgl.Map.prototype.initializeGL_ = function() {\n    var gl = this.gl_;\n    gl.activeTexture(ol.webgl.TEXTURE0);\n    gl.blendFuncSeparate(\n        ol.webgl.SRC_ALPHA, ol.webgl.ONE_MINUS_SRC_ALPHA,\n        ol.webgl.ONE, ol.webgl.ONE_MINUS_SRC_ALPHA);\n    gl.disable(ol.webgl.CULL_FACE);\n    gl.disable(ol.webgl.DEPTH_TEST);\n    gl.disable(ol.webgl.SCISSOR_TEST);\n    gl.disable(ol.webgl.STENCIL_TEST);\n  };\n  \n  \n  /**\n   * @param {ol.Tile} tile Tile.\n   * @return {boolean} Is tile texture loaded.\n   */\n  ol.renderer.webgl.Map.prototype.isTileTextureLoaded = function(tile) {\n    return this.textureCache_.containsKey(tile.getKey());\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.Map.prototype.renderFrame = function(frameState) {\n  \n    var context = this.getContext();\n    var gl = this.getGL();\n  \n    if (gl.isContextLost()) {\n      return false;\n    }\n  \n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.canvas_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return false;\n    }\n  \n    this.focus_ = frameState.focus;\n  \n    this.textureCache_.set((-frameState.index).toString(), null);\n    ++this.textureCacheFrameMarkerCount_;\n  \n    this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE, frameState);\n  \n    /** @type {Array.<ol.LayerState>} */\n    var layerStatesToDraw = [];\n    var layerStatesArray = frameState.layerStatesArray;\n    ol.array.stableSort(layerStatesArray, ol.renderer.Map.sortByZIndex);\n  \n    var viewResolution = frameState.viewState.resolution;\n    var i, ii, layerRenderer, layerState;\n    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      layerState = layerStatesArray[i];\n      if (ol.layer.Layer.visibleAtResolution(layerState, viewResolution) &&\n          layerState.sourceState == ol.source.State.READY) {\n        layerRenderer = /** @type {ol.renderer.webgl.Layer} */ (this.getLayerRenderer(layerState.layer));\n        if (layerRenderer.prepareFrame(frameState, layerState, context)) {\n          layerStatesToDraw.push(layerState);\n        }\n      }\n    }\n  \n    var width = frameState.size[0] * frameState.pixelRatio;\n    var height = frameState.size[1] * frameState.pixelRatio;\n    if (this.canvas_.width != width || this.canvas_.height != height) {\n      this.canvas_.width = width;\n      this.canvas_.height = height;\n    }\n  \n    gl.bindFramebuffer(ol.webgl.FRAMEBUFFER, null);\n  \n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(ol.webgl.COLOR_BUFFER_BIT);\n    gl.enable(ol.webgl.BLEND);\n    gl.viewport(0, 0, this.canvas_.width, this.canvas_.height);\n  \n    for (i = 0, ii = layerStatesToDraw.length; i < ii; ++i) {\n      layerState = layerStatesToDraw[i];\n      layerRenderer = /** @type {ol.renderer.webgl.Layer} */ (this.getLayerRenderer(layerState.layer));\n      layerRenderer.composeFrame(frameState, layerState, context);\n    }\n  \n    if (!this.renderedVisible_) {\n      this.canvas_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n  \n    this.calculateMatrices2D(frameState);\n  \n    if (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ >\n        ol.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {\n      frameState.postRenderFunctions.push(\n          /** @type {ol.PostRenderFunction} */ (this.expireCache_.bind(this))\n      );\n    }\n  \n    if (!this.tileTextureQueue_.isEmpty()) {\n      frameState.postRenderFunctions.push(this.loadNextTileTexture_);\n      frameState.animate = true;\n    }\n  \n    this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE, frameState);\n  \n    this.scheduleRemoveUnusedLayerRenderers(frameState);\n    this.scheduleExpireIconCache(frameState);\n  \n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.Map.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg,\n      layerFilter, thisArg2) {\n    var result;\n  \n    if (this.getGL().isContextLost()) {\n      return false;\n    }\n  \n    var viewState = frameState.viewState;\n  \n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var i;\n    for (i = numLayers - 1; i >= 0; --i) {\n      var layerState = layerStates[i];\n      var layer = layerState.layer;\n      if (ol.layer.Layer.visibleAtResolution(layerState, viewState.resolution) &&\n          layerFilter.call(thisArg2, layer)) {\n        var layerRenderer = this.getLayerRenderer(layer);\n        result = layerRenderer.forEachFeatureAtCoordinate(\n            coordinate, frameState, hitTolerance, callback, thisArg);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return undefined;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.Map.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, layerFilter, thisArg) {\n    var hasFeature = false;\n  \n    if (this.getGL().isContextLost()) {\n      return false;\n    }\n  \n    var viewState = frameState.viewState;\n  \n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var i;\n    for (i = numLayers - 1; i >= 0; --i) {\n      var layerState = layerStates[i];\n      var layer = layerState.layer;\n      if (ol.layer.Layer.visibleAtResolution(layerState, viewState.resolution) &&\n          layerFilter.call(thisArg, layer)) {\n        var layerRenderer = this.getLayerRenderer(layer);\n        hasFeature =\n            layerRenderer.hasFeatureAtCoordinate(coordinate, frameState);\n        if (hasFeature) {\n          return true;\n        }\n      }\n    }\n    return hasFeature;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.Map.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg,\n      layerFilter, thisArg2) {\n    if (this.getGL().isContextLost()) {\n      return false;\n    }\n  \n    var viewState = frameState.viewState;\n    var result;\n  \n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var i;\n    for (i = numLayers - 1; i >= 0; --i) {\n      var layerState = layerStates[i];\n      var layer = layerState.layer;\n      if (ol.layer.Layer.visibleAtResolution(layerState, viewState.resolution) &&\n          layerFilter.call(thisArg, layer)) {\n        var layerRenderer = /** @type {ol.renderer.webgl.Layer} */ (this.getLayerRenderer(layer));\n        result = layerRenderer.forEachLayerAtPixel(\n            pixel, frameState, callback, thisArg);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return undefined;\n  };\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.renderer.webgl.tilelayershader');\n  \n  goog.require('ol');\n  goog.require('ol.webgl.Fragment');\n  goog.require('ol.webgl.Vertex');\n  \n  \n  ol.renderer.webgl.tilelayershader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ?\n    'precision mediump float;\\nvarying vec2 v_texCoord;\\n\\n\\nuniform sampler2D u_texture;\\n\\nvoid main(void) {\\n  gl_FragColor = texture2D(u_texture, v_texCoord);\\n}\\n' :\n    'precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}');\n  \n  ol.renderer.webgl.tilelayershader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ?\n    'varying vec2 v_texCoord;\\n\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\nuniform vec4 u_tileOffset;\\n\\nvoid main(void) {\\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\\n  v_texCoord = a_texCoord;\\n}\\n\\n\\n' :\n    'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}');\n  \n  // This file is automatically generated, do not edit\n  goog.provide('ol.renderer.webgl.tilelayershader.Locations');\n  \n  goog.require('ol');\n  \n  \n  /**\n   * @constructor\n   * @param {WebGLRenderingContext} gl GL.\n   * @param {WebGLProgram} program Program.\n   * @struct\n   */\n  ol.renderer.webgl.tilelayershader.Locations = function(gl, program) {\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_tileOffset = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_tileOffset' : 'd');\n  \n    /**\n     * @type {WebGLUniformLocation}\n     */\n    this.u_texture = gl.getUniformLocation(\n        program, ol.DEBUG_WEBGL ? 'u_texture' : 'e');\n  \n    /**\n     * @type {number}\n     */\n    this.a_position = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_position' : 'b');\n  \n    /**\n     * @type {number}\n     */\n    this.a_texCoord = gl.getAttribLocation(\n        program, ol.DEBUG_WEBGL ? 'a_texCoord' : 'c');\n  };\n  \n  // FIXME large resolutions lead to too large framebuffers :-(\n  // FIXME animated shaders! check in redraw\n  \n  goog.provide('ol.renderer.webgl.TileLayer');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.TileRange');\n  goog.require('ol.TileState');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.math');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.renderer.webgl.Layer');\n  goog.require('ol.renderer.webgl.tilelayershader');\n  goog.require('ol.renderer.webgl.tilelayershader.Locations');\n  goog.require('ol.size');\n  goog.require('ol.transform');\n  goog.require('ol.webgl');\n  goog.require('ol.webgl.Buffer');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.webgl.Layer}\n   * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.\n   * @param {ol.layer.Tile} tileLayer Tile layer.\n   * @api\n   */\n  ol.renderer.webgl.TileLayer = function(mapRenderer, tileLayer) {\n  \n    ol.renderer.webgl.Layer.call(this, mapRenderer, tileLayer);\n  \n    /**\n     * @private\n     * @type {ol.webgl.Fragment}\n     */\n    this.fragmentShader_ = ol.renderer.webgl.tilelayershader.fragment;\n  \n    /**\n     * @private\n     * @type {ol.webgl.Vertex}\n     */\n    this.vertexShader_ = ol.renderer.webgl.tilelayershader.vertex;\n  \n    /**\n     * @private\n     * @type {ol.renderer.webgl.tilelayershader.Locations}\n     */\n    this.locations_ = null;\n  \n    /**\n     * @private\n     * @type {ol.webgl.Buffer}\n     */\n    this.renderArrayBuffer_ = new ol.webgl.Buffer([\n      0, 0, 0, 1,\n      1, 0, 1, 1,\n      0, 1, 0, 0,\n      1, 1, 1, 0\n    ]);\n  \n    /**\n     * @private\n     * @type {ol.TileRange}\n     */\n    this.renderedTileRange_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.renderedFramebufferExtent_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.tmpSize_ = [0, 0];\n  \n  };\n  ol.inherits(ol.renderer.webgl.TileLayer, ol.renderer.webgl.Layer);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @param {ol.layer.Layer} layer The candidate layer.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.webgl.TileLayer['handles'] = function(type, layer) {\n    return type === ol.renderer.Type.WEBGL && layer.getType() === ol.LayerType.TILE;\n  };\n  \n  \n  /**\n   * Create a layer renderer.\n   * @param {ol.renderer.Map} mapRenderer The map renderer.\n   * @param {ol.layer.Layer} layer The layer to be rendererd.\n   * @return {ol.renderer.webgl.TileLayer} The layer renderer.\n   */\n  ol.renderer.webgl.TileLayer['create'] = function(mapRenderer, layer) {\n    return new ol.renderer.webgl.TileLayer(\n        /** @type {ol.renderer.webgl.Map} */ (mapRenderer),\n        /** @type {ol.layer.Tile} */ (layer)\n    );\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.TileLayer.prototype.disposeInternal = function() {\n    var context = this.mapRenderer.getContext();\n    context.deleteBuffer(this.renderArrayBuffer_);\n    ol.renderer.webgl.Layer.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.TileLayer.prototype.createLoadedTileFinder = function(source, projection, tiles) {\n    var mapRenderer = this.mapRenderer;\n  \n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {ol.TileRange} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      function(zoom, tileRange) {\n        function callback(tile) {\n          var loaded = mapRenderer.isTileTextureLoaded(tile);\n          if (loaded) {\n            if (!tiles[zoom]) {\n              tiles[zoom] = {};\n            }\n            tiles[zoom][tile.tileCoord.toString()] = tile;\n          }\n          return loaded;\n        }\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      });\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.TileLayer.prototype.handleWebGLContextLost = function() {\n    ol.renderer.webgl.Layer.prototype.handleWebGLContextLost.call(this);\n    this.locations_ = null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.TileLayer.prototype.prepareFrame = function(frameState, layerState, context) {\n  \n    var mapRenderer = this.mapRenderer;\n    var gl = context.getGL();\n  \n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n  \n    var tileLayer = /** @type {ol.layer.Tile} */ (this.getLayer());\n    var tileSource = tileLayer.getSource();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewState.resolution);\n    var tileResolution = tileGrid.getResolution(z);\n  \n    var tilePixelSize =\n        tileSource.getTilePixelSize(z, frameState.pixelRatio, projection);\n    var pixelRatio = tilePixelSize[0] /\n        ol.size.toSize(tileGrid.getTileSize(z), this.tmpSize_)[0];\n    var tilePixelResolution = tileResolution / pixelRatio;\n    var tileGutter = tileSource.getTilePixelRatio(pixelRatio) * tileSource.getGutter(projection);\n  \n    var center = viewState.center;\n    var extent = frameState.extent;\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n  \n    var framebufferExtent;\n    if (this.renderedTileRange_ &&\n        this.renderedTileRange_.equals(tileRange) &&\n        this.renderedRevision_ == tileSource.getRevision()) {\n      framebufferExtent = this.renderedFramebufferExtent_;\n    } else {\n  \n      var tileRangeSize = tileRange.getSize();\n  \n      var maxDimension = Math.max(\n          tileRangeSize[0] * tilePixelSize[0],\n          tileRangeSize[1] * tilePixelSize[1]);\n      var framebufferDimension = ol.math.roundUpToPowerOfTwo(maxDimension);\n      var framebufferExtentDimension = tilePixelResolution * framebufferDimension;\n      var origin = tileGrid.getOrigin(z);\n      var minX = origin[0] +\n          tileRange.minX * tilePixelSize[0] * tilePixelResolution;\n      var minY = origin[1] +\n          tileRange.minY * tilePixelSize[1] * tilePixelResolution;\n      framebufferExtent = [\n        minX, minY,\n        minX + framebufferExtentDimension, minY + framebufferExtentDimension\n      ];\n  \n      this.bindFramebuffer(frameState, framebufferDimension);\n      gl.viewport(0, 0, framebufferDimension, framebufferDimension);\n  \n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(ol.webgl.COLOR_BUFFER_BIT);\n      gl.disable(ol.webgl.BLEND);\n  \n      var program = context.getProgram(this.fragmentShader_, this.vertexShader_);\n      context.useProgram(program);\n      if (!this.locations_) {\n        this.locations_ = new ol.renderer.webgl.tilelayershader.Locations(gl, program);\n      }\n  \n      context.bindBuffer(ol.webgl.ARRAY_BUFFER, this.renderArrayBuffer_);\n      gl.enableVertexAttribArray(this.locations_.a_position);\n      gl.vertexAttribPointer(\n          this.locations_.a_position, 2, ol.webgl.FLOAT, false, 16, 0);\n      gl.enableVertexAttribArray(this.locations_.a_texCoord);\n      gl.vertexAttribPointer(\n          this.locations_.a_texCoord, 2, ol.webgl.FLOAT, false, 16, 8);\n      gl.uniform1i(this.locations_.u_texture, 0);\n  \n      /**\n       * @type {Object.<number, Object.<string, ol.Tile>>}\n       */\n      var tilesToDrawByZ = {};\n      tilesToDrawByZ[z] = {};\n  \n      var findLoadedTiles = this.createLoadedTileFinder(\n          tileSource, projection, tilesToDrawByZ);\n  \n      var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n      var allTilesLoaded = true;\n      var tmpExtent = ol.extent.createEmpty();\n      var tmpTileRange = new ol.TileRange(0, 0, 0, 0);\n      var childTileRange, drawable, fullyLoaded, tile, tileState;\n      var x, y, tileExtent;\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n  \n          tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n          if (layerState.extent !== undefined) {\n            // ignore tiles outside layer extent\n            tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);\n            if (!ol.extent.intersects(tileExtent, layerState.extent)) {\n              continue;\n            }\n          }\n          tileState = tile.getState();\n          drawable = tileState == ol.TileState.LOADED ||\n              tileState == ol.TileState.EMPTY ||\n              tileState == ol.TileState.ERROR && !useInterimTilesOnError;\n          if (!drawable) {\n            tile = tile.getInterimTile();\n          }\n          tileState = tile.getState();\n          if (tileState == ol.TileState.LOADED) {\n            if (mapRenderer.isTileTextureLoaded(tile)) {\n              tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n              continue;\n            }\n          } else if (tileState == ol.TileState.EMPTY ||\n                     (tileState == ol.TileState.ERROR &&\n                      !useInterimTilesOnError)) {\n            continue;\n          }\n  \n          allTilesLoaded = false;\n          fullyLoaded = tileGrid.forEachTileCoordParentTileRange(\n              tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n          if (!fullyLoaded) {\n            childTileRange = tileGrid.getTileCoordChildTileRange(\n                tile.tileCoord, tmpTileRange, tmpExtent);\n            if (childTileRange) {\n              findLoadedTiles(z + 1, childTileRange);\n            }\n          }\n  \n        }\n  \n      }\n  \n      /** @type {Array.<number>} */\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(ol.array.numberSafeCompareFunction);\n      var u_tileOffset = new Float32Array(4);\n      var i, ii, tileKey, tilesToDraw;\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        tilesToDraw = tilesToDrawByZ[zs[i]];\n        for (tileKey in tilesToDraw) {\n          tile = tilesToDraw[tileKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);\n          u_tileOffset[0] = 2 * (tileExtent[2] - tileExtent[0]) /\n              framebufferExtentDimension;\n          u_tileOffset[1] = 2 * (tileExtent[3] - tileExtent[1]) /\n              framebufferExtentDimension;\n          u_tileOffset[2] = 2 * (tileExtent[0] - framebufferExtent[0]) /\n              framebufferExtentDimension - 1;\n          u_tileOffset[3] = 2 * (tileExtent[1] - framebufferExtent[1]) /\n              framebufferExtentDimension - 1;\n          gl.uniform4fv(this.locations_.u_tileOffset, u_tileOffset);\n          mapRenderer.bindTileTexture(tile, tilePixelSize,\n              tileGutter * pixelRatio, ol.webgl.LINEAR, ol.webgl.LINEAR);\n          gl.drawArrays(ol.webgl.TRIANGLE_STRIP, 0, 4);\n        }\n      }\n  \n      if (allTilesLoaded) {\n        this.renderedTileRange_ = tileRange;\n        this.renderedFramebufferExtent_ = framebufferExtent;\n        this.renderedRevision_ = tileSource.getRevision();\n      } else {\n        this.renderedTileRange_ = null;\n        this.renderedFramebufferExtent_ = null;\n        this.renderedRevision_ = -1;\n        frameState.animate = true;\n      }\n  \n    }\n  \n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    var tileTextureQueue = mapRenderer.getTileTextureQueue();\n    this.manageTilePyramid(\n        frameState, tileSource, tileGrid, pixelRatio, projection, extent, z,\n        tileLayer.getPreload(),\n        /**\n         * @param {ol.Tile} tile Tile.\n         */\n        function(tile) {\n          if (tile.getState() == ol.TileState.LOADED &&\n              !mapRenderer.isTileTextureLoaded(tile) &&\n              !tileTextureQueue.isKeyQueued(tile.getKey())) {\n            tileTextureQueue.enqueue([\n              tile,\n              tileGrid.getTileCoordCenter(tile.tileCoord),\n              tileGrid.getResolution(tile.tileCoord[0]),\n              tilePixelSize, tileGutter * pixelRatio\n            ]);\n          }\n        }, this);\n    this.scheduleExpireCache(frameState, tileSource);\n    this.updateLogos(frameState, tileSource);\n  \n    var texCoordMatrix = this.texCoordMatrix;\n    ol.transform.reset(texCoordMatrix);\n    ol.transform.translate(texCoordMatrix,\n        (Math.round(center[0] / tileResolution) * tileResolution - framebufferExtent[0]) /\n            (framebufferExtent[2] - framebufferExtent[0]),\n        (Math.round(center[1] / tileResolution) * tileResolution - framebufferExtent[1]) /\n            (framebufferExtent[3] - framebufferExtent[1]));\n    if (viewState.rotation !== 0) {\n      ol.transform.rotate(texCoordMatrix, viewState.rotation);\n    }\n    ol.transform.scale(texCoordMatrix,\n        frameState.size[0] * viewState.resolution /\n            (framebufferExtent[2] - framebufferExtent[0]),\n        frameState.size[1] * viewState.resolution /\n            (framebufferExtent[3] - framebufferExtent[1]));\n    ol.transform.translate(texCoordMatrix, -0.5, -0.5);\n  \n    return true;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.TileLayer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {\n    if (!this.framebuffer) {\n      return undefined;\n    }\n  \n    var pixelOnMapScaled = [\n      pixel[0] / frameState.size[0],\n      (frameState.size[1] - pixel[1]) / frameState.size[1]];\n  \n    var pixelOnFrameBufferScaled = ol.transform.apply(\n        this.texCoordMatrix, pixelOnMapScaled.slice());\n    var pixelOnFrameBuffer = [\n      pixelOnFrameBufferScaled[0] * this.framebufferDimension,\n      pixelOnFrameBufferScaled[1] * this.framebufferDimension];\n  \n    var gl = this.mapRenderer.getContext().getGL();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n    var imageData = new Uint8Array(4);\n    gl.readPixels(pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1,\n        gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n  \n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  };\n  \n  goog.provide('ol.renderer.webgl.VectorLayer');\n  \n  goog.require('ol');\n  goog.require('ol.LayerType');\n  goog.require('ol.ViewHint');\n  goog.require('ol.extent');\n  goog.require('ol.render.webgl.ReplayGroup');\n  goog.require('ol.renderer.Type');\n  goog.require('ol.renderer.vector');\n  goog.require('ol.renderer.webgl.Layer');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.renderer.webgl.Layer}\n   * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.\n   * @param {ol.layer.Vector} vectorLayer Vector layer.\n   * @api\n   */\n  ol.renderer.webgl.VectorLayer = function(mapRenderer, vectorLayer) {\n  \n    ol.renderer.webgl.Layer.call(this, mapRenderer, vectorLayer);\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.renderedExtent_ = ol.extent.createEmpty();\n  \n    /**\n     * @private\n     * @type {function(ol.Feature, ol.Feature): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n  \n    /**\n     * @private\n     * @type {ol.render.webgl.ReplayGroup}\n     */\n    this.replayGroup_ = null;\n  \n    /**\n     * The last layer state.\n     * @private\n     * @type {?ol.LayerState}\n     */\n    this.layerState_ = null;\n  \n  };\n  ol.inherits(ol.renderer.webgl.VectorLayer, ol.renderer.webgl.Layer);\n  \n  \n  /**\n   * Determine if this renderer handles the provided layer.\n   * @param {ol.renderer.Type} type The renderer type.\n   * @param {ol.layer.Layer} layer The candidate layer.\n   * @return {boolean} The renderer can render the layer.\n   */\n  ol.renderer.webgl.VectorLayer['handles'] = function(type, layer) {\n    return type === ol.renderer.Type.WEBGL && layer.getType() === ol.LayerType.VECTOR;\n  };\n  \n  \n  /**\n   * Create a layer renderer.\n   * @param {ol.renderer.Map} mapRenderer The map renderer.\n   * @param {ol.layer.Layer} layer The layer to be rendererd.\n   * @return {ol.renderer.webgl.VectorLayer} The layer renderer.\n   */\n  ol.renderer.webgl.VectorLayer['create'] = function(mapRenderer, layer) {\n    return new ol.renderer.webgl.VectorLayer(\n        /** @type {ol.renderer.webgl.Map} */ (mapRenderer),\n        /** @type {ol.layer.Vector} */ (layer)\n    );\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.VectorLayer.prototype.composeFrame = function(frameState, layerState, context) {\n    this.layerState_ = layerState;\n    var viewState = frameState.viewState;\n    var replayGroup = this.replayGroup_;\n    var size = frameState.size;\n    var pixelRatio = frameState.pixelRatio;\n    var gl = this.mapRenderer.getGL();\n    if (replayGroup && !replayGroup.isEmpty()) {\n      gl.enable(gl.SCISSOR_TEST);\n      gl.scissor(0, 0, size[0] * pixelRatio, size[1] * pixelRatio);\n      replayGroup.replay(context,\n          viewState.center, viewState.resolution, viewState.rotation,\n          size, pixelRatio, layerState.opacity,\n          layerState.managed ? frameState.skippedFeatureUids : {});\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  \n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.VectorLayer.prototype.disposeInternal = function() {\n    var replayGroup = this.replayGroup_;\n    if (replayGroup) {\n      var context = this.mapRenderer.getContext();\n      replayGroup.getDeleteResourcesFunction(context)();\n      this.replayGroup_ = null;\n    }\n    ol.renderer.webgl.Layer.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.VectorLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_ || !this.layerState_) {\n      return undefined;\n    } else {\n      var context = this.mapRenderer.getContext();\n      var viewState = frameState.viewState;\n      var layer = this.getLayer();\n      var layerState = this.layerState_;\n      /** @type {Object.<string, boolean>} */\n      var features = {};\n      return this.replayGroup_.forEachFeatureAtCoordinate(coordinate,\n          context, viewState.center, viewState.resolution, viewState.rotation,\n          frameState.size, frameState.pixelRatio, layerState.opacity,\n          {},\n          /**\n           * @param {ol.Feature|ol.render.Feature} feature Feature.\n           * @return {?} Callback result.\n           */\n          function(feature) {\n            var key = ol.getUid(feature).toString();\n            if (!(key in features)) {\n              features[key] = true;\n              return callback.call(thisArg, feature, layer);\n            }\n          });\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.VectorLayer.prototype.hasFeatureAtCoordinate = function(coordinate, frameState) {\n    if (!this.replayGroup_ || !this.layerState_) {\n      return false;\n    } else {\n      var context = this.mapRenderer.getContext();\n      var viewState = frameState.viewState;\n      var layerState = this.layerState_;\n      return this.replayGroup_.hasFeatureAtCoordinate(coordinate,\n          context, viewState.center, viewState.resolution, viewState.rotation,\n          frameState.size, frameState.pixelRatio, layerState.opacity,\n          frameState.skippedFeatureUids);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.VectorLayer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {\n    var coordinate = ol.transform.apply(\n        frameState.pixelToCoordinateTransform, pixel.slice());\n    var hasFeature = this.hasFeatureAtCoordinate(coordinate, frameState);\n  \n    if (hasFeature) {\n      return callback.call(thisArg, this.getLayer(), null);\n    } else {\n      return undefined;\n    }\n  };\n  \n  \n  /**\n   * Handle changes in image style state.\n   * @param {ol.events.Event} event Image style change event.\n   * @private\n   */\n  ol.renderer.webgl.VectorLayer.prototype.handleStyleImageChange_ = function(event) {\n    this.renderIfReadyAndVisible();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.renderer.webgl.VectorLayer.prototype.prepareFrame = function(frameState, layerState, context) {\n  \n    var vectorLayer = /** @type {ol.layer.Vector} */ (this.getLayer());\n    var vectorSource = vectorLayer.getSource();\n  \n    this.updateLogos(frameState, vectorSource);\n  \n    var animating = frameState.viewHints[ol.ViewHint.ANIMATING];\n    var interacting = frameState.viewHints[ol.ViewHint.INTERACTING];\n    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n  \n    if (!this.dirty_ && (!updateWhileAnimating && animating) ||\n        (!updateWhileInteracting && interacting)) {\n      return true;\n    }\n  \n    var frameStateExtent = frameState.extent;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var vectorLayerRevision = vectorLayer.getRevision();\n    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n  \n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = ol.renderer.vector.defaultOrder;\n    }\n  \n    var extent = ol.extent.buffer(frameStateExtent,\n        vectorLayerRenderBuffer * resolution);\n  \n    if (!this.dirty_ &&\n        this.renderedResolution_ == resolution &&\n        this.renderedRevision_ == vectorLayerRevision &&\n        this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n        ol.extent.containsExtent(this.renderedExtent_, extent)) {\n      return true;\n    }\n  \n    if (this.replayGroup_) {\n      frameState.postRenderFunctions.push(\n          this.replayGroup_.getDeleteResourcesFunction(context));\n    }\n  \n    this.dirty_ = false;\n  \n    var replayGroup = new ol.render.webgl.ReplayGroup(\n        ol.renderer.vector.getTolerance(resolution, pixelRatio),\n        extent, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {ol.Feature} feature Feature.\n     * @this {ol.renderer.webgl.VectorLayer}\n     */\n    var renderFeature = function(feature) {\n      var styles;\n      var styleFunction = feature.getStyleFunction();\n      if (styleFunction) {\n        styles = styleFunction.call(feature, resolution);\n      } else {\n        styleFunction = vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n      }\n      if (styles) {\n        var dirty = this.renderFeature(\n            feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    };\n    if (vectorLayerRenderOrder) {\n      /** @type {Array.<ol.Feature>} */\n      var features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n          /**\n           * @param {ol.Feature} feature Feature.\n           */\n          function(feature) {\n            features.push(feature);\n          }, this);\n      features.sort(vectorLayerRenderOrder);\n      features.forEach(renderFeature, this);\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, renderFeature, this);\n    }\n    replayGroup.finish(context);\n  \n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n  \n    return true;\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of\n   *     styles.\n   * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  ol.renderer.webgl.VectorLayer.prototype.renderFeature = function(feature, resolution, pixelRatio, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = styles.length - 1, ii = 0; i >= ii; --i) {\n        loading = ol.renderer.vector.renderFeature(\n            replayGroup, feature, styles[i],\n            ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio),\n            this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = ol.renderer.vector.renderFeature(\n          replayGroup, feature, styles,\n          ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio),\n          this.handleStyleImageChange_, this) || loading;\n    }\n    return loading;\n  };\n  \n  goog.provide('ol.Map');\n  \n  goog.require('ol');\n  goog.require('ol.PluggableMap');\n  goog.require('ol.PluginType');\n  goog.require('ol.control');\n  goog.require('ol.interaction');\n  goog.require('ol.obj');\n  goog.require('ol.plugins');\n  goog.require('ol.renderer.canvas.ImageLayer');\n  goog.require('ol.renderer.canvas.Map');\n  goog.require('ol.renderer.canvas.TileLayer');\n  goog.require('ol.renderer.canvas.VectorLayer');\n  goog.require('ol.renderer.canvas.VectorTileLayer');\n  goog.require('ol.renderer.webgl.ImageLayer');\n  goog.require('ol.renderer.webgl.Map');\n  goog.require('ol.renderer.webgl.TileLayer');\n  goog.require('ol.renderer.webgl.VectorLayer');\n  \n  \n  if (ol.ENABLE_CANVAS) {\n    ol.plugins.register(ol.PluginType.MAP_RENDERER, ol.renderer.canvas.Map);\n    ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER, [\n      ol.renderer.canvas.ImageLayer,\n      ol.renderer.canvas.TileLayer,\n      ol.renderer.canvas.VectorLayer,\n      ol.renderer.canvas.VectorTileLayer\n    ]);\n  }\n  \n  if (ol.ENABLE_WEBGL) {\n    ol.plugins.register(ol.PluginType.MAP_RENDERER, ol.renderer.webgl.Map);\n    ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER, [\n      ol.renderer.webgl.ImageLayer,\n      ol.renderer.webgl.TileLayer,\n      ol.renderer.webgl.VectorLayer\n    ]);\n  }\n  \n  \n  /**\n   * @classdesc\n   * The map is the core component of OpenLayers. For a map to render, a view,\n   * one or more layers, and a target container are needed:\n   *\n   *     var map = new ol.Map({\n   *       view: new ol.View({\n   *         center: [0, 0],\n   *         zoom: 1\n   *       }),\n   *       layers: [\n   *         new ol.layer.Tile({\n   *           source: new ol.source.OSM()\n   *         })\n   *       ],\n   *       target: 'map'\n   *     });\n   *\n   * The above snippet creates a map using a {@link ol.layer.Tile} to display\n   * {@link ol.source.OSM} OSM data and render it to a DOM element with the\n   * id `map`.\n   *\n   * The constructor places a viewport container (with CSS class name\n   * `ol-viewport`) in the target element (see `getViewport()`), and then two\n   * further elements within the viewport: one with CSS class name\n   * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\n   * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\n   * option of {@link ol.Overlay} for the difference). The map itself is placed in\n   * a further element within the viewport.\n   *\n   * Layers are stored as a `ol.Collection` in layerGroups. A top-level group is\n   * provided by the library. This is what is accessed by `getLayerGroup` and\n   * `setLayerGroup`. Layers entered in the options are added to this group, and\n   * `addLayer` and `removeLayer` change the layer collection in the group.\n   * `getLayers` is a convenience function for `getLayerGroup().getLayers()`.\n   * Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers\n   * entered in the options or added with `addLayer` can be groups, which can\n   * contain further groups, and so on.\n   *\n   * @constructor\n   * @extends {ol.PluggableMap}\n   * @param {olx.MapOptions} options Map options.\n   * @fires ol.MapBrowserEvent\n   * @fires ol.MapEvent\n   * @fires ol.render.Event#postcompose\n   * @fires ol.render.Event#precompose\n   * @api\n   */\n  ol.Map = function(options) {\n    options = ol.obj.assign({}, options);\n    if (!options.controls) {\n      options.controls = ol.control.defaults();\n    }\n    if (!options.interactions) {\n      options.interactions = ol.interaction.defaults();\n    }\n  \n    ol.PluggableMap.call(this, options);\n  };\n  ol.inherits(ol.Map, ol.PluggableMap);\n  \n  goog.provide('ol.net');\n  \n  goog.require('ol');\n  \n  \n  /**\n   * Simple JSONP helper. Supports error callbacks and a custom callback param.\n   * The error callback will be called when no JSONP is executed after 10 seconds.\n   *\n   * @param {string} url Request url. A 'callback' query parameter will be\n   *     appended.\n   * @param {Function} callback Callback on success.\n   * @param {function()=} opt_errback Callback on error.\n   * @param {string=} opt_callbackParam Custom query parameter for the JSONP\n   *     callback. Default is 'callback'.\n   */\n  ol.net.jsonp = function(url, callback, opt_errback, opt_callbackParam) {\n    var script = document.createElement('script');\n    var key = 'olc_' + ol.getUid(callback);\n    function cleanup() {\n      delete window[key];\n      script.parentNode.removeChild(script);\n    }\n    script.async = true;\n    script.src = url + (url.indexOf('?') == -1 ? '?' : '&') +\n        (opt_callbackParam || 'callback') + '=' + key;\n    var timer = setTimeout(function() {\n      cleanup();\n      if (opt_errback) {\n        opt_errback();\n      }\n    }, 10000);\n    window[key] = function(data) {\n      clearTimeout(timer);\n      cleanup();\n      callback(data);\n    };\n    document.getElementsByTagName('head')[0].appendChild(script);\n  };\n  \n  goog.provide('ol.proj.common');\n  \n  goog.require('ol.proj');\n  \n  \n  /**\n   * Deprecated.  Transforms between EPSG:4326 and EPSG:3857 are now included by\n   * default.  There is no need to call this function in application code and it\n   * will be removed in a future major release.\n   * @deprecated This function is no longer necessary.\n   * @api\n   */\n  ol.proj.common.add = ol.proj.addCommon;\n  \n  goog.provide('ol.render');\n  \n  goog.require('ol.has');\n  goog.require('ol.transform');\n  goog.require('ol.render.canvas.Immediate');\n  \n  \n  /**\n   * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries\n   * to the context's canvas.\n   *\n   * The units for geometry coordinates are css pixels relative to the top left\n   * corner of the canvas element.\n   * ```js\n   * var canvas = document.createElement('canvas');\n   * var render = ol.render.toContext(canvas.getContext('2d'),\n   *     { size: [100, 100] });\n   * render.setFillStrokeStyle(new ol.style.Fill({ color: blue }));\n   * render.drawPolygon(\n   *     new ol.geom.Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));\n   * ```\n   *\n   * @param {CanvasRenderingContext2D} context Canvas context.\n   * @param {olx.render.ToContextOptions=} opt_options Options.\n   * @return {ol.render.canvas.Immediate} Canvas Immediate.\n   * @api\n   */\n  ol.render.toContext = function(context, opt_options) {\n    var canvas = context.canvas;\n    var options = opt_options ? opt_options : {};\n    var pixelRatio = options.pixelRatio || ol.has.DEVICE_PIXEL_RATIO;\n    var size = options.size;\n    if (size) {\n      canvas.width = size[0] * pixelRatio;\n      canvas.height = size[1] * pixelRatio;\n      canvas.style.width = size[0] + 'px';\n      canvas.style.height = size[1] + 'px';\n    }\n    var extent = [0, 0, canvas.width, canvas.height];\n    var transform = ol.transform.scale(ol.transform.create(), pixelRatio, pixelRatio);\n    return new ol.render.canvas.Immediate(context, pixelRatio, extent, transform,\n        0);\n  };\n  \n  goog.provide('ol.reproj');\n  \n  goog.require('ol.dom');\n  goog.require('ol.extent');\n  goog.require('ol.math');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * Calculates ideal resolution to use from the source in order to achieve\n   * pixel mapping as close as possible to 1:1 during reprojection.\n   * The resolution is calculated regardless of what resolutions\n   * are actually available in the dataset (TileGrid, Image, ...).\n   *\n   * @param {ol.proj.Projection} sourceProj Source projection.\n   * @param {ol.proj.Projection} targetProj Target projection.\n   * @param {ol.Coordinate} targetCenter Target center.\n   * @param {number} targetResolution Target resolution.\n   * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n   */\n  ol.reproj.calculateSourceResolution = function(sourceProj, targetProj,\n      targetCenter, targetResolution) {\n  \n    var sourceCenter = ol.proj.transform(targetCenter, targetProj, sourceProj);\n  \n    // calculate the ideal resolution of the source data\n    var sourceResolution =\n        ol.proj.getPointResolution(targetProj, targetResolution, targetCenter);\n  \n    var targetMetersPerUnit = targetProj.getMetersPerUnit();\n    if (targetMetersPerUnit !== undefined) {\n      sourceResolution *= targetMetersPerUnit;\n    }\n    var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n    if (sourceMetersPerUnit !== undefined) {\n      sourceResolution /= sourceMetersPerUnit;\n    }\n  \n    // Based on the projection properties, the point resolution at the specified\n    // coordinates may be slightly different. We need to reverse-compensate this\n    // in order to achieve optimal results.\n  \n    var sourceExtent = sourceProj.getExtent();\n    if (!sourceExtent || ol.extent.containsCoordinate(sourceExtent, sourceCenter)) {\n      var compensationFactor =\n          ol.proj.getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n          sourceResolution;\n      if (isFinite(compensationFactor) && compensationFactor > 0) {\n        sourceResolution /= compensationFactor;\n      }\n    }\n  \n    return sourceResolution;\n  };\n  \n  \n  /**\n   * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n   * in order to mask gaps caused by antialiasing.\n   *\n   * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n   * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n   * @param {number} x X coordinate of the point (in pixels).\n   * @param {number} y Y coordinate of the point (in pixels).\n   * @return {ol.Coordinate} New point 1 px farther from the centroid.\n   * @private\n   */\n  ol.reproj.enlargeClipPoint_ = function(centroidX, centroidY, x, y) {\n    var dX = x - centroidX, dY = y - centroidY;\n    var distance = Math.sqrt(dX * dX + dY * dY);\n    return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n  };\n  \n  \n  /**\n   * Renders the source data into new canvas based on the triangulation.\n   *\n   * @param {number} width Width of the canvas.\n   * @param {number} height Height of the canvas.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} sourceResolution Source resolution.\n   * @param {ol.Extent} sourceExtent Extent of the data source.\n   * @param {number} targetResolution Target resolution.\n   * @param {ol.Extent} targetExtent Target extent.\n   * @param {ol.reproj.Triangulation} triangulation Calculated triangulation.\n   * @param {Array.<{extent: ol.Extent,\n   *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources\n   *             Array of sources.\n   * @param {number} gutter Gutter of the sources.\n   * @param {boolean=} opt_renderEdges Render reprojection edges.\n   * @return {HTMLCanvasElement} Canvas with reprojected data.\n   */\n  ol.reproj.render = function(width, height, pixelRatio,\n      sourceResolution, sourceExtent, targetResolution, targetExtent,\n      triangulation, sources, gutter, opt_renderEdges) {\n  \n    var context = ol.dom.createCanvasContext2D(Math.round(pixelRatio * width),\n        Math.round(pixelRatio * height));\n  \n    if (sources.length === 0) {\n      return context.canvas;\n    }\n  \n    context.scale(pixelRatio, pixelRatio);\n  \n    var sourceDataExtent = ol.extent.createEmpty();\n    sources.forEach(function(src, i, arr) {\n      ol.extent.extend(sourceDataExtent, src.extent);\n    });\n  \n    var canvasWidthInUnits = ol.extent.getWidth(sourceDataExtent);\n    var canvasHeightInUnits = ol.extent.getHeight(sourceDataExtent);\n    var stitchContext = ol.dom.createCanvasContext2D(\n        Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),\n        Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n  \n    var stitchScale = pixelRatio / sourceResolution;\n  \n    sources.forEach(function(src, i, arr) {\n      var xPos = src.extent[0] - sourceDataExtent[0];\n      var yPos = -(src.extent[3] - sourceDataExtent[3]);\n      var srcWidth = ol.extent.getWidth(src.extent);\n      var srcHeight = ol.extent.getHeight(src.extent);\n  \n      stitchContext.drawImage(\n          src.image,\n          gutter, gutter,\n          src.image.width - 2 * gutter, src.image.height - 2 * gutter,\n          xPos * stitchScale, yPos * stitchScale,\n          srcWidth * stitchScale, srcHeight * stitchScale);\n    });\n  \n    var targetTopLeft = ol.extent.getTopLeft(targetExtent);\n  \n    triangulation.getTriangles().forEach(function(triangle, i, arr) {\n      /* Calculate affine transform (src -> dst)\n       * Resulting matrix can be used to transform coordinate\n       * from `sourceProjection` to destination pixels.\n       *\n       * To optimize number of context calls and increase numerical stability,\n       * we also do the following operations:\n       * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n       * here before solving the linear system so [ui, vi] are pixel coordinates.\n       *\n       * Src points: xi, yi\n       * Dst points: ui, vi\n       * Affine coefficients: aij\n       *\n       * | x0 y0 1  0  0 0 |   |a00|   |u0|\n       * | x1 y1 1  0  0 0 |   |a01|   |u1|\n       * | x2 y2 1  0  0 0 | x |a02| = |u2|\n       * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n       * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n       * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n       */\n      var source = triangle.source, target = triangle.target;\n      var x0 = source[0][0], y0 = source[0][1],\n          x1 = source[1][0], y1 = source[1][1],\n          x2 = source[2][0], y2 = source[2][1];\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,\n          v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,\n          v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,\n          v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n  \n      // Shift all the source points to improve numerical stability\n      // of all the subsequent calculations. The [x0, y0] is used here.\n      // This is also used to simplify the linear system.\n      var sourceNumericalShiftX = x0, sourceNumericalShiftY = y0;\n      x0 = 0;\n      y0 = 0;\n      x1 -= sourceNumericalShiftX;\n      y1 -= sourceNumericalShiftY;\n      x2 -= sourceNumericalShiftX;\n      y2 -= sourceNumericalShiftY;\n  \n      var augmentedMatrix = [\n        [x1, y1, 0, 0, u1 - u0],\n        [x2, y2, 0, 0, u2 - u0],\n        [0, 0, x1, y1, v1 - v0],\n        [0, 0, x2, y2, v2 - v0]\n      ];\n      var affineCoefs = ol.math.solveLinearSystem(augmentedMatrix);\n      if (!affineCoefs) {\n        return;\n      }\n  \n      context.save();\n      context.beginPath();\n      var centroidX = (u0 + u1 + u2) / 3, centroidY = (v0 + v1 + v2) / 3;\n      var p0 = ol.reproj.enlargeClipPoint_(centroidX, centroidY, u0, v0);\n      var p1 = ol.reproj.enlargeClipPoint_(centroidX, centroidY, u1, v1);\n      var p2 = ol.reproj.enlargeClipPoint_(centroidX, centroidY, u2, v2);\n  \n      context.moveTo(p1[0], p1[1]);\n      context.lineTo(p0[0], p0[1]);\n      context.lineTo(p2[0], p2[1]);\n      context.clip();\n  \n      context.transform(\n          affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n  \n      context.translate(sourceDataExtent[0] - sourceNumericalShiftX,\n          sourceDataExtent[3] - sourceNumericalShiftY);\n  \n      context.scale(sourceResolution / pixelRatio,\n          -sourceResolution / pixelRatio);\n  \n      context.drawImage(stitchContext.canvas, 0, 0);\n      context.restore();\n    });\n  \n    if (opt_renderEdges) {\n      context.save();\n  \n      context.strokeStyle = 'black';\n      context.lineWidth = 1;\n  \n      triangulation.getTriangles().forEach(function(triangle, i, arr) {\n        var target = triangle.target;\n        var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,\n            v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n        var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,\n            v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n        var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,\n            v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n  \n        context.beginPath();\n        context.moveTo(u1, v1);\n        context.lineTo(u0, v0);\n        context.lineTo(u2, v2);\n        context.closePath();\n        context.stroke();\n      });\n  \n      context.restore();\n    }\n    return context.canvas;\n  };\n  \n  goog.provide('ol.reproj.Triangulation');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.math');\n  goog.require('ol.proj');\n  \n  \n  /**\n   * @classdesc\n   * Class containing triangulation of the given target extent.\n   * Used for determining source data and the reprojection itself.\n   *\n   * @param {ol.proj.Projection} sourceProj Source projection.\n   * @param {ol.proj.Projection} targetProj Target projection.\n   * @param {ol.Extent} targetExtent Target extent to triangulate.\n   * @param {ol.Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @constructor\n   */\n  ol.reproj.Triangulation = function(sourceProj, targetProj, targetExtent,\n      maxSourceExtent, errorThreshold) {\n  \n    /**\n     * @type {ol.proj.Projection}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n  \n    /**\n     * @type {ol.proj.Projection}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n  \n    /** @type {!Object.<string, ol.Coordinate>} */\n    var transformInvCache = {};\n    var transformInv = ol.proj.getTransform(this.targetProj_, this.sourceProj_);\n  \n    /**\n     * @param {ol.Coordinate} c A coordinate.\n     * @return {ol.Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function(c) {\n      var key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n  \n    /**\n     * @type {ol.Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n  \n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n  \n    /**\n     * @type {Array.<ol.ReprojTriangle>}\n     * @private\n     */\n    this.triangles_ = [];\n  \n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n  \n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&\n        !!maxSourceExtent &&\n        !!this.sourceProj_.getExtent() &&\n        (ol.extent.getWidth(maxSourceExtent) ==\n         ol.extent.getWidth(this.sourceProj_.getExtent()));\n  \n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?\n      ol.extent.getWidth(this.sourceProj_.getExtent()) : null;\n  \n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ?\n      ol.extent.getWidth(this.targetProj_.getExtent()) : null;\n  \n    var destinationTopLeft = ol.extent.getTopLeft(targetExtent);\n    var destinationTopRight = ol.extent.getTopRight(targetExtent);\n    var destinationBottomRight = ol.extent.getBottomRight(targetExtent);\n    var destinationBottomLeft = ol.extent.getBottomLeft(targetExtent);\n    var sourceTopLeft = this.transformInv_(destinationTopLeft);\n    var sourceTopRight = this.transformInv_(destinationTopRight);\n    var sourceBottomRight = this.transformInv_(destinationBottomRight);\n    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n  \n    this.addQuad_(\n        destinationTopLeft, destinationTopRight,\n        destinationBottomRight, destinationBottomLeft,\n        sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,\n        ol.RASTER_REPROJECTION_MAX_SUBDIVISION);\n  \n    if (this.wrapsXInSource_) {\n      var leftBound = Infinity;\n      this.triangles_.forEach(function(triangle, i, arr) {\n        leftBound = Math.min(leftBound,\n            triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      });\n  \n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(function(triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0],\n            triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]]];\n          if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n  \n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          var minX = Math.min(\n              newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          var maxX = Math.max(\n              newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          if ((maxX - minX) < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      }, this);\n    }\n  \n    transformInvCache = {};\n  };\n  \n  \n  /**\n   * Adds triangle to the triangulation.\n   * @param {ol.Coordinate} a The target a coordinate.\n   * @param {ol.Coordinate} b The target b coordinate.\n   * @param {ol.Coordinate} c The target c coordinate.\n   * @param {ol.Coordinate} aSrc The source a coordinate.\n   * @param {ol.Coordinate} bSrc The source b coordinate.\n   * @param {ol.Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  ol.reproj.Triangulation.prototype.addTriangle_ = function(a, b, c,\n      aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c]\n    });\n  };\n  \n  \n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {ol.Coordinate} a The target a coordinate.\n   * @param {ol.Coordinate} b The target b coordinate.\n   * @param {ol.Coordinate} c The target c coordinate.\n   * @param {ol.Coordinate} d The target d coordinate.\n   * @param {ol.Coordinate} aSrc The source a coordinate.\n   * @param {ol.Coordinate} bSrc The source b coordinate.\n   * @param {ol.Coordinate} cSrc The source c coordinate.\n   * @param {ol.Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  ol.reproj.Triangulation.prototype.addQuad_ = function(a, b, c, d,\n      aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n  \n    var sourceQuadExtent = ol.extent.boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    var sourceCoverageX = this.sourceWorldWidth_ ?\n      ol.extent.getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n  \n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    var wrapsX = this.sourceProj_.canWrapX() &&\n                 sourceCoverageX > 0.5 && sourceCoverageX < 1;\n  \n    var needsSubdivision = false;\n  \n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        var targetQuadExtent = ol.extent.boundingExtent([a, b, c, d]);\n        var targetCoverageX =\n            ol.extent.getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision |=\n            targetCoverageX > ol.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision |=\n            sourceCoverageX > ol.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;\n      }\n    }\n  \n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (!ol.extent.intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n        // whole quad outside source projection extent -> ignore\n        return;\n      }\n    }\n  \n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||\n          !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||\n          !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||\n          !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          return;\n        }\n      }\n    }\n  \n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        var centerSrc = this.transformInv_(center);\n  \n        var dx;\n        if (wrapsX) {\n          var centerSrcEstimX =\n              (ol.math.modulo(aSrc[0], sourceWorldWidth) +\n               ol.math.modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX -\n              ol.math.modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        var centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          var bcSrc = this.transformInv_(bc);\n          var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          var daSrc = this.transformInv_(da);\n  \n          this.addQuad_(\n              a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(\n              da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          // split vertically (left & right)\n          var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          var abSrc = this.transformInv_(ab);\n          var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          var cdSrc = this.transformInv_(cd);\n  \n          this.addQuad_(\n              a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(\n              ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n        return;\n      }\n    }\n  \n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n  \n    this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n  };\n  \n  \n  /**\n   * Calculates extent of the 'source' coordinates from all the triangles.\n   *\n   * @return {ol.Extent} Calculated extent.\n   */\n  ol.reproj.Triangulation.prototype.calculateSourceExtent = function() {\n    var extent = ol.extent.createEmpty();\n  \n    this.triangles_.forEach(function(triangle, i, arr) {\n      var src = triangle.source;\n      ol.extent.extendCoordinate(extent, src[0]);\n      ol.extent.extendCoordinate(extent, src[1]);\n      ol.extent.extendCoordinate(extent, src[2]);\n    });\n  \n    return extent;\n  };\n  \n  \n  /**\n   * @return {Array.<ol.ReprojTriangle>} Array of the calculated triangles.\n   */\n  ol.reproj.Triangulation.prototype.getTriangles = function() {\n    return this.triangles_;\n  };\n  \n  goog.provide('ol.reproj.Image');\n  \n  goog.require('ol');\n  goog.require('ol.ImageBase');\n  goog.require('ol.ImageState');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.reproj');\n  goog.require('ol.reproj.Triangulation');\n  \n  \n  /**\n   * @classdesc\n   * Class encapsulating single reprojected image.\n   * See {@link ol.source.Image}.\n   *\n   * @constructor\n   * @extends {ol.ImageBase}\n   * @param {ol.proj.Projection} sourceProj Source projection (of the data).\n   * @param {ol.proj.Projection} targetProj Target projection.\n   * @param {ol.Extent} targetExtent Target extent.\n   * @param {number} targetResolution Target resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.ReprojImageFunctionType} getImageFunction\n   *     Function returning source images (extent, resolution, pixelRatio).\n   */\n  ol.reproj.Image = function(sourceProj, targetProj,\n      targetExtent, targetResolution, pixelRatio, getImageFunction) {\n  \n    /**\n     * @private\n     * @type {ol.proj.Projection}\n     */\n    this.targetProj_ = targetProj;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.maxSourceExtent_ = sourceProj.getExtent();\n    var maxTargetExtent = targetProj.getExtent();\n  \n    var limitedTargetExtent = maxTargetExtent ?\n      ol.extent.getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n  \n    var targetCenter = ol.extent.getCenter(limitedTargetExtent);\n    var sourceResolution = ol.reproj.calculateSourceResolution(\n        sourceProj, targetProj, targetCenter, targetResolution);\n  \n    var errorThresholdInPixels = ol.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;\n  \n    /**\n     * @private\n     * @type {!ol.reproj.Triangulation}\n     */\n    this.triangulation_ = new ol.reproj.Triangulation(\n        sourceProj, targetProj, limitedTargetExtent, this.maxSourceExtent_,\n        sourceResolution * errorThresholdInPixels);\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.targetResolution_ = targetResolution;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.targetExtent_ = targetExtent;\n  \n    var sourceExtent = this.triangulation_.calculateSourceExtent();\n  \n    /**\n     * @private\n     * @type {ol.ImageBase}\n     */\n    this.sourceImage_ =\n        getImageFunction(sourceExtent, sourceResolution, pixelRatio);\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourcePixelRatio_ =\n        this.sourceImage_ ? this.sourceImage_.getPixelRatio() : 1;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n  \n    /**\n     * @private\n     * @type {?ol.EventsKey}\n     */\n    this.sourceListenerKey_ = null;\n  \n  \n    var state = ol.ImageState.LOADED;\n  \n    if (this.sourceImage_) {\n      state = ol.ImageState.IDLE;\n    }\n  \n    ol.ImageBase.call(this, targetExtent, targetResolution, this.sourcePixelRatio_, state);\n  };\n  ol.inherits(ol.reproj.Image, ol.ImageBase);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.reproj.Image.prototype.disposeInternal = function() {\n    if (this.state == ol.ImageState.LOADING) {\n      this.unlistenSource_();\n    }\n    ol.ImageBase.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.reproj.Image.prototype.getImage = function() {\n    return this.canvas_;\n  };\n  \n  \n  /**\n   * @return {ol.proj.Projection} Projection.\n   */\n  ol.reproj.Image.prototype.getProjection = function() {\n    return this.targetProj_;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.reproj.Image.prototype.reproject_ = function() {\n    var sourceState = this.sourceImage_.getState();\n    if (sourceState == ol.ImageState.LOADED) {\n      var width = ol.extent.getWidth(this.targetExtent_) / this.targetResolution_;\n      var height =\n          ol.extent.getHeight(this.targetExtent_) / this.targetResolution_;\n  \n      this.canvas_ = ol.reproj.render(width, height, this.sourcePixelRatio_,\n          this.sourceImage_.getResolution(), this.maxSourceExtent_,\n          this.targetResolution_, this.targetExtent_, this.triangulation_, [{\n            extent: this.sourceImage_.getExtent(),\n            image: this.sourceImage_.getImage()\n          }], 0);\n    }\n    this.state = sourceState;\n    this.changed();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.reproj.Image.prototype.load = function() {\n    if (this.state == ol.ImageState.IDLE) {\n      this.state = ol.ImageState.LOADING;\n      this.changed();\n  \n      var sourceState = this.sourceImage_.getState();\n      if (sourceState == ol.ImageState.LOADED ||\n          sourceState == ol.ImageState.ERROR) {\n        this.reproject_();\n      } else {\n        this.sourceListenerKey_ = ol.events.listen(this.sourceImage_,\n            ol.events.EventType.CHANGE, function(e) {\n              var sourceState = this.sourceImage_.getState();\n              if (sourceState == ol.ImageState.LOADED ||\n                  sourceState == ol.ImageState.ERROR) {\n                this.unlistenSource_();\n                this.reproject_();\n              }\n            }, this);\n        this.sourceImage_.load();\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.reproj.Image.prototype.unlistenSource_ = function() {\n    ol.events.unlistenByKey(/** @type {!ol.EventsKey} */ (this.sourceListenerKey_));\n    this.sourceListenerKey_ = null;\n  };\n  \n  goog.provide('ol.reproj.Tile');\n  \n  goog.require('ol');\n  goog.require('ol.Tile');\n  goog.require('ol.TileState');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.math');\n  goog.require('ol.reproj');\n  goog.require('ol.reproj.Triangulation');\n  \n  \n  /**\n   * @classdesc\n   * Class encapsulating single reprojected tile.\n   * See {@link ol.source.TileImage}.\n   *\n   * @constructor\n   * @extends {ol.Tile}\n   * @param {ol.proj.Projection} sourceProj Source projection.\n   * @param {ol.tilegrid.TileGrid} sourceTileGrid Source tile grid.\n   * @param {ol.proj.Projection} targetProj Target projection.\n   * @param {ol.tilegrid.TileGrid} targetTileGrid Target tile grid.\n   * @param {ol.TileCoord} tileCoord Coordinate of the tile.\n   * @param {ol.TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {ol.ReprojTileFunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n   * @param {boolean=} opt_renderEdges Render reprojection edges.\n   */\n  ol.reproj.Tile = function(sourceProj, sourceTileGrid,\n      targetProj, targetTileGrid, tileCoord, wrappedTileCoord,\n      pixelRatio, gutter, getTileFunction,\n      opt_errorThreshold, opt_renderEdges) {\n    ol.Tile.call(this, tileCoord, ol.TileState.IDLE);\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n  \n    /**\n     * @private\n     * @type {ol.tilegrid.TileGrid}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n  \n    /**\n     * @private\n     * @type {ol.tilegrid.TileGrid}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n  \n    /**\n     * @private\n     * @type {ol.TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n  \n    /**\n     * @private\n     * @type {!Array.<ol.Tile>}\n     */\n    this.sourceTiles_ = [];\n  \n    /**\n     * @private\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n  \n    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    var maxTargetExtent = this.targetTileGrid_.getExtent();\n    var maxSourceExtent = this.sourceTileGrid_.getExtent();\n  \n    var limitedTargetExtent = maxTargetExtent ?\n      ol.extent.getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n  \n    if (ol.extent.getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = ol.TileState.EMPTY;\n      return;\n    }\n  \n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = ol.extent.getIntersection(\n            maxSourceExtent, sourceProjExtent);\n      }\n    }\n  \n    var targetResolution = targetTileGrid.getResolution(\n        this.wrappedTileCoord_[0]);\n  \n    var targetCenter = ol.extent.getCenter(limitedTargetExtent);\n    var sourceResolution = ol.reproj.calculateSourceResolution(\n        sourceProj, targetProj, targetCenter, targetResolution);\n  \n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = ol.TileState.EMPTY;\n      return;\n    }\n  \n    var errorThresholdInPixels = opt_errorThreshold !== undefined ?\n      opt_errorThreshold : ol.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;\n  \n    /**\n     * @private\n     * @type {!ol.reproj.Triangulation}\n     */\n    this.triangulation_ = new ol.reproj.Triangulation(\n        sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,\n        sourceResolution * errorThresholdInPixels);\n  \n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = ol.TileState.EMPTY;\n      return;\n    }\n  \n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = this.triangulation_.calculateSourceExtent();\n  \n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = ol.math.clamp(\n            sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = ol.math.clamp(\n            sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = ol.extent.getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n  \n    if (!ol.extent.getArea(sourceExtent)) {\n      this.state = ol.TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          sourceExtent, this.sourceZ_);\n  \n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n  \n      if (this.sourceTiles_.length === 0) {\n        this.state = ol.TileState.EMPTY;\n      }\n    }\n  };\n  ol.inherits(ol.reproj.Tile, ol.Tile);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.reproj.Tile.prototype.disposeInternal = function() {\n    if (this.state == ol.TileState.LOADING) {\n      this.unlistenSources_();\n    }\n    ol.Tile.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ol.reproj.Tile.prototype.getImage = function() {\n    return this.canvas_;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.reproj.Tile.prototype.reproject_ = function() {\n    var sources = [];\n    this.sourceTiles_.forEach(function(tile, i, arr) {\n      if (tile && tile.getState() == ol.TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }, this);\n    this.sourceTiles_.length = 0;\n  \n    if (sources.length === 0) {\n      this.state = ol.TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n  \n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(\n          this.wrappedTileCoord_);\n      this.canvas_ = ol.reproj.render(width, height, this.pixelRatio_,\n          sourceResolution, this.sourceTileGrid_.getExtent(),\n          targetResolution, targetExtent, this.triangulation_, sources,\n          this.gutter_, this.renderEdges_);\n  \n      this.state = ol.TileState.LOADED;\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.reproj.Tile.prototype.load = function() {\n    if (this.state == ol.TileState.IDLE) {\n      this.state = ol.TileState.LOADING;\n      this.changed();\n  \n      var leftToLoad = 0;\n  \n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        var state = tile.getState();\n        if (state == ol.TileState.IDLE || state == ol.TileState.LOADING) {\n          leftToLoad++;\n  \n          var sourceListenKey;\n          sourceListenKey = ol.events.listen(tile, ol.events.EventType.CHANGE,\n              function(e) {\n                var state = tile.getState();\n                if (state == ol.TileState.LOADED ||\n                    state == ol.TileState.ERROR ||\n                    state == ol.TileState.EMPTY) {\n                  ol.events.unlistenByKey(sourceListenKey);\n                  leftToLoad--;\n                  if (leftToLoad === 0) {\n                    this.unlistenSources_();\n                    this.reproject_();\n                  }\n                }\n              }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      }, this);\n  \n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        var state = tile.getState();\n        if (state == ol.TileState.IDLE) {\n          tile.load();\n        }\n      });\n  \n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.reproj.Tile.prototype.unlistenSources_ = function() {\n    this.sourcesListenerKeys_.forEach(ol.events.unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n  \n  goog.provide('ol.TileUrlFunction');\n  \n  goog.require('ol.asserts');\n  goog.require('ol.math');\n  goog.require('ol.tilecoord');\n  \n  \n  /**\n   * @param {string} template Template.\n   * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.\n   * @return {ol.TileUrlFunctionType} Tile URL function.\n   */\n  ol.TileUrlFunction.createFromTemplate = function(template, tileGrid) {\n    var zRegEx = /\\{z\\}/g;\n    var xRegEx = /\\{x\\}/g;\n    var yRegEx = /\\{y\\}/g;\n    var dashYRegEx = /\\{-y\\}/g;\n    return (\n      /**\n       * @param {ol.TileCoord} tileCoord Tile Coordinate.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {ol.proj.Projection} projection Projection.\n       * @return {string|undefined} Tile URL.\n       */\n      function(tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n          return undefined;\n        } else {\n          return template.replace(zRegEx, tileCoord[0].toString())\n              .replace(xRegEx, tileCoord[1].toString())\n              .replace(yRegEx, function() {\n                var y = -tileCoord[2] - 1;\n                return y.toString();\n              })\n              .replace(dashYRegEx, function() {\n                var z = tileCoord[0];\n                var range = tileGrid.getFullTileRange(z);\n                ol.asserts.assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n                var y = range.getHeight() + tileCoord[2];\n                return y.toString();\n              });\n        }\n      });\n  };\n  \n  \n  /**\n   * @param {Array.<string>} templates Templates.\n   * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.\n   * @return {ol.TileUrlFunctionType} Tile URL function.\n   */\n  ol.TileUrlFunction.createFromTemplates = function(templates, tileGrid) {\n    var len = templates.length;\n    var tileUrlFunctions = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      tileUrlFunctions[i] = ol.TileUrlFunction.createFromTemplate(\n          templates[i], tileGrid);\n    }\n    return ol.TileUrlFunction.createFromTileUrlFunctions(tileUrlFunctions);\n  };\n  \n  \n  /**\n   * @param {Array.<ol.TileUrlFunctionType>} tileUrlFunctions Tile URL Functions.\n   * @return {ol.TileUrlFunctionType} Tile URL function.\n   */\n  ol.TileUrlFunction.createFromTileUrlFunctions = function(tileUrlFunctions) {\n    if (tileUrlFunctions.length === 1) {\n      return tileUrlFunctions[0];\n    }\n    return (\n      /**\n       * @param {ol.TileCoord} tileCoord Tile Coordinate.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {ol.proj.Projection} projection Projection.\n       * @return {string|undefined} Tile URL.\n       */\n      function(tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n          return undefined;\n        } else {\n          var h = ol.tilecoord.hash(tileCoord);\n          var index = ol.math.modulo(h, tileUrlFunctions.length);\n          return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n        }\n      });\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  ol.TileUrlFunction.nullTileUrlFunction = function(tileCoord, pixelRatio, projection) {\n    return undefined;\n  };\n  \n  \n  /**\n   * @param {string} url URL.\n   * @return {Array.<string>} Array of urls.\n   */\n  ol.TileUrlFunction.expandUrl = function(url) {\n    var urls = [];\n    var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n    if (match) {\n      // char range\n      var startCharCode = match[1].charCodeAt(0);\n      var stopCharCode = match[2].charCodeAt(0);\n      var charCode;\n      for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n        urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n      }\n      return urls;\n    }\n    match = match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n    if (match) {\n      // number range\n      var stop = parseInt(match[2], 10);\n      for (var i = parseInt(match[1], 10); i <= stop; i++) {\n        urls.push(url.replace(match[0], i.toString()));\n      }\n      return urls;\n    }\n    urls.push(url);\n    return urls;\n  };\n  \n  goog.provide('ol.TileCache');\n  \n  goog.require('ol');\n  goog.require('ol.structs.LRUCache');\n  goog.require('ol.tilecoord');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.structs.LRUCache.<ol.Tile>}\n   * @param {number=} opt_highWaterMark High water mark.\n   * @struct\n   */\n  ol.TileCache = function(opt_highWaterMark) {\n  \n    ol.structs.LRUCache.call(this, opt_highWaterMark);\n  \n  };\n  ol.inherits(ol.TileCache, ol.structs.LRUCache);\n  \n  \n  /**\n   * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.\n   */\n  ol.TileCache.prototype.expireCache = function(usedTiles) {\n    var tile, zKey;\n    while (this.canExpireCache()) {\n      tile = this.peekLast();\n      zKey = tile.tileCoord[0].toString();\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this.pop().dispose();\n      }\n    }\n  };\n  \n  \n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  ol.TileCache.prototype.pruneExceptNewestZ = function() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    var key = this.peekFirstKey();\n    var tileCoord = ol.tilecoord.fromKey(key);\n    var z = tileCoord[0];\n    this.forEach(function(tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(ol.tilecoord.getKey(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  };\n  \n  goog.provide('ol.source.Tile');\n  \n  goog.require('ol');\n  goog.require('ol.TileCache');\n  goog.require('ol.TileState');\n  goog.require('ol.events.Event');\n  goog.require('ol.proj');\n  goog.require('ol.size');\n  goog.require('ol.source.Source');\n  goog.require('ol.tilecoord');\n  goog.require('ol.tilegrid');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Base class for sources providing images divided into a tile grid.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.source.Source}\n   * @param {ol.SourceTileOptions} options Tile source options.\n   * @api\n   */\n  ol.source.Tile = function(options) {\n  \n    ol.source.Source.call(this, {\n      attributions: options.attributions,\n      extent: options.extent,\n      logo: options.logo,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX\n    });\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ = options.tilePixelRatio !== undefined ?\n      options.tilePixelRatio : 1;\n  \n    /**\n     * @protected\n     * @type {ol.tilegrid.TileGrid}\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n  \n    /**\n     * @protected\n     * @type {ol.TileCache}\n     */\n    this.tileCache = new ol.TileCache(options.cacheSize);\n  \n    /**\n     * @protected\n     * @type {ol.Size}\n     */\n    this.tmpSize = [0, 0];\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = '';\n  \n    /**\n     * @protected\n     * @type {olx.TileOptions}\n     */\n    this.tileOptions = {transition: options.transition};\n  \n  };\n  ol.inherits(ol.source.Tile, ol.source.Source);\n  \n  \n  /**\n   * @return {boolean} Can expire cache.\n   */\n  ol.source.Tile.prototype.canExpireCache = function() {\n    return this.tileCache.canExpireCache();\n  };\n  \n  \n  /**\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.\n   */\n  ol.source.Tile.prototype.expireCache = function(projection, usedTiles) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  };\n  \n  \n  /**\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {ol.TileRange} tileRange Tile range.\n   * @param {function(ol.Tile):(boolean|undefined)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n  ol.source.Tile.prototype.forEachLoadedTile = function(projection, z, tileRange, callback) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n  \n    var covered = true;\n    var tile, tileCoordKey, loaded;\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile = /** @type {!ol.Tile} */ (tileCache.get(tileCoordKey));\n          loaded = tile.getState() === ol.TileState.LOADED;\n          if (loaded) {\n            loaded = (callback(tile) !== false);\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  };\n  \n  \n  /**\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {number} Gutter.\n   */\n  ol.source.Tile.prototype.getGutter = function(projection) {\n    return 0;\n  };\n  \n  \n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n  ol.source.Tile.prototype.getKey = function() {\n    return this.key_;\n  };\n  \n  \n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  ol.source.Tile.prototype.setKey = function(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  ol.source.Tile.prototype.getOpaque = function(projection) {\n    return this.opaque_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.Tile.prototype.getResolutions = function() {\n    return this.tileGrid.getResolutions();\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {!ol.Tile} Tile.\n   */\n  ol.source.Tile.prototype.getTile = function(z, x, y, pixelRatio, projection) {};\n  \n  \n  /**\n   * Return the tile grid of the tile source.\n   * @return {ol.tilegrid.TileGrid} Tile grid.\n   * @api\n   */\n  ol.source.Tile.prototype.getTileGrid = function() {\n    return this.tileGrid;\n  };\n  \n  \n  /**\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {!ol.tilegrid.TileGrid} Tile grid.\n   */\n  ol.source.Tile.prototype.getTileGridForProjection = function(projection) {\n    if (!this.tileGrid) {\n      return ol.tilegrid.getForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  };\n  \n  \n  /**\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {ol.TileCache} Tile cache.\n   * @protected\n   */\n  ol.source.Tile.prototype.getTileCacheForProjection = function(projection) {\n    var thisProj = this.getProjection();\n    if (thisProj && !ol.proj.equivalent(thisProj, projection)) {\n      return null;\n    } else {\n      return this.tileCache;\n    }\n  };\n  \n  \n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  ol.source.Tile.prototype.getTilePixelRatio = function(pixelRatio) {\n    return this.tilePixelRatio_;\n  };\n  \n  \n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {ol.Size} Tile size.\n   */\n  ol.source.Tile.prototype.getTilePixelSize = function(z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    var tileSize = ol.size.toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return ol.size.scale(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  };\n  \n  \n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.proj.Projection=} opt_projection Projection.\n   * @return {ol.TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  ol.source.Tile.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {\n    var projection = opt_projection !== undefined ?\n      opt_projection : this.getProjection();\n    var tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = ol.tilegrid.wrapX(tileGrid, tileCoord, projection);\n    }\n    return ol.tilecoord.withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.Tile.prototype.refresh = function() {\n    this.tileCache.clear();\n    this.changed();\n  };\n  \n  \n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {ol.proj.Projection} projection Projection.\n   */\n  ol.source.Tile.prototype.useTile = ol.nullFunction;\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.source.Tile} instances are instances of this\n   * type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.source.Tile.Event}\n   * @param {string} type Type.\n   * @param {ol.Tile} tile The tile.\n   */\n  ol.source.Tile.Event = function(type, tile) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The tile related to the event.\n     * @type {ol.Tile}\n     * @api\n     */\n    this.tile = tile;\n  \n  };\n  ol.inherits(ol.source.Tile.Event, ol.events.Event);\n  \n  goog.provide('ol.source.TileEventType');\n  \n  /**\n   * @enum {string}\n   */\n  ol.source.TileEventType = {\n  \n    /**\n     * Triggered when a tile starts loading.\n     * @event ol.source.Tile.Event#tileloadstart\n     * @api\n     */\n    TILELOADSTART: 'tileloadstart',\n  \n    /**\n     * Triggered when a tile finishes loading, either when its data is loaded,\n     * or when loading was aborted because the tile is no longer needed.\n     * @event ol.source.Tile.Event#tileloadend\n     * @api\n     */\n    TILELOADEND: 'tileloadend',\n  \n    /**\n     * Triggered if tile loading results in an error.\n     * @event ol.source.Tile.Event#tileloaderror\n     * @api\n     */\n    TILELOADERROR: 'tileloaderror'\n  \n  };\n  \n  goog.provide('ol.source.UrlTile');\n  \n  goog.require('ol');\n  goog.require('ol.TileState');\n  goog.require('ol.TileUrlFunction');\n  goog.require('ol.source.Tile');\n  goog.require('ol.source.TileEventType');\n  goog.require('ol.tilecoord');\n  \n  \n  /**\n   * @classdesc\n   * Base class for sources providing tiles divided into a tile grid over http.\n   *\n   * @constructor\n   * @abstract\n   * @fires ol.source.Tile.Event\n   * @extends {ol.source.Tile}\n   * @param {ol.SourceUrlTileOptions} options Image tile options.\n   */\n  ol.source.UrlTile = function(options) {\n  \n    ol.source.Tile.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      extent: options.extent,\n      logo: options.logo,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition\n    });\n  \n    /**\n     * @protected\n     * @type {ol.TileLoadFunctionType}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n  \n    /**\n     * @protected\n     * @type {ol.TileUrlFunctionType}\n     */\n    this.tileUrlFunction = this.fixedTileUrlFunction ?\n      this.fixedTileUrlFunction.bind(this) :\n      ol.TileUrlFunction.nullTileUrlFunction;\n  \n    /**\n     * @protected\n     * @type {!Array.<string>|null}\n     */\n    this.urls = null;\n  \n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n    if (options.tileUrlFunction) {\n      this.setTileUrlFunction(options.tileUrlFunction);\n    }\n  \n    /**\n     * @private\n     * @type {Object.<number, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n  \n  };\n  ol.inherits(ol.source.UrlTile, ol.source.Tile);\n  \n  \n  /**\n   * @type {ol.TileUrlFunctionType|undefined}\n   * @protected\n   */\n  ol.source.UrlTile.prototype.fixedTileUrlFunction;\n  \n  /**\n   * Return the tile load function of the source.\n   * @return {ol.TileLoadFunctionType} TileLoadFunction\n   * @api\n   */\n  ol.source.UrlTile.prototype.getTileLoadFunction = function() {\n    return this.tileLoadFunction;\n  };\n  \n  \n  /**\n   * Return the tile URL function of the source.\n   * @return {ol.TileUrlFunctionType} TileUrlFunction\n   * @api\n   */\n  ol.source.UrlTile.prototype.getTileUrlFunction = function() {\n    return this.tileUrlFunction;\n  };\n  \n  \n  /**\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array.<string>|null} URLs.\n   * @api\n   */\n  ol.source.UrlTile.prototype.getUrls = function() {\n    return this.urls;\n  };\n  \n  \n  /**\n   * Handle tile change events.\n   * @param {ol.events.Event} event Event.\n   * @protected\n   */\n  ol.source.UrlTile.prototype.handleTileChange = function(event) {\n    var tile = /** @type {ol.Tile} */ (event.target);\n    var uid = ol.getUid(tile);\n    var tileState = tile.getState();\n    var type;\n    if (tileState == ol.TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = ol.source.TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type = tileState == ol.TileState.ERROR ? ol.source.TileEventType.TILELOADERROR :\n        (tileState == ol.TileState.LOADED || tileState == ol.TileState.ABORT) ?\n          ol.source.TileEventType.TILELOADEND : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new ol.source.Tile.Event(type, tile));\n    }\n  };\n  \n  \n  /**\n   * Set the tile load function of the source.\n   * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.\n   * @api\n   */\n  ol.source.UrlTile.prototype.setTileLoadFunction = function(tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the tile URL function of the source.\n   * @param {ol.TileUrlFunctionType} tileUrlFunction Tile URL function.\n   * @param {string=} opt_key Optional new tile key for the source.\n   * @api\n   */\n  ol.source.UrlTile.prototype.setTileUrlFunction = function(tileUrlFunction, opt_key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n    if (typeof opt_key !== 'undefined') {\n      this.setKey(opt_key);\n    } else {\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  ol.source.UrlTile.prototype.setUrl = function(url) {\n    var urls = this.urls = ol.TileUrlFunction.expandUrl(url);\n    this.setTileUrlFunction(this.fixedTileUrlFunction ?\n      this.fixedTileUrlFunction.bind(this) :\n      ol.TileUrlFunction.createFromTemplates(urls, this.tileGrid), url);\n  };\n  \n  \n  /**\n   * Set the URLs to use for requests.\n   * @param {Array.<string>} urls URLs.\n   * @api\n   */\n  ol.source.UrlTile.prototype.setUrls = function(urls) {\n    this.urls = urls;\n    var key = urls.join('\\n');\n    this.setTileUrlFunction(this.fixedTileUrlFunction ?\n      this.fixedTileUrlFunction.bind(this) :\n      ol.TileUrlFunction.createFromTemplates(urls, this.tileGrid), key);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.UrlTile.prototype.useTile = function(z, x, y) {\n    var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  };\n  \n  goog.provide('ol.source.TileImage');\n  \n  goog.require('ol');\n  goog.require('ol.ImageTile');\n  goog.require('ol.TileCache');\n  goog.require('ol.TileState');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.proj');\n  goog.require('ol.reproj.Tile');\n  goog.require('ol.source.UrlTile');\n  goog.require('ol.tilecoord');\n  goog.require('ol.tilegrid');\n  \n  \n  /**\n   * @classdesc\n   * Base class for sources providing images divided into a tile grid.\n   *\n   * @constructor\n   * @fires ol.source.Tile.Event\n   * @extends {ol.source.UrlTile}\n   * @param {olx.source.TileImageOptions} options Image tile options.\n   * @api\n   */\n  ol.source.TileImage = function(options) {\n  \n    ol.source.UrlTile.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      extent: options.extent,\n      logo: options.logo,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction ?\n        options.tileLoadFunction : ol.source.TileImage.defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition\n    });\n  \n    /**\n     * @protected\n     * @type {?string}\n     */\n    this.crossOrigin =\n        options.crossOrigin !== undefined ? options.crossOrigin : null;\n  \n    /**\n     * @protected\n     * @type {function(new: ol.ImageTile, ol.TileCoord, ol.TileState, string,\n     *        ?string, ol.TileLoadFunctionType, olx.TileOptions=)}\n     */\n    this.tileClass = options.tileClass !== undefined ?\n      options.tileClass : ol.ImageTile;\n  \n    /**\n     * @protected\n     * @type {Object.<string, ol.TileCache>}\n     */\n    this.tileCacheForProjection = {};\n  \n    /**\n     * @protected\n     * @type {Object.<string, ol.tilegrid.TileGrid>}\n     */\n    this.tileGridForProjection = {};\n  \n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderReprojectionEdges_ = false;\n  };\n  ol.inherits(ol.source.TileImage, ol.source.UrlTile);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileImage.prototype.canExpireCache = function() {\n    if (!ol.ENABLE_RASTER_REPROJECTION) {\n      return ol.source.UrlTile.prototype.canExpireCache.call(this);\n    }\n    if (this.tileCache.canExpireCache()) {\n      return true;\n    } else {\n      for (var key in this.tileCacheForProjection) {\n        if (this.tileCacheForProjection[key].canExpireCache()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileImage.prototype.expireCache = function(projection, usedTiles) {\n    if (!ol.ENABLE_RASTER_REPROJECTION) {\n      ol.source.UrlTile.prototype.expireCache.call(this, projection, usedTiles);\n      return;\n    }\n    var usedTileCache = this.getTileCacheForProjection(projection);\n  \n    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n    for (var id in this.tileCacheForProjection) {\n      var tileCache = this.tileCacheForProjection[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileImage.prototype.getGutter = function(projection) {\n    if (ol.ENABLE_RASTER_REPROJECTION &&\n        this.getProjection() && projection &&\n        !ol.proj.equivalent(this.getProjection(), projection)) {\n      return 0;\n    } else {\n      return this.getGutterInternal();\n    }\n  };\n  \n  \n  /**\n   * @protected\n   * @return {number} Gutter.\n   */\n  ol.source.TileImage.prototype.getGutterInternal = function() {\n    return 0;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileImage.prototype.getOpaque = function(projection) {\n    if (ol.ENABLE_RASTER_REPROJECTION &&\n        this.getProjection() && projection &&\n        !ol.proj.equivalent(this.getProjection(), projection)) {\n      return false;\n    } else {\n      return ol.source.UrlTile.prototype.getOpaque.call(this, projection);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileImage.prototype.getTileGridForProjection = function(projection) {\n    if (!ol.ENABLE_RASTER_REPROJECTION) {\n      return ol.source.UrlTile.prototype.getTileGridForProjection.call(this, projection);\n    }\n    var thisProj = this.getProjection();\n    if (this.tileGrid &&\n        (!thisProj || ol.proj.equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    } else {\n      var projKey = ol.getUid(projection).toString();\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] =\n            ol.tilegrid.getForProjection(projection);\n      }\n      return /** @type {!ol.tilegrid.TileGrid} */ (this.tileGridForProjection[projKey]);\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileImage.prototype.getTileCacheForProjection = function(projection) {\n    if (!ol.ENABLE_RASTER_REPROJECTION) {\n      return ol.source.UrlTile.prototype.getTileCacheForProjection.call(this, projection);\n    }\n    var thisProj = this.getProjection();\n    if (!thisProj || ol.proj.equivalent(thisProj, projection)) {\n      return this.tileCache;\n    } else {\n      var projKey = ol.getUid(projection).toString();\n      if (!(projKey in this.tileCacheForProjection)) {\n        this.tileCacheForProjection[projKey] = new ol.TileCache(this.tileCache.highWaterMark);\n      }\n      return this.tileCacheForProjection[projKey];\n    }\n  };\n  \n  \n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!ol.Tile} Tile.\n   * @private\n   */\n  ol.source.TileImage.prototype.createTile_ = function(z, x, y, pixelRatio, projection, key) {\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(\n        tileCoord, projection);\n    var tileUrl = urlTileCoord ?\n      this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;\n    var tile = new this.tileClass(\n        tileCoord,\n        tileUrl !== undefined ? ol.TileState.IDLE : ol.TileState.EMPTY,\n        tileUrl !== undefined ? tileUrl : '',\n        this.crossOrigin,\n        this.tileLoadFunction,\n        this.tileOptions);\n    tile.key = key;\n    ol.events.listen(tile, ol.events.EventType.CHANGE,\n        this.handleTileChange, this);\n    return tile;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileImage.prototype.getTile = function(z, x, y, pixelRatio, projection) {\n    var sourceProjection = /** @type {!ol.proj.Projection} */ (this.getProjection());\n    if (!ol.ENABLE_RASTER_REPROJECTION ||\n        !sourceProjection || !projection ||\n        ol.proj.equivalent(sourceProjection, projection)) {\n      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);\n    } else {\n      var cache = this.getTileCacheForProjection(projection);\n      var tileCoord = [z, x, y];\n      var tile;\n      var tileCoordKey = ol.tilecoord.getKey(tileCoord);\n      if (cache.containsKey(tileCoordKey)) {\n        tile = /** @type {!ol.Tile} */ (cache.get(tileCoordKey));\n      }\n      var key = this.getKey();\n      if (tile && tile.key == key) {\n        return tile;\n      } else {\n        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n        var targetTileGrid = this.getTileGridForProjection(projection);\n        var wrappedTileCoord =\n            this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var newTile = new ol.reproj.Tile(\n            sourceProjection, sourceTileGrid,\n            projection, targetTileGrid,\n            tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio),\n            this.getGutterInternal(),\n            function(z, x, y, pixelRatio) {\n              return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n            }.bind(this), this.reprojectionErrorThreshold_,\n            this.renderReprojectionEdges_);\n        newTile.key = key;\n  \n        if (tile) {\n          newTile.interimTile = tile;\n          newTile.refreshInterimChain();\n          cache.replace(tileCoordKey, newTile);\n        } else {\n          cache.set(tileCoordKey, newTile);\n        }\n        return newTile;\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!ol.proj.Projection} projection Projection.\n   * @return {!ol.Tile} Tile.\n   * @protected\n   */\n  ol.source.TileImage.prototype.getTileInternal = function(z, x, y, pixelRatio, projection) {\n    var tile = null;\n    var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);\n    var key = this.getKey();\n    if (!this.tileCache.containsKey(tileCoordKey)) {\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n      this.tileCache.set(tileCoordKey, tile);\n    } else {\n      tile = this.tileCache.get(tileCoordKey);\n      if (tile.key != key) {\n        // The source's params changed. If the tile has an interim tile and if we\n        // can use it then we use it. Otherwise we create a new tile.  In both\n        // cases we attempt to assign an interim tile to the new tile.\n        var interimTile = tile;\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n  \n        //make the new tile the head of the list,\n        if (interimTile.getState() == ol.TileState.IDLE) {\n          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n          tile.interimTile = interimTile.interimTile;\n        } else {\n          tile.interimTile = interimTile;\n        }\n        tile.refreshInterimChain();\n        this.tileCache.replace(tileCoordKey, tile);\n      }\n    }\n    return tile;\n  };\n  \n  \n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  ol.source.TileImage.prototype.setRenderReprojectionEdges = function(render) {\n    if (!ol.ENABLE_RASTER_REPROJECTION ||\n        this.renderReprojectionEdges_ == render) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    for (var id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n    this.changed();\n  };\n  \n  \n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {ol.ProjectionLike} projection Projection.\n   * @param {ol.tilegrid.TileGrid} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  ol.source.TileImage.prototype.setTileGridForProjection = function(projection, tilegrid) {\n    if (ol.ENABLE_RASTER_REPROJECTION) {\n      var proj = ol.proj.get(projection);\n      if (proj) {\n        var projKey = ol.getUid(proj).toString();\n        if (!(projKey in this.tileGridForProjection)) {\n          this.tileGridForProjection[projKey] = tilegrid;\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {ol.ImageTile} imageTile Image tile.\n   * @param {string} src Source.\n   */\n  ol.source.TileImage.defaultTileLoadFunction = function(imageTile, src) {\n    imageTile.getImage().src = src;\n  };\n  \n  goog.provide('ol.source.BingMaps');\n  \n  goog.require('ol');\n  goog.require('ol.TileUrlFunction');\n  goog.require('ol.extent');\n  goog.require('ol.net');\n  goog.require('ol.proj');\n  goog.require('ol.source.State');\n  goog.require('ol.source.TileImage');\n  goog.require('ol.tilecoord');\n  goog.require('ol.tilegrid');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for Bing Maps tile data.\n   *\n   * @constructor\n   * @extends {ol.source.TileImage}\n   * @param {olx.source.BingMapsOptions} options Bing Maps options.\n   * @api\n   */\n  ol.source.BingMaps = function(options) {\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : false;\n  \n    ol.source.TileImage.call(this, {\n      cacheSize: options.cacheSize,\n      crossOrigin: 'anonymous',\n      opaque: true,\n      projection: ol.proj.get('EPSG:3857'),\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: ol.source.State.LOADING,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: this.hidpi_ ? 2 : 1,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition\n    });\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.culture_ = options.culture !== undefined ? options.culture : 'en-us';\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxZoom_ = options.maxZoom !== undefined ? options.maxZoom : -1;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.apiKey_ = options.key;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.imagerySet_ = options.imagerySet;\n  \n    var url = 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/' +\n        this.imagerySet_ +\n        '?uriScheme=https&include=ImageryProviders&key=' + this.apiKey_ +\n        '&c=' + this.culture_;\n  \n    ol.net.jsonp(url, this.handleImageryMetadataResponse.bind(this), undefined,\n        'jsonp');\n  \n  };\n  ol.inherits(ol.source.BingMaps, ol.source.TileImage);\n  \n  \n  /**\n   * The attribution containing a link to the Microsoft® Bing™ Maps Platform APIs’\n   * Terms Of Use.\n   * @const\n   * @type {string}\n   * @api\n   */\n  ol.source.BingMaps.TOS_ATTRIBUTION = '<a class=\"ol-attribution-bing-tos\" ' +\n        'href=\"https://www.microsoft.com/maps/product/terms.html\">' +\n        'Terms of Use</a>';\n  \n  \n  /**\n   * Get the api key used for this source.\n   *\n   * @return {string} The api key.\n   * @api\n   */\n  ol.source.BingMaps.prototype.getApiKey = function() {\n    return this.apiKey_;\n  };\n  \n  \n  /**\n   * Get the imagery set associated with this source.\n   *\n   * @return {string} The imagery set.\n   * @api\n   */\n  ol.source.BingMaps.prototype.getImagerySet = function() {\n    return this.imagerySet_;\n  };\n  \n  \n  /**\n   * @param {BingMapsImageryMetadataResponse} response Response.\n   */\n  ol.source.BingMaps.prototype.handleImageryMetadataResponse = function(response) {\n    if (response.statusCode != 200 ||\n        response.statusDescription != 'OK' ||\n        response.authenticationResultCode != 'ValidCredentials' ||\n        response.resourceSets.length != 1 ||\n        response.resourceSets[0].resources.length != 1) {\n      this.setState(ol.source.State.ERROR);\n      return;\n    }\n  \n    var brandLogoUri = response.brandLogoUri;\n    if (brandLogoUri.indexOf('https') == -1) {\n      brandLogoUri = brandLogoUri.replace('http', 'https');\n    }\n    //var copyright = response.copyright;  // FIXME do we need to display this?\n    var resource = response.resourceSets[0].resources[0];\n    var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;\n  \n    var sourceProjection = this.getProjection();\n    var extent = ol.tilegrid.extentFromProjection(sourceProjection);\n    var tileSize = resource.imageWidth == resource.imageHeight ?\n      resource.imageWidth : [resource.imageWidth, resource.imageHeight];\n    var tileGrid = ol.tilegrid.createXYZ({\n      extent: extent,\n      minZoom: resource.zoomMin,\n      maxZoom: maxZoom,\n      tileSize: tileSize / (this.hidpi_ ? 2 : 1)\n    });\n    this.tileGrid = tileGrid;\n  \n    var culture = this.culture_;\n    var hidpi = this.hidpi_;\n    this.tileUrlFunction = ol.TileUrlFunction.createFromTileUrlFunctions(\n        resource.imageUrlSubdomains.map(function(subdomain) {\n          var quadKeyTileCoord = [0, 0, 0];\n          var imageUrl = resource.imageUrl\n              .replace('{subdomain}', subdomain)\n              .replace('{culture}', culture);\n          return (\n            /**\n             * @param {ol.TileCoord} tileCoord Tile coordinate.\n             * @param {number} pixelRatio Pixel ratio.\n             * @param {ol.proj.Projection} projection Projection.\n             * @return {string|undefined} Tile URL.\n             */\n            function(tileCoord, pixelRatio, projection) {\n              if (!tileCoord) {\n                return undefined;\n              } else {\n                ol.tilecoord.createOrUpdate(tileCoord[0], tileCoord[1],\n                    -tileCoord[2] - 1, quadKeyTileCoord);\n                var url = imageUrl;\n                if (hidpi) {\n                  url += '&dpi=d1&device=mobile';\n                }\n                return url.replace('{quadkey}', ol.tilecoord.quadKey(\n                    quadKeyTileCoord));\n              }\n            });\n        }));\n  \n    if (resource.imageryProviders) {\n      var transform = ol.proj.getTransformFromProjections(\n          ol.proj.get('EPSG:4326'), this.getProjection());\n  \n      this.setAttributions(function(frameState) {\n        var attributions = [];\n        var zoom = frameState.viewState.zoom;\n        resource.imageryProviders.map(function(imageryProvider) {\n          var intersects = false;\n          var coverageAreas = imageryProvider.coverageAreas;\n          for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {\n            var coverageArea = coverageAreas[i];\n            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {\n              var bbox = coverageArea.bbox;\n              var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];\n              var extent = ol.extent.applyTransform(epsg4326Extent, transform);\n              if (ol.extent.intersects(extent, frameState.extent)) {\n                intersects = true;\n                break;\n              }\n            }\n          }\n          if (intersects) {\n            attributions.push(imageryProvider.attribution);\n          }\n        });\n  \n        attributions.push(ol.source.BingMaps.TOS_ATTRIBUTION);\n        return attributions;\n      });\n    }\n  \n    this.setLogo(brandLogoUri);\n  \n    this.setState(ol.source.State.READY);\n  };\n  \n  goog.provide('ol.source.XYZ');\n  \n  goog.require('ol');\n  goog.require('ol.source.TileImage');\n  goog.require('ol.tilegrid');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for tile data with URLs in a set XYZ format that are\n   * defined in a URL template. By default, this follows the widely-used\n   * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n   * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n   * using the `{-y}` placeholder in the URL template, so long as the\n   * source does not have a custom tile grid. In this case,\n   * {@link ol.source.TileImage} can be used with a `tileUrlFunction`\n   * such as:\n   *\n   *  tileUrlFunction: function(coordinate) {\n   *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n   *        coordinate[1] + '/' + coordinate[2] + '.png';\n   *    }\n   *\n   *\n   * @constructor\n   * @extends {ol.source.TileImage}\n   * @param {olx.source.XYZOptions=} opt_options XYZ options.\n   * @api\n   */\n  ol.source.XYZ = function(opt_options) {\n    var options = opt_options || {};\n    var projection = options.projection !== undefined ?\n      options.projection : 'EPSG:3857';\n  \n    var tileGrid = options.tileGrid !== undefined ? options.tileGrid :\n      ol.tilegrid.createXYZ({\n        extent: ol.tilegrid.extentFromProjection(projection),\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize\n      });\n  \n    ol.source.TileImage.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      logo: options.logo,\n      opaque: options.opaque,\n      projection: projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition\n    });\n  \n  };\n  ol.inherits(ol.source.XYZ, ol.source.TileImage);\n  \n  goog.provide('ol.source.CartoDB');\n  \n  goog.require('ol');\n  goog.require('ol.obj');\n  goog.require('ol.source.State');\n  goog.require('ol.source.XYZ');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for the CartoDB Maps API.\n   *\n   * @constructor\n   * @extends {ol.source.XYZ}\n   * @param {olx.source.CartoDBOptions} options CartoDB options.\n   * @api\n   */\n  ol.source.CartoDB = function(options) {\n  \n    /**\n     * @type {string}\n     * @private\n     */\n    this.account_ = options.account;\n  \n    /**\n     * @type {string}\n     * @private\n     */\n    this.mapId_ = options.map || '';\n  \n    /**\n     * @type {!Object}\n     * @private\n     */\n    this.config_ = options.config || {};\n  \n    /**\n     * @type {!Object.<string, CartoDBLayerInfo>}\n     * @private\n     */\n    this.templateCache_ = {};\n  \n    ol.source.XYZ.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      logo: options.logo,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 18,\n      minZoom: options.minZoom,\n      projection: options.projection,\n      state: ol.source.State.LOADING,\n      wrapX: options.wrapX\n    });\n    this.initializeMap_();\n  };\n  ol.inherits(ol.source.CartoDB, ol.source.XYZ);\n  \n  \n  /**\n   * Returns the current config.\n   * @return {!Object} The current configuration.\n   * @api\n   */\n  ol.source.CartoDB.prototype.getConfig = function() {\n    return this.config_;\n  };\n  \n  \n  /**\n   * Updates the carto db config.\n   * @param {Object} config a key-value lookup. Values will replace current values\n   *     in the config.\n   * @api\n   */\n  ol.source.CartoDB.prototype.updateConfig = function(config) {\n    ol.obj.assign(this.config_, config);\n    this.initializeMap_();\n  };\n  \n  \n  /**\n   * Sets the CartoDB config\n   * @param {Object} config In the case of anonymous maps, a CartoDB configuration\n   *     object.\n   * If using named maps, a key-value lookup with the template parameters.\n   * @api\n   */\n  ol.source.CartoDB.prototype.setConfig = function(config) {\n    this.config_ = config || {};\n    this.initializeMap_();\n  };\n  \n  \n  /**\n   * Issue a request to initialize the CartoDB map.\n   * @private\n   */\n  ol.source.CartoDB.prototype.initializeMap_ = function() {\n    var paramHash = JSON.stringify(this.config_);\n    if (this.templateCache_[paramHash]) {\n      this.applyTemplate_(this.templateCache_[paramHash]);\n      return;\n    }\n    var mapUrl = 'https://' + this.account_ + '.carto.com/api/v1/map';\n  \n    if (this.mapId_) {\n      mapUrl += '/named/' + this.mapId_;\n    }\n  \n    var client = new XMLHttpRequest();\n    client.addEventListener('load', this.handleInitResponse_.bind(this, paramHash));\n    client.addEventListener('error', this.handleInitError_.bind(this));\n    client.open('POST', mapUrl);\n    client.setRequestHeader('Content-type', 'application/json');\n    client.send(JSON.stringify(this.config_));\n  };\n  \n  \n  /**\n   * Handle map initialization response.\n   * @param {string} paramHash a hash representing the parameter set that was used\n   *     for the request\n   * @param {Event} event Event.\n   * @private\n   */\n  ol.source.CartoDB.prototype.handleInitResponse_ = function(paramHash, event) {\n    var client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response;\n      try {\n        response = /** @type {CartoDBLayerInfo} */(JSON.parse(client.responseText));\n      } catch (err) {\n        this.setState(ol.source.State.ERROR);\n        return;\n      }\n      this.applyTemplate_(response);\n      this.templateCache_[paramHash] = response;\n      this.setState(ol.source.State.READY);\n    } else {\n      this.setState(ol.source.State.ERROR);\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} event Event.\n   */\n  ol.source.CartoDB.prototype.handleInitError_ = function(event) {\n    this.setState(ol.source.State.ERROR);\n  };\n  \n  \n  /**\n   * Apply the new tile urls returned by carto db\n   * @param {CartoDBLayerInfo} data Result of carto db call.\n   * @private\n   */\n  ol.source.CartoDB.prototype.applyTemplate_ = function(data) {\n    var tilesUrl = 'https://' + data.cdn_url.https + '/' + this.account_ +\n        '/api/v1/map/' + data.layergroupid + '/{z}/{x}/{y}.png';\n    this.setUrl(tilesUrl);\n  };\n  \n  // FIXME keep cluster cache by resolution ?\n  // FIXME distance not respected because of the centroid\n  \n  goog.provide('ol.source.Cluster');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.Feature');\n  goog.require('ol.coordinate');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.geom.Point');\n  goog.require('ol.source.Vector');\n  \n  \n  /**\n   * @classdesc\n   * Layer source to cluster vector data. Works out of the box with point\n   * geometries. For other geometry types, or if not all geometries should be\n   * considered for clustering, a custom `geometryFunction` can be defined.\n   *\n   * @constructor\n   * @param {olx.source.ClusterOptions} options Constructor options.\n   * @extends {ol.source.Vector}\n   * @api\n   */\n  ol.source.Cluster = function(options) {\n    ol.source.Vector.call(this, {\n      attributions: options.attributions,\n      extent: options.extent,\n      logo: options.logo,\n      projection: options.projection,\n      wrapX: options.wrapX\n    });\n  \n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.resolution = undefined;\n  \n    /**\n     * @type {number}\n     * @protected\n     */\n    this.distance = options.distance !== undefined ? options.distance : 20;\n  \n    /**\n     * @type {Array.<ol.Feature>}\n     * @protected\n     */\n    this.features = [];\n  \n    /**\n     * @param {ol.Feature} feature Feature.\n     * @return {ol.geom.Point} Cluster calculation point.\n     * @protected\n     */\n    this.geometryFunction = options.geometryFunction || function(feature) {\n      var geometry = /** @type {ol.geom.Point} */ (feature.getGeometry());\n      ol.asserts.assert(geometry instanceof ol.geom.Point,\n          10); // The default `geometryFunction` can only handle `ol.geom.Point` geometries\n      return geometry;\n    };\n  \n    /**\n     * @type {ol.source.Vector}\n     * @protected\n     */\n    this.source = options.source;\n  \n    this.source.on(ol.events.EventType.CHANGE,\n        ol.source.Cluster.prototype.refresh, this);\n  };\n  ol.inherits(ol.source.Cluster, ol.source.Vector);\n  \n  \n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  ol.source.Cluster.prototype.getDistance = function() {\n    return this.distance;\n  };\n  \n  \n  /**\n   * Get a reference to the wrapped source.\n   * @return {ol.source.Vector} Source.\n   * @api\n   */\n  ol.source.Cluster.prototype.getSource = function() {\n    return this.source;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.Cluster.prototype.loadFeatures = function(extent, resolution,\n      projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.clear();\n      this.resolution = resolution;\n      this.cluster();\n      this.addFeatures(this.features);\n    }\n  };\n  \n  \n  /**\n   * Set the distance in pixels between clusters.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  ol.source.Cluster.prototype.setDistance = function(distance) {\n    this.distance = distance;\n    this.refresh();\n  };\n  \n  \n  /**\n   * handle the source changing\n   * @override\n   */\n  ol.source.Cluster.prototype.refresh = function() {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n    ol.source.Vector.prototype.refresh.call(this);\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.source.Cluster.prototype.cluster = function() {\n    if (this.resolution === undefined) {\n      return;\n    }\n    this.features.length = 0;\n    var extent = ol.extent.createEmpty();\n    var mapDistance = this.distance * this.resolution;\n    var features = this.source.getFeatures();\n  \n    /**\n     * @type {!Object.<string, boolean>}\n     */\n    var clustered = {};\n  \n    for (var i = 0, ii = features.length; i < ii; i++) {\n      var feature = features[i];\n      if (!(ol.getUid(feature).toString() in clustered)) {\n        var geometry = this.geometryFunction(feature);\n        if (geometry) {\n          var coordinates = geometry.getCoordinates();\n          ol.extent.createOrUpdateFromCoordinate(coordinates, extent);\n          ol.extent.buffer(extent, mapDistance, extent);\n  \n          var neighbors = this.source.getFeaturesInExtent(extent);\n          neighbors = neighbors.filter(function(neighbor) {\n            var uid = ol.getUid(neighbor).toString();\n            if (!(uid in clustered)) {\n              clustered[uid] = true;\n              return true;\n            } else {\n              return false;\n            }\n          });\n          this.features.push(this.createCluster(neighbors));\n        }\n      }\n    }\n  };\n  \n  \n  /**\n   * @param {Array.<ol.Feature>} features Features\n   * @return {ol.Feature} The cluster feature.\n   * @protected\n   */\n  ol.source.Cluster.prototype.createCluster = function(features) {\n    var centroid = [0, 0];\n    for (var i = features.length - 1; i >= 0; --i) {\n      var geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        ol.coordinate.add(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    ol.coordinate.scale(centroid, 1 / features.length);\n  \n    var cluster = new ol.Feature(new ol.geom.Point(centroid));\n    cluster.set('features', features);\n    return cluster;\n  };\n  \n  goog.provide('ol.source.Image');\n  \n  goog.require('ol');\n  goog.require('ol.ImageState');\n  goog.require('ol.array');\n  goog.require('ol.events.Event');\n  goog.require('ol.extent');\n  goog.require('ol.proj');\n  goog.require('ol.reproj.Image');\n  goog.require('ol.source.Source');\n  \n  \n  /**\n   * @classdesc\n   * Abstract base class; normally only used for creating subclasses and not\n   * instantiated in apps.\n   * Base class for sources providing a single image.\n   *\n   * @constructor\n   * @abstract\n   * @extends {ol.source.Source}\n   * @param {ol.SourceImageOptions} options Single image source options.\n   * @api\n   */\n  ol.source.Image = function(options) {\n    ol.source.Source.call(this, {\n      attributions: options.attributions,\n      extent: options.extent,\n      logo: options.logo,\n      projection: options.projection,\n      state: options.state\n    });\n  \n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.resolutions_ = options.resolutions !== undefined ?\n      options.resolutions : null;\n  \n  \n    /**\n     * @private\n     * @type {ol.reproj.Image}\n     */\n    this.reprojectedImage_ = null;\n  \n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.reprojectedRevision_ = 0;\n  };\n  ol.inherits(ol.source.Image, ol.source.Source);\n  \n  \n  /**\n   * @return {Array.<number>} Resolutions.\n   * @override\n   */\n  ol.source.Image.prototype.getResolutions = function() {\n    return this.resolutions_;\n  };\n  \n  \n  /**\n   * @protected\n   * @param {number} resolution Resolution.\n   * @return {number} Resolution.\n   */\n  ol.source.Image.prototype.findNearestResolution = function(resolution) {\n    if (this.resolutions_) {\n      var idx = ol.array.linearFindNearest(this.resolutions_, resolution, 0);\n      resolution = this.resolutions_[idx];\n    }\n    return resolution;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {ol.ImageBase} Single image.\n   */\n  ol.source.Image.prototype.getImage = function(extent, resolution, pixelRatio, projection) {\n    var sourceProjection = this.getProjection();\n    if (!ol.ENABLE_RASTER_REPROJECTION ||\n        !sourceProjection ||\n        !projection ||\n        ol.proj.equivalent(sourceProjection, projection)) {\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n      return this.getImageInternal(extent, resolution, pixelRatio, projection);\n    } else {\n      if (this.reprojectedImage_) {\n        if (this.reprojectedRevision_ == this.getRevision() &&\n            ol.proj.equivalent(\n                this.reprojectedImage_.getProjection(), projection) &&\n            this.reprojectedImage_.getResolution() == resolution &&\n            ol.extent.equals(this.reprojectedImage_.getExtent(), extent)) {\n          return this.reprojectedImage_;\n        }\n        this.reprojectedImage_.dispose();\n        this.reprojectedImage_ = null;\n      }\n  \n      this.reprojectedImage_ = new ol.reproj.Image(\n          sourceProjection, projection, extent, resolution, pixelRatio,\n          function(extent, resolution, pixelRatio) {\n            return this.getImageInternal(extent, resolution,\n                pixelRatio, sourceProjection);\n          }.bind(this));\n      this.reprojectedRevision_ = this.getRevision();\n  \n      return this.reprojectedImage_;\n    }\n  };\n  \n  \n  /**\n   * @abstract\n   * @param {ol.Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {ol.ImageBase} Single image.\n   * @protected\n   */\n  ol.source.Image.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {};\n  \n  \n  /**\n   * Handle image change events.\n   * @param {ol.events.Event} event Event.\n   * @protected\n   */\n  ol.source.Image.prototype.handleImageChange = function(event) {\n    var image = /** @type {ol.Image} */ (event.target);\n    switch (image.getState()) {\n      case ol.ImageState.LOADING:\n        this.dispatchEvent(\n            new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADSTART,\n                image));\n        break;\n      case ol.ImageState.LOADED:\n        this.dispatchEvent(\n            new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADEND,\n                image));\n        break;\n      case ol.ImageState.ERROR:\n        this.dispatchEvent(\n            new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADERROR,\n                image));\n        break;\n      default:\n        // pass\n    }\n  };\n  \n  \n  /**\n   * Default image load function for image sources that use ol.Image image\n   * instances.\n   * @param {ol.Image} image Image.\n   * @param {string} src Source.\n   */\n  ol.source.Image.defaultImageLoadFunction = function(image, src) {\n    image.getImage().src = src;\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.source.Image} instances are instances of this\n   * type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.source.ImageEvent}\n   * @param {string} type Type.\n   * @param {ol.Image} image The image.\n   */\n  ol.source.Image.Event = function(type, image) {\n  \n    ol.events.Event.call(this, type);\n  \n    /**\n     * The image related to the event.\n     * @type {ol.Image}\n     * @api\n     */\n    this.image = image;\n  \n  };\n  ol.inherits(ol.source.Image.Event, ol.events.Event);\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.source.Image.EventType_ = {\n  \n    /**\n     * Triggered when an image starts loading.\n     * @event ol.source.Image.Event#imageloadstart\n     * @api\n     */\n    IMAGELOADSTART: 'imageloadstart',\n  \n    /**\n     * Triggered when an image finishes loading.\n     * @event ol.source.Image.Event#imageloadend\n     * @api\n     */\n    IMAGELOADEND: 'imageloadend',\n  \n    /**\n     * Triggered if image loading results in an error.\n     * @event ol.source.Image.Event#imageloaderror\n     * @api\n     */\n    IMAGELOADERROR: 'imageloaderror'\n  \n  };\n  \n  goog.provide('ol.uri');\n  \n  \n  /**\n   * Appends query parameters to a URI.\n   *\n   * @param {string} uri The original URI, which may already have query data.\n   * @param {!Object} params An object where keys are URI-encoded parameter keys,\n   *     and the values are arbitrary types or arrays.\n   * @return {string} The new URI.\n   */\n  ol.uri.appendParams = function(uri, params) {\n    var keyParams = [];\n    // Skip any null or undefined parameter values\n    Object.keys(params).forEach(function(k) {\n      if (params[k] !== null && params[k] !== undefined) {\n        keyParams.push(k + '=' + encodeURIComponent(params[k]));\n      }\n    });\n    var qs = keyParams.join('&');\n    // remove any trailing ? or &\n    uri = uri.replace(/[?&]$/, '');\n    // append ? or & depending on whether uri has existing parameters\n    uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';\n    return uri + qs;\n  };\n  \n  goog.provide('ol.source.ImageArcGISRest');\n  \n  goog.require('ol');\n  goog.require('ol.Image');\n  goog.require('ol.asserts');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.source.Image');\n  goog.require('ol.uri');\n  \n  \n  /**\n   * @classdesc\n   * Source for data from ArcGIS Rest services providing single, untiled images.\n   * Useful when underlying map service has labels.\n   *\n   * If underlying map service is not using labels,\n   * take advantage of ol image caching and use\n   * {@link ol.source.TileArcGISRest} data source.\n   *\n   * @constructor\n   * @fires ol.source.Image.Event\n   * @extends {ol.source.Image}\n   * @param {olx.source.ImageArcGISRestOptions=} opt_options Image ArcGIS Rest Options.\n   * @api\n   */\n  ol.source.ImageArcGISRest = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    ol.source.Image.call(this, {\n      attributions: options.attributions,\n      logo: options.logo,\n      projection: options.projection,\n      resolutions: options.resolutions\n    });\n  \n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n        options.crossOrigin !== undefined ? options.crossOrigin : null;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n  \n    /**\n     * @private\n     * @type {ol.ImageLoadFunctionType}\n     */\n    this.imageLoadFunction_ = options.imageLoadFunction !== undefined ?\n      options.imageLoadFunction : ol.source.Image.defaultImageLoadFunction;\n  \n  \n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n  \n    /**\n     * @private\n     * @type {ol.Image}\n     */\n    this.image_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.imageSize_ = [0, 0];\n  \n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n  \n  };\n  ol.inherits(ol.source.ImageArcGISRest, ol.source.Image);\n  \n  \n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  ol.source.ImageArcGISRest.prototype.getParams = function() {\n    return this.params_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.ImageArcGISRest.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {\n  \n    if (this.url_ === undefined) {\n      return null;\n    }\n  \n    resolution = this.findNearestResolution(resolution);\n    pixelRatio = this.hidpi_ ? pixelRatio : 1;\n  \n    var image = this.image_;\n    if (image &&\n        this.renderedRevision_ == this.getRevision() &&\n        image.getResolution() == resolution &&\n        image.getPixelRatio() == pixelRatio &&\n        ol.extent.containsExtent(image.getExtent(), extent)) {\n      return image;\n    }\n  \n    var params = {\n      'F': 'image',\n      'FORMAT': 'PNG32',\n      'TRANSPARENT': true\n    };\n    ol.obj.assign(params, this.params_);\n  \n    extent = extent.slice();\n    var centerX = (extent[0] + extent[2]) / 2;\n    var centerY = (extent[1] + extent[3]) / 2;\n    if (this.ratio_ != 1) {\n      var halfWidth = this.ratio_ * ol.extent.getWidth(extent) / 2;\n      var halfHeight = this.ratio_ * ol.extent.getHeight(extent) / 2;\n      extent[0] = centerX - halfWidth;\n      extent[1] = centerY - halfHeight;\n      extent[2] = centerX + halfWidth;\n      extent[3] = centerY + halfHeight;\n    }\n  \n    var imageResolution = resolution / pixelRatio;\n  \n    // Compute an integer width and height.\n    var width = Math.ceil(ol.extent.getWidth(extent) / imageResolution);\n    var height = Math.ceil(ol.extent.getHeight(extent) / imageResolution);\n  \n    // Modify the extent to match the integer width and height.\n    extent[0] = centerX - imageResolution * width / 2;\n    extent[2] = centerX + imageResolution * width / 2;\n    extent[1] = centerY - imageResolution * height / 2;\n    extent[3] = centerY + imageResolution * height / 2;\n  \n    this.imageSize_[0] = width;\n    this.imageSize_[1] = height;\n  \n    var url = this.getRequestUrl_(extent, this.imageSize_, pixelRatio,\n        projection, params);\n  \n    this.image_ = new ol.Image(extent, resolution, pixelRatio,\n        url, this.crossOrigin_, this.imageLoadFunction_);\n  \n    this.renderedRevision_ = this.getRevision();\n  \n    ol.events.listen(this.image_, ol.events.EventType.CHANGE,\n        this.handleImageChange, this);\n  \n    return this.image_;\n  \n  };\n  \n  \n  /**\n   * Return the image load function of the source.\n   * @return {ol.ImageLoadFunctionType} The image load function.\n   * @api\n   */\n  ol.source.ImageArcGISRest.prototype.getImageLoadFunction = function() {\n    return this.imageLoadFunction_;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {Object} params Params.\n   * @return {string} Request URL.\n   * @private\n   */\n  ol.source.ImageArcGISRest.prototype.getRequestUrl_ = function(extent, size, pixelRatio, projection, params) {\n    // ArcGIS Server only wants the numeric portion of the projection ID.\n    var srid = projection.getCode().split(':').pop();\n  \n    params['SIZE'] = size[0] + ',' + size[1];\n    params['BBOX'] = extent.join(',');\n    params['BBOXSR'] = srid;\n    params['IMAGESR'] = srid;\n    params['DPI'] = Math.round(90 * pixelRatio);\n  \n    var url = this.url_;\n  \n    var modifiedUrl = url\n        .replace(/MapServer\\/?$/, 'MapServer/export')\n        .replace(/ImageServer\\/?$/, 'ImageServer/exportImage');\n    if (modifiedUrl == url) {\n      ol.asserts.assert(false, 50); // `options.featureTypes` should be an Array\n    }\n    return ol.uri.appendParams(modifiedUrl, params);\n  };\n  \n  \n  /**\n   * Return the URL used for this ArcGIS source.\n   * @return {string|undefined} URL.\n   * @api\n   */\n  ol.source.ImageArcGISRest.prototype.getUrl = function() {\n    return this.url_;\n  };\n  \n  \n  /**\n   * Set the image load function of the source.\n   * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.\n   * @api\n   */\n  ol.source.ImageArcGISRest.prototype.setImageLoadFunction = function(imageLoadFunction) {\n    this.image_ = null;\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the URL to use for requests.\n   * @param {string|undefined} url URL.\n   * @api\n   */\n  ol.source.ImageArcGISRest.prototype.setUrl = function(url) {\n    if (url != this.url_) {\n      this.url_ = url;\n      this.image_ = null;\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  ol.source.ImageArcGISRest.prototype.updateParams = function(params) {\n    ol.obj.assign(this.params_, params);\n    this.image_ = null;\n    this.changed();\n  };\n  \n  goog.provide('ol.source.ImageCanvas');\n  \n  goog.require('ol');\n  goog.require('ol.ImageCanvas');\n  goog.require('ol.extent');\n  goog.require('ol.source.Image');\n  \n  \n  /**\n   * @classdesc\n   * Base class for image sources where a canvas element is the image.\n   *\n   * @constructor\n   * @extends {ol.source.Image}\n   * @param {olx.source.ImageCanvasOptions} options Constructor options.\n   * @api\n   */\n  ol.source.ImageCanvas = function(options) {\n  \n    ol.source.Image.call(this, {\n      attributions: options.attributions,\n      logo: options.logo,\n      projection: options.projection,\n      resolutions: options.resolutions,\n      state: options.state\n    });\n  \n    /**\n     * @private\n     * @type {ol.CanvasFunctionType}\n     */\n    this.canvasFunction_ = options.canvasFunction;\n  \n    /**\n     * @private\n     * @type {ol.ImageCanvas}\n     */\n    this.canvas_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ?\n      options.ratio : 1.5;\n  \n  };\n  ol.inherits(ol.source.ImageCanvas, ol.source.Image);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.ImageCanvas.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {\n    resolution = this.findNearestResolution(resolution);\n  \n    var canvas = this.canvas_;\n    if (canvas &&\n        this.renderedRevision_ == this.getRevision() &&\n        canvas.getResolution() == resolution &&\n        canvas.getPixelRatio() == pixelRatio &&\n        ol.extent.containsExtent(canvas.getExtent(), extent)) {\n      return canvas;\n    }\n  \n    extent = extent.slice();\n    ol.extent.scaleFromCenter(extent, this.ratio_);\n    var width = ol.extent.getWidth(extent) / resolution;\n    var height = ol.extent.getHeight(extent) / resolution;\n    var size = [width * pixelRatio, height * pixelRatio];\n  \n    var canvasElement = this.canvasFunction_(\n        extent, resolution, pixelRatio, size, projection);\n    if (canvasElement) {\n      canvas = new ol.ImageCanvas(extent, resolution, pixelRatio, canvasElement);\n    }\n    this.canvas_ = canvas;\n    this.renderedRevision_ = this.getRevision();\n  \n    return canvas;\n  };\n  \n  goog.provide('ol.source.ImageMapGuide');\n  \n  goog.require('ol');\n  goog.require('ol.Image');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.source.Image');\n  goog.require('ol.uri');\n  \n  \n  /**\n   * @classdesc\n   * Source for images from Mapguide servers\n   *\n   * @constructor\n   * @fires ol.source.Image.Event\n   * @extends {ol.source.Image}\n   * @param {olx.source.ImageMapGuideOptions} options Options.\n   * @api\n   */\n  ol.source.ImageMapGuide = function(options) {\n  \n    ol.source.Image.call(this, {\n      projection: options.projection,\n      resolutions: options.resolutions\n    });\n  \n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n        options.crossOrigin !== undefined ? options.crossOrigin : null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.displayDpi_ = options.displayDpi !== undefined ?\n      options.displayDpi : 96;\n  \n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n  \n    /**\n     * @private\n     * @type {ol.ImageLoadFunctionType}\n     */\n    this.imageLoadFunction_ = options.imageLoadFunction !== undefined ?\n      options.imageLoadFunction : ol.source.Image.defaultImageLoadFunction;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.metersPerUnit_ = options.metersPerUnit !== undefined ?\n      options.metersPerUnit : 1;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useOverlay_ = options.useOverlay !== undefined ?\n      options.useOverlay : false;\n  \n    /**\n     * @private\n     * @type {ol.Image}\n     */\n    this.image_ = null;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n  \n  };\n  ol.inherits(ol.source.ImageMapGuide, ol.source.Image);\n  \n  \n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  ol.source.ImageMapGuide.prototype.getParams = function() {\n    return this.params_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.ImageMapGuide.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {\n    resolution = this.findNearestResolution(resolution);\n    pixelRatio = this.hidpi_ ? pixelRatio : 1;\n  \n    var image = this.image_;\n    if (image &&\n        this.renderedRevision_ == this.getRevision() &&\n        image.getResolution() == resolution &&\n        image.getPixelRatio() == pixelRatio &&\n        ol.extent.containsExtent(image.getExtent(), extent)) {\n      return image;\n    }\n  \n    if (this.ratio_ != 1) {\n      extent = extent.slice();\n      ol.extent.scaleFromCenter(extent, this.ratio_);\n    }\n    var width = ol.extent.getWidth(extent) / resolution;\n    var height = ol.extent.getHeight(extent) / resolution;\n    var size = [width * pixelRatio, height * pixelRatio];\n  \n    if (this.url_ !== undefined) {\n      var imageUrl = this.getUrl(this.url_, this.params_, extent, size,\n          projection);\n      image = new ol.Image(extent, resolution, pixelRatio,\n          imageUrl, this.crossOrigin_,\n          this.imageLoadFunction_);\n      ol.events.listen(image, ol.events.EventType.CHANGE,\n          this.handleImageChange, this);\n    } else {\n      image = null;\n    }\n    this.image_ = image;\n    this.renderedRevision_ = this.getRevision();\n  \n    return image;\n  };\n  \n  \n  /**\n   * Return the image load function of the source.\n   * @return {ol.ImageLoadFunctionType} The image load function.\n   * @api\n   */\n  ol.source.ImageMapGuide.prototype.getImageLoadFunction = function() {\n    return this.imageLoadFunction_;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent The map extents.\n   * @param {ol.Size} size The viewport size.\n   * @param {number} metersPerUnit The meters-per-unit value.\n   * @param {number} dpi The display resolution.\n   * @return {number} The computed map scale.\n   */\n  ol.source.ImageMapGuide.getScale = function(extent, size, metersPerUnit, dpi) {\n    var mcsW = ol.extent.getWidth(extent);\n    var mcsH = ol.extent.getHeight(extent);\n    var devW = size[0];\n    var devH = size[1];\n    var mpp = 0.0254 / dpi;\n    if (devH * mcsW > devW * mcsH) {\n      return mcsW * metersPerUnit / (devW * mpp); // width limited\n    } else {\n      return mcsH * metersPerUnit / (devH * mpp); // height limited\n    }\n  };\n  \n  \n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  ol.source.ImageMapGuide.prototype.updateParams = function(params) {\n    ol.obj.assign(this.params_, params);\n    this.changed();\n  };\n  \n  \n  /**\n   * @param {string} baseUrl The mapagent url.\n   * @param {Object.<string, string|number>} params Request parameters.\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Size} size Size.\n   * @param {ol.proj.Projection} projection Projection.\n   * @return {string} The mapagent map image request URL.\n   */\n  ol.source.ImageMapGuide.prototype.getUrl = function(baseUrl, params, extent, size, projection) {\n    var scale = ol.source.ImageMapGuide.getScale(extent, size,\n        this.metersPerUnit_, this.displayDpi_);\n    var center = ol.extent.getCenter(extent);\n    var baseParams = {\n      'OPERATION': this.useOverlay_ ? 'GETDYNAMICMAPOVERLAYIMAGE' : 'GETMAPIMAGE',\n      'VERSION': '2.0.0',\n      'LOCALE': 'en',\n      'CLIENTAGENT': 'ol.source.ImageMapGuide source',\n      'CLIP': '1',\n      'SETDISPLAYDPI': this.displayDpi_,\n      'SETDISPLAYWIDTH': Math.round(size[0]),\n      'SETDISPLAYHEIGHT': Math.round(size[1]),\n      'SETVIEWSCALE': scale,\n      'SETVIEWCENTERX': center[0],\n      'SETVIEWCENTERY': center[1]\n    };\n    ol.obj.assign(baseParams, params);\n    return ol.uri.appendParams(baseUrl, baseParams);\n  };\n  \n  \n  /**\n   * Set the image load function of the MapGuide source.\n   * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.\n   * @api\n   */\n  ol.source.ImageMapGuide.prototype.setImageLoadFunction = function(\n      imageLoadFunction) {\n    this.image_ = null;\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  };\n  \n  goog.provide('ol.source.ImageStatic');\n  \n  goog.require('ol');\n  goog.require('ol.Image');\n  goog.require('ol.ImageState');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.proj');\n  goog.require('ol.source.Image');\n  \n  \n  /**\n   * @classdesc\n   * A layer source for displaying a single, static image.\n   *\n   * @constructor\n   * @extends {ol.source.Image}\n   * @param {olx.source.ImageStaticOptions} options Options.\n   * @api\n   */\n  ol.source.ImageStatic = function(options) {\n    var imageExtent = options.imageExtent;\n  \n    var crossOrigin = options.crossOrigin !== undefined ?\n      options.crossOrigin : null;\n  \n    var /** @type {ol.ImageLoadFunctionType} */ imageLoadFunction =\n        options.imageLoadFunction !== undefined ?\n          options.imageLoadFunction : ol.source.Image.defaultImageLoadFunction;\n  \n    ol.source.Image.call(this, {\n      attributions: options.attributions,\n      logo: options.logo,\n      projection: ol.proj.get(options.projection)\n    });\n  \n    /**\n     * @private\n     * @type {ol.Image}\n     */\n    this.image_ = new ol.Image(imageExtent, undefined, 1, options.url, crossOrigin, imageLoadFunction);\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.imageSize_ = options.imageSize ? options.imageSize : null;\n  \n    ol.events.listen(this.image_, ol.events.EventType.CHANGE,\n        this.handleImageChange, this);\n  \n  };\n  ol.inherits(ol.source.ImageStatic, ol.source.Image);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.ImageStatic.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {\n    if (ol.extent.intersects(extent, this.image_.getExtent())) {\n      return this.image_;\n    }\n    return null;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.ImageStatic.prototype.handleImageChange = function(evt) {\n    if (this.image_.getState() == ol.ImageState.LOADED) {\n      var imageExtent = this.image_.getExtent();\n      var image = this.image_.getImage();\n      var imageWidth, imageHeight;\n      if (this.imageSize_) {\n        imageWidth = this.imageSize_[0];\n        imageHeight = this.imageSize_[1];\n      } else {\n        imageWidth = image.width;\n        imageHeight = image.height;\n      }\n      var resolution = ol.extent.getHeight(imageExtent) / imageHeight;\n      var targetWidth = Math.ceil(ol.extent.getWidth(imageExtent) / resolution);\n      if (targetWidth != imageWidth) {\n        var context = ol.dom.createCanvasContext2D(targetWidth, imageHeight);\n        var canvas = context.canvas;\n        context.drawImage(image, 0, 0, imageWidth, imageHeight,\n            0, 0, canvas.width, canvas.height);\n        this.image_.setImage(canvas);\n      }\n    }\n    ol.source.Image.prototype.handleImageChange.call(this, evt);\n  };\n  \n  goog.provide('ol.source.ImageVector');\n  \n  goog.require('ol');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.ext.rbush');\n  goog.require('ol.extent');\n  goog.require('ol.render.canvas.ReplayGroup');\n  goog.require('ol.renderer.vector');\n  goog.require('ol.source.ImageCanvas');\n  goog.require('ol.style.Style');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @deprecated\n   * @classdesc\n   * **Deprecated**. Use an `ol.layer.Vector` with `renderMode: 'image'` and an\n   * `ol.source.Vector` instead.\n   *\n   * An image source whose images are canvas elements into which vector features\n   * read from a vector source (`ol.source.Vector`) are drawn. An\n   * `ol.source.ImageVector` object is to be used as the `source` of an image\n   * layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,\n   * as opposed to being re-rendered, during animations and interactions. So, like\n   * any other image layer, an image layer configured with an\n   * `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a\n   * vector layer, where vector features are re-drawn during animations and\n   * interactions.\n   *\n   * @constructor\n   * @extends {ol.source.ImageCanvas}\n   * @param {olx.source.ImageVectorOptions} options Options.\n   * @api\n   */\n  ol.source.ImageVector = function(options) {\n  \n    /**\n     * @private\n     * @type {ol.source.Vector}\n     */\n    this.source_ = options.source;\n  \n    /**\n     * @private\n     * @type {ol.Transform}\n     */\n    this.transform_ = ol.transform.create();\n  \n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.canvasContext_ = ol.dom.createCanvasContext2D();\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.canvasSize_ = [0, 0];\n  \n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = ol.ext.rbush(9);\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderBuffer_ = options.renderBuffer == undefined ? 100 : options.renderBuffer;\n  \n    /**\n     * @private\n     * @type {ol.render.canvas.ReplayGroup}\n     */\n    this.replayGroup_ = null;\n  \n    ol.source.ImageCanvas.call(this, {\n      attributions: options.attributions,\n      canvasFunction: this.canvasFunctionInternal_.bind(this),\n      logo: options.logo,\n      projection: options.projection,\n      ratio: options.ratio,\n      resolutions: options.resolutions,\n      state: this.source_.getState()\n    });\n  \n    /**\n     * User provided style.\n     * @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}\n     * @private\n     */\n    this.style_ = null;\n  \n    /**\n     * Style function for use within the library.\n     * @type {ol.StyleFunction|undefined}\n     * @private\n     */\n    this.styleFunction_ = undefined;\n  \n    this.setStyle(options.style);\n  \n    ol.events.listen(this.source_, ol.events.EventType.CHANGE,\n        this.handleSourceChange_, this);\n  \n  };\n  ol.inherits(ol.source.ImageVector, ol.source.ImageCanvas);\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.Size} size Size.\n   * @param {ol.proj.Projection} projection Projection;\n   * @return {HTMLCanvasElement} Canvas element.\n   * @private\n   */\n  ol.source.ImageVector.prototype.canvasFunctionInternal_ = function(extent, resolution, pixelRatio, size, projection) {\n  \n    var replayGroup = new ol.render.canvas.ReplayGroup(\n        ol.renderer.vector.getTolerance(resolution, pixelRatio), extent,\n        resolution, pixelRatio, this.source_.getOverlaps(), this.declutterTree_, this.renderBuffer_);\n  \n    this.source_.loadFeatures(extent, resolution, projection);\n  \n    var loading = false;\n    this.source_.forEachFeatureInExtent(extent,\n        /**\n         * @param {ol.Feature} feature Feature.\n         */\n        function(feature) {\n          loading = loading ||\n              this.renderFeature_(feature, resolution, pixelRatio, replayGroup);\n        }, this);\n    replayGroup.finish();\n  \n    if (loading) {\n      return null;\n    }\n  \n    if (this.canvasSize_[0] != size[0] || this.canvasSize_[1] != size[1]) {\n      this.canvasContext_.canvas.width = size[0];\n      this.canvasContext_.canvas.height = size[1];\n      this.canvasSize_[0] = size[0];\n      this.canvasSize_[1] = size[1];\n    } else {\n      this.canvasContext_.clearRect(0, 0, size[0], size[1]);\n    }\n  \n    this.declutterTree_.clear();\n  \n    var transform = this.getTransform_(ol.extent.getCenter(extent),\n        resolution, pixelRatio, size);\n    replayGroup.replay(this.canvasContext_, transform, 0, {});\n  \n    this.replayGroup_ = replayGroup;\n  \n    return this.canvasContext_.canvas;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.ImageVector.prototype.forEachFeatureAtCoordinate = function(\n      coordinate, resolution, rotation, hitTolerance, skippedFeatureUids, callback) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      /** @type {Object.<string, boolean>} */\n      var features = {};\n      var result = this.replayGroup_.forEachFeatureAtCoordinate(\n          coordinate, resolution, 0, hitTolerance, skippedFeatureUids,\n          /**\n           * @param {ol.Feature|ol.render.Feature} feature Feature.\n           * @return {?} Callback result.\n           */\n          function(feature) {\n            var key = ol.getUid(feature).toString();\n            if (!(key in features)) {\n              features[key] = true;\n              return callback(feature);\n            }\n          }, null);\n      return result;\n    }\n  };\n  \n  \n  /**\n   * Get a reference to the wrapped source.\n   * @return {ol.source.Vector} Source.\n   * @api\n   */\n  ol.source.ImageVector.prototype.getSource = function() {\n    return this.source_;\n  };\n  \n  \n  /**\n   * Get the style for features.  This returns whatever was passed to the `style`\n   * option at construction or to the `setStyle` method.\n   * @return {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}\n   *     Layer style.\n   * @api\n   */\n  ol.source.ImageVector.prototype.getStyle = function() {\n    return this.style_;\n  };\n  \n  \n  /**\n   * Get the style function.\n   * @return {ol.StyleFunction|undefined} Layer style function.\n   * @api\n   */\n  ol.source.ImageVector.prototype.getStyleFunction = function() {\n    return this.styleFunction_;\n  };\n  \n  \n  /**\n   * @param {ol.Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.Size} size Size.\n   * @return {!ol.Transform} Transform.\n   * @private\n   */\n  ol.source.ImageVector.prototype.getTransform_ = function(center, resolution, pixelRatio, size) {\n    var dx1 = size[0] / 2;\n    var dy1 = size[1] / 2;\n    var sx = pixelRatio / resolution;\n    var sy = -sx;\n    var dx2 = -center[0];\n    var dy2 = -center[1];\n  \n    return ol.transform.compose(this.transform_, dx1, dy1, sx, sy, 0, dx2, dy2);\n  };\n  \n  \n  /**\n   * Handle changes in image style state.\n   * @param {ol.events.Event} event Image style change event.\n   * @private\n   */\n  ol.source.ImageVector.prototype.handleImageChange_ = function(event) {\n    this.changed();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.source.ImageVector.prototype.handleSourceChange_ = function() {\n    // setState will trigger a CHANGE event, so we always rely\n    // change events by calling setState.\n    this.setState(this.source_.getState());\n  };\n  \n  \n  /**\n   * @param {ol.Feature} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   * @private\n   */\n  ol.source.ImageVector.prototype.renderFeature_ = function(feature, resolution, pixelRatio, replayGroup) {\n    var styles;\n    var styleFunction = feature.getStyleFunction();\n    if (styleFunction) {\n      styles = styleFunction.call(feature, resolution);\n    } else if (this.styleFunction_) {\n      styles = this.styleFunction_(feature, resolution);\n    }\n    if (!styles) {\n      return false;\n    }\n    var i, ii, loading = false;\n    if (!Array.isArray(styles)) {\n      styles = [styles];\n    }\n    for (i = 0, ii = styles.length; i < ii; ++i) {\n      loading = ol.renderer.vector.renderFeature(\n          replayGroup, feature, styles[i],\n          ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio),\n          this.handleImageChange_, this) || loading;\n    }\n    return loading;\n  };\n  \n  \n  /**\n   * Set the style for features.  This can be a single style object, an array\n   * of styles, or a function that takes a feature and resolution and returns\n   * an array of styles. If it is `undefined` the default style is used. If\n   * it is `null` the layer has no style (a `null` style), so only features\n   * that have their own styles will be rendered in the layer. See\n   * {@link ol.style} for information on the default style.\n   * @param {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined}\n   *     style Layer style.\n   * @api\n   */\n  ol.source.ImageVector.prototype.setStyle = function(style) {\n    this.style_ = style !== undefined ? style : ol.style.Style.defaultFunction;\n    this.styleFunction_ = !style ?\n      undefined : ol.style.Style.createFunction(this.style_);\n    this.changed();\n  };\n  \n  goog.provide('ol.source.WMSServerType');\n  \n  \n  /**\n   * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,\n   *     `'qgis'`. These are servers that have vendor parameters beyond the WMS\n   *     specification that OpenLayers can make use of.\n   * @enum {string}\n   */\n  ol.source.WMSServerType = {\n    CARMENTA_SERVER: 'carmentaserver',\n    GEOSERVER: 'geoserver',\n    MAPSERVER: 'mapserver',\n    QGIS: 'qgis'\n  };\n  \n  // FIXME cannot be shared between maps with different projections\n  \n  goog.provide('ol.source.ImageWMS');\n  \n  goog.require('ol');\n  goog.require('ol.Image');\n  goog.require('ol.asserts');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.reproj');\n  goog.require('ol.source.Image');\n  goog.require('ol.source.WMSServerType');\n  goog.require('ol.string');\n  goog.require('ol.uri');\n  \n  \n  /**\n   * @classdesc\n   * Source for WMS servers providing single, untiled images.\n   *\n   * @constructor\n   * @fires ol.source.Image.Event\n   * @extends {ol.source.Image}\n   * @param {olx.source.ImageWMSOptions=} opt_options Options.\n   * @api\n   */\n  ol.source.ImageWMS = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    ol.source.Image.call(this, {\n      attributions: options.attributions,\n      logo: options.logo,\n      projection: options.projection,\n      resolutions: options.resolutions\n    });\n  \n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n        options.crossOrigin !== undefined ? options.crossOrigin : null;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n  \n    /**\n     * @private\n     * @type {ol.ImageLoadFunctionType}\n     */\n    this.imageLoadFunction_ = options.imageLoadFunction !== undefined ?\n      options.imageLoadFunction : ol.source.Image.defaultImageLoadFunction;\n  \n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.v13_ = true;\n    this.updateV13_();\n  \n    /**\n     * @private\n     * @type {ol.source.WMSServerType|undefined}\n     */\n    this.serverType_ = /** @type {ol.source.WMSServerType|undefined} */ (options.serverType);\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n  \n    /**\n     * @private\n     * @type {ol.Image}\n     */\n    this.image_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.imageSize_ = [0, 0];\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n  \n  };\n  ol.inherits(ol.source.ImageWMS, ol.source.Image);\n  \n  \n  /**\n   * @const\n   * @type {ol.Size}\n   * @private\n   */\n  ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_ = [101, 101];\n  \n  \n  /**\n   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and\n   * projection. Return `undefined` if the GetFeatureInfo URL cannot be\n   * constructed.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {ol.ProjectionLike} projection Projection.\n   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should\n   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified\n   *     in the `LAYERS` parameter will be used. `VERSION` should not be\n   *     specified here.\n   * @return {string|undefined} GetFeatureInfo URL.\n   * @api\n   */\n  ol.source.ImageWMS.prototype.getGetFeatureInfoUrl = function(coordinate, resolution, projection, params) {\n    if (this.url_ === undefined) {\n      return undefined;\n    }\n    var projectionObj = ol.proj.get(projection);\n    var sourceProjectionObj = this.getProjection();\n  \n    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {\n      resolution = ol.reproj.calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);\n      coordinate = ol.proj.transform(coordinate, projectionObj, sourceProjectionObj);\n    }\n  \n    var extent = ol.extent.getForViewAndSize(\n        coordinate, resolution, 0,\n        ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_);\n  \n    var baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': ol.DEFAULT_WMS_VERSION,\n      'REQUEST': 'GetFeatureInfo',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true,\n      'QUERY_LAYERS': this.params_['LAYERS']\n    };\n    ol.obj.assign(baseParams, this.params_, params);\n  \n    var x = Math.floor((coordinate[0] - extent[0]) / resolution);\n    var y = Math.floor((extent[3] - coordinate[1]) / resolution);\n    baseParams[this.v13_ ? 'I' : 'X'] = x;\n    baseParams[this.v13_ ? 'J' : 'Y'] = y;\n  \n    return this.getRequestUrl_(\n        extent, ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_,\n        1, sourceProjectionObj || projectionObj, baseParams);\n  };\n  \n  \n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  ol.source.ImageWMS.prototype.getParams = function() {\n    return this.params_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.ImageWMS.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {\n  \n    if (this.url_ === undefined) {\n      return null;\n    }\n  \n    resolution = this.findNearestResolution(resolution);\n  \n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {\n      pixelRatio = 1;\n    }\n  \n    var imageResolution = resolution / pixelRatio;\n  \n    var center = ol.extent.getCenter(extent);\n    var viewWidth = Math.ceil(ol.extent.getWidth(extent) / imageResolution);\n    var viewHeight = Math.ceil(ol.extent.getHeight(extent) / imageResolution);\n    var viewExtent = ol.extent.getForViewAndSize(center, imageResolution, 0,\n        [viewWidth, viewHeight]);\n    var requestWidth = Math.ceil(this.ratio_ * ol.extent.getWidth(extent) / imageResolution);\n    var requestHeight = Math.ceil(this.ratio_ * ol.extent.getHeight(extent) / imageResolution);\n    var requestExtent = ol.extent.getForViewAndSize(center, imageResolution, 0,\n        [requestWidth, requestHeight]);\n  \n    var image = this.image_;\n    if (image &&\n        this.renderedRevision_ == this.getRevision() &&\n        image.getResolution() == resolution &&\n        image.getPixelRatio() == pixelRatio &&\n        ol.extent.containsExtent(image.getExtent(), viewExtent)) {\n      return image;\n    }\n  \n    var params = {\n      'SERVICE': 'WMS',\n      'VERSION': ol.DEFAULT_WMS_VERSION,\n      'REQUEST': 'GetMap',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true\n    };\n    ol.obj.assign(params, this.params_);\n  \n    this.imageSize_[0] = Math.round(ol.extent.getWidth(requestExtent) / imageResolution);\n    this.imageSize_[1] = Math.round(ol.extent.getHeight(requestExtent) / imageResolution);\n  \n    var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio,\n        projection, params);\n  \n    this.image_ = new ol.Image(requestExtent, resolution, pixelRatio,\n        url, this.crossOrigin_, this.imageLoadFunction_);\n  \n    this.renderedRevision_ = this.getRevision();\n  \n    ol.events.listen(this.image_, ol.events.EventType.CHANGE,\n        this.handleImageChange, this);\n  \n    return this.image_;\n  \n  };\n  \n  \n  /**\n   * Return the image load function of the source.\n   * @return {ol.ImageLoadFunctionType} The image load function.\n   * @api\n   */\n  ol.source.ImageWMS.prototype.getImageLoadFunction = function() {\n    return this.imageLoadFunction_;\n  };\n  \n  \n  /**\n   * @param {ol.Extent} extent Extent.\n   * @param {ol.Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {Object} params Params.\n   * @return {string} Request URL.\n   * @private\n   */\n  ol.source.ImageWMS.prototype.getRequestUrl_ = function(extent, size, pixelRatio, projection, params) {\n  \n    ol.asserts.assert(this.url_ !== undefined, 9); // `url` must be configured or set using `#setUrl()`\n  \n    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();\n  \n    if (!('STYLES' in this.params_)) {\n      params['STYLES'] = '';\n    }\n  \n    if (pixelRatio != 1) {\n      switch (this.serverType_) {\n        case ol.source.WMSServerType.GEOSERVER:\n          var dpi = (90 * pixelRatio + 0.5) | 0;\n          if ('FORMAT_OPTIONS' in params) {\n            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;\n          } else {\n            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;\n          }\n          break;\n        case ol.source.WMSServerType.MAPSERVER:\n          params['MAP_RESOLUTION'] = 90 * pixelRatio;\n          break;\n        case ol.source.WMSServerType.CARMENTA_SERVER:\n        case ol.source.WMSServerType.QGIS:\n          params['DPI'] = 90 * pixelRatio;\n          break;\n        default:\n          ol.asserts.assert(false, 8); // Unknown `serverType` configured\n          break;\n      }\n    }\n  \n    params['WIDTH'] = size[0];\n    params['HEIGHT'] = size[1];\n  \n    var axisOrientation = projection.getAxisOrientation();\n    var bbox;\n    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {\n      bbox = [extent[1], extent[0], extent[3], extent[2]];\n    } else {\n      bbox = extent;\n    }\n    params['BBOX'] = bbox.join(',');\n  \n    return ol.uri.appendParams(/** @type {string} */ (this.url_), params);\n  };\n  \n  \n  /**\n   * Return the URL used for this WMS source.\n   * @return {string|undefined} URL.\n   * @api\n   */\n  ol.source.ImageWMS.prototype.getUrl = function() {\n    return this.url_;\n  };\n  \n  \n  /**\n   * Set the image load function of the source.\n   * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.\n   * @api\n   */\n  ol.source.ImageWMS.prototype.setImageLoadFunction = function(\n      imageLoadFunction) {\n    this.image_ = null;\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  };\n  \n  \n  /**\n   * Set the URL to use for requests.\n   * @param {string|undefined} url URL.\n   * @api\n   */\n  ol.source.ImageWMS.prototype.setUrl = function(url) {\n    if (url != this.url_) {\n      this.url_ = url;\n      this.image_ = null;\n      this.changed();\n    }\n  };\n  \n  \n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  ol.source.ImageWMS.prototype.updateParams = function(params) {\n    ol.obj.assign(this.params_, params);\n    this.updateV13_();\n    this.image_ = null;\n    this.changed();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.source.ImageWMS.prototype.updateV13_ = function() {\n    var version = this.params_['VERSION'] || ol.DEFAULT_WMS_VERSION;\n    this.v13_ = ol.string.compareVersions(version, '1.3') >= 0;\n  };\n  \n  goog.provide('ol.source.OSM');\n  \n  goog.require('ol');\n  goog.require('ol.source.XYZ');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for the OpenStreetMap tile server.\n   *\n   * @constructor\n   * @extends {ol.source.XYZ}\n   * @param {olx.source.OSMOptions=} opt_options Open Street Map options.\n   * @api\n   */\n  ol.source.OSM = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    var attributions;\n    if (options.attributions !== undefined) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ol.source.OSM.ATTRIBUTION];\n    }\n  \n    var crossOrigin = options.crossOrigin !== undefined ?\n      options.crossOrigin : 'anonymous';\n  \n    var url = options.url !== undefined ?\n      options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n  \n    ol.source.XYZ.call(this, {\n      attributions: attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: crossOrigin,\n      opaque: options.opaque !== undefined ? options.opaque : true,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      url: url,\n      wrapX: options.wrapX\n    });\n  \n  };\n  ol.inherits(ol.source.OSM, ol.source.XYZ);\n  \n  \n  /**\n   * The attribution containing a link to the OpenStreetMap Copyright and License\n   * page.\n   * @const\n   * @type {string}\n   * @api\n   */\n  ol.source.OSM.ATTRIBUTION = '&copy; ' +\n        '<a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> ' +\n        'contributors.';\n  \n  \n  /**\n   * @fileoverview\n   * @suppress {accessControls, ambiguousFunctionDecl, checkDebuggerStatement, checkRegExp, checkTypes, checkVars, const, constantProperty, deprecated, duplicate, es5Strict, fileoverviewTags, missingProperties, nonStandardJsDocs, strictModuleDepCheck, suspiciousCode, undefinedNames, undefinedVars, unknownDefines, unusedLocalVariables, uselessCode, visibility}\n   */\n  goog.provide('ol.ext.pixelworks.Processor');\n  \n  /** @typedef {function(*)} */\n  ol.ext.pixelworks.Processor = function() {};\n  \n  (function() {(function (exports) {\n  'use strict';\n  \n  var hasImageData = true;\n  try {\n    new ImageData(10, 10);\n  } catch (_) {\n    hasImageData = false;\n  }\n  var context = document.createElement('canvas').getContext('2d');\n  function newImageData$1(data, width, height) {\n    if (hasImageData) {\n      return new ImageData(data, width, height);\n    } else {\n      var imageData = context.createImageData(width, height);\n      imageData.data.set(data);\n      return imageData;\n    }\n  }\n  var newImageData_1 = newImageData$1;\n  var util = {\n      newImageData: newImageData_1\n  };\n  \n  var newImageData = util.newImageData;\n  function createMinion(operation) {\n    var workerHasImageData = true;\n    try {\n      new ImageData(10, 10);\n    } catch (_) {\n      workerHasImageData = false;\n    }\n    function newWorkerImageData(data, width, height) {\n      if (workerHasImageData) {\n        return new ImageData(data, width, height);\n      } else {\n        return {data: data, width: width, height: height};\n      }\n    }\n    return function(data) {\n      var buffers = data['buffers'];\n      var meta = data['meta'];\n      var imageOps = data['imageOps'];\n      var width = data['width'];\n      var height = data['height'];\n      var numBuffers = buffers.length;\n      var numBytes = buffers[0].byteLength;\n      var output, b;\n      if (imageOps) {\n        var images = new Array(numBuffers);\n        for (b = 0; b < numBuffers; ++b) {\n          images[b] = newWorkerImageData(\n              new Uint8ClampedArray(buffers[b]), width, height);\n        }\n        output = operation(images, meta).data;\n      } else {\n        output = new Uint8ClampedArray(numBytes);\n        var arrays = new Array(numBuffers);\n        var pixels = new Array(numBuffers);\n        for (b = 0; b < numBuffers; ++b) {\n          arrays[b] = new Uint8ClampedArray(buffers[b]);\n          pixels[b] = [0, 0, 0, 0];\n        }\n        for (var i = 0; i < numBytes; i += 4) {\n          for (var j = 0; j < numBuffers; ++j) {\n            var array = arrays[j];\n            pixels[j][0] = array[i];\n            pixels[j][1] = array[i + 1];\n            pixels[j][2] = array[i + 2];\n            pixels[j][3] = array[i + 3];\n          }\n          var pixel = operation(pixels, meta);\n          output[i] = pixel[0];\n          output[i + 1] = pixel[1];\n          output[i + 2] = pixel[2];\n          output[i + 3] = pixel[3];\n        }\n      }\n      return output.buffer;\n    };\n  }\n  function createWorker(config, onMessage) {\n    var lib = Object.keys(config.lib || {}).map(function(name) {\n      return 'var ' + name + ' = ' + config.lib[name].toString() + ';';\n    });\n    var lines = lib.concat([\n      'var __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');',\n      'self.addEventListener(\"message\", function(event) {',\n      '  var buffer = __minion__(event.data);',\n      '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',\n      '});'\n    ]);\n    var blob = new Blob(lines, {type: 'text/javascript'});\n    var source = URL.createObjectURL(blob);\n    var worker = new Worker(source);\n    worker.addEventListener('message', onMessage);\n    return worker;\n  }\n  function createFauxWorker(config, onMessage) {\n    var minion = createMinion(config.operation);\n    return {\n      postMessage: function(data) {\n        setTimeout(function() {\n          onMessage({'data': {'buffer': minion(data), 'meta': data['meta']}});\n        }, 0);\n      }\n    };\n  }\n  function Processor(config) {\n    this._imageOps = !!config.imageOps;\n    var threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this._imageOps) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n    var workers = [];\n    if (threads) {\n      for (var i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(config, this._onWorkerMessage.bind(this, 0));\n    }\n    this._workers = workers;\n    this._queue = [];\n    this._maxQueueLength = config.queue || Infinity;\n    this._running = 0;\n    this._dataLookup = {};\n    this._job = null;\n  }\n  Processor.prototype.process = function(inputs, meta, callback) {\n    this._enqueue({\n      inputs: inputs,\n      meta: meta,\n      callback: callback\n    });\n    this._dispatch();\n  };\n  Processor.prototype.destroy = function() {\n    for (var key in this) {\n      this[key] = null;\n    }\n    this._destroyed = true;\n  };\n  Processor.prototype._enqueue = function(job) {\n    this._queue.push(job);\n    while (this._queue.length > this._maxQueueLength) {\n      this._queue.shift().callback(null, null);\n    }\n  };\n  Processor.prototype._dispatch = function() {\n    if (this._running === 0 && this._queue.length > 0) {\n      var job = this._job = this._queue.shift();\n      var width = job.inputs[0].width;\n      var height = job.inputs[0].height;\n      var buffers = job.inputs.map(function(input) {\n        return input.data.buffer;\n      });\n      var threads = this._workers.length;\n      this._running = threads;\n      if (threads === 1) {\n        this._workers[0].postMessage({\n          'buffers': buffers,\n          'meta': job.meta,\n          'imageOps': this._imageOps,\n          'width': width,\n          'height': height\n        }, buffers);\n      } else {\n        var length = job.inputs[0].data.length;\n        var segmentLength = 4 * Math.ceil(length / 4 / threads);\n        for (var i = 0; i < threads; ++i) {\n          var offset = i * segmentLength;\n          var slices = [];\n          for (var j = 0, jj = buffers.length; j < jj; ++j) {\n            slices.push(buffers[i].slice(offset, offset + segmentLength));\n          }\n          this._workers[i].postMessage({\n            'buffers': slices,\n            'meta': job.meta,\n            'imageOps': this._imageOps,\n            'width': width,\n            'height': height\n          }, slices);\n        }\n      }\n    }\n  };\n  Processor.prototype._onWorkerMessage = function(index, event) {\n    if (this._destroyed) {\n      return;\n    }\n    this._dataLookup[index] = event.data;\n    --this._running;\n    if (this._running === 0) {\n      this._resolveJob();\n    }\n  };\n  Processor.prototype._resolveJob = function() {\n    var job = this._job;\n    var threads = this._workers.length;\n    var data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);\n      meta = this._dataLookup[0]['meta'];\n    } else {\n      var length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(length);\n      var segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (var i = 0; i < threads; ++i) {\n        var buffer = this._dataLookup[i]['buffer'];\n        var offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this._dataLookup[i]['meta'];\n      }\n    }\n    this._job = null;\n    this._dataLookup = {};\n    job.callback(null,\n        newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);\n    this._dispatch();\n  };\n  var processor = Processor;\n  \n  var Processor_1 = processor;\n  var lib = {\n      Processor: Processor_1\n  };\n  \n  exports['default'] = lib;\n  exports.Processor = Processor_1;\n  \n  }((this.pixelworks = this.pixelworks || {})));}).call(ol.ext);\n  \n  goog.provide('ol.source.RasterOperationType');\n  \n  /**\n   * Raster operation type. Supported values are `'pixel'` and `'image'`.\n   * @enum {string}\n   */\n  ol.source.RasterOperationType = {\n    PIXEL: 'pixel',\n    IMAGE: 'image'\n  };\n  \n  goog.provide('ol.source.Raster');\n  \n  goog.require('ol');\n  goog.require('ol.ImageCanvas');\n  goog.require('ol.TileQueue');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.EventType');\n  goog.require('ol.ext.pixelworks.Processor');\n  goog.require('ol.extent');\n  goog.require('ol.layer.Image');\n  goog.require('ol.layer.Tile');\n  goog.require('ol.obj');\n  goog.require('ol.renderer.canvas.ImageLayer');\n  goog.require('ol.renderer.canvas.TileLayer');\n  goog.require('ol.source.Image');\n  goog.require('ol.source.RasterOperationType');\n  goog.require('ol.source.State');\n  goog.require('ol.source.Tile');\n  goog.require('ol.transform');\n  \n  \n  /**\n   * @classdesc\n   * A source that transforms data from any number of input sources using an\n   * {@link ol.RasterOperation} function to transform input pixel values into\n   * output pixel values.\n   *\n   * @constructor\n   * @extends {ol.source.Image}\n   * @fires ol.source.Raster.Event\n   * @param {olx.source.RasterOptions} options Options.\n   * @api\n   */\n  ol.source.Raster = function(options) {\n  \n    /**\n     * @private\n     * @type {*}\n     */\n    this.worker_ = null;\n  \n    /**\n     * @private\n     * @type {ol.source.RasterOperationType}\n     */\n    this.operationType_ = options.operationType !== undefined ?\n      options.operationType : ol.source.RasterOperationType.PIXEL;\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n  \n    /**\n     * @private\n     * @type {Array.<ol.renderer.canvas.Layer>}\n     */\n    this.renderers_ = ol.source.Raster.createRenderers_(options.sources);\n  \n    for (var r = 0, rr = this.renderers_.length; r < rr; ++r) {\n      ol.events.listen(this.renderers_[r], ol.events.EventType.CHANGE,\n          this.changed, this);\n    }\n  \n    /**\n     * @private\n     * @type {ol.TileQueue}\n     */\n    this.tileQueue_ = new ol.TileQueue(\n        function() {\n          return 1;\n        },\n        this.changed.bind(this));\n  \n    var layerStatesArray = ol.source.Raster.getLayerStatesArray_(this.renderers_);\n    var layerStates = {};\n    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      layerStates[ol.getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\n    }\n  \n    /**\n     * The most recently requested frame state.\n     * @type {olx.FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n  \n    /**\n     * The most recently rendered image canvas.\n     * @type {ol.ImageCanvas}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n  \n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     */\n    this.renderedRevision_;\n  \n    /**\n     * @private\n     * @type {olx.FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: ol.transform.create(),\n      extent: null,\n      focus: null,\n      index: 0,\n      layerStates: layerStates,\n      layerStatesArray: layerStatesArray,\n      logos: {},\n      pixelRatio: 1,\n      pixelToCoordinateTransform: ol.transform.create(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      skippedFeatureUids: {},\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {olx.ViewState} */ ({\n        rotation: 0\n      }),\n      viewHints: [],\n      wantedTiles: {}\n    };\n  \n    ol.source.Image.call(this, {});\n  \n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  \n  };\n  ol.inherits(ol.source.Raster, ol.source.Image);\n  \n  \n  /**\n   * Set the operation.\n   * @param {ol.RasterOperation} operation New operation.\n   * @param {Object=} opt_lib Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  ol.source.Raster.prototype.setOperation = function(operation, opt_lib) {\n    this.worker_ = new ol.ext.pixelworks.Processor({\n      operation: operation,\n      imageOps: this.operationType_ === ol.source.RasterOperationType.IMAGE,\n      queue: 1,\n      lib: opt_lib,\n      threads: this.threads_\n    });\n    this.changed();\n  };\n  \n  \n  /**\n   * Update the stored frame state.\n   * @param {ol.Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {ol.proj.Projection} projection The view projection.\n   * @return {olx.FrameState} The updated frame state.\n   * @private\n   */\n  ol.source.Raster.prototype.updateFrameState_ = function(extent, resolution, projection) {\n  \n    var frameState = /** @type {olx.FrameState} */ (\n      ol.obj.assign({}, this.frameState_));\n  \n    frameState.viewState = /** @type {olx.ViewState} */ (\n      ol.obj.assign({}, frameState.viewState));\n  \n    var center = ol.extent.getCenter(extent);\n  \n    frameState.extent = extent.slice();\n    frameState.focus = center;\n    frameState.size[0] = Math.round(ol.extent.getWidth(extent) / resolution);\n    frameState.size[1] = Math.round(ol.extent.getHeight(extent) / resolution);\n    frameState.time = Date.now();\n    frameState.animate = false;\n  \n    var viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  };\n  \n  \n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  ol.source.Raster.prototype.allSourcesReady_ = function() {\n    var ready = true;\n    var source;\n    for (var i = 0, ii = this.renderers_.length; i < ii; ++i) {\n      source = this.renderers_[i].getLayer().getSource();\n      if (source.getState() !== ol.source.State.READY) {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.Raster.prototype.getImage = function(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n  \n    var frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n  \n    // check if we can't reuse the existing ol.ImageCanvas\n    if (this.renderedImageCanvas_) {\n      var renderedResolution = this.renderedImageCanvas_.getResolution();\n      var renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (resolution !== renderedResolution || !ol.extent.equals(extent, renderedExtent)) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n  \n    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {\n      this.processSources_();\n    }\n  \n    frameState.tileQueue.loadMoreTiles(16, 16);\n  \n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n  \n    return this.renderedImageCanvas_;\n  };\n  \n  \n  /**\n   * Start processing source data.\n   * @private\n   */\n  ol.source.Raster.prototype.processSources_ = function() {\n    var frameState = this.requestedFrameState_;\n    var len = this.renderers_.length;\n    var imageDatas = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      var imageData = ol.source.Raster.getImageData_(\n          this.renderers_[i], frameState, frameState.layerStatesArray[i]);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n  \n    var data = {};\n    this.dispatchEvent(new ol.source.Raster.Event(\n        ol.source.Raster.EventType_.BEFOREOPERATIONS, frameState, data));\n    this.worker_.process(imageDatas, data,\n        this.onWorkerComplete_.bind(this, frameState));\n  };\n  \n  \n  /**\n   * Called when pixel processing is complete.\n   * @param {olx.FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object} data The user data.\n   * @private\n   */\n  ol.source.Raster.prototype.onWorkerComplete_ = function(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n  \n    // do nothing if extent or resolution changed\n    var extent = frameState.extent;\n    var resolution = frameState.viewState.resolution;\n    if (resolution !== this.requestedFrameState_.viewState.resolution ||\n        !ol.extent.equals(extent, this.requestedFrameState_.extent)) {\n      return;\n    }\n  \n    var context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      var width = Math.round(ol.extent.getWidth(extent) / resolution);\n      var height = Math.round(ol.extent.getHeight(extent) / resolution);\n      context = ol.dom.createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ol.ImageCanvas(extent, resolution, 1, context.canvas);\n    }\n    context.putImageData(output, 0, 0);\n  \n    this.changed();\n    this.renderedRevision_ = this.getRevision();\n  \n    this.dispatchEvent(new ol.source.Raster.Event(\n        ol.source.Raster.EventType_.AFTEROPERATIONS, frameState, data));\n  };\n  \n  \n  /**\n   * Get image data from a renderer.\n   * @param {ol.renderer.canvas.Layer} renderer Layer renderer.\n   * @param {olx.FrameState} frameState The frame state.\n   * @param {ol.LayerState} layerState The layer state.\n   * @return {ImageData} The image data.\n   * @private\n   */\n  ol.source.Raster.getImageData_ = function(renderer, frameState, layerState) {\n    if (!renderer.prepareFrame(frameState, layerState)) {\n      return null;\n    }\n    var width = frameState.size[0];\n    var height = frameState.size[1];\n    if (!ol.source.Raster.context_) {\n      ol.source.Raster.context_ = ol.dom.createCanvasContext2D(width, height);\n    } else {\n      var canvas = ol.source.Raster.context_.canvas;\n      if (canvas.width !== width || canvas.height !== height) {\n        ol.source.Raster.context_ = ol.dom.createCanvasContext2D(width, height);\n      } else {\n        ol.source.Raster.context_.clearRect(0, 0, width, height);\n      }\n    }\n    renderer.composeFrame(frameState, layerState, ol.source.Raster.context_);\n    return ol.source.Raster.context_.getImageData(0, 0, width, height);\n  };\n  \n  \n  /**\n   * A reusable canvas context.\n   * @type {CanvasRenderingContext2D}\n   * @private\n   */\n  ol.source.Raster.context_ = null;\n  \n  \n  /**\n   * Get a list of layer states from a list of renderers.\n   * @param {Array.<ol.renderer.canvas.Layer>} renderers Layer renderers.\n   * @return {Array.<ol.LayerState>} The layer states.\n   * @private\n   */\n  ol.source.Raster.getLayerStatesArray_ = function(renderers) {\n    return renderers.map(function(renderer) {\n      return renderer.getLayer().getLayerState();\n    });\n  };\n  \n  \n  /**\n   * Create renderers for all sources.\n   * @param {Array.<ol.source.Source>} sources The sources.\n   * @return {Array.<ol.renderer.canvas.Layer>} Array of layer renderers.\n   * @private\n   */\n  ol.source.Raster.createRenderers_ = function(sources) {\n    var len = sources.length;\n    var renderers = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      renderers[i] = ol.source.Raster.createRenderer_(sources[i]);\n    }\n    return renderers;\n  };\n  \n  \n  /**\n   * Create a renderer for the provided source.\n   * @param {ol.source.Source} source The source.\n   * @return {ol.renderer.canvas.Layer} The renderer.\n   * @private\n   */\n  ol.source.Raster.createRenderer_ = function(source) {\n    var renderer = null;\n    if (source instanceof ol.source.Tile) {\n      renderer = ol.source.Raster.createTileRenderer_(source);\n    } else if (source instanceof ol.source.Image) {\n      renderer = ol.source.Raster.createImageRenderer_(source);\n    }\n    return renderer;\n  };\n  \n  \n  /**\n   * Create an image renderer for the provided source.\n   * @param {ol.source.Image} source The source.\n   * @return {ol.renderer.canvas.Layer} The renderer.\n   * @private\n   */\n  ol.source.Raster.createImageRenderer_ = function(source) {\n    var layer = new ol.layer.Image({source: source});\n    return new ol.renderer.canvas.ImageLayer(layer);\n  };\n  \n  \n  /**\n   * Create a tile renderer for the provided source.\n   * @param {ol.source.Tile} source The source.\n   * @return {ol.renderer.canvas.Layer} The renderer.\n   * @private\n   */\n  ol.source.Raster.createTileRenderer_ = function(source) {\n    var layer = new ol.layer.Tile({source: source});\n    return new ol.renderer.canvas.TileLayer(layer);\n  };\n  \n  \n  /**\n   * @classdesc\n   * Events emitted by {@link ol.source.Raster} instances are instances of this\n   * type.\n   *\n   * @constructor\n   * @extends {ol.events.Event}\n   * @implements {oli.source.RasterEvent}\n   * @param {string} type Type.\n   * @param {olx.FrameState} frameState The frame state.\n   * @param {Object} data An object made available to operations.\n   */\n  ol.source.Raster.Event = function(type, frameState, data) {\n    ol.events.Event.call(this, type);\n  \n    /**\n     * The raster extent.\n     * @type {ol.Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n  \n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n  \n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  \n  };\n  ol.inherits(ol.source.Raster.Event, ol.events.Event);\n  \n  \n  /**\n   * @override\n   */\n  ol.source.Raster.prototype.getImageInternal = function() {\n    return null; // not implemented\n  };\n  \n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.source.Raster.EventType_ = {\n    /**\n     * Triggered before operations are run.\n     * @event ol.source.Raster.Event#beforeoperations\n     * @api\n     */\n    BEFOREOPERATIONS: 'beforeoperations',\n  \n    /**\n     * Triggered after operations are run.\n     * @event ol.source.Raster.Event#afteroperations\n     * @api\n     */\n    AFTEROPERATIONS: 'afteroperations'\n  };\n  \n  goog.provide('ol.source.Stamen');\n  \n  goog.require('ol');\n  goog.require('ol.source.OSM');\n  goog.require('ol.source.XYZ');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for the Stamen tile server.\n   *\n   * @constructor\n   * @extends {ol.source.XYZ}\n   * @param {olx.source.StamenOptions} options Stamen options.\n   * @api\n   */\n  ol.source.Stamen = function(options) {\n    var i = options.layer.indexOf('-');\n    var provider = i == -1 ? options.layer : options.layer.slice(0, i);\n    var providerConfig = ol.source.Stamen.ProviderConfig[provider];\n  \n    var layerConfig = ol.source.Stamen.LayerConfig[options.layer];\n  \n    var url = options.url !== undefined ? options.url :\n      'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' + options.layer +\n        '/{z}/{x}/{y}.' + layerConfig.extension;\n  \n    ol.source.XYZ.call(this, {\n      attributions: ol.source.Stamen.ATTRIBUTIONS,\n      cacheSize: options.cacheSize,\n      crossOrigin: 'anonymous',\n      maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,\n      minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,\n      opaque: layerConfig.opaque,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      url: url,\n      wrapX: options.wrapX\n    });\n  };\n  ol.inherits(ol.source.Stamen, ol.source.XYZ);\n  \n  \n  /**\n   * @const\n   * @type {Array.<string>}\n   */\n  ol.source.Stamen.ATTRIBUTIONS = [\n    'Map tiles by <a href=\"https://stamen.com/\">Stamen Design</a>, ' +\n          'under <a href=\"https://creativecommons.org/licenses/by/3.0/\">CC BY' +\n          ' 3.0</a>.',\n    ol.source.OSM.ATTRIBUTION\n  ];\n  \n  /**\n   * @type {Object.<string, {extension: string, opaque: boolean}>}\n   */\n  ol.source.Stamen.LayerConfig = {\n    'terrain': {\n      extension: 'jpg',\n      opaque: true\n    },\n    'terrain-background': {\n      extension: 'jpg',\n      opaque: true\n    },\n    'terrain-labels': {\n      extension: 'png',\n      opaque: false\n    },\n    'terrain-lines': {\n      extension: 'png',\n      opaque: false\n    },\n    'toner-background': {\n      extension: 'png',\n      opaque: true\n    },\n    'toner': {\n      extension: 'png',\n      opaque: true\n    },\n    'toner-hybrid': {\n      extension: 'png',\n      opaque: false\n    },\n    'toner-labels': {\n      extension: 'png',\n      opaque: false\n    },\n    'toner-lines': {\n      extension: 'png',\n      opaque: false\n    },\n    'toner-lite': {\n      extension: 'png',\n      opaque: true\n    },\n    'watercolor': {\n      extension: 'jpg',\n      opaque: true\n    }\n  };\n  \n  /**\n   * @type {Object.<string, {minZoom: number, maxZoom: number}>}\n   */\n  ol.source.Stamen.ProviderConfig = {\n    'terrain': {\n      minZoom: 4,\n      maxZoom: 18\n    },\n    'toner': {\n      minZoom: 0,\n      maxZoom: 20\n    },\n    'watercolor': {\n      minZoom: 1,\n      maxZoom: 16\n    }\n  };\n  \n  goog.provide('ol.source.TileArcGISRest');\n  \n  goog.require('ol');\n  goog.require('ol.extent');\n  goog.require('ol.math');\n  goog.require('ol.obj');\n  goog.require('ol.size');\n  goog.require('ol.source.TileImage');\n  goog.require('ol.tilecoord');\n  goog.require('ol.uri');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for tile data from ArcGIS Rest services. Map and Image\n   * Services are supported.\n   *\n   * For cached ArcGIS services, better performance is available using the\n   * {@link ol.source.XYZ} data source.\n   *\n   * @constructor\n   * @extends {ol.source.TileImage}\n   * @param {olx.source.TileArcGISRestOptions=} opt_options Tile ArcGIS Rest\n   *     options.\n   * @api\n   */\n  ol.source.TileArcGISRest = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    ol.source.TileImage.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      logo: options.logo,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition\n    });\n  \n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.tmpExtent_ = ol.extent.createEmpty();\n  \n    this.setKey(this.getKeyForParams_());\n  };\n  ol.inherits(ol.source.TileArcGISRest, ol.source.TileImage);\n  \n  \n  /**\n   * @private\n   * @return {string} The key for the current params.\n   */\n  ol.source.TileArcGISRest.prototype.getKeyForParams_ = function() {\n    var i = 0;\n    var res = [];\n    for (var key in this.params_) {\n      res[i++] = key + '-' + this.params_[key];\n    }\n    return res.join('/');\n  };\n  \n  \n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  ol.source.TileArcGISRest.prototype.getParams = function() {\n    return this.params_;\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.Size} tileSize Tile size.\n   * @param {ol.Extent} tileExtent Tile extent.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {Object} params Params.\n   * @return {string|undefined} Request URL.\n   * @private\n   */\n  ol.source.TileArcGISRest.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent,\n      pixelRatio, projection, params) {\n  \n    var urls = this.urls;\n    if (!urls) {\n      return undefined;\n    }\n  \n    // ArcGIS Server only wants the numeric portion of the projection ID.\n    var srid = projection.getCode().split(':').pop();\n  \n    params['SIZE'] = tileSize[0] + ',' + tileSize[1];\n    params['BBOX'] = tileExtent.join(',');\n    params['BBOXSR'] = srid;\n    params['IMAGESR'] = srid;\n    params['DPI'] = Math.round(\n        params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio\n    );\n  \n    var url;\n    if (urls.length == 1) {\n      url = urls[0];\n    } else {\n      var index = ol.math.modulo(ol.tilecoord.hash(tileCoord), urls.length);\n      url = urls[index];\n    }\n  \n    var modifiedUrl = url\n        .replace(/MapServer\\/?$/, 'MapServer/export')\n        .replace(/ImageServer\\/?$/, 'ImageServer/exportImage');\n    return ol.uri.appendParams(modifiedUrl, params);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileArcGISRest.prototype.getTilePixelRatio = function(pixelRatio) {\n    return /** @type {number} */ (pixelRatio);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileArcGISRest.prototype.fixedTileUrlFunction = function(tileCoord, pixelRatio, projection) {\n  \n    var tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projection);\n    }\n  \n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n  \n    var tileExtent = tileGrid.getTileCoordExtent(\n        tileCoord, this.tmpExtent_);\n    var tileSize = ol.size.toSize(\n        tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n  \n    if (pixelRatio != 1) {\n      tileSize = ol.size.scale(tileSize, pixelRatio, this.tmpSize);\n    }\n  \n    // Apply default params and override with user specified values.\n    var baseParams = {\n      'F': 'image',\n      'FORMAT': 'PNG32',\n      'TRANSPARENT': true\n    };\n    ol.obj.assign(baseParams, this.params_);\n  \n    return this.getRequestUrl_(tileCoord, tileSize, tileExtent,\n        pixelRatio, projection, baseParams);\n  };\n  \n  \n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  ol.source.TileArcGISRest.prototype.updateParams = function(params) {\n    ol.obj.assign(this.params_, params);\n    this.setKey(this.getKeyForParams_());\n  };\n  \n  goog.provide('ol.source.TileDebug');\n  \n  goog.require('ol');\n  goog.require('ol.Tile');\n  goog.require('ol.TileState');\n  goog.require('ol.dom');\n  goog.require('ol.size');\n  goog.require('ol.source.Tile');\n  goog.require('ol.tilecoord');\n  \n  \n  /**\n   * @classdesc\n   * A pseudo tile source, which does not fetch tiles from a server, but renders\n   * a grid outline for the tile grid/projection along with the coordinates for\n   * each tile. See examples/canvas-tiles for an example.\n   *\n   * Uses Canvas context2d, so requires Canvas support.\n   *\n   * @constructor\n   * @extends {ol.source.Tile}\n   * @param {olx.source.TileDebugOptions} options Debug tile options.\n   * @api\n   */\n  ol.source.TileDebug = function(options) {\n  \n    ol.source.Tile.call(this, {\n      opaque: false,\n      projection: options.projection,\n      tileGrid: options.tileGrid,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true\n    });\n  \n  };\n  ol.inherits(ol.source.TileDebug, ol.source.Tile);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileDebug.prototype.getTile = function(z, x, y) {\n    var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return /** @type {!ol.source.TileDebug.Tile_} */ (this.tileCache.get(tileCoordKey));\n    } else {\n      var tileSize = ol.size.toSize(this.tileGrid.getTileSize(z));\n      var tileCoord = [z, x, y];\n      var textTileCoord = this.getTileCoordForTileUrlFunction(tileCoord);\n      var text = !textTileCoord ? '' :\n        this.getTileCoordForTileUrlFunction(textTileCoord).toString();\n      var tile = new ol.source.TileDebug.Tile_(tileCoord, tileSize, text);\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  };\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.Tile}\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.Size} tileSize Tile size.\n   * @param {string} text Text.\n   * @private\n   */\n  ol.source.TileDebug.Tile_ = function(tileCoord, tileSize, text) {\n  \n    ol.Tile.call(this, tileCoord, ol.TileState.LOADED);\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.tileSize_ = tileSize;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.text_ = text;\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n  \n  };\n  ol.inherits(ol.source.TileDebug.Tile_, ol.Tile);\n  \n  \n  /**\n   * Get the image element for this tile.\n   * @return {HTMLCanvasElement} Image.\n   */\n  ol.source.TileDebug.Tile_.prototype.getImage = function() {\n    if (this.canvas_) {\n      return this.canvas_;\n    } else {\n      var tileSize = this.tileSize_;\n      var context = ol.dom.createCanvasContext2D(tileSize[0], tileSize[1]);\n  \n      context.strokeStyle = 'black';\n      context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);\n  \n      context.fillStyle = 'black';\n      context.textAlign = 'center';\n      context.textBaseline = 'middle';\n      context.font = '24px sans-serif';\n      context.fillText(this.text_, tileSize[0] / 2, tileSize[1] / 2);\n  \n      this.canvas_ = context.canvas;\n      return context.canvas;\n    }\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.source.TileDebug.Tile_.prototype.load = function() {};\n  \n  // FIXME check order of async callbacks\n  \n  /**\n   * @see http://mapbox.com/developers/api/\n   */\n  \n  goog.provide('ol.source.TileJSON');\n  \n  goog.require('ol');\n  goog.require('ol.TileUrlFunction');\n  goog.require('ol.asserts');\n  goog.require('ol.extent');\n  goog.require('ol.net');\n  goog.require('ol.proj');\n  goog.require('ol.source.State');\n  goog.require('ol.source.TileImage');\n  goog.require('ol.tilegrid');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for tile data in TileJSON format.\n   *\n   * @constructor\n   * @extends {ol.source.TileImage}\n   * @param {olx.source.TileJSONOptions} options TileJSON options.\n   * @api\n   */\n  ol.source.TileJSON = function(options) {\n  \n    /**\n     * @type {TileJSON}\n     * @private\n     */\n    this.tileJSON_ = null;\n  \n    ol.source.TileImage.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      projection: ol.proj.get('EPSG:3857'),\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: ol.source.State.LOADING,\n      tileLoadFunction: options.tileLoadFunction,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition\n    });\n  \n    if (options.url) {\n      if (options.jsonp) {\n        ol.net.jsonp(options.url, this.handleTileJSONResponse.bind(this),\n            this.handleTileJSONError.bind(this));\n      } else {\n        var client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      ol.asserts.assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n  \n  };\n  ol.inherits(ol.source.TileJSON, ol.source.TileImage);\n  \n  \n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  ol.source.TileJSON.prototype.onXHRLoad_ = function(event) {\n    var client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response;\n      try {\n        response = /** @type {TileJSON} */(JSON.parse(client.responseText));\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  ol.source.TileJSON.prototype.onXHRError_ = function(event) {\n    this.handleTileJSONError();\n  };\n  \n  \n  /**\n   * @return {TileJSON} The tilejson object.\n   * @api\n   */\n  ol.source.TileJSON.prototype.getTileJSON = function() {\n    return this.tileJSON_;\n  };\n  \n  \n  /**\n   * @protected\n   * @param {TileJSON} tileJSON Tile JSON.\n   */\n  ol.source.TileJSON.prototype.handleTileJSONResponse = function(tileJSON) {\n  \n    var epsg4326Projection = ol.proj.get('EPSG:4326');\n  \n    var sourceProjection = this.getProjection();\n    var extent;\n    if (tileJSON.bounds !== undefined) {\n      var transform = ol.proj.getTransformFromProjections(\n          epsg4326Projection, sourceProjection);\n      extent = ol.extent.applyTransform(tileJSON.bounds, transform);\n    }\n  \n    var minZoom = tileJSON.minzoom || 0;\n    var maxZoom = tileJSON.maxzoom || 22;\n    var tileGrid = ol.tilegrid.createXYZ({\n      extent: ol.tilegrid.extentFromProjection(sourceProjection),\n      maxZoom: maxZoom,\n      minZoom: minZoom\n    });\n    this.tileGrid = tileGrid;\n  \n    this.tileUrlFunction =\n        ol.TileUrlFunction.createFromTemplates(tileJSON.tiles, tileGrid);\n  \n    if (tileJSON.attribution !== undefined && !this.getAttributions2()) {\n      var attributionExtent = extent !== undefined ?\n        extent : epsg4326Projection.getExtent();\n  \n      this.setAttributions(function(frameState) {\n        if (ol.extent.intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON.attribution];\n        }\n        return null;\n      });\n  \n    }\n    this.tileJSON_ = tileJSON;\n    this.setState(ol.source.State.READY);\n  \n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.source.TileJSON.prototype.handleTileJSONError = function() {\n    this.setState(ol.source.State.ERROR);\n  };\n  \n  goog.provide('ol.source.TileUTFGrid');\n  \n  goog.require('ol');\n  goog.require('ol.Tile');\n  goog.require('ol.TileState');\n  goog.require('ol.TileUrlFunction');\n  goog.require('ol.asserts');\n  goog.require('ol.events');\n  goog.require('ol.events.EventType');\n  goog.require('ol.extent');\n  goog.require('ol.net');\n  goog.require('ol.proj');\n  goog.require('ol.source.State');\n  goog.require('ol.source.Tile');\n  goog.require('ol.tilecoord');\n  goog.require('ol.tilegrid');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for UTFGrid interaction data loaded from TileJSON format.\n   *\n   * @constructor\n   * @extends {ol.source.Tile}\n   * @param {olx.source.TileUTFGridOptions} options Source options.\n   * @api\n   */\n  ol.source.TileUTFGrid = function(options) {\n    ol.source.Tile.call(this, {\n      projection: ol.proj.get('EPSG:3857'),\n      state: ol.source.State.LOADING\n    });\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = options.preemptive !== undefined ?\n      options.preemptive : true;\n  \n    /**\n     * @private\n     * @type {!ol.TileUrlFunctionType}\n     */\n    this.tileUrlFunction_ = ol.TileUrlFunction.nullTileUrlFunction;\n  \n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n  \n    if (options.url) {\n      if (this.jsonp_) {\n        ol.net.jsonp(options.url, this.handleTileJSONResponse.bind(this),\n            this.handleTileJSONError.bind(this));\n      } else {\n        var client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      ol.asserts.assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n  };\n  ol.inherits(ol.source.TileUTFGrid, ol.source.Tile);\n  \n  \n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  ol.source.TileUTFGrid.prototype.onXHRLoad_ = function(event) {\n    var client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response;\n      try {\n        response = /** @type {TileJSON} */(JSON.parse(client.responseText));\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  ol.source.TileUTFGrid.prototype.onXHRError_ = function(event) {\n    this.handleTileJSONError();\n  };\n  \n  \n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  ol.source.TileUTFGrid.prototype.getTemplate = function() {\n    return this.template_;\n  };\n  \n  \n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(this: T, *)} callback Callback.\n   * @param {T=} opt_this The object to use as `this` in the callback.\n   * @param {boolean=} opt_request If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @template T\n   * @api\n   */\n  ol.source.TileUTFGrid.prototype.forDataAtCoordinateAndResolution = function(\n      coordinate, resolution, callback, opt_this, opt_request) {\n    if (this.tileGrid) {\n      var tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(\n          coordinate, resolution);\n      var tile = /** @type {!ol.source.TileUTFGrid.Tile_} */(this.getTile(\n          tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection()));\n      tile.forDataAtCoordinate(coordinate, callback, opt_this, opt_request);\n    } else {\n      if (opt_request === true) {\n        setTimeout(function() {\n          callback.call(opt_this, null);\n        }, 0);\n      } else {\n        callback.call(opt_this, null);\n      }\n    }\n  };\n  \n  \n  /**\n   * @protected\n   */\n  ol.source.TileUTFGrid.prototype.handleTileJSONError = function() {\n    this.setState(ol.source.State.ERROR);\n  };\n  \n  \n  /**\n   * TODO: very similar to ol.source.TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {TileJSON} tileJSON Tile JSON.\n   */\n  ol.source.TileUTFGrid.prototype.handleTileJSONResponse = function(tileJSON) {\n  \n    var epsg4326Projection = ol.proj.get('EPSG:4326');\n  \n    var sourceProjection = this.getProjection();\n    var extent;\n    if (tileJSON.bounds !== undefined) {\n      var transform = ol.proj.getTransformFromProjections(\n          epsg4326Projection, sourceProjection);\n      extent = ol.extent.applyTransform(tileJSON.bounds, transform);\n    }\n  \n    var minZoom = tileJSON.minzoom || 0;\n    var maxZoom = tileJSON.maxzoom || 22;\n    var tileGrid = ol.tilegrid.createXYZ({\n      extent: ol.tilegrid.extentFromProjection(sourceProjection),\n      maxZoom: maxZoom,\n      minZoom: minZoom\n    });\n    this.tileGrid = tileGrid;\n  \n    this.template_ = tileJSON.template;\n  \n    var grids = tileJSON.grids;\n    if (!grids) {\n      this.setState(ol.source.State.ERROR);\n      return;\n    }\n  \n    this.tileUrlFunction_ =\n        ol.TileUrlFunction.createFromTemplates(grids, tileGrid);\n  \n    if (tileJSON.attribution !== undefined) {\n      var attributionExtent = extent !== undefined ?\n        extent : epsg4326Projection.getExtent();\n  \n      this.setAttributions(function(frameState) {\n        if (ol.extent.intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON.attribution];\n        }\n        return null;\n      });\n    }\n  \n    this.setState(ol.source.State.READY);\n  \n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileUTFGrid.prototype.getTile = function(z, x, y, pixelRatio, projection) {\n    var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return /** @type {!ol.Tile} */ (this.tileCache.get(tileCoordKey));\n    } else {\n      var tileCoord = [z, x, y];\n      var urlTileCoord =\n          this.getTileCoordForTileUrlFunction(tileCoord, projection);\n      var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n      var tile = new ol.source.TileUTFGrid.Tile_(\n          tileCoord,\n          tileUrl !== undefined ? ol.TileState.IDLE : ol.TileState.EMPTY,\n          tileUrl !== undefined ? tileUrl : '',\n          this.tileGrid.getTileCoordExtent(tileCoord),\n          this.preemptive_,\n          this.jsonp_);\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileUTFGrid.prototype.useTile = function(z, x, y) {\n    var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  };\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.Tile}\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.TileState} state State.\n   * @param {string} src Image source URI.\n   * @param {ol.Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   * @private\n   */\n  ol.source.TileUTFGrid.Tile_ = function(tileCoord, state, src, extent, preemptive, jsonp) {\n  \n    ol.Tile.call(this, tileCoord, state);\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.extent_ = extent;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n  \n    /**\n     * @private\n     * @type {Array.<string>}\n     */\n    this.grid_ = null;\n  \n    /**\n     * @private\n     * @type {Array.<string>}\n     */\n    this.keys_ = null;\n  \n    /**\n     * @private\n     * @type {Object.<string, Object>|undefined}\n     */\n    this.data_ = null;\n  \n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n  \n  };\n  ol.inherits(ol.source.TileUTFGrid.Tile_, ol.Tile);\n  \n  \n  /**\n   * Get the image element for this tile.\n   * @return {Image} Image.\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.getImage = function() {\n    return null;\n  };\n  \n  \n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.getData = function(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    var xRelative = (coordinate[0] - this.extent_[0]) /\n        (this.extent_[2] - this.extent_[0]);\n    var yRelative = (coordinate[1] - this.extent_[1]) /\n        (this.extent_[3] - this.extent_[1]);\n  \n    var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n  \n    if (typeof row !== 'string') {\n      return null;\n    }\n  \n    var code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n  \n    var data = null;\n    if (code in this.keys_) {\n      var id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  };\n  \n  \n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {function(this: T, *)} callback Callback.\n   * @param {T=} opt_this The object to use as `this` in the callback.\n   * @param {boolean=} opt_request If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @template T\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.forDataAtCoordinate = function(coordinate, callback, opt_this, opt_request) {\n    if (this.state == ol.TileState.IDLE && opt_request === true) {\n      ol.events.listenOnce(this, ol.events.EventType.CHANGE, function(e) {\n        callback.call(opt_this, this.getData(coordinate));\n      }, this);\n      this.loadInternal_();\n    } else {\n      if (opt_request === true) {\n        setTimeout(function() {\n          callback.call(opt_this, this.getData(coordinate));\n        }.bind(this), 0);\n      } else {\n        callback.call(opt_this, this.getData(coordinate));\n      }\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.getKey = function() {\n    return this.src_;\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.handleError_ = function() {\n    this.state = ol.TileState.ERROR;\n    this.changed();\n  };\n  \n  \n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.handleLoad_ = function(json) {\n    this.grid_ = json.grid;\n    this.keys_ = json.keys;\n    this.data_ = json.data;\n  \n    this.state = ol.TileState.EMPTY;\n    this.changed();\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.loadInternal_ = function() {\n    if (this.state == ol.TileState.IDLE) {\n      this.state = ol.TileState.LOADING;\n      if (this.jsonp_) {\n        ol.net.jsonp(this.src_, this.handleLoad_.bind(this),\n            this.handleError_.bind(this));\n      } else {\n        var client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.onXHRLoad_ = function(event) {\n    var client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response;\n      try {\n        response = /** @type {!UTFGridJSON} */(JSON.parse(client.responseText));\n      } catch (err) {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  };\n  \n  \n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.onXHRError_ = function(event) {\n    this.handleError_();\n  };\n  \n  \n  /**\n   * @override\n   */\n  ol.source.TileUTFGrid.Tile_.prototype.load = function() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    }\n  };\n  \n  // FIXME add minZoom support\n  // FIXME add date line wrap (tile coord transform)\n  // FIXME cannot be shared between maps with different projections\n  \n  goog.provide('ol.source.TileWMS');\n  \n  goog.require('ol');\n  goog.require('ol.asserts');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.math');\n  goog.require('ol.proj');\n  goog.require('ol.reproj');\n  goog.require('ol.size');\n  goog.require('ol.source.TileImage');\n  goog.require('ol.source.WMSServerType');\n  goog.require('ol.tilecoord');\n  goog.require('ol.string');\n  goog.require('ol.uri');\n  \n  /**\n   * @classdesc\n   * Layer source for tile data from WMS servers.\n   *\n   * @constructor\n   * @extends {ol.source.TileImage}\n   * @param {olx.source.TileWMSOptions=} opt_options Tile WMS options.\n   * @api\n   */\n  ol.source.TileWMS = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    var params = options.params || {};\n  \n    var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;\n  \n    ol.source.TileImage.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      logo: options.logo,\n      opaque: !transparent,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition\n    });\n  \n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n  \n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = params;\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.v13_ = true;\n  \n    /**\n     * @private\n     * @type {ol.source.WMSServerType|undefined}\n     */\n    this.serverType_ = /** @type {ol.source.WMSServerType|undefined} */ (options.serverType);\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.tmpExtent_ = ol.extent.createEmpty();\n  \n    this.updateV13_();\n    this.setKey(this.getKeyForParams_());\n  \n  };\n  ol.inherits(ol.source.TileWMS, ol.source.TileImage);\n  \n  \n  /**\n   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and\n   * projection. Return `undefined` if the GetFeatureInfo URL cannot be\n   * constructed.\n   * @param {ol.Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {ol.ProjectionLike} projection Projection.\n   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should\n   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified\n   *     in the `LAYERS` parameter will be used. `VERSION` should not be\n   *     specified here.\n   * @return {string|undefined} GetFeatureInfo URL.\n   * @api\n   */\n  ol.source.TileWMS.prototype.getGetFeatureInfoUrl = function(coordinate, resolution, projection, params) {\n    var projectionObj = ol.proj.get(projection);\n    var sourceProjectionObj = this.getProjection();\n  \n    var tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projectionObj);\n    }\n  \n    var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n  \n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n  \n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    var tileSize = ol.size.toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n  \n  \n    var gutter = this.gutter_;\n    if (gutter !== 0) {\n      tileSize = ol.size.buffer(tileSize, gutter, this.tmpSize);\n      tileExtent = ol.extent.buffer(tileExtent, tileResolution * gutter, tileExtent);\n    }\n  \n    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {\n      tileResolution = ol.reproj.calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);\n      tileExtent = ol.proj.transformExtent(tileExtent, projectionObj, sourceProjectionObj);\n      coordinate = ol.proj.transform(coordinate, projectionObj, sourceProjectionObj);\n    }\n  \n    var baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': ol.DEFAULT_WMS_VERSION,\n      'REQUEST': 'GetFeatureInfo',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true,\n      'QUERY_LAYERS': this.params_['LAYERS']\n    };\n    ol.obj.assign(baseParams, this.params_, params);\n  \n    var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);\n    var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);\n  \n    baseParams[this.v13_ ? 'I' : 'X'] = x;\n    baseParams[this.v13_ ? 'J' : 'Y'] = y;\n  \n    return this.getRequestUrl_(tileCoord, tileSize, tileExtent,\n        1, sourceProjectionObj || projectionObj, baseParams);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileWMS.prototype.getGutterInternal = function() {\n    return this.gutter_;\n  };\n  \n  \n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  ol.source.TileWMS.prototype.getParams = function() {\n    return this.params_;\n  };\n  \n  \n  /**\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.Size} tileSize Tile size.\n   * @param {ol.Extent} tileExtent Tile extent.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {Object} params Params.\n   * @return {string|undefined} Request URL.\n   * @private\n   */\n  ol.source.TileWMS.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent,\n      pixelRatio, projection, params) {\n  \n    var urls = this.urls;\n    if (!urls) {\n      return undefined;\n    }\n  \n    params['WIDTH'] = tileSize[0];\n    params['HEIGHT'] = tileSize[1];\n  \n    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();\n  \n    if (!('STYLES' in this.params_)) {\n      params['STYLES'] = '';\n    }\n  \n    if (pixelRatio != 1) {\n      switch (this.serverType_) {\n        case ol.source.WMSServerType.GEOSERVER:\n          var dpi = (90 * pixelRatio + 0.5) | 0;\n          if ('FORMAT_OPTIONS' in params) {\n            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;\n          } else {\n            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;\n          }\n          break;\n        case ol.source.WMSServerType.MAPSERVER:\n          params['MAP_RESOLUTION'] = 90 * pixelRatio;\n          break;\n        case ol.source.WMSServerType.CARMENTA_SERVER:\n        case ol.source.WMSServerType.QGIS:\n          params['DPI'] = 90 * pixelRatio;\n          break;\n        default:\n          ol.asserts.assert(false, 52); // Unknown `serverType` configured\n          break;\n      }\n    }\n  \n    var axisOrientation = projection.getAxisOrientation();\n    var bbox = tileExtent;\n    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {\n      var tmp;\n      tmp = tileExtent[0];\n      bbox[0] = tileExtent[1];\n      bbox[1] = tmp;\n      tmp = tileExtent[2];\n      bbox[2] = tileExtent[3];\n      bbox[3] = tmp;\n    }\n    params['BBOX'] = bbox.join(',');\n  \n    var url;\n    if (urls.length == 1) {\n      url = urls[0];\n    } else {\n      var index = ol.math.modulo(ol.tilecoord.hash(tileCoord), urls.length);\n      url = urls[index];\n    }\n    return ol.uri.appendParams(url, params);\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileWMS.prototype.getTilePixelRatio = function(pixelRatio) {\n    return (!this.hidpi_ || this.serverType_ === undefined) ? 1 :\n    /** @type {number} */ (pixelRatio);\n  };\n  \n  \n  /**\n   * @private\n   * @return {string} The key for the current params.\n   */\n  ol.source.TileWMS.prototype.getKeyForParams_ = function() {\n    var i = 0;\n    var res = [];\n    for (var key in this.params_) {\n      res[i++] = key + '-' + this.params_[key];\n    }\n    return res.join('/');\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.TileWMS.prototype.fixedTileUrlFunction = function(tileCoord, pixelRatio, projection) {\n  \n    var tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projection);\n    }\n  \n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n  \n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {\n      pixelRatio = 1;\n    }\n  \n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    var tileSize = ol.size.toSize(\n        tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n  \n    var gutter = this.gutter_;\n    if (gutter !== 0) {\n      tileSize = ol.size.buffer(tileSize, gutter, this.tmpSize);\n      tileExtent = ol.extent.buffer(tileExtent,\n          tileResolution * gutter, tileExtent);\n    }\n  \n    if (pixelRatio != 1) {\n      tileSize = ol.size.scale(tileSize, pixelRatio, this.tmpSize);\n    }\n  \n    var baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': ol.DEFAULT_WMS_VERSION,\n      'REQUEST': 'GetMap',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true\n    };\n    ol.obj.assign(baseParams, this.params_);\n  \n    return this.getRequestUrl_(tileCoord, tileSize, tileExtent,\n        pixelRatio, projection, baseParams);\n  };\n  \n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  ol.source.TileWMS.prototype.updateParams = function(params) {\n    ol.obj.assign(this.params_, params);\n    this.updateV13_();\n    this.setKey(this.getKeyForParams_());\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.source.TileWMS.prototype.updateV13_ = function() {\n    var version = this.params_['VERSION'] || ol.DEFAULT_WMS_VERSION;\n    this.v13_ = ol.string.compareVersions(version, '1.3') >= 0;\n  };\n  \n  goog.provide('ol.VectorImageTile');\n  \n  goog.require('ol');\n  goog.require('ol.Tile');\n  goog.require('ol.TileState');\n  goog.require('ol.dom');\n  goog.require('ol.events');\n  goog.require('ol.extent');\n  goog.require('ol.events.EventType');\n  goog.require('ol.featureloader');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.Tile}\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.TileState} state State.\n   * @param {number} sourceRevision Source revision.\n   * @param {ol.format.Feature} format Feature format.\n   * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.\n   * @param {ol.TileCoord} urlTileCoord Wrapped tile coordinate for source urls.\n   * @param {ol.TileUrlFunctionType} tileUrlFunction Tile url function.\n   * @param {ol.tilegrid.TileGrid} sourceTileGrid Tile grid of the source.\n   * @param {ol.tilegrid.TileGrid} tileGrid Tile grid of the renderer.\n   * @param {Object.<string,ol.VectorTile>} sourceTiles Source tiles.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {ol.proj.Projection} projection Projection.\n   * @param {function(new: ol.VectorTile, ol.TileCoord, ol.TileState, string,\n   *     ol.format.Feature, ol.TileLoadFunctionType)} tileClass Class to\n   *     instantiate for source tiles.\n   * @param {function(this: ol.source.VectorTile, ol.events.Event)} handleTileChange\n   *     Function to call when a source tile's state changes.\n   * @param {olx.TileOptions=} opt_options Tile options.\n   */\n  ol.VectorImageTile = function(tileCoord, state, sourceRevision, format,\n      tileLoadFunction, urlTileCoord, tileUrlFunction, sourceTileGrid, tileGrid,\n      sourceTiles, pixelRatio, projection, tileClass, handleTileChange, opt_options) {\n  \n    ol.Tile.call(this, tileCoord, state, opt_options);\n  \n    /**\n     * @private\n     * @type {Object.<string, CanvasRenderingContext2D>}\n     */\n    this.context_ = {};\n  \n    /**\n     * @private\n     * @type {ol.FeatureLoader}\n     */\n    this.loader_;\n  \n    /**\n     * @private\n     * @type {Object.<string, ol.TileReplayState>}\n     */\n    this.replayState_ = {};\n  \n    /**\n     * @private\n     * @type {Object.<string,ol.VectorTile>}\n     */\n    this.sourceTiles_ = sourceTiles;\n  \n    /**\n     * Keys of source tiles used by this tile. Use with {@link #getTile}.\n     * @type {Array.<string>}\n     */\n    this.tileKeys = [];\n  \n    /**\n     * @type {number}\n     */\n    this.sourceRevision_ = sourceRevision;\n  \n    /**\n     * @type {ol.TileCoord}\n     */\n    this.wrappedTileCoord = urlTileCoord;\n  \n    /**\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.loadListenerKeys_ = [];\n  \n    /**\n     * @type {Array.<ol.EventsKey>}\n     */\n    this.sourceTileListenerKeys_ = [];\n  \n    if (urlTileCoord) {\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      var resolution = tileGrid.getResolution(tileCoord[0]);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function(sourceTileCoord) {\n        var sharedExtent = ol.extent.getIntersection(extent,\n            sourceTileGrid.getTileCoordExtent(sourceTileCoord));\n        var sourceExtent = sourceTileGrid.getExtent();\n        if (sourceExtent) {\n          sharedExtent = ol.extent.getIntersection(sharedExtent, sourceExtent);\n        }\n        if (ol.extent.getWidth(sharedExtent) / resolution >= 0.5 &&\n            ol.extent.getHeight(sharedExtent) / resolution >= 0.5) {\n          // only include source tile if overlap is at least 1 pixel\n          var sourceTileKey = sourceTileCoord.toString();\n          var sourceTile = sourceTiles[sourceTileKey];\n          if (!sourceTile) {\n            var tileUrl = tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n            sourceTile = sourceTiles[sourceTileKey] = new tileClass(sourceTileCoord,\n                tileUrl == undefined ? ol.TileState.EMPTY : ol.TileState.IDLE,\n                tileUrl == undefined ? '' : tileUrl,\n                format, tileLoadFunction);\n            this.sourceTileListenerKeys_.push(\n                ol.events.listen(sourceTile, ol.events.EventType.CHANGE, handleTileChange));\n          }\n          sourceTile.consumers++;\n          this.tileKeys.push(sourceTileKey);\n        }\n      }.bind(this));\n    }\n  \n  };\n  ol.inherits(ol.VectorImageTile, ol.Tile);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.VectorImageTile.prototype.disposeInternal = function() {\n    for (var i = 0, ii = this.tileKeys.length; i < ii; ++i) {\n      var sourceTileKey = this.tileKeys[i];\n      var sourceTile = this.getTile(sourceTileKey);\n      sourceTile.consumers--;\n      if (sourceTile.consumers == 0) {\n        delete this.sourceTiles_[sourceTileKey];\n        sourceTile.dispose();\n      }\n    }\n    this.tileKeys.length = 0;\n    this.sourceTiles_ = null;\n    this.loadListenerKeys_.forEach(ol.events.unlistenByKey);\n    this.loadListenerKeys_.length = 0;\n    if (this.interimTile) {\n      this.interimTile.dispose();\n    }\n    this.state = ol.TileState.ABORT;\n    this.changed();\n    this.sourceTileListenerKeys_.forEach(ol.events.unlistenByKey);\n    this.sourceTileListenerKeys_.length = 0;\n    ol.Tile.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * @param {ol.layer.Layer} layer Layer.\n   * @return {CanvasRenderingContext2D} The rendering context.\n   */\n  ol.VectorImageTile.prototype.getContext = function(layer) {\n    var key = ol.getUid(layer).toString();\n    if (!(key in this.context_)) {\n      this.context_[key] = ol.dom.createCanvasContext2D();\n    }\n    return this.context_[key];\n  };\n  \n  \n  /**\n   * Get the Canvas for this tile.\n   * @param {ol.layer.Layer} layer Layer.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ol.VectorImageTile.prototype.getImage = function(layer) {\n    return this.getReplayState(layer).renderedTileRevision == -1 ?\n      null : this.getContext(layer).canvas;\n  };\n  \n  \n  /**\n   * @param {ol.layer.Layer} layer Layer.\n   * @return {ol.TileReplayState} The replay state.\n   */\n  ol.VectorImageTile.prototype.getReplayState = function(layer) {\n    var key = ol.getUid(layer).toString();\n    if (!(key in this.replayState_)) {\n      this.replayState_[key] = {\n        dirty: false,\n        renderedRenderOrder: null,\n        renderedRevision: -1,\n        renderedTileRevision: -1\n      };\n    }\n    return this.replayState_[key];\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.VectorImageTile.prototype.getKey = function() {\n    return this.tileKeys.join('/') + '-' + this.sourceRevision_;\n  };\n  \n  \n  /**\n   * @param {string} tileKey Key (tileCoord) of the source tile.\n   * @return {ol.VectorTile} Source tile.\n   */\n  ol.VectorImageTile.prototype.getTile = function(tileKey) {\n    return this.sourceTiles_[tileKey];\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.VectorImageTile.prototype.load = function() {\n    // Source tiles with LOADED state - we just count them because once they are\n    // loaded, we're no longer listening to state changes.\n    var leftToLoad = 0;\n    // Source tiles with ERROR state - we track them because they can still have\n    // an ERROR state after another load attempt.\n    var errorSourceTiles = {};\n  \n    if (this.state == ol.TileState.IDLE) {\n      this.setState(ol.TileState.LOADING);\n    }\n    if (this.state == ol.TileState.LOADING) {\n      this.tileKeys.forEach(function(sourceTileKey) {\n        var sourceTile = this.getTile(sourceTileKey);\n        if (sourceTile.state == ol.TileState.IDLE) {\n          sourceTile.setLoader(this.loader_);\n          sourceTile.load();\n        }\n        if (sourceTile.state == ol.TileState.LOADING) {\n          var key = ol.events.listen(sourceTile, ol.events.EventType.CHANGE, function(e) {\n            var state = sourceTile.getState();\n            if (state == ol.TileState.LOADED ||\n                state == ol.TileState.ERROR) {\n              var uid = ol.getUid(sourceTile);\n              if (state == ol.TileState.ERROR) {\n                errorSourceTiles[uid] = true;\n              } else {\n                --leftToLoad;\n                delete errorSourceTiles[uid];\n              }\n              if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {\n                this.finishLoading_();\n              }\n            }\n          }.bind(this));\n          this.loadListenerKeys_.push(key);\n          ++leftToLoad;\n        }\n      }.bind(this));\n    }\n    if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {\n      setTimeout(this.finishLoading_.bind(this), 0);\n    }\n  };\n  \n  \n  /**\n   * @private\n   */\n  ol.VectorImageTile.prototype.finishLoading_ = function() {\n    var loaded = this.tileKeys.length;\n    var empty = 0;\n    for (var i = loaded - 1; i >= 0; --i) {\n      var state = this.getTile(this.tileKeys[i]).getState();\n      if (state != ol.TileState.LOADED) {\n        --loaded;\n      }\n      if (state == ol.TileState.EMPTY) {\n        ++empty;\n      }\n    }\n    if (loaded == this.tileKeys.length) {\n      this.loadListenerKeys_.forEach(ol.events.unlistenByKey);\n      this.loadListenerKeys_.length = 0;\n      this.setState(ol.TileState.LOADED);\n    } else {\n      this.setState(empty == this.tileKeys.length ? ol.TileState.EMPTY : ol.TileState.ERROR);\n    }\n  };\n  \n  \n  /**\n   * Sets the loader for a tile.\n   * @param {ol.VectorTile} tile Vector tile.\n   * @param {string} url URL.\n   */\n  ol.VectorImageTile.defaultLoadFunction = function(tile, url) {\n    var loader = ol.featureloader.loadFeaturesXhr(\n        url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));\n  \n    tile.setLoader(loader);\n  };\n  \n  goog.provide('ol.VectorTile');\n  \n  goog.require('ol');\n  goog.require('ol.Tile');\n  goog.require('ol.TileState');\n  \n  \n  /**\n   * @constructor\n   * @extends {ol.Tile}\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.TileState} state State.\n   * @param {string} src Data source url.\n   * @param {ol.format.Feature} format Feature format.\n   * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.\n   * @param {olx.TileOptions=} opt_options Tile options.\n   */\n  ol.VectorTile = function(tileCoord, state, src, format, tileLoadFunction, opt_options) {\n  \n    ol.Tile.call(this, tileCoord, state, opt_options);\n  \n    /**\n     * @type {number}\n     */\n    this.consumers = 0;\n  \n    /**\n     * @private\n     * @type {ol.Extent}\n     */\n    this.extent_ = null;\n  \n    /**\n     * @private\n     * @type {ol.format.Feature}\n     */\n    this.format_ = format;\n  \n    /**\n     * @private\n     * @type {Array.<ol.Feature>}\n     */\n    this.features_ = null;\n  \n    /**\n     * @private\n     * @type {ol.FeatureLoader}\n     */\n    this.loader_;\n  \n    /**\n     * Data projection\n     * @private\n     * @type {ol.proj.Projection}\n     */\n    this.projection_;\n  \n    /**\n     * @private\n     * @type {Object.<string, ol.render.ReplayGroup>}\n     */\n    this.replayGroups_ = {};\n  \n    /**\n     * @private\n     * @type {ol.TileLoadFunctionType}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.url_ = src;\n  \n  };\n  ol.inherits(ol.VectorTile, ol.Tile);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.VectorTile.prototype.disposeInternal = function() {\n    this.features_ = null;\n    this.replayGroups_ = {};\n    this.state = ol.TileState.ABORT;\n    this.changed();\n    ol.Tile.prototype.disposeInternal.call(this);\n  };\n  \n  \n  /**\n   * Gets the extent of the vector tile.\n   * @return {ol.Extent} The extent.\n   * @api\n   */\n  ol.VectorTile.prototype.getExtent = function() {\n    return this.extent_ || ol.VectorTile.DEFAULT_EXTENT;\n  };\n  \n  \n  /**\n   * Get the feature format assigned for reading this tile's features.\n   * @return {ol.format.Feature} Feature format.\n   * @api\n   */\n  ol.VectorTile.prototype.getFormat = function() {\n    return this.format_;\n  };\n  \n  \n  /**\n   * Get the features for this tile. Geometries will be in the projection returned\n   * by {@link ol.VectorTile#getProjection}.\n   * @return {Array.<ol.Feature|ol.render.Feature>} Features.\n   * @api\n   */\n  ol.VectorTile.prototype.getFeatures = function() {\n    return this.features_;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.VectorTile.prototype.getKey = function() {\n    return this.url_;\n  };\n  \n  \n  /**\n   * Get the feature projection of features returned by\n   * {@link ol.VectorTile#getFeatures}.\n   * @return {ol.proj.Projection} Feature projection.\n   * @api\n   */\n  ol.VectorTile.prototype.getProjection = function() {\n    return this.projection_;\n  };\n  \n  \n  /**\n   * @param {ol.layer.Layer} layer Layer.\n   * @param {string} key Key.\n   * @return {ol.render.ReplayGroup} Replay group.\n   */\n  ol.VectorTile.prototype.getReplayGroup = function(layer, key) {\n    return this.replayGroups_[ol.getUid(layer) + ',' + key];\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.VectorTile.prototype.load = function() {\n    if (this.state == ol.TileState.IDLE) {\n      this.setState(ol.TileState.LOADING);\n      this.tileLoadFunction_(this, this.url_);\n      this.loader_(null, NaN, null);\n    }\n  };\n  \n  \n  /**\n   * Handler for successful tile load.\n   * @param {Array.<ol.Feature>} features The loaded features.\n   * @param {ol.proj.Projection} dataProjection Data projection.\n   * @param {ol.Extent} extent Extent.\n   */\n  ol.VectorTile.prototype.onLoad = function(features, dataProjection, extent) {\n    this.setProjection(dataProjection);\n    this.setFeatures(features);\n    this.setExtent(extent);\n  };\n  \n  \n  /**\n   * Handler for tile load errors.\n   */\n  ol.VectorTile.prototype.onError = function() {\n    this.setState(ol.TileState.ERROR);\n  };\n  \n  \n  /**\n   * Function for use in an {@link ol.source.VectorTile}'s `tileLoadFunction`.\n   * Sets the extent of the vector tile. This is only required for tiles in\n   * projections with `tile-pixels` as units. The extent should be set to\n   * `[0, 0, tilePixelSize, tilePixelSize]`, where `tilePixelSize` is calculated\n   * by multiplying the tile size with the tile pixel ratio. For sources using\n   * {@link ol.format.MVT} as feature format, the\n   * {@link ol.format.MVT#getLastExtent} method will return the correct extent.\n   * The default is `[0, 0, 4096, 4096]`.\n   * @param {ol.Extent} extent The extent.\n   * @api\n   */\n  ol.VectorTile.prototype.setExtent = function(extent) {\n    this.extent_ = extent;\n  };\n  \n  \n  /**\n   * Function for use in an {@link ol.source.VectorTile}'s `tileLoadFunction`.\n   * Sets the features for the tile.\n   * @param {Array.<ol.Feature>} features Features.\n   * @api\n   */\n  ol.VectorTile.prototype.setFeatures = function(features) {\n    this.features_ = features;\n    this.setState(ol.TileState.LOADED);\n  };\n  \n  \n  /**\n   * Function for use in an {@link ol.source.VectorTile}'s `tileLoadFunction`.\n   * Sets the projection of the features that were added with\n   * {@link ol.VectorTile#setFeatures}.\n   * @param {ol.proj.Projection} projection Feature projection.\n   * @api\n   */\n  ol.VectorTile.prototype.setProjection = function(projection) {\n    this.projection_ = projection;\n  };\n  \n  \n  /**\n   * @param {ol.layer.Layer} layer Layer.\n   * @param {string} key Key.\n   * @param {ol.render.ReplayGroup} replayGroup Replay group.\n   */\n  ol.VectorTile.prototype.setReplayGroup = function(layer, key, replayGroup) {\n    this.replayGroups_[ol.getUid(layer) + ',' + key] = replayGroup;\n  };\n  \n  \n  /**\n   * Set the feature loader for reading this tile's features.\n   * @param {ol.FeatureLoader} loader Feature loader.\n   * @api\n   */\n  ol.VectorTile.prototype.setLoader = function(loader) {\n    this.loader_ = loader;\n  };\n  \n  \n  /**\n   * @const\n   * @type {ol.Extent}\n   */\n  ol.VectorTile.DEFAULT_EXTENT = [0, 0, 4096, 4096];\n  \n  goog.provide('ol.source.VectorTile');\n  \n  goog.require('ol');\n  goog.require('ol.TileState');\n  goog.require('ol.VectorImageTile');\n  goog.require('ol.VectorTile');\n  goog.require('ol.size');\n  goog.require('ol.source.UrlTile');\n  goog.require('ol.tilecoord');\n  goog.require('ol.tilegrid');\n  \n  \n  /**\n   * @classdesc\n   * Class for layer sources providing vector data divided into a tile grid, to be\n   * used with {@link ol.layer.VectorTile}. Although this source receives tiles\n   * with vector features from the server, it is not meant for feature editing.\n   * Features are optimized for rendering, their geometries are clipped at or near\n   * tile boundaries and simplified for a view resolution. See\n   * {@link ol.source.Vector} for vector sources that are suitable for feature\n   * editing.\n   *\n   * @constructor\n   * @fires ol.source.Tile.Event\n   * @extends {ol.source.UrlTile}\n   * @param {olx.source.VectorTileOptions} options Vector tile options.\n   * @api\n   */\n  ol.source.VectorTile = function(options) {\n    var projection = options.projection || 'EPSG:3857';\n  \n    var extent = options.extent || ol.tilegrid.extentFromProjection(projection);\n  \n    var tileGrid = options.tileGrid || ol.tilegrid.createXYZ({\n      extent: extent,\n      maxZoom: options.maxZoom || 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n  \n    ol.source.UrlTile.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize !== undefined ? options.cacheSize : 128,\n      extent: extent,\n      logo: options.logo,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ?\n        options.tileLoadFunction : ol.VectorImageTile.defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition\n    });\n  \n    /**\n     * @private\n     * @type {ol.format.Feature}\n     */\n    this.format_ = options.format ? options.format : null;\n  \n    /**\n     * @private\n     * @type {Object.<string,ol.VectorTile>}\n     */\n    this.sourceTiles_ = {};\n  \n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n  \n    /**\n     * @protected\n     * @type {function(new: ol.VectorTile, ol.TileCoord, ol.TileState, string,\n     *        ol.format.Feature, ol.TileLoadFunctionType)}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : ol.VectorTile;\n  \n    /**\n     * @private\n     * @type {Object.<string,ol.tilegrid.TileGrid>}\n     */\n    this.tileGrids_ = {};\n  \n  };\n  ol.inherits(ol.source.VectorTile, ol.source.UrlTile);\n  \n  \n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  ol.source.VectorTile.prototype.getOverlaps = function() {\n    return this.overlaps_;\n  };\n  \n  /**\n   * clear {@link ol.TileCache} and delete all source tiles\n   * @api\n   */\n  ol.source.VectorTile.prototype.clear = function() {\n    this.tileCache.clear();\n    this.sourceTiles_ = {};\n  };\n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.VectorTile.prototype.getTile = function(z, x, y, pixelRatio, projection) {\n    var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return /** @type {!ol.Tile} */ (this.tileCache.get(tileCoordKey));\n    } else {\n      var tileCoord = [z, x, y];\n      var urlTileCoord = this.getTileCoordForTileUrlFunction(\n          tileCoord, projection);\n      var tile = new ol.VectorImageTile(\n          tileCoord,\n          urlTileCoord !== null ? ol.TileState.IDLE : ol.TileState.EMPTY,\n          this.getRevision(),\n          this.format_, this.tileLoadFunction, urlTileCoord, this.tileUrlFunction,\n          this.tileGrid, this.getTileGridForProjection(projection),\n          this.sourceTiles_, pixelRatio, projection, this.tileClass,\n          this.handleTileChange.bind(this),\n          this.tileOptions);\n  \n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.VectorTile.prototype.getTileGridForProjection = function(projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = this.tileGrids_[code] = ol.tilegrid.createForProjection(projection, undefined,\n          sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n    }\n    return tileGrid;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.VectorTile.prototype.getTilePixelRatio = function(pixelRatio) {\n    return pixelRatio;\n  };\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.VectorTile.prototype.getTilePixelSize = function(z, pixelRatio, projection) {\n    var tileSize = ol.size.toSize(this.getTileGridForProjection(projection).getTileSize(z));\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n  \n  goog.provide('ol.source.WMTSRequestEncoding');\n  \n  /**\n   * Request encoding. One of 'KVP', 'REST'.\n   * @enum {string}\n   */\n  ol.source.WMTSRequestEncoding = {\n    KVP: 'KVP',  // see spec §8\n    REST: 'REST' // see spec §10\n  };\n  \n  goog.provide('ol.tilegrid.WMTS');\n  \n  goog.require('ol');\n  goog.require('ol.array');\n  goog.require('ol.proj');\n  goog.require('ol.tilegrid.TileGrid');\n  \n  \n  /**\n   * @classdesc\n   * Set the grid pattern for sources accessing WMTS tiled-image servers.\n   *\n   * @constructor\n   * @extends {ol.tilegrid.TileGrid}\n   * @param {olx.tilegrid.WMTSOptions} options WMTS options.\n   * @struct\n   * @api\n   */\n  ol.tilegrid.WMTS = function(options) {\n    /**\n     * @private\n     * @type {!Array.<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n    // FIXME: should the matrixIds become optional?\n  \n    ol.tilegrid.TileGrid.call(this, {\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes\n    });\n  };\n  ol.inherits(ol.tilegrid.WMTS, ol.tilegrid.TileGrid);\n  \n  \n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  ol.tilegrid.WMTS.prototype.getMatrixId = function(z) {\n    return this.matrixIds_[z];\n  };\n  \n  \n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array.<string>} MatrixIds.\n   * @api\n   */\n  ol.tilegrid.WMTS.prototype.getMatrixIds = function() {\n    return this.matrixIds_;\n  };\n  \n  \n  /**\n   * Create a tile grid from a WMTS capabilities matrix set and an\n   * optional TileMatrixSetLimits.\n   * @param {Object} matrixSet An object representing a matrixSet in the\n   *     capabilities document.\n   * @param {ol.Extent=} opt_extent An optional extent to restrict the tile\n   *     ranges the server provides.\n   * @param {Array.<Object>=} opt_matrixLimits An optional object representing\n   *     the available matrices for tileGrid.\n   * @return {ol.tilegrid.WMTS} WMTS tileGrid instance.\n   * @api\n   */\n  ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet = function(matrixSet, opt_extent,\n      opt_matrixLimits) {\n  \n    /** @type {!Array.<number>} */\n    var resolutions = [];\n    /** @type {!Array.<string>} */\n    var matrixIds = [];\n    /** @type {!Array.<ol.Coordinate>} */\n    var origins = [];\n    /** @type {!Array.<ol.Size>} */\n    var tileSizes = [];\n    /** @type {!Array.<ol.Size>} */\n    var sizes = [];\n  \n    var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];\n  \n    var supportedCRSPropName = 'SupportedCRS';\n    var matrixIdsPropName = 'TileMatrix';\n    var identifierPropName = 'Identifier';\n    var scaleDenominatorPropName = 'ScaleDenominator';\n    var topLeftCornerPropName = 'TopLeftCorner';\n    var tileWidthPropName = 'TileWidth';\n    var tileHeightPropName = 'TileHeight';\n  \n    var code = matrixSet[supportedCRSPropName];\n    var projection = ol.proj.get(code.replace(/urn:ogc:def:crs:(\\w+):(.*:)?(\\w+)$/, '$1:$3')) ||\n        ol.proj.get(code);\n    var metersPerUnit = projection.getMetersPerUnit();\n    // swap origin x and y coordinates if axis orientation is lat/long\n    var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n  \n    matrixSet[matrixIdsPropName].sort(function(a, b) {\n      return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n    });\n  \n    matrixSet[matrixIdsPropName].forEach(function(elt, index, array) {\n  \n      var matrixAvailable;\n      // use of matrixLimits to filter TileMatrices from GetCapabilities\n      // TileMatrixSet from unavailable matrix levels.\n      if (matrixLimits.length > 0) {\n        matrixAvailable = ol.array.find(matrixLimits,\n            function(elt_ml, index_ml, array_ml) {\n              return elt[identifierPropName] == elt_ml[matrixIdsPropName];\n            });\n      } else {\n        matrixAvailable = true;\n      }\n  \n      if (matrixAvailable) {\n        matrixIds.push(elt[identifierPropName]);\n        var resolution = elt[scaleDenominatorPropName] * 0.28E-3 / metersPerUnit;\n        var tileWidth = elt[tileWidthPropName];\n        var tileHeight = elt[tileHeightPropName];\n        if (switchOriginXY) {\n          origins.push([elt[topLeftCornerPropName][1],\n            elt[topLeftCornerPropName][0]]);\n        } else {\n          origins.push(elt[topLeftCornerPropName]);\n        }\n        resolutions.push(resolution);\n        tileSizes.push(tileWidth == tileHeight ?\n          tileWidth : [tileWidth, tileHeight]);\n        // top-left origin, so height is negative\n        sizes.push([elt['MatrixWidth'], -elt['MatrixHeight']]);\n      }\n    });\n  \n    return new ol.tilegrid.WMTS({\n      extent: opt_extent,\n      origins: origins,\n      resolutions: resolutions,\n      matrixIds: matrixIds,\n      tileSizes: tileSizes,\n      sizes: sizes\n    });\n  };\n  \n  goog.provide('ol.source.WMTS');\n  \n  goog.require('ol');\n  goog.require('ol.TileUrlFunction');\n  goog.require('ol.array');\n  goog.require('ol.extent');\n  goog.require('ol.obj');\n  goog.require('ol.proj');\n  goog.require('ol.source.TileImage');\n  goog.require('ol.source.WMTSRequestEncoding');\n  goog.require('ol.tilegrid.WMTS');\n  goog.require('ol.uri');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for tile data from WMTS servers.\n   *\n   * @constructor\n   * @extends {ol.source.TileImage}\n   * @param {olx.source.WMTSOptions} options WMTS options.\n   * @api\n   */\n  ol.source.WMTS = function(options) {\n  \n    // TODO: add support for TileMatrixLimits\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.version_ = options.version !== undefined ? options.version : '1.0.0';\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.format_ = options.format !== undefined ? options.format : 'image/jpeg';\n  \n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.layer_ = options.layer;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.matrixSet_ = options.matrixSet;\n  \n    /**\n     * @private\n     * @type {string}\n     */\n    this.style_ = options.style;\n  \n    var urls = options.urls;\n    if (urls === undefined && options.url !== undefined) {\n      urls = ol.TileUrlFunction.expandUrl(options.url);\n    }\n  \n    // FIXME: should we guess this requestEncoding from options.url(s)\n    //        structure? that would mean KVP only if a template is not provided.\n  \n    /**\n     * @private\n     * @type {ol.source.WMTSRequestEncoding}\n     */\n    this.requestEncoding_ = options.requestEncoding !== undefined ?\n      /** @type {ol.source.WMTSRequestEncoding} */ (options.requestEncoding) :\n      ol.source.WMTSRequestEncoding.KVP;\n  \n    var requestEncoding = this.requestEncoding_;\n  \n    // FIXME: should we create a default tileGrid?\n    // we could issue a getCapabilities xhr to retrieve missing configuration\n    var tileGrid = options.tileGrid;\n  \n    // context property names are lower case to allow for a case insensitive\n    // replacement as some services use different naming conventions\n    var context = {\n      'layer': this.layer_,\n      'style': this.style_,\n      'tilematrixset': this.matrixSet_\n    };\n  \n    if (requestEncoding == ol.source.WMTSRequestEncoding.KVP) {\n      ol.obj.assign(context, {\n        'Service': 'WMTS',\n        'Request': 'GetTile',\n        'Version': this.version_,\n        'Format': this.format_\n      });\n    }\n  \n    var dimensions = this.dimensions_;\n  \n    /**\n     * @param {string} template Template.\n     * @return {ol.TileUrlFunctionType} Tile URL function.\n     * @private\n     */\n    this.createFromWMTSTemplate_ = function(template) {\n  \n      // TODO: we may want to create our own appendParams function so that params\n      // order conforms to wmts spec guidance, and so that we can avoid to escape\n      // special template params\n  \n      template = (requestEncoding == ol.source.WMTSRequestEncoding.KVP) ?\n        ol.uri.appendParams(template, context) :\n        template.replace(/\\{(\\w+?)\\}/g, function(m, p) {\n          return (p.toLowerCase() in context) ? context[p.toLowerCase()] : m;\n        });\n  \n      return (\n        /**\n         * @param {ol.TileCoord} tileCoord Tile coordinate.\n         * @param {number} pixelRatio Pixel ratio.\n         * @param {ol.proj.Projection} projection Projection.\n         * @return {string|undefined} Tile URL.\n         */\n        function(tileCoord, pixelRatio, projection) {\n          if (!tileCoord) {\n            return undefined;\n          } else {\n            var localContext = {\n              'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),\n              'TileCol': tileCoord[1],\n              'TileRow': -tileCoord[2] - 1\n            };\n            ol.obj.assign(localContext, dimensions);\n            var url = template;\n            if (requestEncoding == ol.source.WMTSRequestEncoding.KVP) {\n              url = ol.uri.appendParams(url, localContext);\n            } else {\n              url = url.replace(/\\{(\\w+?)\\}/g, function(m, p) {\n                return localContext[p];\n              });\n            }\n            return url;\n          }\n        });\n    };\n  \n    var tileUrlFunction = (urls && urls.length > 0) ?\n      ol.TileUrlFunction.createFromTileUrlFunctions(\n          urls.map(this.createFromWMTSTemplate_)) :\n      ol.TileUrlFunction.nullTileUrlFunction;\n  \n    ol.source.TileImage.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      logo: options.logo,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: tileUrlFunction,\n      urls: urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : false,\n      transition: options.transition\n    });\n  \n    this.setKey(this.getKeyForDimensions_());\n  \n  };\n  ol.inherits(ol.source.WMTS, ol.source.TileImage);\n  \n  /**\n   * Set the URLs to use for requests.\n   * URLs may contain OCG conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.\n   * @override\n   */\n  ol.source.WMTS.prototype.setUrls = function(urls) {\n    this.urls = urls;\n    var key = urls.join('\\n');\n    this.setTileUrlFunction(this.fixedTileUrlFunction ?\n      this.fixedTileUrlFunction.bind(this) :\n      ol.TileUrlFunction.createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate_.bind(this))), key);\n  };\n  \n  /**\n   * Get the dimensions, i.e. those passed to the constructor through the\n   * \"dimensions\" option, and possibly updated using the updateDimensions\n   * method.\n   * @return {!Object} Dimensions.\n   * @api\n   */\n  ol.source.WMTS.prototype.getDimensions = function() {\n    return this.dimensions_;\n  };\n  \n  \n  /**\n   * Return the image format of the WMTS source.\n   * @return {string} Format.\n   * @api\n   */\n  ol.source.WMTS.prototype.getFormat = function() {\n    return this.format_;\n  };\n  \n  \n  /**\n   * Return the layer of the WMTS source.\n   * @return {string} Layer.\n   * @api\n   */\n  ol.source.WMTS.prototype.getLayer = function() {\n    return this.layer_;\n  };\n  \n  \n  /**\n   * Return the matrix set of the WMTS source.\n   * @return {string} MatrixSet.\n   * @api\n   */\n  ol.source.WMTS.prototype.getMatrixSet = function() {\n    return this.matrixSet_;\n  };\n  \n  \n  /**\n   * Return the request encoding, either \"KVP\" or \"REST\".\n   * @return {ol.source.WMTSRequestEncoding} Request encoding.\n   * @api\n   */\n  ol.source.WMTS.prototype.getRequestEncoding = function() {\n    return this.requestEncoding_;\n  };\n  \n  \n  /**\n   * Return the style of the WMTS source.\n   * @return {string} Style.\n   * @api\n   */\n  ol.source.WMTS.prototype.getStyle = function() {\n    return this.style_;\n  };\n  \n  \n  /**\n   * Return the version of the WMTS source.\n   * @return {string} Version.\n   * @api\n   */\n  ol.source.WMTS.prototype.getVersion = function() {\n    return this.version_;\n  };\n  \n  \n  /**\n   * @private\n   * @return {string} The key for the current dimensions.\n   */\n  ol.source.WMTS.prototype.getKeyForDimensions_ = function() {\n    var i = 0;\n    var res = [];\n    for (var key in this.dimensions_) {\n      res[i++] = key + '-' + this.dimensions_[key];\n    }\n    return res.join('/');\n  };\n  \n  \n  /**\n   * Update the dimensions.\n   * @param {Object} dimensions Dimensions.\n   * @api\n   */\n  ol.source.WMTS.prototype.updateDimensions = function(dimensions) {\n    ol.obj.assign(this.dimensions_, dimensions);\n    this.setKey(this.getKeyForDimensions_());\n  };\n  \n  \n  /**\n   * Generate source options from a capabilities object.\n   * @param {Object} wmtsCap An object representing the capabilities document.\n   * @param {Object} config Configuration properties for the layer.  Defaults for\n   *                  the layer will apply if not provided.\n   *\n   * Required config properties:\n   *  - layer - {string} The layer identifier.\n   *\n   * Optional config properties:\n   *  - matrixSet - {string} The matrix set identifier, required if there is\n   *       more than one matrix set in the layer capabilities.\n   *  - projection - {string} The desired CRS when no matrixSet is specified.\n   *       eg: \"EPSG:3857\". If the desired projection is not available,\n   *       an error is thrown.\n   *  - requestEncoding - {string} url encoding format for the layer. Default is\n   *       the first tile url format found in the GetCapabilities response.\n   *  - style - {string} The name of the style\n   *  - format - {string} Image format for the layer. Default is the first\n   *       format returned in the GetCapabilities response.\n   *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.\n   * @return {?olx.source.WMTSOptions} WMTS source options object or `null` if the layer was not found.\n   * @api\n   */\n  ol.source.WMTS.optionsFromCapabilities = function(wmtsCap, config) {\n    var layers = wmtsCap['Contents']['Layer'];\n    var l = ol.array.find(layers, function(elt, index, array) {\n      return elt['Identifier'] == config['layer'];\n    });\n    if (l === null) {\n      return null;\n    }\n    var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];\n    var idx, matrixSet, matrixLimits;\n    if (l['TileMatrixSetLink'].length > 1) {\n      if ('projection' in config) {\n        idx = ol.array.findIndex(l['TileMatrixSetLink'],\n            function(elt, index, array) {\n              var tileMatrixSet = ol.array.find(tileMatrixSets, function(el) {\n                return el['Identifier'] == elt['TileMatrixSet'];\n              });\n              var supportedCRS = tileMatrixSet['SupportedCRS'];\n              var proj1 = ol.proj.get(supportedCRS.replace(/urn:ogc:def:crs:(\\w+):(.*:)?(\\w+)$/, '$1:$3')) ||\n                  ol.proj.get(supportedCRS);\n              var proj2 = ol.proj.get(config['projection']);\n              if (proj1 && proj2) {\n                return ol.proj.equivalent(proj1, proj2);\n              } else {\n                return supportedCRS == config['projection'];\n              }\n            });\n      } else {\n        idx = ol.array.findIndex(l['TileMatrixSetLink'],\n            function(elt, index, array) {\n              return elt['TileMatrixSet'] == config['matrixSet'];\n            });\n      }\n    } else {\n      idx = 0;\n    }\n    if (idx < 0) {\n      idx = 0;\n    }\n    matrixSet = /** @type {string} */\n      (l['TileMatrixSetLink'][idx]['TileMatrixSet']);\n    matrixLimits = /** @type {Array.<Object>} */\n      (l['TileMatrixSetLink'][idx]['TileMatrixSetLimits']);\n  \n    var format = /** @type {string} */ (l['Format'][0]);\n    if ('format' in config) {\n      format = config['format'];\n    }\n    idx = ol.array.findIndex(l['Style'], function(elt, index, array) {\n      if ('style' in config) {\n        return elt['Title'] == config['style'];\n      } else {\n        return elt['isDefault'];\n      }\n    });\n    if (idx < 0) {\n      idx = 0;\n    }\n    var style = /** @type {string} */ (l['Style'][idx]['Identifier']);\n  \n    var dimensions = {};\n    if ('Dimension' in l) {\n      l['Dimension'].forEach(function(elt, index, array) {\n        var key = elt['Identifier'];\n        var value = elt['Default'];\n        if (value === undefined) {\n          value = elt['Value'][0];\n        }\n        dimensions[key] = value;\n      });\n    }\n  \n    var matrixSets = wmtsCap['Contents']['TileMatrixSet'];\n    var matrixSetObj = ol.array.find(matrixSets, function(elt, index, array) {\n      return elt['Identifier'] == matrixSet;\n    });\n  \n    var projection;\n    var code = matrixSetObj['SupportedCRS'];\n    if (code) {\n      projection = ol.proj.get(code.replace(/urn:ogc:def:crs:(\\w+):(.*:)?(\\w+)$/, '$1:$3')) ||\n          ol.proj.get(code);\n    }\n    if ('projection' in config) {\n      var projConfig = ol.proj.get(config['projection']);\n      if (projConfig) {\n        if (!projection || ol.proj.equivalent(projConfig, projection)) {\n          projection = projConfig;\n        }\n      }\n    }\n  \n    var wgs84BoundingBox = l['WGS84BoundingBox'];\n    var extent, wrapX;\n    if (wgs84BoundingBox !== undefined) {\n      var wgs84ProjectionExtent = ol.proj.get('EPSG:4326').getExtent();\n      wrapX = (wgs84BoundingBox[0] == wgs84ProjectionExtent[0] &&\n          wgs84BoundingBox[2] == wgs84ProjectionExtent[2]);\n      extent = ol.proj.transformExtent(\n          wgs84BoundingBox, 'EPSG:4326', projection);\n      var projectionExtent = projection.getExtent();\n      if (projectionExtent) {\n        // If possible, do a sanity check on the extent - it should never be\n        // bigger than the validity extent of the projection of a matrix set.\n        if (!ol.extent.containsExtent(projectionExtent, extent)) {\n          extent = undefined;\n        }\n      }\n    }\n  \n    var tileGrid = ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet(\n        matrixSetObj, extent, matrixLimits);\n  \n    /** @type {!Array.<string>} */\n    var urls = [];\n    var requestEncoding = config['requestEncoding'];\n    requestEncoding = requestEncoding !== undefined ? requestEncoding : '';\n  \n    if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {\n      var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];\n  \n      for (var i = 0, ii = gets.length; i < ii; ++i) {\n        if (gets[i]['Constraint']) {\n          var constraint = ol.array.find(gets[i]['Constraint'], function(element) {\n            return element['name'] == 'GetEncoding';\n          });\n          var encodings = constraint['AllowedValues']['Value'];\n  \n          if (requestEncoding === '') {\n            // requestEncoding not provided, use the first encoding from the list\n            requestEncoding = encodings[0];\n          }\n          if (requestEncoding === ol.source.WMTSRequestEncoding.KVP) {\n            if (ol.array.includes(encodings, ol.source.WMTSRequestEncoding.KVP)) {\n              urls.push(/** @type {string} */ (gets[i]['href']));\n            }\n          } else {\n            break;\n          }\n        } else if (gets[i]['href']) {\n          requestEncoding = ol.source.WMTSRequestEncoding.KVP;\n          urls.push(/** @type {string} */ (gets[i]['href']));\n        }\n      }\n    }\n    if (urls.length === 0) {\n      requestEncoding = ol.source.WMTSRequestEncoding.REST;\n      l['ResourceURL'].forEach(function(element) {\n        if (element['resourceType'] === 'tile') {\n          format = element['format'];\n          urls.push(/** @type {string} */ (element['template']));\n        }\n      });\n    }\n  \n    return {\n      urls: urls,\n      layer: config['layer'],\n      matrixSet: matrixSet,\n      format: format,\n      projection: projection,\n      requestEncoding: requestEncoding,\n      tileGrid: tileGrid,\n      style: style,\n      dimensions: dimensions,\n      wrapX: wrapX,\n      crossOrigin: config['crossOrigin']\n    };\n  };\n  \n  goog.provide('ol.source.Zoomify');\n  \n  goog.require('ol');\n  goog.require('ol.ImageTile');\n  goog.require('ol.TileState');\n  goog.require('ol.TileUrlFunction');\n  goog.require('ol.asserts');\n  goog.require('ol.dom');\n  goog.require('ol.extent');\n  goog.require('ol.size');\n  goog.require('ol.source.TileImage');\n  goog.require('ol.tilegrid.TileGrid');\n  \n  \n  /**\n   * @classdesc\n   * Layer source for tile data in Zoomify format (both Zoomify and Internet\n   * Imaging Protocol are supported).\n   *\n   * @constructor\n   * @extends {ol.source.TileImage}\n   * @param {olx.source.ZoomifyOptions=} opt_options Options.\n   * @api\n   */\n  ol.source.Zoomify = function(opt_options) {\n  \n    var options = opt_options || {};\n  \n    var size = options.size;\n    var tierSizeCalculation = options.tierSizeCalculation !== undefined ?\n      options.tierSizeCalculation :\n      ol.source.Zoomify.TierSizeCalculation_.DEFAULT;\n  \n    var imageWidth = size[0];\n    var imageHeight = size[1];\n    var extent = options.extent || [0, -size[1], size[0], 0];\n    var tierSizeInTiles = [];\n    var tileSize = options.tileSize || ol.DEFAULT_TILE_SIZE;\n    var tileSizeForTierSizeCalculation = tileSize;\n  \n    switch (tierSizeCalculation) {\n      case ol.source.Zoomify.TierSizeCalculation_.DEFAULT:\n        while (imageWidth > tileSizeForTierSizeCalculation || imageHeight > tileSizeForTierSizeCalculation) {\n          tierSizeInTiles.push([\n            Math.ceil(imageWidth / tileSizeForTierSizeCalculation),\n            Math.ceil(imageHeight / tileSizeForTierSizeCalculation)\n          ]);\n          tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;\n        }\n        break;\n      case ol.source.Zoomify.TierSizeCalculation_.TRUNCATED:\n        var width = imageWidth;\n        var height = imageHeight;\n        while (width > tileSizeForTierSizeCalculation || height > tileSizeForTierSizeCalculation) {\n          tierSizeInTiles.push([\n            Math.ceil(width / tileSizeForTierSizeCalculation),\n            Math.ceil(height / tileSizeForTierSizeCalculation)\n          ]);\n          width >>= 1;\n          height >>= 1;\n        }\n        break;\n      default:\n        ol.asserts.assert(false, 53); // Unknown `tierSizeCalculation` configured\n        break;\n    }\n  \n    tierSizeInTiles.push([1, 1]);\n    tierSizeInTiles.reverse();\n  \n    var resolutions = [1];\n    var tileCountUpToTier = [0];\n    var i, ii;\n    for (i = 1, ii = tierSizeInTiles.length; i < ii; i++) {\n      resolutions.push(1 << i);\n      tileCountUpToTier.push(\n          tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] +\n          tileCountUpToTier[i - 1]\n      );\n    }\n    resolutions.reverse();\n  \n    var tileGrid = new ol.tilegrid.TileGrid({\n      tileSize: tileSize,\n      extent: extent,\n      origin: ol.extent.getTopLeft(extent),\n      resolutions: resolutions\n    });\n  \n    var url = options.url;\n    if (url && url.indexOf('{TileGroup}') == -1 && url.indexOf('{tileIndex}') == -1) {\n      url += '{TileGroup}/{z}-{x}-{y}.jpg';\n    }\n    var urls = ol.TileUrlFunction.expandUrl(url);\n  \n    /**\n     * @param {string} template Template.\n     * @return {ol.TileUrlFunctionType} Tile URL function.\n     */\n    function createFromTemplate(template) {\n  \n      return (\n        /**\n         * @param {ol.TileCoord} tileCoord Tile Coordinate.\n         * @param {number} pixelRatio Pixel ratio.\n         * @param {ol.proj.Projection} projection Projection.\n         * @return {string|undefined} Tile URL.\n         */\n        function(tileCoord, pixelRatio, projection) {\n          if (!tileCoord) {\n            return undefined;\n          } else {\n            var tileCoordZ = tileCoord[0];\n            var tileCoordX = tileCoord[1];\n            var tileCoordY = -tileCoord[2] - 1;\n            var tileIndex =\n                tileCoordX +\n                tileCoordY * tierSizeInTiles[tileCoordZ][0];\n            var tileSize = tileGrid.getTileSize(tileCoordZ);\n            var tileGroup = ((tileIndex + tileCountUpToTier[tileCoordZ]) / tileSize) | 0;\n            var localContext = {\n              'z': tileCoordZ,\n              'x': tileCoordX,\n              'y': tileCoordY,\n              'tileIndex': tileIndex,\n              'TileGroup': 'TileGroup' + tileGroup\n            };\n            return template.replace(/\\{(\\w+?)\\}/g, function(m, p) {\n              return localContext[p];\n            });\n          }\n        });\n    }\n  \n    var tileUrlFunction = ol.TileUrlFunction.createFromTileUrlFunctions(urls.map(createFromTemplate));\n  \n    var ZoomifyTileClass = ol.source.Zoomify.Tile_.bind(null, tileGrid);\n  \n    ol.source.TileImage.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      logo: options.logo,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: ZoomifyTileClass,\n      tileGrid: tileGrid,\n      tileUrlFunction: tileUrlFunction,\n      transition: options.transition\n    });\n  \n  };\n  ol.inherits(ol.source.Zoomify, ol.source.TileImage);\n  \n  /**\n   * @constructor\n   * @extends {ol.ImageTile}\n   * @param {ol.tilegrid.TileGrid} tileGrid TileGrid that the tile belongs to.\n   * @param {ol.TileCoord} tileCoord Tile coordinate.\n   * @param {ol.TileState} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.\n   * @param {olx.TileOptions=} opt_options Tile options.\n   * @private\n   */\n  ol.source.Zoomify.Tile_ = function(\n      tileGrid, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {\n  \n    ol.ImageTile.call(this, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options);\n  \n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}\n     */\n    this.zoomifyImage_ = null;\n  \n    /**\n     * @private\n     * @type {ol.Size}\n     */\n    this.tileSize_ = ol.size.toSize(tileGrid.getTileSize(tileCoord[0]));\n  };\n  ol.inherits(ol.source.Zoomify.Tile_, ol.ImageTile);\n  \n  \n  /**\n   * @inheritDoc\n   */\n  ol.source.Zoomify.Tile_.prototype.getImage = function() {\n    if (this.zoomifyImage_) {\n      return this.zoomifyImage_;\n    }\n    var image = ol.ImageTile.prototype.getImage.call(this);\n    if (this.state == ol.TileState.LOADED) {\n      var tileSize = this.tileSize_;\n      if (image.width == tileSize[0] && image.height == tileSize[1]) {\n        this.zoomifyImage_ = image;\n        return image;\n      } else {\n        var context = ol.dom.createCanvasContext2D(tileSize[0], tileSize[1]);\n        context.drawImage(image, 0, 0);\n        this.zoomifyImage_ = context.canvas;\n        return context.canvas;\n      }\n    } else {\n      return image;\n    }\n  };\n  \n  /**\n   * @enum {string}\n   * @private\n   */\n  ol.source.Zoomify.TierSizeCalculation_ = {\n    DEFAULT: 'default',\n    TRUNCATED: 'truncated'\n  };\n  \n  // Copyright 2009 The Closure Library Authors.\n  // All Rights Reserved.\n  //\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  //      http://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS-IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n  //\n  // This file has been auto-generated by GenJsDeps, please do not edit.\n  \n  goog.addDependency(\n      'demos/editor/equationeditor.js', ['goog.demos.editor.EquationEditor'],\n      ['goog.ui.equation.EquationEditorDialog']);\n  goog.addDependency(\n      'demos/editor/helloworld.js', ['goog.demos.editor.HelloWorld'],\n      ['goog.dom', 'goog.dom.TagName', 'goog.editor.Plugin']);\n  goog.addDependency(\n      'demos/editor/helloworlddialog.js',\n      [\n        'goog.demos.editor.HelloWorldDialog',\n        'goog.demos.editor.HelloWorldDialog.OkEvent'\n      ],\n      [\n        'goog.dom.TagName', 'goog.events.Event', 'goog.string',\n        'goog.ui.editor.AbstractDialog', 'goog.ui.editor.AbstractDialog.Builder',\n        'goog.ui.editor.AbstractDialog.EventType'\n      ]);\n  goog.addDependency(\n      'demos/editor/helloworlddialogplugin.js',\n      [\n        'goog.demos.editor.HelloWorldDialogPlugin',\n        'goog.demos.editor.HelloWorldDialogPlugin.Command'\n      ],\n      [\n        'goog.demos.editor.HelloWorldDialog', 'goog.dom.TagName',\n        'goog.editor.plugins.AbstractDialogPlugin', 'goog.editor.range',\n        'goog.functions', 'goog.ui.editor.AbstractDialog.EventType'\n      ]);\n  \n  /**\n   * @fileoverview Custom exports file.\n   * @suppress {checkVars,extraRequire}\n   */\n  \n  goog.require('ol');\n  goog.require('ol.AssertionError');\n  goog.require('ol.Attribution');\n  goog.require('ol.CanvasMap');\n  goog.require('ol.Collection');\n  goog.require('ol.DeviceOrientation');\n  goog.require('ol.Feature');\n  goog.require('ol.Geolocation');\n  goog.require('ol.Graticule');\n  goog.require('ol.Image');\n  goog.require('ol.ImageTile');\n  goog.require('ol.Kinetic');\n  goog.require('ol.Map');\n  goog.require('ol.MapBrowserEvent');\n  goog.require('ol.MapEvent');\n  goog.require('ol.Object');\n  goog.require('ol.Observable');\n  goog.require('ol.Overlay');\n  goog.require('ol.PluggableMap');\n  goog.require('ol.Sphere');\n  goog.require('ol.Tile');\n  goog.require('ol.VectorTile');\n  goog.require('ol.View');\n  goog.require('ol.color');\n  goog.require('ol.colorlike');\n  goog.require('ol.control');\n  goog.require('ol.control.Attribution');\n  goog.require('ol.control.Control');\n  goog.require('ol.control.FullScreen');\n  goog.require('ol.control.MousePosition');\n  goog.require('ol.control.OverviewMap');\n  goog.require('ol.control.Rotate');\n  goog.require('ol.control.ScaleLine');\n  goog.require('ol.control.Zoom');\n  goog.require('ol.control.ZoomSlider');\n  goog.require('ol.control.ZoomToExtent');\n  goog.require('ol.coordinate');\n  goog.require('ol.easing');\n  goog.require('ol.events.Event');\n  goog.require('ol.events.condition');\n  goog.require('ol.extent');\n  goog.require('ol.featureloader');\n  goog.require('ol.format.EsriJSON');\n  goog.require('ol.format.Feature');\n  goog.require('ol.format.GML');\n  goog.require('ol.format.GML2');\n  goog.require('ol.format.GML3');\n  goog.require('ol.format.GMLBase');\n  goog.require('ol.format.GPX');\n  goog.require('ol.format.GeoJSON');\n  goog.require('ol.format.IGC');\n  goog.require('ol.format.KML');\n  goog.require('ol.format.MVT');\n  goog.require('ol.format.OSMXML');\n  goog.require('ol.format.Polyline');\n  goog.require('ol.format.TopoJSON');\n  goog.require('ol.format.WFS');\n  goog.require('ol.format.WKT');\n  goog.require('ol.format.WMSCapabilities');\n  goog.require('ol.format.WMSGetFeatureInfo');\n  goog.require('ol.format.WMTSCapabilities');\n  goog.require('ol.format.filter');\n  goog.require('ol.format.filter.And');\n  goog.require('ol.format.filter.Bbox');\n  goog.require('ol.format.filter.Comparison');\n  goog.require('ol.format.filter.ComparisonBinary');\n  goog.require('ol.format.filter.Contains');\n  goog.require('ol.format.filter.During');\n  goog.require('ol.format.filter.EqualTo');\n  goog.require('ol.format.filter.Filter');\n  goog.require('ol.format.filter.GreaterThan');\n  goog.require('ol.format.filter.GreaterThanOrEqualTo');\n  goog.require('ol.format.filter.Intersects');\n  goog.require('ol.format.filter.IsBetween');\n  goog.require('ol.format.filter.IsLike');\n  goog.require('ol.format.filter.IsNull');\n  goog.require('ol.format.filter.LessThan');\n  goog.require('ol.format.filter.LessThanOrEqualTo');\n  goog.require('ol.format.filter.Not');\n  goog.require('ol.format.filter.NotEqualTo');\n  goog.require('ol.format.filter.Or');\n  goog.require('ol.format.filter.Spatial');\n  goog.require('ol.format.filter.Within');\n  goog.require('ol.geom.Circle');\n  goog.require('ol.geom.Geometry');\n  goog.require('ol.geom.GeometryCollection');\n  goog.require('ol.geom.LineString');\n  goog.require('ol.geom.LinearRing');\n  goog.require('ol.geom.MultiLineString');\n  goog.require('ol.geom.MultiPoint');\n  goog.require('ol.geom.MultiPolygon');\n  goog.require('ol.geom.Point');\n  goog.require('ol.geom.Polygon');\n  goog.require('ol.geom.SimpleGeometry');\n  goog.require('ol.has');\n  goog.require('ol.interaction');\n  goog.require('ol.interaction.DoubleClickZoom');\n  goog.require('ol.interaction.DragAndDrop');\n  goog.require('ol.interaction.DragBox');\n  goog.require('ol.interaction.DragPan');\n  goog.require('ol.interaction.DragRotate');\n  goog.require('ol.interaction.DragRotateAndZoom');\n  goog.require('ol.interaction.DragZoom');\n  goog.require('ol.interaction.Draw');\n  goog.require('ol.interaction.Extent');\n  goog.require('ol.interaction.Interaction');\n  goog.require('ol.interaction.KeyboardPan');\n  goog.require('ol.interaction.KeyboardZoom');\n  goog.require('ol.interaction.Modify');\n  goog.require('ol.interaction.MouseWheelZoom');\n  goog.require('ol.interaction.PinchRotate');\n  goog.require('ol.interaction.PinchZoom');\n  goog.require('ol.interaction.Pointer');\n  goog.require('ol.interaction.Select');\n  goog.require('ol.interaction.Snap');\n  goog.require('ol.interaction.Translate');\n  goog.require('ol.layer.Base');\n  goog.require('ol.layer.Group');\n  goog.require('ol.layer.Heatmap');\n  goog.require('ol.layer.Image');\n  goog.require('ol.layer.Layer');\n  goog.require('ol.layer.Tile');\n  goog.require('ol.layer.Vector');\n  goog.require('ol.layer.VectorTile');\n  goog.require('ol.loadingstrategy');\n  goog.require('ol.proj');\n  goog.require('ol.proj.Projection');\n  goog.require('ol.proj.Units');\n  goog.require('ol.proj.common');\n  goog.require('ol.render');\n  goog.require('ol.render.Event');\n  goog.require('ol.render.Feature');\n  goog.require('ol.render.VectorContext');\n  goog.require('ol.render.canvas.Immediate');\n  goog.require('ol.render.webgl.Immediate');\n  goog.require('ol.renderer.canvas.ImageLayer');\n  goog.require('ol.renderer.canvas.Map');\n  goog.require('ol.renderer.canvas.TileLayer');\n  goog.require('ol.renderer.canvas.VectorLayer');\n  goog.require('ol.renderer.canvas.VectorTileLayer');\n  goog.require('ol.renderer.webgl.ImageLayer');\n  goog.require('ol.renderer.webgl.Map');\n  goog.require('ol.renderer.webgl.TileLayer');\n  goog.require('ol.renderer.webgl.VectorLayer');\n  goog.require('ol.size');\n  goog.require('ol.source.BingMaps');\n  goog.require('ol.source.CartoDB');\n  goog.require('ol.source.Cluster');\n  goog.require('ol.source.Image');\n  goog.require('ol.source.ImageArcGISRest');\n  goog.require('ol.source.ImageCanvas');\n  goog.require('ol.source.ImageMapGuide');\n  goog.require('ol.source.ImageStatic');\n  goog.require('ol.source.ImageVector');\n  goog.require('ol.source.ImageWMS');\n  goog.require('ol.source.OSM');\n  goog.require('ol.source.Raster');\n  goog.require('ol.source.Source');\n  goog.require('ol.source.Stamen');\n  goog.require('ol.source.Tile');\n  goog.require('ol.source.TileArcGISRest');\n  goog.require('ol.source.TileDebug');\n  goog.require('ol.source.TileImage');\n  goog.require('ol.source.TileJSON');\n  goog.require('ol.source.TileUTFGrid');\n  goog.require('ol.source.TileWMS');\n  goog.require('ol.source.UrlTile');\n  goog.require('ol.source.Vector');\n  goog.require('ol.source.VectorTile');\n  goog.require('ol.source.WMTS');\n  goog.require('ol.source.XYZ');\n  goog.require('ol.source.Zoomify');\n  goog.require('ol.style');\n  goog.require('ol.style.AtlasManager');\n  goog.require('ol.style.Circle');\n  goog.require('ol.style.Fill');\n  goog.require('ol.style.Icon');\n  goog.require('ol.style.IconImageCache');\n  goog.require('ol.style.Image');\n  goog.require('ol.style.RegularShape');\n  goog.require('ol.style.Stroke');\n  goog.require('ol.style.Style');\n  goog.require('ol.style.Text');\n  goog.require('ol.tilegrid');\n  goog.require('ol.tilegrid.TileGrid');\n  goog.require('ol.tilegrid.WMTS');\n  goog.require('ol.webgl.Context');\n  goog.require('ol.xml');\n  \n  \n  \n  goog.exportProperty(\n      ol.AssertionError.prototype,\n      'code',\n      ol.AssertionError.prototype.code);\n  \n  goog.exportSymbol(\n      'ol.Attribution',\n      ol.Attribution,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Attribution.prototype,\n      'getHTML',\n      ol.Attribution.prototype.getHTML);\n  \n  goog.exportSymbol(\n      'ol.CanvasMap',\n      ol.CanvasMap,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.Collection',\n      ol.Collection,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'clear',\n      ol.Collection.prototype.clear);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'extend',\n      ol.Collection.prototype.extend);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'forEach',\n      ol.Collection.prototype.forEach);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'getArray',\n      ol.Collection.prototype.getArray);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'item',\n      ol.Collection.prototype.item);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'getLength',\n      ol.Collection.prototype.getLength);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'insertAt',\n      ol.Collection.prototype.insertAt);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'pop',\n      ol.Collection.prototype.pop);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'push',\n      ol.Collection.prototype.push);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'remove',\n      ol.Collection.prototype.remove);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'removeAt',\n      ol.Collection.prototype.removeAt);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'setAt',\n      ol.Collection.prototype.setAt);\n  \n  goog.exportProperty(\n      ol.Collection.Event.prototype,\n      'element',\n      ol.Collection.Event.prototype.element);\n  \n  goog.exportSymbol(\n      'ol.color.asArray',\n      ol.color.asArray,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.color.asString',\n      ol.color.asString,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.colorlike.asColorLike',\n      ol.colorlike.asColorLike,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.defaults',\n      ol.control.defaults,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.coordinate.add',\n      ol.coordinate.add,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.coordinate.createStringXY',\n      ol.coordinate.createStringXY,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.coordinate.format',\n      ol.coordinate.format,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.coordinate.rotate',\n      ol.coordinate.rotate,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.coordinate.toStringHDMS',\n      ol.coordinate.toStringHDMS,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.coordinate.toStringXY',\n      ol.coordinate.toStringXY,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.DeviceOrientation',\n      ol.DeviceOrientation,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'getAlpha',\n      ol.DeviceOrientation.prototype.getAlpha);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'getBeta',\n      ol.DeviceOrientation.prototype.getBeta);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'getGamma',\n      ol.DeviceOrientation.prototype.getGamma);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'getHeading',\n      ol.DeviceOrientation.prototype.getHeading);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'getTracking',\n      ol.DeviceOrientation.prototype.getTracking);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'setTracking',\n      ol.DeviceOrientation.prototype.setTracking);\n  \n  goog.exportSymbol(\n      'ol.easing.easeIn',\n      ol.easing.easeIn,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.easing.easeOut',\n      ol.easing.easeOut,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.easing.inAndOut',\n      ol.easing.inAndOut,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.easing.linear',\n      ol.easing.linear,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.easing.upAndDown',\n      ol.easing.upAndDown,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.boundingExtent',\n      ol.extent.boundingExtent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.buffer',\n      ol.extent.buffer,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.containsCoordinate',\n      ol.extent.containsCoordinate,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.containsExtent',\n      ol.extent.containsExtent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.containsXY',\n      ol.extent.containsXY,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.createEmpty',\n      ol.extent.createEmpty,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.equals',\n      ol.extent.equals,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.extend',\n      ol.extent.extend,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getArea',\n      ol.extent.getArea,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getBottomLeft',\n      ol.extent.getBottomLeft,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getBottomRight',\n      ol.extent.getBottomRight,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getCenter',\n      ol.extent.getCenter,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getHeight',\n      ol.extent.getHeight,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getIntersection',\n      ol.extent.getIntersection,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getSize',\n      ol.extent.getSize,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getTopLeft',\n      ol.extent.getTopLeft,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getTopRight',\n      ol.extent.getTopRight,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.getWidth',\n      ol.extent.getWidth,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.intersects',\n      ol.extent.intersects,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.isEmpty',\n      ol.extent.isEmpty,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.extent.applyTransform',\n      ol.extent.applyTransform,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.Feature',\n      ol.Feature,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'clone',\n      ol.Feature.prototype.clone);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'getGeometry',\n      ol.Feature.prototype.getGeometry);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'getId',\n      ol.Feature.prototype.getId);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'getGeometryName',\n      ol.Feature.prototype.getGeometryName);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'getStyle',\n      ol.Feature.prototype.getStyle);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'getStyleFunction',\n      ol.Feature.prototype.getStyleFunction);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'setGeometry',\n      ol.Feature.prototype.setGeometry);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'setStyle',\n      ol.Feature.prototype.setStyle);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'setId',\n      ol.Feature.prototype.setId);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'setGeometryName',\n      ol.Feature.prototype.setGeometryName);\n  \n  goog.exportSymbol(\n      'ol.featureloader.xhr',\n      ol.featureloader.xhr,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.Geolocation',\n      ol.Geolocation,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getAccuracy',\n      ol.Geolocation.prototype.getAccuracy);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getAccuracyGeometry',\n      ol.Geolocation.prototype.getAccuracyGeometry);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getAltitude',\n      ol.Geolocation.prototype.getAltitude);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getAltitudeAccuracy',\n      ol.Geolocation.prototype.getAltitudeAccuracy);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getHeading',\n      ol.Geolocation.prototype.getHeading);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getPosition',\n      ol.Geolocation.prototype.getPosition);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getProjection',\n      ol.Geolocation.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getSpeed',\n      ol.Geolocation.prototype.getSpeed);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getTracking',\n      ol.Geolocation.prototype.getTracking);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getTrackingOptions',\n      ol.Geolocation.prototype.getTrackingOptions);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'setProjection',\n      ol.Geolocation.prototype.setProjection);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'setTracking',\n      ol.Geolocation.prototype.setTracking);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'setTrackingOptions',\n      ol.Geolocation.prototype.setTrackingOptions);\n  \n  goog.exportSymbol(\n      'ol.Graticule',\n      ol.Graticule,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Graticule.prototype,\n      'getMap',\n      ol.Graticule.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.Graticule.prototype,\n      'getMeridians',\n      ol.Graticule.prototype.getMeridians);\n  \n  goog.exportProperty(\n      ol.Graticule.prototype,\n      'getParallels',\n      ol.Graticule.prototype.getParallels);\n  \n  goog.exportProperty(\n      ol.Graticule.prototype,\n      'setMap',\n      ol.Graticule.prototype.setMap);\n  \n  goog.exportSymbol(\n      'ol.has.DEVICE_PIXEL_RATIO',\n      ol.has.DEVICE_PIXEL_RATIO,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.has.CANVAS',\n      ol.has.CANVAS,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.has.DEVICE_ORIENTATION',\n      ol.has.DEVICE_ORIENTATION,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.has.GEOLOCATION',\n      ol.has.GEOLOCATION,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.has.TOUCH',\n      ol.has.TOUCH,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.has.WEBGL',\n      ol.has.WEBGL,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Image.prototype,\n      'getImage',\n      ol.Image.prototype.getImage);\n  \n  goog.exportProperty(\n      ol.Image.prototype,\n      'load',\n      ol.Image.prototype.load);\n  \n  goog.exportProperty(\n      ol.ImageTile.prototype,\n      'getImage',\n      ol.ImageTile.prototype.getImage);\n  \n  goog.exportSymbol(\n      'ol.inherits',\n      ol.inherits,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.defaults',\n      ol.interaction.defaults,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.Kinetic',\n      ol.Kinetic,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.loadingstrategy.all',\n      ol.loadingstrategy.all,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.loadingstrategy.bbox',\n      ol.loadingstrategy.bbox,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.loadingstrategy.tile',\n      ol.loadingstrategy.tile,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.Map',\n      ol.Map,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'originalEvent',\n      ol.MapBrowserEvent.prototype.originalEvent);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'pixel',\n      ol.MapBrowserEvent.prototype.pixel);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'coordinate',\n      ol.MapBrowserEvent.prototype.coordinate);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'dragging',\n      ol.MapBrowserEvent.prototype.dragging);\n  \n  goog.exportProperty(\n      ol.MapEvent.prototype,\n      'map',\n      ol.MapEvent.prototype.map);\n  \n  goog.exportProperty(\n      ol.MapEvent.prototype,\n      'frameState',\n      ol.MapEvent.prototype.frameState);\n  \n  goog.exportSymbol(\n      'ol.Object',\n      ol.Object,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'get',\n      ol.Object.prototype.get);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'getKeys',\n      ol.Object.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'getProperties',\n      ol.Object.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'set',\n      ol.Object.prototype.set);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'setProperties',\n      ol.Object.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'unset',\n      ol.Object.prototype.unset);\n  \n  goog.exportProperty(\n      ol.Object.Event.prototype,\n      'key',\n      ol.Object.Event.prototype.key);\n  \n  goog.exportProperty(\n      ol.Object.Event.prototype,\n      'oldValue',\n      ol.Object.Event.prototype.oldValue);\n  \n  goog.exportSymbol(\n      'ol.Observable',\n      ol.Observable,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.Observable.unByKey',\n      ol.Observable.unByKey,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Observable.prototype,\n      'changed',\n      ol.Observable.prototype.changed);\n  \n  goog.exportProperty(\n      ol.Observable.prototype,\n      'dispatchEvent',\n      ol.Observable.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.Observable.prototype,\n      'getRevision',\n      ol.Observable.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.Observable.prototype,\n      'on',\n      ol.Observable.prototype.on);\n  \n  goog.exportProperty(\n      ol.Observable.prototype,\n      'once',\n      ol.Observable.prototype.once);\n  \n  goog.exportProperty(\n      ol.Observable.prototype,\n      'un',\n      ol.Observable.prototype.un);\n  \n  goog.exportSymbol(\n      'ol.Overlay',\n      ol.Overlay,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getElement',\n      ol.Overlay.prototype.getElement);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getId',\n      ol.Overlay.prototype.getId);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getMap',\n      ol.Overlay.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getOffset',\n      ol.Overlay.prototype.getOffset);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getPosition',\n      ol.Overlay.prototype.getPosition);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getPositioning',\n      ol.Overlay.prototype.getPositioning);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'setElement',\n      ol.Overlay.prototype.setElement);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'setMap',\n      ol.Overlay.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'setOffset',\n      ol.Overlay.prototype.setOffset);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'setPosition',\n      ol.Overlay.prototype.setPosition);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'setPositioning',\n      ol.Overlay.prototype.setPositioning);\n  \n  goog.exportSymbol(\n      'ol.PluggableMap',\n      ol.PluggableMap,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'addControl',\n      ol.PluggableMap.prototype.addControl);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'addInteraction',\n      ol.PluggableMap.prototype.addInteraction);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'addLayer',\n      ol.PluggableMap.prototype.addLayer);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'addOverlay',\n      ol.PluggableMap.prototype.addOverlay);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'forEachFeatureAtPixel',\n      ol.PluggableMap.prototype.forEachFeatureAtPixel);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getFeaturesAtPixel',\n      ol.PluggableMap.prototype.getFeaturesAtPixel);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'forEachLayerAtPixel',\n      ol.PluggableMap.prototype.forEachLayerAtPixel);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'hasFeatureAtPixel',\n      ol.PluggableMap.prototype.hasFeatureAtPixel);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getEventCoordinate',\n      ol.PluggableMap.prototype.getEventCoordinate);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getEventPixel',\n      ol.PluggableMap.prototype.getEventPixel);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getTarget',\n      ol.PluggableMap.prototype.getTarget);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getTargetElement',\n      ol.PluggableMap.prototype.getTargetElement);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getCoordinateFromPixel',\n      ol.PluggableMap.prototype.getCoordinateFromPixel);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getControls',\n      ol.PluggableMap.prototype.getControls);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getOverlays',\n      ol.PluggableMap.prototype.getOverlays);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getOverlayById',\n      ol.PluggableMap.prototype.getOverlayById);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getInteractions',\n      ol.PluggableMap.prototype.getInteractions);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getLayerGroup',\n      ol.PluggableMap.prototype.getLayerGroup);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getLayers',\n      ol.PluggableMap.prototype.getLayers);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getPixelFromCoordinate',\n      ol.PluggableMap.prototype.getPixelFromCoordinate);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getSize',\n      ol.PluggableMap.prototype.getSize);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getView',\n      ol.PluggableMap.prototype.getView);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getViewport',\n      ol.PluggableMap.prototype.getViewport);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'renderSync',\n      ol.PluggableMap.prototype.renderSync);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'render',\n      ol.PluggableMap.prototype.render);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'removeControl',\n      ol.PluggableMap.prototype.removeControl);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'removeInteraction',\n      ol.PluggableMap.prototype.removeInteraction);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'removeLayer',\n      ol.PluggableMap.prototype.removeLayer);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'removeOverlay',\n      ol.PluggableMap.prototype.removeOverlay);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'setLayerGroup',\n      ol.PluggableMap.prototype.setLayerGroup);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'setSize',\n      ol.PluggableMap.prototype.setSize);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'setTarget',\n      ol.PluggableMap.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'setView',\n      ol.PluggableMap.prototype.setView);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'updateSize',\n      ol.PluggableMap.prototype.updateSize);\n  \n  goog.exportSymbol(\n      'ol.proj.METERS_PER_UNIT',\n      ol.proj.METERS_PER_UNIT,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.setProj4',\n      ol.proj.setProj4,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.getPointResolution',\n      ol.proj.getPointResolution,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.addEquivalentProjections',\n      ol.proj.addEquivalentProjections,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.addProjection',\n      ol.proj.addProjection,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.addCoordinateTransforms',\n      ol.proj.addCoordinateTransforms,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.fromLonLat',\n      ol.proj.fromLonLat,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.toLonLat',\n      ol.proj.toLonLat,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.get',\n      ol.proj.get,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.equivalent',\n      ol.proj.equivalent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.getTransform',\n      ol.proj.getTransform,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.transform',\n      ol.proj.transform,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.transformExtent',\n      ol.proj.transformExtent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.render.toContext',\n      ol.render.toContext,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.size.toSize',\n      ol.size.toSize,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.Sphere',\n      ol.Sphere,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Sphere.prototype,\n      'geodesicArea',\n      ol.Sphere.prototype.geodesicArea);\n  \n  goog.exportProperty(\n      ol.Sphere.prototype,\n      'haversineDistance',\n      ol.Sphere.prototype.haversineDistance);\n  \n  goog.exportSymbol(\n      'ol.Sphere.getLength',\n      ol.Sphere.getLength,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.Sphere.getArea',\n      ol.Sphere.getArea,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.style.iconImageCache',\n      ol.style.iconImageCache,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Tile.prototype,\n      'getTileCoord',\n      ol.Tile.prototype.getTileCoord);\n  \n  goog.exportProperty(\n      ol.Tile.prototype,\n      'load',\n      ol.Tile.prototype.load);\n  \n  goog.exportSymbol(\n      'ol.tilegrid.createXYZ',\n      ol.tilegrid.createXYZ,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'getExtent',\n      ol.VectorTile.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'getFormat',\n      ol.VectorTile.prototype.getFormat);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'getFeatures',\n      ol.VectorTile.prototype.getFeatures);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'getProjection',\n      ol.VectorTile.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'setExtent',\n      ol.VectorTile.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'setFeatures',\n      ol.VectorTile.prototype.setFeatures);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'setProjection',\n      ol.VectorTile.prototype.setProjection);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'setLoader',\n      ol.VectorTile.prototype.setLoader);\n  \n  goog.exportSymbol(\n      'ol.View',\n      ol.View,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'animate',\n      ol.View.prototype.animate);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getAnimating',\n      ol.View.prototype.getAnimating);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getInteracting',\n      ol.View.prototype.getInteracting);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'cancelAnimations',\n      ol.View.prototype.cancelAnimations);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'constrainCenter',\n      ol.View.prototype.constrainCenter);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'constrainResolution',\n      ol.View.prototype.constrainResolution);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'constrainRotation',\n      ol.View.prototype.constrainRotation);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getCenter',\n      ol.View.prototype.getCenter);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'calculateExtent',\n      ol.View.prototype.calculateExtent);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getMaxResolution',\n      ol.View.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getMinResolution',\n      ol.View.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getMaxZoom',\n      ol.View.prototype.getMaxZoom);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'setMaxZoom',\n      ol.View.prototype.setMaxZoom);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getMinZoom',\n      ol.View.prototype.getMinZoom);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'setMinZoom',\n      ol.View.prototype.setMinZoom);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getProjection',\n      ol.View.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getResolution',\n      ol.View.prototype.getResolution);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getResolutions',\n      ol.View.prototype.getResolutions);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getResolutionForExtent',\n      ol.View.prototype.getResolutionForExtent);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getRotation',\n      ol.View.prototype.getRotation);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getZoom',\n      ol.View.prototype.getZoom);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getZoomForResolution',\n      ol.View.prototype.getZoomForResolution);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getResolutionForZoom',\n      ol.View.prototype.getResolutionForZoom);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'fit',\n      ol.View.prototype.fit);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'centerOn',\n      ol.View.prototype.centerOn);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'rotate',\n      ol.View.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'setCenter',\n      ol.View.prototype.setCenter);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'setResolution',\n      ol.View.prototype.setResolution);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'setRotation',\n      ol.View.prototype.setRotation);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'setZoom',\n      ol.View.prototype.setZoom);\n  \n  goog.exportSymbol(\n      'ol.xml.getAllTextContent',\n      ol.xml.getAllTextContent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.xml.parse',\n      ol.xml.parse,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.webgl.Context.prototype,\n      'getGL',\n      ol.webgl.Context.prototype.getGL);\n  \n  goog.exportProperty(\n      ol.webgl.Context.prototype,\n      'useProgram',\n      ol.webgl.Context.prototype.useProgram);\n  \n  goog.exportSymbol(\n      'ol.tilegrid.TileGrid',\n      ol.tilegrid.TileGrid,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'forEachTileCoord',\n      ol.tilegrid.TileGrid.prototype.forEachTileCoord);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getMaxZoom',\n      ol.tilegrid.TileGrid.prototype.getMaxZoom);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getMinZoom',\n      ol.tilegrid.TileGrid.prototype.getMinZoom);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getOrigin',\n      ol.tilegrid.TileGrid.prototype.getOrigin);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getResolution',\n      ol.tilegrid.TileGrid.prototype.getResolution);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getResolutions',\n      ol.tilegrid.TileGrid.prototype.getResolutions);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getTileCoordExtent',\n      ol.tilegrid.TileGrid.prototype.getTileCoordExtent);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getTileCoordForCoordAndResolution',\n      ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndResolution);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getTileCoordForCoordAndZ',\n      ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndZ);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getTileSize',\n      ol.tilegrid.TileGrid.prototype.getTileSize);\n  \n  goog.exportProperty(\n      ol.tilegrid.TileGrid.prototype,\n      'getZForResolution',\n      ol.tilegrid.TileGrid.prototype.getZForResolution);\n  \n  goog.exportSymbol(\n      'ol.tilegrid.WMTS',\n      ol.tilegrid.WMTS,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getMatrixIds',\n      ol.tilegrid.WMTS.prototype.getMatrixIds);\n  \n  goog.exportSymbol(\n      'ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet',\n      ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.style.AtlasManager',\n      ol.style.AtlasManager,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.style.Circle',\n      ol.style.Circle,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'setRadius',\n      ol.style.Circle.prototype.setRadius);\n  \n  goog.exportSymbol(\n      'ol.style.Fill',\n      ol.style.Fill,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.style.Fill.prototype,\n      'clone',\n      ol.style.Fill.prototype.clone);\n  \n  goog.exportProperty(\n      ol.style.Fill.prototype,\n      'getColor',\n      ol.style.Fill.prototype.getColor);\n  \n  goog.exportProperty(\n      ol.style.Fill.prototype,\n      'setColor',\n      ol.style.Fill.prototype.setColor);\n  \n  goog.exportSymbol(\n      'ol.style.Icon',\n      ol.style.Icon,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'clone',\n      ol.style.Icon.prototype.clone);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getAnchor',\n      ol.style.Icon.prototype.getAnchor);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getColor',\n      ol.style.Icon.prototype.getColor);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getImage',\n      ol.style.Icon.prototype.getImage);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getOrigin',\n      ol.style.Icon.prototype.getOrigin);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getSrc',\n      ol.style.Icon.prototype.getSrc);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getSize',\n      ol.style.Icon.prototype.getSize);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'load',\n      ol.style.Icon.prototype.load);\n  \n  goog.exportProperty(\n      ol.style.IconImageCache.prototype,\n      'setSize',\n      ol.style.IconImageCache.prototype.setSize);\n  \n  goog.exportSymbol(\n      'ol.style.Image',\n      ol.style.Image,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.style.Image.prototype,\n      'getOpacity',\n      ol.style.Image.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.style.Image.prototype,\n      'getRotateWithView',\n      ol.style.Image.prototype.getRotateWithView);\n  \n  goog.exportProperty(\n      ol.style.Image.prototype,\n      'getRotation',\n      ol.style.Image.prototype.getRotation);\n  \n  goog.exportProperty(\n      ol.style.Image.prototype,\n      'getScale',\n      ol.style.Image.prototype.getScale);\n  \n  goog.exportProperty(\n      ol.style.Image.prototype,\n      'getSnapToPixel',\n      ol.style.Image.prototype.getSnapToPixel);\n  \n  goog.exportProperty(\n      ol.style.Image.prototype,\n      'setOpacity',\n      ol.style.Image.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.style.Image.prototype,\n      'setRotation',\n      ol.style.Image.prototype.setRotation);\n  \n  goog.exportProperty(\n      ol.style.Image.prototype,\n      'setScale',\n      ol.style.Image.prototype.setScale);\n  \n  goog.exportSymbol(\n      'ol.style.RegularShape',\n      ol.style.RegularShape,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'clone',\n      ol.style.RegularShape.prototype.clone);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getAnchor',\n      ol.style.RegularShape.prototype.getAnchor);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getAngle',\n      ol.style.RegularShape.prototype.getAngle);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getFill',\n      ol.style.RegularShape.prototype.getFill);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getImage',\n      ol.style.RegularShape.prototype.getImage);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getOrigin',\n      ol.style.RegularShape.prototype.getOrigin);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getPoints',\n      ol.style.RegularShape.prototype.getPoints);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getRadius',\n      ol.style.RegularShape.prototype.getRadius);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getRadius2',\n      ol.style.RegularShape.prototype.getRadius2);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getSize',\n      ol.style.RegularShape.prototype.getSize);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getStroke',\n      ol.style.RegularShape.prototype.getStroke);\n  \n  goog.exportSymbol(\n      'ol.style.Stroke',\n      ol.style.Stroke,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'clone',\n      ol.style.Stroke.prototype.clone);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'getColor',\n      ol.style.Stroke.prototype.getColor);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'getLineCap',\n      ol.style.Stroke.prototype.getLineCap);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'getLineDash',\n      ol.style.Stroke.prototype.getLineDash);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'getLineDashOffset',\n      ol.style.Stroke.prototype.getLineDashOffset);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'getLineJoin',\n      ol.style.Stroke.prototype.getLineJoin);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'getMiterLimit',\n      ol.style.Stroke.prototype.getMiterLimit);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'getWidth',\n      ol.style.Stroke.prototype.getWidth);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'setColor',\n      ol.style.Stroke.prototype.setColor);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'setLineCap',\n      ol.style.Stroke.prototype.setLineCap);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'setLineDash',\n      ol.style.Stroke.prototype.setLineDash);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'setLineDashOffset',\n      ol.style.Stroke.prototype.setLineDashOffset);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'setLineJoin',\n      ol.style.Stroke.prototype.setLineJoin);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'setMiterLimit',\n      ol.style.Stroke.prototype.setMiterLimit);\n  \n  goog.exportProperty(\n      ol.style.Stroke.prototype,\n      'setWidth',\n      ol.style.Stroke.prototype.setWidth);\n  \n  goog.exportSymbol(\n      'ol.style.Style',\n      ol.style.Style,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'clone',\n      ol.style.Style.prototype.clone);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'getRenderer',\n      ol.style.Style.prototype.getRenderer);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'setRenderer',\n      ol.style.Style.prototype.setRenderer);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'getGeometry',\n      ol.style.Style.prototype.getGeometry);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'getGeometryFunction',\n      ol.style.Style.prototype.getGeometryFunction);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'getFill',\n      ol.style.Style.prototype.getFill);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'setFill',\n      ol.style.Style.prototype.setFill);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'getImage',\n      ol.style.Style.prototype.getImage);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'setImage',\n      ol.style.Style.prototype.setImage);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'getStroke',\n      ol.style.Style.prototype.getStroke);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'setStroke',\n      ol.style.Style.prototype.setStroke);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'getText',\n      ol.style.Style.prototype.getText);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'setText',\n      ol.style.Style.prototype.setText);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'getZIndex',\n      ol.style.Style.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'setGeometry',\n      ol.style.Style.prototype.setGeometry);\n  \n  goog.exportProperty(\n      ol.style.Style.prototype,\n      'setZIndex',\n      ol.style.Style.prototype.setZIndex);\n  \n  goog.exportSymbol(\n      'ol.style.Text',\n      ol.style.Text,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'clone',\n      ol.style.Text.prototype.clone);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getOverflow',\n      ol.style.Text.prototype.getOverflow);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getFont',\n      ol.style.Text.prototype.getFont);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getMaxAngle',\n      ol.style.Text.prototype.getMaxAngle);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getPlacement',\n      ol.style.Text.prototype.getPlacement);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getOffsetX',\n      ol.style.Text.prototype.getOffsetX);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getOffsetY',\n      ol.style.Text.prototype.getOffsetY);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getFill',\n      ol.style.Text.prototype.getFill);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getRotateWithView',\n      ol.style.Text.prototype.getRotateWithView);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getRotation',\n      ol.style.Text.prototype.getRotation);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getScale',\n      ol.style.Text.prototype.getScale);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getStroke',\n      ol.style.Text.prototype.getStroke);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getText',\n      ol.style.Text.prototype.getText);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getTextAlign',\n      ol.style.Text.prototype.getTextAlign);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getTextBaseline',\n      ol.style.Text.prototype.getTextBaseline);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getBackgroundFill',\n      ol.style.Text.prototype.getBackgroundFill);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getBackgroundStroke',\n      ol.style.Text.prototype.getBackgroundStroke);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'getPadding',\n      ol.style.Text.prototype.getPadding);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setOverflow',\n      ol.style.Text.prototype.setOverflow);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setFont',\n      ol.style.Text.prototype.setFont);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setMaxAngle',\n      ol.style.Text.prototype.setMaxAngle);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setOffsetX',\n      ol.style.Text.prototype.setOffsetX);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setOffsetY',\n      ol.style.Text.prototype.setOffsetY);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setPlacement',\n      ol.style.Text.prototype.setPlacement);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setFill',\n      ol.style.Text.prototype.setFill);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setRotation',\n      ol.style.Text.prototype.setRotation);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setScale',\n      ol.style.Text.prototype.setScale);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setStroke',\n      ol.style.Text.prototype.setStroke);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setText',\n      ol.style.Text.prototype.setText);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setTextAlign',\n      ol.style.Text.prototype.setTextAlign);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setTextBaseline',\n      ol.style.Text.prototype.setTextBaseline);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setBackgroundFill',\n      ol.style.Text.prototype.setBackgroundFill);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setBackgroundStroke',\n      ol.style.Text.prototype.setBackgroundStroke);\n  \n  goog.exportProperty(\n      ol.style.Text.prototype,\n      'setPadding',\n      ol.style.Text.prototype.setPadding);\n  \n  goog.exportSymbol(\n      'ol.source.BingMaps',\n      ol.source.BingMaps,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.BingMaps.TOS_ATTRIBUTION',\n      ol.source.BingMaps.TOS_ATTRIBUTION,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getApiKey',\n      ol.source.BingMaps.prototype.getApiKey);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getImagerySet',\n      ol.source.BingMaps.prototype.getImagerySet);\n  \n  goog.exportSymbol(\n      'ol.source.CartoDB',\n      ol.source.CartoDB,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getConfig',\n      ol.source.CartoDB.prototype.getConfig);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'updateConfig',\n      ol.source.CartoDB.prototype.updateConfig);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setConfig',\n      ol.source.CartoDB.prototype.setConfig);\n  \n  goog.exportSymbol(\n      'ol.source.Cluster',\n      ol.source.Cluster,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getDistance',\n      ol.source.Cluster.prototype.getDistance);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getSource',\n      ol.source.Cluster.prototype.getSource);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'setDistance',\n      ol.source.Cluster.prototype.setDistance);\n  \n  goog.exportSymbol(\n      'ol.source.Image',\n      ol.source.Image,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.Image.Event.prototype,\n      'image',\n      ol.source.Image.Event.prototype.image);\n  \n  goog.exportSymbol(\n      'ol.source.ImageArcGISRest',\n      ol.source.ImageArcGISRest,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getParams',\n      ol.source.ImageArcGISRest.prototype.getParams);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getImageLoadFunction',\n      ol.source.ImageArcGISRest.prototype.getImageLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getUrl',\n      ol.source.ImageArcGISRest.prototype.getUrl);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'setImageLoadFunction',\n      ol.source.ImageArcGISRest.prototype.setImageLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'setUrl',\n      ol.source.ImageArcGISRest.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'updateParams',\n      ol.source.ImageArcGISRest.prototype.updateParams);\n  \n  goog.exportSymbol(\n      'ol.source.ImageCanvas',\n      ol.source.ImageCanvas,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.ImageMapGuide',\n      ol.source.ImageMapGuide,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getParams',\n      ol.source.ImageMapGuide.prototype.getParams);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getImageLoadFunction',\n      ol.source.ImageMapGuide.prototype.getImageLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'updateParams',\n      ol.source.ImageMapGuide.prototype.updateParams);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'setImageLoadFunction',\n      ol.source.ImageMapGuide.prototype.setImageLoadFunction);\n  \n  goog.exportSymbol(\n      'ol.source.ImageStatic',\n      ol.source.ImageStatic,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.ImageVector',\n      ol.source.ImageVector,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getSource',\n      ol.source.ImageVector.prototype.getSource);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getStyle',\n      ol.source.ImageVector.prototype.getStyle);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getStyleFunction',\n      ol.source.ImageVector.prototype.getStyleFunction);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'setStyle',\n      ol.source.ImageVector.prototype.setStyle);\n  \n  goog.exportSymbol(\n      'ol.source.ImageWMS',\n      ol.source.ImageWMS,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getGetFeatureInfoUrl',\n      ol.source.ImageWMS.prototype.getGetFeatureInfoUrl);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getParams',\n      ol.source.ImageWMS.prototype.getParams);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getImageLoadFunction',\n      ol.source.ImageWMS.prototype.getImageLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getUrl',\n      ol.source.ImageWMS.prototype.getUrl);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'setImageLoadFunction',\n      ol.source.ImageWMS.prototype.setImageLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'setUrl',\n      ol.source.ImageWMS.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'updateParams',\n      ol.source.ImageWMS.prototype.updateParams);\n  \n  goog.exportSymbol(\n      'ol.source.OSM',\n      ol.source.OSM,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.OSM.ATTRIBUTION',\n      ol.source.OSM.ATTRIBUTION,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.Raster',\n      ol.source.Raster,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'setOperation',\n      ol.source.Raster.prototype.setOperation);\n  \n  goog.exportProperty(\n      ol.source.Raster.Event.prototype,\n      'extent',\n      ol.source.Raster.Event.prototype.extent);\n  \n  goog.exportProperty(\n      ol.source.Raster.Event.prototype,\n      'resolution',\n      ol.source.Raster.Event.prototype.resolution);\n  \n  goog.exportProperty(\n      ol.source.Raster.Event.prototype,\n      'data',\n      ol.source.Raster.Event.prototype.data);\n  \n  goog.exportSymbol(\n      'ol.source.Source',\n      ol.source.Source,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'getAttributions',\n      ol.source.Source.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'getLogo',\n      ol.source.Source.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'getProjection',\n      ol.source.Source.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'getState',\n      ol.source.Source.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'refresh',\n      ol.source.Source.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'setAttributions',\n      ol.source.Source.prototype.setAttributions);\n  \n  goog.exportSymbol(\n      'ol.source.Stamen',\n      ol.source.Stamen,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.Tile',\n      ol.source.Tile,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'getTileGrid',\n      ol.source.Tile.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.Tile.Event.prototype,\n      'tile',\n      ol.source.Tile.Event.prototype.tile);\n  \n  goog.exportSymbol(\n      'ol.source.TileArcGISRest',\n      ol.source.TileArcGISRest,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getParams',\n      ol.source.TileArcGISRest.prototype.getParams);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'updateParams',\n      ol.source.TileArcGISRest.prototype.updateParams);\n  \n  goog.exportSymbol(\n      'ol.source.TileDebug',\n      ol.source.TileDebug,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.TileImage',\n      ol.source.TileImage,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.TileImage.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'setTileGridForProjection',\n      ol.source.TileImage.prototype.setTileGridForProjection);\n  \n  goog.exportSymbol(\n      'ol.source.TileJSON',\n      ol.source.TileJSON,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getTileJSON',\n      ol.source.TileJSON.prototype.getTileJSON);\n  \n  goog.exportSymbol(\n      'ol.source.TileUTFGrid',\n      ol.source.TileUTFGrid,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getTemplate',\n      ol.source.TileUTFGrid.prototype.getTemplate);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'forDataAtCoordinateAndResolution',\n      ol.source.TileUTFGrid.prototype.forDataAtCoordinateAndResolution);\n  \n  goog.exportSymbol(\n      'ol.source.TileWMS',\n      ol.source.TileWMS,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getGetFeatureInfoUrl',\n      ol.source.TileWMS.prototype.getGetFeatureInfoUrl);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getParams',\n      ol.source.TileWMS.prototype.getParams);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'updateParams',\n      ol.source.TileWMS.prototype.updateParams);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getTileLoadFunction',\n      ol.source.UrlTile.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getTileUrlFunction',\n      ol.source.UrlTile.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getUrls',\n      ol.source.UrlTile.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'setTileLoadFunction',\n      ol.source.UrlTile.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'setTileUrlFunction',\n      ol.source.UrlTile.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'setUrl',\n      ol.source.UrlTile.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'setUrls',\n      ol.source.UrlTile.prototype.setUrls);\n  \n  goog.exportSymbol(\n      'ol.source.Vector',\n      ol.source.Vector,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'addFeature',\n      ol.source.Vector.prototype.addFeature);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'addFeatures',\n      ol.source.Vector.prototype.addFeatures);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'clear',\n      ol.source.Vector.prototype.clear);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'forEachFeature',\n      ol.source.Vector.prototype.forEachFeature);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'forEachFeatureInExtent',\n      ol.source.Vector.prototype.forEachFeatureInExtent);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'forEachFeatureIntersectingExtent',\n      ol.source.Vector.prototype.forEachFeatureIntersectingExtent);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getFeaturesCollection',\n      ol.source.Vector.prototype.getFeaturesCollection);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getFeatures',\n      ol.source.Vector.prototype.getFeatures);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getFeaturesAtCoordinate',\n      ol.source.Vector.prototype.getFeaturesAtCoordinate);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getFeaturesInExtent',\n      ol.source.Vector.prototype.getFeaturesInExtent);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getClosestFeatureToCoordinate',\n      ol.source.Vector.prototype.getClosestFeatureToCoordinate);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getExtent',\n      ol.source.Vector.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getFeatureById',\n      ol.source.Vector.prototype.getFeatureById);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getFormat',\n      ol.source.Vector.prototype.getFormat);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getUrl',\n      ol.source.Vector.prototype.getUrl);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'removeLoadedExtent',\n      ol.source.Vector.prototype.removeLoadedExtent);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'removeFeature',\n      ol.source.Vector.prototype.removeFeature);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'setLoader',\n      ol.source.Vector.prototype.setLoader);\n  \n  goog.exportProperty(\n      ol.source.Vector.Event.prototype,\n      'feature',\n      ol.source.Vector.Event.prototype.feature);\n  \n  goog.exportSymbol(\n      'ol.source.VectorTile',\n      ol.source.VectorTile,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'clear',\n      ol.source.VectorTile.prototype.clear);\n  \n  goog.exportSymbol(\n      'ol.source.WMTS',\n      ol.source.WMTS,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getDimensions',\n      ol.source.WMTS.prototype.getDimensions);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getFormat',\n      ol.source.WMTS.prototype.getFormat);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getLayer',\n      ol.source.WMTS.prototype.getLayer);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getMatrixSet',\n      ol.source.WMTS.prototype.getMatrixSet);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getRequestEncoding',\n      ol.source.WMTS.prototype.getRequestEncoding);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getStyle',\n      ol.source.WMTS.prototype.getStyle);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getVersion',\n      ol.source.WMTS.prototype.getVersion);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'updateDimensions',\n      ol.source.WMTS.prototype.updateDimensions);\n  \n  goog.exportSymbol(\n      'ol.source.WMTS.optionsFromCapabilities',\n      ol.source.WMTS.optionsFromCapabilities,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.XYZ',\n      ol.source.XYZ,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.source.Zoomify',\n      ol.source.Zoomify,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.webgl.ImageLayer',\n      ol.renderer.webgl.ImageLayer,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.webgl.Map',\n      ol.renderer.webgl.Map,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.webgl.TileLayer',\n      ol.renderer.webgl.TileLayer,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.webgl.VectorLayer',\n      ol.renderer.webgl.VectorLayer,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.canvas.ImageLayer',\n      ol.renderer.canvas.ImageLayer,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.canvas.Map',\n      ol.renderer.canvas.Map,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.canvas.TileLayer',\n      ol.renderer.canvas.TileLayer,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.canvas.VectorLayer',\n      ol.renderer.canvas.VectorLayer,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.renderer.canvas.VectorTileLayer',\n      ol.renderer.canvas.VectorTileLayer,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.render.Event.prototype,\n      'vectorContext',\n      ol.render.Event.prototype.vectorContext);\n  \n  goog.exportProperty(\n      ol.render.Event.prototype,\n      'frameState',\n      ol.render.Event.prototype.frameState);\n  \n  goog.exportProperty(\n      ol.render.Event.prototype,\n      'context',\n      ol.render.Event.prototype.context);\n  \n  goog.exportProperty(\n      ol.render.Event.prototype,\n      'glContext',\n      ol.render.Event.prototype.glContext);\n  \n  goog.exportProperty(\n      ol.render.Feature.prototype,\n      'get',\n      ol.render.Feature.prototype.get);\n  \n  goog.exportProperty(\n      ol.render.Feature.prototype,\n      'getExtent',\n      ol.render.Feature.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.render.Feature.prototype,\n      'getId',\n      ol.render.Feature.prototype.getId);\n  \n  goog.exportProperty(\n      ol.render.Feature.prototype,\n      'getGeometry',\n      ol.render.Feature.prototype.getGeometry);\n  \n  goog.exportProperty(\n      ol.render.Feature.prototype,\n      'getProperties',\n      ol.render.Feature.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.render.Feature.prototype,\n      'getType',\n      ol.render.Feature.prototype.getType);\n  \n  goog.exportSymbol(\n      'ol.render.VectorContext',\n      ol.render.VectorContext,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.render.webgl.Immediate.prototype,\n      'setStyle',\n      ol.render.webgl.Immediate.prototype.setStyle);\n  \n  goog.exportProperty(\n      ol.render.webgl.Immediate.prototype,\n      'drawGeometry',\n      ol.render.webgl.Immediate.prototype.drawGeometry);\n  \n  goog.exportProperty(\n      ol.render.webgl.Immediate.prototype,\n      'drawFeature',\n      ol.render.webgl.Immediate.prototype.drawFeature);\n  \n  goog.exportProperty(\n      ol.render.canvas.Immediate.prototype,\n      'drawCircle',\n      ol.render.canvas.Immediate.prototype.drawCircle);\n  \n  goog.exportProperty(\n      ol.render.canvas.Immediate.prototype,\n      'setStyle',\n      ol.render.canvas.Immediate.prototype.setStyle);\n  \n  goog.exportProperty(\n      ol.render.canvas.Immediate.prototype,\n      'drawGeometry',\n      ol.render.canvas.Immediate.prototype.drawGeometry);\n  \n  goog.exportProperty(\n      ol.render.canvas.Immediate.prototype,\n      'drawFeature',\n      ol.render.canvas.Immediate.prototype.drawFeature);\n  \n  goog.exportSymbol(\n      'ol.proj.common.add',\n      ol.proj.common.add,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.proj.Projection',\n      ol.proj.Projection,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'getCode',\n      ol.proj.Projection.prototype.getCode);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'getExtent',\n      ol.proj.Projection.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'getUnits',\n      ol.proj.Projection.prototype.getUnits);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'getMetersPerUnit',\n      ol.proj.Projection.prototype.getMetersPerUnit);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'getWorldExtent',\n      ol.proj.Projection.prototype.getWorldExtent);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'getAxisOrientation',\n      ol.proj.Projection.prototype.getAxisOrientation);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'isGlobal',\n      ol.proj.Projection.prototype.isGlobal);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'setGlobal',\n      ol.proj.Projection.prototype.setGlobal);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'setExtent',\n      ol.proj.Projection.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'setWorldExtent',\n      ol.proj.Projection.prototype.setWorldExtent);\n  \n  goog.exportProperty(\n      ol.proj.Projection.prototype,\n      'setGetPointResolution',\n      ol.proj.Projection.prototype.setGetPointResolution);\n  \n  goog.exportSymbol(\n      'ol.proj.Units.METERS_PER_UNIT',\n      ol.proj.Units.METERS_PER_UNIT,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.layer.Base',\n      ol.layer.Base,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getExtent',\n      ol.layer.Base.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getMaxResolution',\n      ol.layer.Base.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getMinResolution',\n      ol.layer.Base.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getOpacity',\n      ol.layer.Base.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getVisible',\n      ol.layer.Base.prototype.getVisible);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getZIndex',\n      ol.layer.Base.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'setExtent',\n      ol.layer.Base.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'setMaxResolution',\n      ol.layer.Base.prototype.setMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'setMinResolution',\n      ol.layer.Base.prototype.setMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'setOpacity',\n      ol.layer.Base.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'setVisible',\n      ol.layer.Base.prototype.setVisible);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'setZIndex',\n      ol.layer.Base.prototype.setZIndex);\n  \n  goog.exportSymbol(\n      'ol.layer.Group',\n      ol.layer.Group,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getLayers',\n      ol.layer.Group.prototype.getLayers);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'setLayers',\n      ol.layer.Group.prototype.setLayers);\n  \n  goog.exportSymbol(\n      'ol.layer.Heatmap',\n      ol.layer.Heatmap,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getBlur',\n      ol.layer.Heatmap.prototype.getBlur);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getGradient',\n      ol.layer.Heatmap.prototype.getGradient);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getRadius',\n      ol.layer.Heatmap.prototype.getRadius);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setBlur',\n      ol.layer.Heatmap.prototype.setBlur);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setGradient',\n      ol.layer.Heatmap.prototype.setGradient);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setRadius',\n      ol.layer.Heatmap.prototype.setRadius);\n  \n  goog.exportSymbol(\n      'ol.layer.Image',\n      ol.layer.Image,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getSource',\n      ol.layer.Image.prototype.getSource);\n  \n  goog.exportSymbol(\n      'ol.layer.Layer',\n      ol.layer.Layer,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getSource',\n      ol.layer.Layer.prototype.getSource);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setMap',\n      ol.layer.Layer.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setSource',\n      ol.layer.Layer.prototype.setSource);\n  \n  goog.exportSymbol(\n      'ol.layer.Tile',\n      ol.layer.Tile,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getPreload',\n      ol.layer.Tile.prototype.getPreload);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getSource',\n      ol.layer.Tile.prototype.getSource);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setPreload',\n      ol.layer.Tile.prototype.setPreload);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getUseInterimTilesOnError',\n      ol.layer.Tile.prototype.getUseInterimTilesOnError);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setUseInterimTilesOnError',\n      ol.layer.Tile.prototype.setUseInterimTilesOnError);\n  \n  goog.exportSymbol(\n      'ol.layer.Vector',\n      ol.layer.Vector,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getSource',\n      ol.layer.Vector.prototype.getSource);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getStyle',\n      ol.layer.Vector.prototype.getStyle);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getStyleFunction',\n      ol.layer.Vector.prototype.getStyleFunction);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setStyle',\n      ol.layer.Vector.prototype.setStyle);\n  \n  goog.exportSymbol(\n      'ol.layer.VectorTile',\n      ol.layer.VectorTile,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getPreload',\n      ol.layer.VectorTile.prototype.getPreload);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getUseInterimTilesOnError',\n      ol.layer.VectorTile.prototype.getUseInterimTilesOnError);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setPreload',\n      ol.layer.VectorTile.prototype.setPreload);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setUseInterimTilesOnError',\n      ol.layer.VectorTile.prototype.setUseInterimTilesOnError);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getSource',\n      ol.layer.VectorTile.prototype.getSource);\n  \n  goog.exportSymbol(\n      'ol.interaction.DoubleClickZoom',\n      ol.interaction.DoubleClickZoom,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.DoubleClickZoom.handleEvent',\n      ol.interaction.DoubleClickZoom.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.DragAndDrop',\n      ol.interaction.DragAndDrop,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.DragAndDrop.handleEvent',\n      ol.interaction.DragAndDrop.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.Event.prototype,\n      'features',\n      ol.interaction.DragAndDrop.Event.prototype.features);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.Event.prototype,\n      'file',\n      ol.interaction.DragAndDrop.Event.prototype.file);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.Event.prototype,\n      'projection',\n      ol.interaction.DragAndDrop.Event.prototype.projection);\n  \n  goog.exportSymbol(\n      'ol.interaction.DragBox',\n      ol.interaction.DragBox,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'getGeometry',\n      ol.interaction.DragBox.prototype.getGeometry);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.Event.prototype,\n      'coordinate',\n      ol.interaction.DragBox.Event.prototype.coordinate);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.Event.prototype,\n      'mapBrowserEvent',\n      ol.interaction.DragBox.Event.prototype.mapBrowserEvent);\n  \n  goog.exportSymbol(\n      'ol.interaction.DragPan',\n      ol.interaction.DragPan,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.DragRotate',\n      ol.interaction.DragRotate,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.DragRotateAndZoom',\n      ol.interaction.DragRotateAndZoom,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.DragZoom',\n      ol.interaction.DragZoom,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.Draw',\n      ol.interaction.Draw,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.Draw.handleEvent',\n      ol.interaction.Draw.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'removeLastPoint',\n      ol.interaction.Draw.prototype.removeLastPoint);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'finishDrawing',\n      ol.interaction.Draw.prototype.finishDrawing);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'extend',\n      ol.interaction.Draw.prototype.extend);\n  \n  goog.exportSymbol(\n      'ol.interaction.Draw.createRegularPolygon',\n      ol.interaction.Draw.createRegularPolygon,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.Draw.createBox',\n      ol.interaction.Draw.createBox,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.Event.prototype,\n      'feature',\n      ol.interaction.Draw.Event.prototype.feature);\n  \n  goog.exportSymbol(\n      'ol.interaction.Extent',\n      ol.interaction.Extent,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'getExtent',\n      ol.interaction.Extent.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'setExtent',\n      ol.interaction.Extent.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.Event.prototype,\n      'extent',\n      ol.interaction.Extent.Event.prototype.extent);\n  \n  goog.exportSymbol(\n      'ol.interaction.Interaction',\n      ol.interaction.Interaction,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'getActive',\n      ol.interaction.Interaction.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'getMap',\n      ol.interaction.Interaction.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'setActive',\n      ol.interaction.Interaction.prototype.setActive);\n  \n  goog.exportSymbol(\n      'ol.interaction.KeyboardPan',\n      ol.interaction.KeyboardPan,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.KeyboardPan.handleEvent',\n      ol.interaction.KeyboardPan.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.KeyboardZoom',\n      ol.interaction.KeyboardZoom,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.KeyboardZoom.handleEvent',\n      ol.interaction.KeyboardZoom.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.Modify',\n      ol.interaction.Modify,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.Modify.handleEvent',\n      ol.interaction.Modify.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'removePoint',\n      ol.interaction.Modify.prototype.removePoint);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.Event.prototype,\n      'features',\n      ol.interaction.Modify.Event.prototype.features);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.Event.prototype,\n      'mapBrowserEvent',\n      ol.interaction.Modify.Event.prototype.mapBrowserEvent);\n  \n  goog.exportSymbol(\n      'ol.interaction.MouseWheelZoom',\n      ol.interaction.MouseWheelZoom,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.MouseWheelZoom.handleEvent',\n      ol.interaction.MouseWheelZoom.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'setMouseAnchor',\n      ol.interaction.MouseWheelZoom.prototype.setMouseAnchor);\n  \n  goog.exportSymbol(\n      'ol.interaction.PinchRotate',\n      ol.interaction.PinchRotate,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.PinchZoom',\n      ol.interaction.PinchZoom,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.Pointer',\n      ol.interaction.Pointer,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.Pointer.handleEvent',\n      ol.interaction.Pointer.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.interaction.Select',\n      ol.interaction.Select,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'getFeatures',\n      ol.interaction.Select.prototype.getFeatures);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'getHitTolerance',\n      ol.interaction.Select.prototype.getHitTolerance);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'getLayer',\n      ol.interaction.Select.prototype.getLayer);\n  \n  goog.exportSymbol(\n      'ol.interaction.Select.handleEvent',\n      ol.interaction.Select.handleEvent,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'setHitTolerance',\n      ol.interaction.Select.prototype.setHitTolerance);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'setMap',\n      ol.interaction.Select.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.interaction.Select.Event.prototype,\n      'selected',\n      ol.interaction.Select.Event.prototype.selected);\n  \n  goog.exportProperty(\n      ol.interaction.Select.Event.prototype,\n      'deselected',\n      ol.interaction.Select.Event.prototype.deselected);\n  \n  goog.exportProperty(\n      ol.interaction.Select.Event.prototype,\n      'mapBrowserEvent',\n      ol.interaction.Select.Event.prototype.mapBrowserEvent);\n  \n  goog.exportSymbol(\n      'ol.interaction.Snap',\n      ol.interaction.Snap,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'addFeature',\n      ol.interaction.Snap.prototype.addFeature);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'removeFeature',\n      ol.interaction.Snap.prototype.removeFeature);\n  \n  goog.exportSymbol(\n      'ol.interaction.Translate',\n      ol.interaction.Translate,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'getHitTolerance',\n      ol.interaction.Translate.prototype.getHitTolerance);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'setHitTolerance',\n      ol.interaction.Translate.prototype.setHitTolerance);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.Event.prototype,\n      'features',\n      ol.interaction.Translate.Event.prototype.features);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.Event.prototype,\n      'coordinate',\n      ol.interaction.Translate.Event.prototype.coordinate);\n  \n  goog.exportSymbol(\n      'ol.geom.Circle',\n      ol.geom.Circle,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'clone',\n      ol.geom.Circle.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getCenter',\n      ol.geom.Circle.prototype.getCenter);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getRadius',\n      ol.geom.Circle.prototype.getRadius);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getType',\n      ol.geom.Circle.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'intersectsExtent',\n      ol.geom.Circle.prototype.intersectsExtent);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'setCenter',\n      ol.geom.Circle.prototype.setCenter);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'setCenterAndRadius',\n      ol.geom.Circle.prototype.setCenterAndRadius);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'setRadius',\n      ol.geom.Circle.prototype.setRadius);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'transform',\n      ol.geom.Circle.prototype.transform);\n  \n  goog.exportSymbol(\n      'ol.geom.Geometry',\n      ol.geom.Geometry,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'getClosestPoint',\n      ol.geom.Geometry.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'intersectsCoordinate',\n      ol.geom.Geometry.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'getExtent',\n      ol.geom.Geometry.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'rotate',\n      ol.geom.Geometry.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'scale',\n      ol.geom.Geometry.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'simplify',\n      ol.geom.Geometry.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'transform',\n      ol.geom.Geometry.prototype.transform);\n  \n  goog.exportSymbol(\n      'ol.geom.GeometryCollection',\n      ol.geom.GeometryCollection,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'clone',\n      ol.geom.GeometryCollection.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'getGeometries',\n      ol.geom.GeometryCollection.prototype.getGeometries);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'getType',\n      ol.geom.GeometryCollection.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'intersectsExtent',\n      ol.geom.GeometryCollection.prototype.intersectsExtent);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'setGeometries',\n      ol.geom.GeometryCollection.prototype.setGeometries);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'applyTransform',\n      ol.geom.GeometryCollection.prototype.applyTransform);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'translate',\n      ol.geom.GeometryCollection.prototype.translate);\n  \n  goog.exportSymbol(\n      'ol.geom.LinearRing',\n      ol.geom.LinearRing,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'clone',\n      ol.geom.LinearRing.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getArea',\n      ol.geom.LinearRing.prototype.getArea);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getCoordinates',\n      ol.geom.LinearRing.prototype.getCoordinates);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getType',\n      ol.geom.LinearRing.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'setCoordinates',\n      ol.geom.LinearRing.prototype.setCoordinates);\n  \n  goog.exportSymbol(\n      'ol.geom.LineString',\n      ol.geom.LineString,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'appendCoordinate',\n      ol.geom.LineString.prototype.appendCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'clone',\n      ol.geom.LineString.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'forEachSegment',\n      ol.geom.LineString.prototype.forEachSegment);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getCoordinateAtM',\n      ol.geom.LineString.prototype.getCoordinateAtM);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getCoordinates',\n      ol.geom.LineString.prototype.getCoordinates);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getCoordinateAt',\n      ol.geom.LineString.prototype.getCoordinateAt);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getLength',\n      ol.geom.LineString.prototype.getLength);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getType',\n      ol.geom.LineString.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'intersectsExtent',\n      ol.geom.LineString.prototype.intersectsExtent);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'setCoordinates',\n      ol.geom.LineString.prototype.setCoordinates);\n  \n  goog.exportSymbol(\n      'ol.geom.MultiLineString',\n      ol.geom.MultiLineString,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'appendLineString',\n      ol.geom.MultiLineString.prototype.appendLineString);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'clone',\n      ol.geom.MultiLineString.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getCoordinateAtM',\n      ol.geom.MultiLineString.prototype.getCoordinateAtM);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getCoordinates',\n      ol.geom.MultiLineString.prototype.getCoordinates);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getLineString',\n      ol.geom.MultiLineString.prototype.getLineString);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getLineStrings',\n      ol.geom.MultiLineString.prototype.getLineStrings);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getType',\n      ol.geom.MultiLineString.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'intersectsExtent',\n      ol.geom.MultiLineString.prototype.intersectsExtent);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'setCoordinates',\n      ol.geom.MultiLineString.prototype.setCoordinates);\n  \n  goog.exportSymbol(\n      'ol.geom.MultiPoint',\n      ol.geom.MultiPoint,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'appendPoint',\n      ol.geom.MultiPoint.prototype.appendPoint);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'clone',\n      ol.geom.MultiPoint.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getCoordinates',\n      ol.geom.MultiPoint.prototype.getCoordinates);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getPoint',\n      ol.geom.MultiPoint.prototype.getPoint);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getPoints',\n      ol.geom.MultiPoint.prototype.getPoints);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getType',\n      ol.geom.MultiPoint.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'intersectsExtent',\n      ol.geom.MultiPoint.prototype.intersectsExtent);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'setCoordinates',\n      ol.geom.MultiPoint.prototype.setCoordinates);\n  \n  goog.exportSymbol(\n      'ol.geom.MultiPolygon',\n      ol.geom.MultiPolygon,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'appendPolygon',\n      ol.geom.MultiPolygon.prototype.appendPolygon);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'clone',\n      ol.geom.MultiPolygon.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getArea',\n      ol.geom.MultiPolygon.prototype.getArea);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getCoordinates',\n      ol.geom.MultiPolygon.prototype.getCoordinates);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getInteriorPoints',\n      ol.geom.MultiPolygon.prototype.getInteriorPoints);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getPolygon',\n      ol.geom.MultiPolygon.prototype.getPolygon);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getPolygons',\n      ol.geom.MultiPolygon.prototype.getPolygons);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getType',\n      ol.geom.MultiPolygon.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'intersectsExtent',\n      ol.geom.MultiPolygon.prototype.intersectsExtent);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'setCoordinates',\n      ol.geom.MultiPolygon.prototype.setCoordinates);\n  \n  goog.exportSymbol(\n      'ol.geom.Point',\n      ol.geom.Point,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'clone',\n      ol.geom.Point.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getCoordinates',\n      ol.geom.Point.prototype.getCoordinates);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getType',\n      ol.geom.Point.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'intersectsExtent',\n      ol.geom.Point.prototype.intersectsExtent);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'setCoordinates',\n      ol.geom.Point.prototype.setCoordinates);\n  \n  goog.exportSymbol(\n      'ol.geom.Polygon',\n      ol.geom.Polygon,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'appendLinearRing',\n      ol.geom.Polygon.prototype.appendLinearRing);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'clone',\n      ol.geom.Polygon.prototype.clone);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getArea',\n      ol.geom.Polygon.prototype.getArea);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getCoordinates',\n      ol.geom.Polygon.prototype.getCoordinates);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getInteriorPoint',\n      ol.geom.Polygon.prototype.getInteriorPoint);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getLinearRingCount',\n      ol.geom.Polygon.prototype.getLinearRingCount);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getLinearRing',\n      ol.geom.Polygon.prototype.getLinearRing);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getLinearRings',\n      ol.geom.Polygon.prototype.getLinearRings);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getType',\n      ol.geom.Polygon.prototype.getType);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'intersectsExtent',\n      ol.geom.Polygon.prototype.intersectsExtent);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'setCoordinates',\n      ol.geom.Polygon.prototype.setCoordinates);\n  \n  goog.exportSymbol(\n      'ol.geom.Polygon.circular',\n      ol.geom.Polygon.circular,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.geom.Polygon.fromExtent',\n      ol.geom.Polygon.fromExtent,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.geom.Polygon.fromCircle',\n      ol.geom.Polygon.fromCircle,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.geom.SimpleGeometry',\n      ol.geom.SimpleGeometry,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'getFirstCoordinate',\n      ol.geom.SimpleGeometry.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'getLastCoordinate',\n      ol.geom.SimpleGeometry.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'getLayout',\n      ol.geom.SimpleGeometry.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'applyTransform',\n      ol.geom.SimpleGeometry.prototype.applyTransform);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'translate',\n      ol.geom.SimpleGeometry.prototype.translate);\n  \n  goog.exportSymbol(\n      'ol.format.EsriJSON',\n      ol.format.EsriJSON,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'readFeature',\n      ol.format.EsriJSON.prototype.readFeature);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'readFeatures',\n      ol.format.EsriJSON.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'readGeometry',\n      ol.format.EsriJSON.prototype.readGeometry);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'readProjection',\n      ol.format.EsriJSON.prototype.readProjection);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'writeGeometry',\n      ol.format.EsriJSON.prototype.writeGeometry);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'writeGeometryObject',\n      ol.format.EsriJSON.prototype.writeGeometryObject);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'writeFeature',\n      ol.format.EsriJSON.prototype.writeFeature);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'writeFeatureObject',\n      ol.format.EsriJSON.prototype.writeFeatureObject);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'writeFeatures',\n      ol.format.EsriJSON.prototype.writeFeatures);\n  \n  goog.exportProperty(\n      ol.format.EsriJSON.prototype,\n      'writeFeaturesObject',\n      ol.format.EsriJSON.prototype.writeFeaturesObject);\n  \n  goog.exportSymbol(\n      'ol.format.Feature',\n      ol.format.Feature,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.and',\n      ol.format.filter.and,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.or',\n      ol.format.filter.or,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.not',\n      ol.format.filter.not,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.bbox',\n      ol.format.filter.bbox,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.contains',\n      ol.format.filter.contains,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.intersects',\n      ol.format.filter.intersects,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.within',\n      ol.format.filter.within,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.equalTo',\n      ol.format.filter.equalTo,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.notEqualTo',\n      ol.format.filter.notEqualTo,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.lessThan',\n      ol.format.filter.lessThan,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.lessThanOrEqualTo',\n      ol.format.filter.lessThanOrEqualTo,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.greaterThan',\n      ol.format.filter.greaterThan,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.greaterThanOrEqualTo',\n      ol.format.filter.greaterThanOrEqualTo,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.isNull',\n      ol.format.filter.isNull,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.between',\n      ol.format.filter.between,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.like',\n      ol.format.filter.like,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.during',\n      ol.format.filter.during,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.GeoJSON',\n      ol.format.GeoJSON,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'readFeature',\n      ol.format.GeoJSON.prototype.readFeature);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'readFeatures',\n      ol.format.GeoJSON.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'readGeometry',\n      ol.format.GeoJSON.prototype.readGeometry);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'readProjection',\n      ol.format.GeoJSON.prototype.readProjection);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'writeFeature',\n      ol.format.GeoJSON.prototype.writeFeature);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'writeFeatureObject',\n      ol.format.GeoJSON.prototype.writeFeatureObject);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'writeFeatures',\n      ol.format.GeoJSON.prototype.writeFeatures);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'writeFeaturesObject',\n      ol.format.GeoJSON.prototype.writeFeaturesObject);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'writeGeometry',\n      ol.format.GeoJSON.prototype.writeGeometry);\n  \n  goog.exportProperty(\n      ol.format.GeoJSON.prototype,\n      'writeGeometryObject',\n      ol.format.GeoJSON.prototype.writeGeometryObject);\n  \n  goog.exportSymbol(\n      'ol.format.GML',\n      ol.format.GML,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.GML.prototype,\n      'writeFeatures',\n      ol.format.GML.prototype.writeFeatures);\n  \n  goog.exportProperty(\n      ol.format.GML.prototype,\n      'writeFeaturesNode',\n      ol.format.GML.prototype.writeFeaturesNode);\n  \n  goog.exportSymbol(\n      'ol.format.GML2',\n      ol.format.GML2,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.GML3',\n      ol.format.GML3,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.GML3.prototype,\n      'writeGeometryNode',\n      ol.format.GML3.prototype.writeGeometryNode);\n  \n  goog.exportProperty(\n      ol.format.GML3.prototype,\n      'writeFeatures',\n      ol.format.GML3.prototype.writeFeatures);\n  \n  goog.exportProperty(\n      ol.format.GML3.prototype,\n      'writeFeaturesNode',\n      ol.format.GML3.prototype.writeFeaturesNode);\n  \n  goog.exportProperty(\n      ol.format.GMLBase.prototype,\n      'readFeatures',\n      ol.format.GMLBase.prototype.readFeatures);\n  \n  goog.exportSymbol(\n      'ol.format.GPX',\n      ol.format.GPX,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.GPX.prototype,\n      'readFeature',\n      ol.format.GPX.prototype.readFeature);\n  \n  goog.exportProperty(\n      ol.format.GPX.prototype,\n      'readFeatures',\n      ol.format.GPX.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.GPX.prototype,\n      'readProjection',\n      ol.format.GPX.prototype.readProjection);\n  \n  goog.exportProperty(\n      ol.format.GPX.prototype,\n      'writeFeatures',\n      ol.format.GPX.prototype.writeFeatures);\n  \n  goog.exportProperty(\n      ol.format.GPX.prototype,\n      'writeFeaturesNode',\n      ol.format.GPX.prototype.writeFeaturesNode);\n  \n  goog.exportSymbol(\n      'ol.format.IGC',\n      ol.format.IGC,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.IGC.prototype,\n      'readFeature',\n      ol.format.IGC.prototype.readFeature);\n  \n  goog.exportProperty(\n      ol.format.IGC.prototype,\n      'readFeatures',\n      ol.format.IGC.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.IGC.prototype,\n      'readProjection',\n      ol.format.IGC.prototype.readProjection);\n  \n  goog.exportSymbol(\n      'ol.format.KML',\n      ol.format.KML,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'readFeature',\n      ol.format.KML.prototype.readFeature);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'readFeatures',\n      ol.format.KML.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'readName',\n      ol.format.KML.prototype.readName);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'readNetworkLinks',\n      ol.format.KML.prototype.readNetworkLinks);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'readRegion',\n      ol.format.KML.prototype.readRegion);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'readRegionFromNode',\n      ol.format.KML.prototype.readRegionFromNode);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'readProjection',\n      ol.format.KML.prototype.readProjection);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'writeFeatures',\n      ol.format.KML.prototype.writeFeatures);\n  \n  goog.exportProperty(\n      ol.format.KML.prototype,\n      'writeFeaturesNode',\n      ol.format.KML.prototype.writeFeaturesNode);\n  \n  goog.exportSymbol(\n      'ol.format.MVT',\n      ol.format.MVT,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.MVT.prototype,\n      'getLastExtent',\n      ol.format.MVT.prototype.getLastExtent);\n  \n  goog.exportProperty(\n      ol.format.MVT.prototype,\n      'readFeatures',\n      ol.format.MVT.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.MVT.prototype,\n      'readProjection',\n      ol.format.MVT.prototype.readProjection);\n  \n  goog.exportProperty(\n      ol.format.MVT.prototype,\n      'setLayers',\n      ol.format.MVT.prototype.setLayers);\n  \n  goog.exportSymbol(\n      'ol.format.OSMXML',\n      ol.format.OSMXML,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.OSMXML.prototype,\n      'readFeatures',\n      ol.format.OSMXML.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.OSMXML.prototype,\n      'readProjection',\n      ol.format.OSMXML.prototype.readProjection);\n  \n  goog.exportSymbol(\n      'ol.format.Polyline',\n      ol.format.Polyline,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.Polyline.encodeDeltas',\n      ol.format.Polyline.encodeDeltas,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.Polyline.decodeDeltas',\n      ol.format.Polyline.decodeDeltas,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.Polyline.encodeFloats',\n      ol.format.Polyline.encodeFloats,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.Polyline.decodeFloats',\n      ol.format.Polyline.decodeFloats,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.Polyline.prototype,\n      'readFeature',\n      ol.format.Polyline.prototype.readFeature);\n  \n  goog.exportProperty(\n      ol.format.Polyline.prototype,\n      'readFeatures',\n      ol.format.Polyline.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.Polyline.prototype,\n      'readGeometry',\n      ol.format.Polyline.prototype.readGeometry);\n  \n  goog.exportProperty(\n      ol.format.Polyline.prototype,\n      'readProjection',\n      ol.format.Polyline.prototype.readProjection);\n  \n  goog.exportProperty(\n      ol.format.Polyline.prototype,\n      'writeGeometry',\n      ol.format.Polyline.prototype.writeGeometry);\n  \n  goog.exportSymbol(\n      'ol.format.TopoJSON',\n      ol.format.TopoJSON,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.TopoJSON.prototype,\n      'readFeatures',\n      ol.format.TopoJSON.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.TopoJSON.prototype,\n      'readProjection',\n      ol.format.TopoJSON.prototype.readProjection);\n  \n  goog.exportSymbol(\n      'ol.format.WFS',\n      ol.format.WFS,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.WFS.prototype,\n      'readFeatures',\n      ol.format.WFS.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.WFS.prototype,\n      'readTransactionResponse',\n      ol.format.WFS.prototype.readTransactionResponse);\n  \n  goog.exportProperty(\n      ol.format.WFS.prototype,\n      'readFeatureCollectionMetadata',\n      ol.format.WFS.prototype.readFeatureCollectionMetadata);\n  \n  goog.exportSymbol(\n      'ol.format.WFS.writeFilter',\n      ol.format.WFS.writeFilter,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.WFS.prototype,\n      'writeGetFeature',\n      ol.format.WFS.prototype.writeGetFeature);\n  \n  goog.exportProperty(\n      ol.format.WFS.prototype,\n      'writeTransaction',\n      ol.format.WFS.prototype.writeTransaction);\n  \n  goog.exportProperty(\n      ol.format.WFS.prototype,\n      'readProjection',\n      ol.format.WFS.prototype.readProjection);\n  \n  goog.exportSymbol(\n      'ol.format.WKT',\n      ol.format.WKT,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.WKT.prototype,\n      'readFeature',\n      ol.format.WKT.prototype.readFeature);\n  \n  goog.exportProperty(\n      ol.format.WKT.prototype,\n      'readFeatures',\n      ol.format.WKT.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.WKT.prototype,\n      'readGeometry',\n      ol.format.WKT.prototype.readGeometry);\n  \n  goog.exportProperty(\n      ol.format.WKT.prototype,\n      'writeFeature',\n      ol.format.WKT.prototype.writeFeature);\n  \n  goog.exportProperty(\n      ol.format.WKT.prototype,\n      'writeFeatures',\n      ol.format.WKT.prototype.writeFeatures);\n  \n  goog.exportProperty(\n      ol.format.WKT.prototype,\n      'writeGeometry',\n      ol.format.WKT.prototype.writeGeometry);\n  \n  goog.exportSymbol(\n      'ol.format.WMSCapabilities',\n      ol.format.WMSCapabilities,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.WMSCapabilities.prototype,\n      'read',\n      ol.format.WMSCapabilities.prototype.read);\n  \n  goog.exportSymbol(\n      'ol.format.WMSGetFeatureInfo',\n      ol.format.WMSGetFeatureInfo,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.WMSGetFeatureInfo.prototype,\n      'readFeatures',\n      ol.format.WMSGetFeatureInfo.prototype.readFeatures);\n  \n  goog.exportSymbol(\n      'ol.format.WMTSCapabilities',\n      ol.format.WMTSCapabilities,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.format.WMTSCapabilities.prototype,\n      'read',\n      ol.format.WMTSCapabilities.prototype.read);\n  \n  goog.exportSymbol(\n      'ol.format.filter.And',\n      ol.format.filter.And,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Bbox',\n      ol.format.filter.Bbox,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Comparison',\n      ol.format.filter.Comparison,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.ComparisonBinary',\n      ol.format.filter.ComparisonBinary,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Contains',\n      ol.format.filter.Contains,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.During',\n      ol.format.filter.During,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.EqualTo',\n      ol.format.filter.EqualTo,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Filter',\n      ol.format.filter.Filter,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.GreaterThan',\n      ol.format.filter.GreaterThan,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.GreaterThanOrEqualTo',\n      ol.format.filter.GreaterThanOrEqualTo,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Intersects',\n      ol.format.filter.Intersects,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.IsBetween',\n      ol.format.filter.IsBetween,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.IsLike',\n      ol.format.filter.IsLike,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.IsNull',\n      ol.format.filter.IsNull,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.LessThan',\n      ol.format.filter.LessThan,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.LessThanOrEqualTo',\n      ol.format.filter.LessThanOrEqualTo,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Not',\n      ol.format.filter.Not,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.NotEqualTo',\n      ol.format.filter.NotEqualTo,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Or',\n      ol.format.filter.Or,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Spatial',\n      ol.format.filter.Spatial,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.format.filter.Within',\n      ol.format.filter.Within,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.altKeyOnly',\n      ol.events.condition.altKeyOnly,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.altShiftKeysOnly',\n      ol.events.condition.altShiftKeysOnly,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.always',\n      ol.events.condition.always,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.click',\n      ol.events.condition.click,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.never',\n      ol.events.condition.never,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.pointerMove',\n      ol.events.condition.pointerMove,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.singleClick',\n      ol.events.condition.singleClick,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.doubleClick',\n      ol.events.condition.doubleClick,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.noModifierKeys',\n      ol.events.condition.noModifierKeys,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.platformModifierKeyOnly',\n      ol.events.condition.platformModifierKeyOnly,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.shiftKeyOnly',\n      ol.events.condition.shiftKeyOnly,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.targetNotEditable',\n      ol.events.condition.targetNotEditable,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.mouseOnly',\n      ol.events.condition.mouseOnly,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.events.condition.primaryAction',\n      ol.events.condition.primaryAction,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.events.Event.prototype,\n      'type',\n      ol.events.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.events.Event.prototype,\n      'target',\n      ol.events.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.events.Event.prototype,\n      'preventDefault',\n      ol.events.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.events.Event.prototype,\n      'stopPropagation',\n      ol.events.Event.prototype.stopPropagation);\n  \n  goog.exportSymbol(\n      'ol.control.Attribution',\n      ol.control.Attribution,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.Attribution.render',\n      ol.control.Attribution.render,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'getCollapsible',\n      ol.control.Attribution.prototype.getCollapsible);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'setCollapsible',\n      ol.control.Attribution.prototype.setCollapsible);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'setCollapsed',\n      ol.control.Attribution.prototype.setCollapsed);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'getCollapsed',\n      ol.control.Attribution.prototype.getCollapsed);\n  \n  goog.exportSymbol(\n      'ol.control.Control',\n      ol.control.Control,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'getMap',\n      ol.control.Control.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'setMap',\n      ol.control.Control.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'setTarget',\n      ol.control.Control.prototype.setTarget);\n  \n  goog.exportSymbol(\n      'ol.control.FullScreen',\n      ol.control.FullScreen,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.MousePosition',\n      ol.control.MousePosition,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.MousePosition.render',\n      ol.control.MousePosition.render,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'getCoordinateFormat',\n      ol.control.MousePosition.prototype.getCoordinateFormat);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'getProjection',\n      ol.control.MousePosition.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'setCoordinateFormat',\n      ol.control.MousePosition.prototype.setCoordinateFormat);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'setProjection',\n      ol.control.MousePosition.prototype.setProjection);\n  \n  goog.exportSymbol(\n      'ol.control.OverviewMap',\n      ol.control.OverviewMap,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.OverviewMap.render',\n      ol.control.OverviewMap.render,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'getCollapsible',\n      ol.control.OverviewMap.prototype.getCollapsible);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'setCollapsible',\n      ol.control.OverviewMap.prototype.setCollapsible);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'setCollapsed',\n      ol.control.OverviewMap.prototype.setCollapsed);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'getCollapsed',\n      ol.control.OverviewMap.prototype.getCollapsed);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'getOverviewMap',\n      ol.control.OverviewMap.prototype.getOverviewMap);\n  \n  goog.exportSymbol(\n      'ol.control.Rotate',\n      ol.control.Rotate,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.Rotate.render',\n      ol.control.Rotate.render,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.ScaleLine',\n      ol.control.ScaleLine,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'getUnits',\n      ol.control.ScaleLine.prototype.getUnits);\n  \n  goog.exportSymbol(\n      'ol.control.ScaleLine.render',\n      ol.control.ScaleLine.render,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'setUnits',\n      ol.control.ScaleLine.prototype.setUnits);\n  \n  goog.exportSymbol(\n      'ol.control.Zoom',\n      ol.control.Zoom,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.ZoomSlider',\n      ol.control.ZoomSlider,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.ZoomSlider.render',\n      ol.control.ZoomSlider.render,\n      OPENLAYERS);\n  \n  goog.exportSymbol(\n      'ol.control.ZoomToExtent',\n      ol.control.ZoomToExtent,\n      OPENLAYERS);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'changed',\n      ol.Object.prototype.changed);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'dispatchEvent',\n      ol.Object.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'getRevision',\n      ol.Object.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'on',\n      ol.Object.prototype.on);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'once',\n      ol.Object.prototype.once);\n  \n  goog.exportProperty(\n      ol.Object.prototype,\n      'un',\n      ol.Object.prototype.un);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'get',\n      ol.PluggableMap.prototype.get);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getKeys',\n      ol.PluggableMap.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getProperties',\n      ol.PluggableMap.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'set',\n      ol.PluggableMap.prototype.set);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'setProperties',\n      ol.PluggableMap.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'unset',\n      ol.PluggableMap.prototype.unset);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'changed',\n      ol.PluggableMap.prototype.changed);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'dispatchEvent',\n      ol.PluggableMap.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'getRevision',\n      ol.PluggableMap.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'on',\n      ol.PluggableMap.prototype.on);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'once',\n      ol.PluggableMap.prototype.once);\n  \n  goog.exportProperty(\n      ol.PluggableMap.prototype,\n      'un',\n      ol.PluggableMap.prototype.un);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'addControl',\n      ol.CanvasMap.prototype.addControl);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'addInteraction',\n      ol.CanvasMap.prototype.addInteraction);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'addLayer',\n      ol.CanvasMap.prototype.addLayer);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'addOverlay',\n      ol.CanvasMap.prototype.addOverlay);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'forEachFeatureAtPixel',\n      ol.CanvasMap.prototype.forEachFeatureAtPixel);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getFeaturesAtPixel',\n      ol.CanvasMap.prototype.getFeaturesAtPixel);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'forEachLayerAtPixel',\n      ol.CanvasMap.prototype.forEachLayerAtPixel);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'hasFeatureAtPixel',\n      ol.CanvasMap.prototype.hasFeatureAtPixel);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getEventCoordinate',\n      ol.CanvasMap.prototype.getEventCoordinate);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getEventPixel',\n      ol.CanvasMap.prototype.getEventPixel);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getTarget',\n      ol.CanvasMap.prototype.getTarget);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getTargetElement',\n      ol.CanvasMap.prototype.getTargetElement);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getCoordinateFromPixel',\n      ol.CanvasMap.prototype.getCoordinateFromPixel);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getControls',\n      ol.CanvasMap.prototype.getControls);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getOverlays',\n      ol.CanvasMap.prototype.getOverlays);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getOverlayById',\n      ol.CanvasMap.prototype.getOverlayById);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getInteractions',\n      ol.CanvasMap.prototype.getInteractions);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getLayerGroup',\n      ol.CanvasMap.prototype.getLayerGroup);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getLayers',\n      ol.CanvasMap.prototype.getLayers);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getPixelFromCoordinate',\n      ol.CanvasMap.prototype.getPixelFromCoordinate);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getSize',\n      ol.CanvasMap.prototype.getSize);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getView',\n      ol.CanvasMap.prototype.getView);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getViewport',\n      ol.CanvasMap.prototype.getViewport);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'renderSync',\n      ol.CanvasMap.prototype.renderSync);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'render',\n      ol.CanvasMap.prototype.render);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'removeControl',\n      ol.CanvasMap.prototype.removeControl);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'removeInteraction',\n      ol.CanvasMap.prototype.removeInteraction);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'removeLayer',\n      ol.CanvasMap.prototype.removeLayer);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'removeOverlay',\n      ol.CanvasMap.prototype.removeOverlay);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'setLayerGroup',\n      ol.CanvasMap.prototype.setLayerGroup);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'setSize',\n      ol.CanvasMap.prototype.setSize);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'setTarget',\n      ol.CanvasMap.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'setView',\n      ol.CanvasMap.prototype.setView);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'updateSize',\n      ol.CanvasMap.prototype.updateSize);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'get',\n      ol.CanvasMap.prototype.get);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getKeys',\n      ol.CanvasMap.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getProperties',\n      ol.CanvasMap.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'set',\n      ol.CanvasMap.prototype.set);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'setProperties',\n      ol.CanvasMap.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'unset',\n      ol.CanvasMap.prototype.unset);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'changed',\n      ol.CanvasMap.prototype.changed);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'dispatchEvent',\n      ol.CanvasMap.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'getRevision',\n      ol.CanvasMap.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'on',\n      ol.CanvasMap.prototype.on);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'once',\n      ol.CanvasMap.prototype.once);\n  \n  goog.exportProperty(\n      ol.CanvasMap.prototype,\n      'un',\n      ol.CanvasMap.prototype.un);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'get',\n      ol.Collection.prototype.get);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'getKeys',\n      ol.Collection.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'getProperties',\n      ol.Collection.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'set',\n      ol.Collection.prototype.set);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'setProperties',\n      ol.Collection.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'unset',\n      ol.Collection.prototype.unset);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'changed',\n      ol.Collection.prototype.changed);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'dispatchEvent',\n      ol.Collection.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'getRevision',\n      ol.Collection.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'on',\n      ol.Collection.prototype.on);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'once',\n      ol.Collection.prototype.once);\n  \n  goog.exportProperty(\n      ol.Collection.prototype,\n      'un',\n      ol.Collection.prototype.un);\n  \n  goog.exportProperty(\n      ol.Collection.Event.prototype,\n      'type',\n      ol.Collection.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.Collection.Event.prototype,\n      'target',\n      ol.Collection.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.Collection.Event.prototype,\n      'preventDefault',\n      ol.Collection.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.Collection.Event.prototype,\n      'stopPropagation',\n      ol.Collection.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'get',\n      ol.DeviceOrientation.prototype.get);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'getKeys',\n      ol.DeviceOrientation.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'getProperties',\n      ol.DeviceOrientation.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'set',\n      ol.DeviceOrientation.prototype.set);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'setProperties',\n      ol.DeviceOrientation.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'unset',\n      ol.DeviceOrientation.prototype.unset);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'changed',\n      ol.DeviceOrientation.prototype.changed);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'dispatchEvent',\n      ol.DeviceOrientation.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'getRevision',\n      ol.DeviceOrientation.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'on',\n      ol.DeviceOrientation.prototype.on);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'once',\n      ol.DeviceOrientation.prototype.once);\n  \n  goog.exportProperty(\n      ol.DeviceOrientation.prototype,\n      'un',\n      ol.DeviceOrientation.prototype.un);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'get',\n      ol.Feature.prototype.get);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'getKeys',\n      ol.Feature.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'getProperties',\n      ol.Feature.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'set',\n      ol.Feature.prototype.set);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'setProperties',\n      ol.Feature.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'unset',\n      ol.Feature.prototype.unset);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'changed',\n      ol.Feature.prototype.changed);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'dispatchEvent',\n      ol.Feature.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'getRevision',\n      ol.Feature.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'on',\n      ol.Feature.prototype.on);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'once',\n      ol.Feature.prototype.once);\n  \n  goog.exportProperty(\n      ol.Feature.prototype,\n      'un',\n      ol.Feature.prototype.un);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'get',\n      ol.Geolocation.prototype.get);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getKeys',\n      ol.Geolocation.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getProperties',\n      ol.Geolocation.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'set',\n      ol.Geolocation.prototype.set);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'setProperties',\n      ol.Geolocation.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'unset',\n      ol.Geolocation.prototype.unset);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'changed',\n      ol.Geolocation.prototype.changed);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'dispatchEvent',\n      ol.Geolocation.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'getRevision',\n      ol.Geolocation.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'on',\n      ol.Geolocation.prototype.on);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'once',\n      ol.Geolocation.prototype.once);\n  \n  goog.exportProperty(\n      ol.Geolocation.prototype,\n      'un',\n      ol.Geolocation.prototype.un);\n  \n  goog.exportProperty(\n      ol.ImageTile.prototype,\n      'getTileCoord',\n      ol.ImageTile.prototype.getTileCoord);\n  \n  goog.exportProperty(\n      ol.ImageTile.prototype,\n      'load',\n      ol.ImageTile.prototype.load);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'addControl',\n      ol.Map.prototype.addControl);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'addInteraction',\n      ol.Map.prototype.addInteraction);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'addLayer',\n      ol.Map.prototype.addLayer);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'addOverlay',\n      ol.Map.prototype.addOverlay);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'forEachFeatureAtPixel',\n      ol.Map.prototype.forEachFeatureAtPixel);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getFeaturesAtPixel',\n      ol.Map.prototype.getFeaturesAtPixel);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'forEachLayerAtPixel',\n      ol.Map.prototype.forEachLayerAtPixel);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'hasFeatureAtPixel',\n      ol.Map.prototype.hasFeatureAtPixel);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getEventCoordinate',\n      ol.Map.prototype.getEventCoordinate);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getEventPixel',\n      ol.Map.prototype.getEventPixel);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getTarget',\n      ol.Map.prototype.getTarget);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getTargetElement',\n      ol.Map.prototype.getTargetElement);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getCoordinateFromPixel',\n      ol.Map.prototype.getCoordinateFromPixel);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getControls',\n      ol.Map.prototype.getControls);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getOverlays',\n      ol.Map.prototype.getOverlays);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getOverlayById',\n      ol.Map.prototype.getOverlayById);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getInteractions',\n      ol.Map.prototype.getInteractions);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getLayerGroup',\n      ol.Map.prototype.getLayerGroup);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getLayers',\n      ol.Map.prototype.getLayers);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getPixelFromCoordinate',\n      ol.Map.prototype.getPixelFromCoordinate);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getSize',\n      ol.Map.prototype.getSize);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getView',\n      ol.Map.prototype.getView);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getViewport',\n      ol.Map.prototype.getViewport);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'renderSync',\n      ol.Map.prototype.renderSync);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'render',\n      ol.Map.prototype.render);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'removeControl',\n      ol.Map.prototype.removeControl);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'removeInteraction',\n      ol.Map.prototype.removeInteraction);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'removeLayer',\n      ol.Map.prototype.removeLayer);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'removeOverlay',\n      ol.Map.prototype.removeOverlay);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'setLayerGroup',\n      ol.Map.prototype.setLayerGroup);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'setSize',\n      ol.Map.prototype.setSize);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'setTarget',\n      ol.Map.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'setView',\n      ol.Map.prototype.setView);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'updateSize',\n      ol.Map.prototype.updateSize);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'get',\n      ol.Map.prototype.get);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getKeys',\n      ol.Map.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getProperties',\n      ol.Map.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'set',\n      ol.Map.prototype.set);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'setProperties',\n      ol.Map.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'unset',\n      ol.Map.prototype.unset);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'changed',\n      ol.Map.prototype.changed);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'dispatchEvent',\n      ol.Map.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'getRevision',\n      ol.Map.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'on',\n      ol.Map.prototype.on);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'once',\n      ol.Map.prototype.once);\n  \n  goog.exportProperty(\n      ol.Map.prototype,\n      'un',\n      ol.Map.prototype.un);\n  \n  goog.exportProperty(\n      ol.MapEvent.prototype,\n      'type',\n      ol.MapEvent.prototype.type);\n  \n  goog.exportProperty(\n      ol.MapEvent.prototype,\n      'target',\n      ol.MapEvent.prototype.target);\n  \n  goog.exportProperty(\n      ol.MapEvent.prototype,\n      'preventDefault',\n      ol.MapEvent.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.MapEvent.prototype,\n      'stopPropagation',\n      ol.MapEvent.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'map',\n      ol.MapBrowserEvent.prototype.map);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'frameState',\n      ol.MapBrowserEvent.prototype.frameState);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'type',\n      ol.MapBrowserEvent.prototype.type);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'target',\n      ol.MapBrowserEvent.prototype.target);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'preventDefault',\n      ol.MapBrowserEvent.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.MapBrowserEvent.prototype,\n      'stopPropagation',\n      ol.MapBrowserEvent.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'originalEvent',\n      ol.MapBrowserPointerEvent.prototype.originalEvent);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'pixel',\n      ol.MapBrowserPointerEvent.prototype.pixel);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'coordinate',\n      ol.MapBrowserPointerEvent.prototype.coordinate);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'dragging',\n      ol.MapBrowserPointerEvent.prototype.dragging);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'preventDefault',\n      ol.MapBrowserPointerEvent.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'stopPropagation',\n      ol.MapBrowserPointerEvent.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'map',\n      ol.MapBrowserPointerEvent.prototype.map);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'frameState',\n      ol.MapBrowserPointerEvent.prototype.frameState);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'type',\n      ol.MapBrowserPointerEvent.prototype.type);\n  \n  goog.exportProperty(\n      ol.MapBrowserPointerEvent.prototype,\n      'target',\n      ol.MapBrowserPointerEvent.prototype.target);\n  \n  goog.exportProperty(\n      ol.Object.Event.prototype,\n      'type',\n      ol.Object.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.Object.Event.prototype,\n      'target',\n      ol.Object.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.Object.Event.prototype,\n      'preventDefault',\n      ol.Object.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.Object.Event.prototype,\n      'stopPropagation',\n      ol.Object.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'get',\n      ol.Overlay.prototype.get);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getKeys',\n      ol.Overlay.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getProperties',\n      ol.Overlay.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'set',\n      ol.Overlay.prototype.set);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'setProperties',\n      ol.Overlay.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'unset',\n      ol.Overlay.prototype.unset);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'changed',\n      ol.Overlay.prototype.changed);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'dispatchEvent',\n      ol.Overlay.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'getRevision',\n      ol.Overlay.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'on',\n      ol.Overlay.prototype.on);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'once',\n      ol.Overlay.prototype.once);\n  \n  goog.exportProperty(\n      ol.Overlay.prototype,\n      'un',\n      ol.Overlay.prototype.un);\n  \n  goog.exportProperty(\n      ol.VectorImageTile.prototype,\n      'getTileCoord',\n      ol.VectorImageTile.prototype.getTileCoord);\n  \n  goog.exportProperty(\n      ol.VectorImageTile.prototype,\n      'load',\n      ol.VectorImageTile.prototype.load);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'getTileCoord',\n      ol.VectorTile.prototype.getTileCoord);\n  \n  goog.exportProperty(\n      ol.VectorTile.prototype,\n      'load',\n      ol.VectorTile.prototype.load);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'get',\n      ol.View.prototype.get);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getKeys',\n      ol.View.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getProperties',\n      ol.View.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'set',\n      ol.View.prototype.set);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'setProperties',\n      ol.View.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'unset',\n      ol.View.prototype.unset);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'changed',\n      ol.View.prototype.changed);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'dispatchEvent',\n      ol.View.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'getRevision',\n      ol.View.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'on',\n      ol.View.prototype.on);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'once',\n      ol.View.prototype.once);\n  \n  goog.exportProperty(\n      ol.View.prototype,\n      'un',\n      ol.View.prototype.un);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'forEachTileCoord',\n      ol.tilegrid.WMTS.prototype.forEachTileCoord);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getMaxZoom',\n      ol.tilegrid.WMTS.prototype.getMaxZoom);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getMinZoom',\n      ol.tilegrid.WMTS.prototype.getMinZoom);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getOrigin',\n      ol.tilegrid.WMTS.prototype.getOrigin);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getResolution',\n      ol.tilegrid.WMTS.prototype.getResolution);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getResolutions',\n      ol.tilegrid.WMTS.prototype.getResolutions);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getTileCoordExtent',\n      ol.tilegrid.WMTS.prototype.getTileCoordExtent);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getTileCoordForCoordAndResolution',\n      ol.tilegrid.WMTS.prototype.getTileCoordForCoordAndResolution);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getTileCoordForCoordAndZ',\n      ol.tilegrid.WMTS.prototype.getTileCoordForCoordAndZ);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getTileSize',\n      ol.tilegrid.WMTS.prototype.getTileSize);\n  \n  goog.exportProperty(\n      ol.tilegrid.WMTS.prototype,\n      'getZForResolution',\n      ol.tilegrid.WMTS.prototype.getZForResolution);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getOpacity',\n      ol.style.RegularShape.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getRotateWithView',\n      ol.style.RegularShape.prototype.getRotateWithView);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getRotation',\n      ol.style.RegularShape.prototype.getRotation);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getScale',\n      ol.style.RegularShape.prototype.getScale);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'getSnapToPixel',\n      ol.style.RegularShape.prototype.getSnapToPixel);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'setOpacity',\n      ol.style.RegularShape.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'setRotation',\n      ol.style.RegularShape.prototype.setRotation);\n  \n  goog.exportProperty(\n      ol.style.RegularShape.prototype,\n      'setScale',\n      ol.style.RegularShape.prototype.setScale);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'clone',\n      ol.style.Circle.prototype.clone);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getAngle',\n      ol.style.Circle.prototype.getAngle);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getFill',\n      ol.style.Circle.prototype.getFill);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getPoints',\n      ol.style.Circle.prototype.getPoints);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getRadius',\n      ol.style.Circle.prototype.getRadius);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getRadius2',\n      ol.style.Circle.prototype.getRadius2);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getStroke',\n      ol.style.Circle.prototype.getStroke);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getOpacity',\n      ol.style.Circle.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getRotateWithView',\n      ol.style.Circle.prototype.getRotateWithView);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getRotation',\n      ol.style.Circle.prototype.getRotation);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getScale',\n      ol.style.Circle.prototype.getScale);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'getSnapToPixel',\n      ol.style.Circle.prototype.getSnapToPixel);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'setOpacity',\n      ol.style.Circle.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'setRotation',\n      ol.style.Circle.prototype.setRotation);\n  \n  goog.exportProperty(\n      ol.style.Circle.prototype,\n      'setScale',\n      ol.style.Circle.prototype.setScale);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getOpacity',\n      ol.style.Icon.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getRotateWithView',\n      ol.style.Icon.prototype.getRotateWithView);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getRotation',\n      ol.style.Icon.prototype.getRotation);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getScale',\n      ol.style.Icon.prototype.getScale);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'getSnapToPixel',\n      ol.style.Icon.prototype.getSnapToPixel);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'setOpacity',\n      ol.style.Icon.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'setRotation',\n      ol.style.Icon.prototype.setRotation);\n  \n  goog.exportProperty(\n      ol.style.Icon.prototype,\n      'setScale',\n      ol.style.Icon.prototype.setScale);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'get',\n      ol.source.Source.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'getKeys',\n      ol.source.Source.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'getProperties',\n      ol.source.Source.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'set',\n      ol.source.Source.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'setProperties',\n      ol.source.Source.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'unset',\n      ol.source.Source.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'changed',\n      ol.source.Source.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'dispatchEvent',\n      ol.source.Source.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'getRevision',\n      ol.source.Source.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'on',\n      ol.source.Source.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'once',\n      ol.source.Source.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.Source.prototype,\n      'un',\n      ol.source.Source.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'getAttributions',\n      ol.source.Tile.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'getLogo',\n      ol.source.Tile.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'getProjection',\n      ol.source.Tile.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'getState',\n      ol.source.Tile.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'refresh',\n      ol.source.Tile.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'setAttributions',\n      ol.source.Tile.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'get',\n      ol.source.Tile.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'getKeys',\n      ol.source.Tile.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'getProperties',\n      ol.source.Tile.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'set',\n      ol.source.Tile.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'setProperties',\n      ol.source.Tile.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'unset',\n      ol.source.Tile.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'changed',\n      ol.source.Tile.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'dispatchEvent',\n      ol.source.Tile.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'getRevision',\n      ol.source.Tile.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'on',\n      ol.source.Tile.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'once',\n      ol.source.Tile.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.Tile.prototype,\n      'un',\n      ol.source.Tile.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getTileGrid',\n      ol.source.UrlTile.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'refresh',\n      ol.source.UrlTile.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getAttributions',\n      ol.source.UrlTile.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getLogo',\n      ol.source.UrlTile.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getProjection',\n      ol.source.UrlTile.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getState',\n      ol.source.UrlTile.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'setAttributions',\n      ol.source.UrlTile.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'get',\n      ol.source.UrlTile.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getKeys',\n      ol.source.UrlTile.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getProperties',\n      ol.source.UrlTile.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'set',\n      ol.source.UrlTile.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'setProperties',\n      ol.source.UrlTile.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'unset',\n      ol.source.UrlTile.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'changed',\n      ol.source.UrlTile.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'dispatchEvent',\n      ol.source.UrlTile.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'getRevision',\n      ol.source.UrlTile.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'on',\n      ol.source.UrlTile.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'once',\n      ol.source.UrlTile.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.UrlTile.prototype,\n      'un',\n      ol.source.UrlTile.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getTileLoadFunction',\n      ol.source.TileImage.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getTileUrlFunction',\n      ol.source.TileImage.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getUrls',\n      ol.source.TileImage.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'setTileLoadFunction',\n      ol.source.TileImage.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'setTileUrlFunction',\n      ol.source.TileImage.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'setUrl',\n      ol.source.TileImage.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'setUrls',\n      ol.source.TileImage.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getTileGrid',\n      ol.source.TileImage.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'refresh',\n      ol.source.TileImage.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getAttributions',\n      ol.source.TileImage.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getLogo',\n      ol.source.TileImage.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getProjection',\n      ol.source.TileImage.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getState',\n      ol.source.TileImage.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'setAttributions',\n      ol.source.TileImage.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'get',\n      ol.source.TileImage.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getKeys',\n      ol.source.TileImage.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getProperties',\n      ol.source.TileImage.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'set',\n      ol.source.TileImage.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'setProperties',\n      ol.source.TileImage.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'unset',\n      ol.source.TileImage.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'changed',\n      ol.source.TileImage.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'dispatchEvent',\n      ol.source.TileImage.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'getRevision',\n      ol.source.TileImage.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'on',\n      ol.source.TileImage.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'once',\n      ol.source.TileImage.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.TileImage.prototype,\n      'un',\n      ol.source.TileImage.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.BingMaps.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'setTileGridForProjection',\n      ol.source.BingMaps.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getTileLoadFunction',\n      ol.source.BingMaps.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getTileUrlFunction',\n      ol.source.BingMaps.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getUrls',\n      ol.source.BingMaps.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'setTileLoadFunction',\n      ol.source.BingMaps.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'setTileUrlFunction',\n      ol.source.BingMaps.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'setUrl',\n      ol.source.BingMaps.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'setUrls',\n      ol.source.BingMaps.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getTileGrid',\n      ol.source.BingMaps.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'refresh',\n      ol.source.BingMaps.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getAttributions',\n      ol.source.BingMaps.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getLogo',\n      ol.source.BingMaps.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getProjection',\n      ol.source.BingMaps.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getState',\n      ol.source.BingMaps.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'setAttributions',\n      ol.source.BingMaps.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'get',\n      ol.source.BingMaps.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getKeys',\n      ol.source.BingMaps.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getProperties',\n      ol.source.BingMaps.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'set',\n      ol.source.BingMaps.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'setProperties',\n      ol.source.BingMaps.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'unset',\n      ol.source.BingMaps.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'changed',\n      ol.source.BingMaps.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'dispatchEvent',\n      ol.source.BingMaps.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'getRevision',\n      ol.source.BingMaps.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'on',\n      ol.source.BingMaps.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'once',\n      ol.source.BingMaps.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.BingMaps.prototype,\n      'un',\n      ol.source.BingMaps.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.XYZ.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'setTileGridForProjection',\n      ol.source.XYZ.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getTileLoadFunction',\n      ol.source.XYZ.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getTileUrlFunction',\n      ol.source.XYZ.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getUrls',\n      ol.source.XYZ.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'setTileLoadFunction',\n      ol.source.XYZ.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'setTileUrlFunction',\n      ol.source.XYZ.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'setUrl',\n      ol.source.XYZ.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'setUrls',\n      ol.source.XYZ.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getTileGrid',\n      ol.source.XYZ.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'refresh',\n      ol.source.XYZ.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getAttributions',\n      ol.source.XYZ.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getLogo',\n      ol.source.XYZ.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getProjection',\n      ol.source.XYZ.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getState',\n      ol.source.XYZ.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'setAttributions',\n      ol.source.XYZ.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'get',\n      ol.source.XYZ.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getKeys',\n      ol.source.XYZ.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getProperties',\n      ol.source.XYZ.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'set',\n      ol.source.XYZ.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'setProperties',\n      ol.source.XYZ.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'unset',\n      ol.source.XYZ.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'changed',\n      ol.source.XYZ.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'dispatchEvent',\n      ol.source.XYZ.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'getRevision',\n      ol.source.XYZ.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'on',\n      ol.source.XYZ.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'once',\n      ol.source.XYZ.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.XYZ.prototype,\n      'un',\n      ol.source.XYZ.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.CartoDB.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setTileGridForProjection',\n      ol.source.CartoDB.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getTileLoadFunction',\n      ol.source.CartoDB.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getTileUrlFunction',\n      ol.source.CartoDB.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getUrls',\n      ol.source.CartoDB.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setTileLoadFunction',\n      ol.source.CartoDB.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setTileUrlFunction',\n      ol.source.CartoDB.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setUrl',\n      ol.source.CartoDB.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setUrls',\n      ol.source.CartoDB.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getTileGrid',\n      ol.source.CartoDB.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'refresh',\n      ol.source.CartoDB.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getAttributions',\n      ol.source.CartoDB.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getLogo',\n      ol.source.CartoDB.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getProjection',\n      ol.source.CartoDB.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getState',\n      ol.source.CartoDB.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setAttributions',\n      ol.source.CartoDB.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'get',\n      ol.source.CartoDB.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getKeys',\n      ol.source.CartoDB.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getProperties',\n      ol.source.CartoDB.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'set',\n      ol.source.CartoDB.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'setProperties',\n      ol.source.CartoDB.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'unset',\n      ol.source.CartoDB.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'changed',\n      ol.source.CartoDB.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'dispatchEvent',\n      ol.source.CartoDB.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'getRevision',\n      ol.source.CartoDB.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'on',\n      ol.source.CartoDB.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'once',\n      ol.source.CartoDB.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.CartoDB.prototype,\n      'un',\n      ol.source.CartoDB.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getAttributions',\n      ol.source.Vector.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getLogo',\n      ol.source.Vector.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getProjection',\n      ol.source.Vector.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getState',\n      ol.source.Vector.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'refresh',\n      ol.source.Vector.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'setAttributions',\n      ol.source.Vector.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'get',\n      ol.source.Vector.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getKeys',\n      ol.source.Vector.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getProperties',\n      ol.source.Vector.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'set',\n      ol.source.Vector.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'setProperties',\n      ol.source.Vector.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'unset',\n      ol.source.Vector.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'changed',\n      ol.source.Vector.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'dispatchEvent',\n      ol.source.Vector.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'getRevision',\n      ol.source.Vector.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'on',\n      ol.source.Vector.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'once',\n      ol.source.Vector.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.Vector.prototype,\n      'un',\n      ol.source.Vector.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'addFeature',\n      ol.source.Cluster.prototype.addFeature);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'addFeatures',\n      ol.source.Cluster.prototype.addFeatures);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'clear',\n      ol.source.Cluster.prototype.clear);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'forEachFeature',\n      ol.source.Cluster.prototype.forEachFeature);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'forEachFeatureInExtent',\n      ol.source.Cluster.prototype.forEachFeatureInExtent);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'forEachFeatureIntersectingExtent',\n      ol.source.Cluster.prototype.forEachFeatureIntersectingExtent);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getFeaturesCollection',\n      ol.source.Cluster.prototype.getFeaturesCollection);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getFeatures',\n      ol.source.Cluster.prototype.getFeatures);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getFeaturesAtCoordinate',\n      ol.source.Cluster.prototype.getFeaturesAtCoordinate);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getFeaturesInExtent',\n      ol.source.Cluster.prototype.getFeaturesInExtent);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getClosestFeatureToCoordinate',\n      ol.source.Cluster.prototype.getClosestFeatureToCoordinate);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getExtent',\n      ol.source.Cluster.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getFeatureById',\n      ol.source.Cluster.prototype.getFeatureById);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getFormat',\n      ol.source.Cluster.prototype.getFormat);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getUrl',\n      ol.source.Cluster.prototype.getUrl);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'removeLoadedExtent',\n      ol.source.Cluster.prototype.removeLoadedExtent);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'removeFeature',\n      ol.source.Cluster.prototype.removeFeature);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'setLoader',\n      ol.source.Cluster.prototype.setLoader);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getAttributions',\n      ol.source.Cluster.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getLogo',\n      ol.source.Cluster.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getProjection',\n      ol.source.Cluster.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getState',\n      ol.source.Cluster.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'refresh',\n      ol.source.Cluster.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'setAttributions',\n      ol.source.Cluster.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'get',\n      ol.source.Cluster.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getKeys',\n      ol.source.Cluster.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getProperties',\n      ol.source.Cluster.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'set',\n      ol.source.Cluster.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'setProperties',\n      ol.source.Cluster.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'unset',\n      ol.source.Cluster.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'changed',\n      ol.source.Cluster.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'dispatchEvent',\n      ol.source.Cluster.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'getRevision',\n      ol.source.Cluster.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'on',\n      ol.source.Cluster.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'once',\n      ol.source.Cluster.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.Cluster.prototype,\n      'un',\n      ol.source.Cluster.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'getAttributions',\n      ol.source.Image.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'getLogo',\n      ol.source.Image.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'getProjection',\n      ol.source.Image.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'getState',\n      ol.source.Image.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'refresh',\n      ol.source.Image.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'setAttributions',\n      ol.source.Image.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'get',\n      ol.source.Image.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'getKeys',\n      ol.source.Image.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'getProperties',\n      ol.source.Image.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'set',\n      ol.source.Image.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'setProperties',\n      ol.source.Image.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'unset',\n      ol.source.Image.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'changed',\n      ol.source.Image.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'dispatchEvent',\n      ol.source.Image.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'getRevision',\n      ol.source.Image.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'on',\n      ol.source.Image.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'once',\n      ol.source.Image.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.Image.prototype,\n      'un',\n      ol.source.Image.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Image.Event.prototype,\n      'type',\n      ol.source.Image.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.source.Image.Event.prototype,\n      'target',\n      ol.source.Image.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.source.Image.Event.prototype,\n      'preventDefault',\n      ol.source.Image.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.source.Image.Event.prototype,\n      'stopPropagation',\n      ol.source.Image.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getAttributions',\n      ol.source.ImageArcGISRest.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getLogo',\n      ol.source.ImageArcGISRest.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getProjection',\n      ol.source.ImageArcGISRest.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getState',\n      ol.source.ImageArcGISRest.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'refresh',\n      ol.source.ImageArcGISRest.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'setAttributions',\n      ol.source.ImageArcGISRest.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'get',\n      ol.source.ImageArcGISRest.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getKeys',\n      ol.source.ImageArcGISRest.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getProperties',\n      ol.source.ImageArcGISRest.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'set',\n      ol.source.ImageArcGISRest.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'setProperties',\n      ol.source.ImageArcGISRest.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'unset',\n      ol.source.ImageArcGISRest.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'changed',\n      ol.source.ImageArcGISRest.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'dispatchEvent',\n      ol.source.ImageArcGISRest.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'getRevision',\n      ol.source.ImageArcGISRest.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'on',\n      ol.source.ImageArcGISRest.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'once',\n      ol.source.ImageArcGISRest.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.ImageArcGISRest.prototype,\n      'un',\n      ol.source.ImageArcGISRest.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'getAttributions',\n      ol.source.ImageCanvas.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'getLogo',\n      ol.source.ImageCanvas.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'getProjection',\n      ol.source.ImageCanvas.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'getState',\n      ol.source.ImageCanvas.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'refresh',\n      ol.source.ImageCanvas.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'setAttributions',\n      ol.source.ImageCanvas.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'get',\n      ol.source.ImageCanvas.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'getKeys',\n      ol.source.ImageCanvas.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'getProperties',\n      ol.source.ImageCanvas.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'set',\n      ol.source.ImageCanvas.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'setProperties',\n      ol.source.ImageCanvas.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'unset',\n      ol.source.ImageCanvas.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'changed',\n      ol.source.ImageCanvas.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'dispatchEvent',\n      ol.source.ImageCanvas.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'getRevision',\n      ol.source.ImageCanvas.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'on',\n      ol.source.ImageCanvas.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'once',\n      ol.source.ImageCanvas.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.ImageCanvas.prototype,\n      'un',\n      ol.source.ImageCanvas.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getAttributions',\n      ol.source.ImageMapGuide.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getLogo',\n      ol.source.ImageMapGuide.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getProjection',\n      ol.source.ImageMapGuide.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getState',\n      ol.source.ImageMapGuide.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'refresh',\n      ol.source.ImageMapGuide.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'setAttributions',\n      ol.source.ImageMapGuide.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'get',\n      ol.source.ImageMapGuide.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getKeys',\n      ol.source.ImageMapGuide.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getProperties',\n      ol.source.ImageMapGuide.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'set',\n      ol.source.ImageMapGuide.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'setProperties',\n      ol.source.ImageMapGuide.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'unset',\n      ol.source.ImageMapGuide.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'changed',\n      ol.source.ImageMapGuide.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'dispatchEvent',\n      ol.source.ImageMapGuide.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'getRevision',\n      ol.source.ImageMapGuide.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'on',\n      ol.source.ImageMapGuide.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'once',\n      ol.source.ImageMapGuide.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.ImageMapGuide.prototype,\n      'un',\n      ol.source.ImageMapGuide.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'getAttributions',\n      ol.source.ImageStatic.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'getLogo',\n      ol.source.ImageStatic.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'getProjection',\n      ol.source.ImageStatic.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'getState',\n      ol.source.ImageStatic.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'refresh',\n      ol.source.ImageStatic.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'setAttributions',\n      ol.source.ImageStatic.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'get',\n      ol.source.ImageStatic.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'getKeys',\n      ol.source.ImageStatic.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'getProperties',\n      ol.source.ImageStatic.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'set',\n      ol.source.ImageStatic.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'setProperties',\n      ol.source.ImageStatic.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'unset',\n      ol.source.ImageStatic.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'changed',\n      ol.source.ImageStatic.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'dispatchEvent',\n      ol.source.ImageStatic.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'getRevision',\n      ol.source.ImageStatic.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'on',\n      ol.source.ImageStatic.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'once',\n      ol.source.ImageStatic.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.ImageStatic.prototype,\n      'un',\n      ol.source.ImageStatic.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getAttributions',\n      ol.source.ImageVector.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getLogo',\n      ol.source.ImageVector.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getProjection',\n      ol.source.ImageVector.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getState',\n      ol.source.ImageVector.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'refresh',\n      ol.source.ImageVector.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'setAttributions',\n      ol.source.ImageVector.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'get',\n      ol.source.ImageVector.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getKeys',\n      ol.source.ImageVector.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getProperties',\n      ol.source.ImageVector.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'set',\n      ol.source.ImageVector.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'setProperties',\n      ol.source.ImageVector.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'unset',\n      ol.source.ImageVector.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'changed',\n      ol.source.ImageVector.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'dispatchEvent',\n      ol.source.ImageVector.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'getRevision',\n      ol.source.ImageVector.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'on',\n      ol.source.ImageVector.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'once',\n      ol.source.ImageVector.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.ImageVector.prototype,\n      'un',\n      ol.source.ImageVector.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getAttributions',\n      ol.source.ImageWMS.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getLogo',\n      ol.source.ImageWMS.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getProjection',\n      ol.source.ImageWMS.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getState',\n      ol.source.ImageWMS.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'refresh',\n      ol.source.ImageWMS.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'setAttributions',\n      ol.source.ImageWMS.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'get',\n      ol.source.ImageWMS.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getKeys',\n      ol.source.ImageWMS.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getProperties',\n      ol.source.ImageWMS.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'set',\n      ol.source.ImageWMS.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'setProperties',\n      ol.source.ImageWMS.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'unset',\n      ol.source.ImageWMS.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'changed',\n      ol.source.ImageWMS.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'dispatchEvent',\n      ol.source.ImageWMS.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'getRevision',\n      ol.source.ImageWMS.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'on',\n      ol.source.ImageWMS.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'once',\n      ol.source.ImageWMS.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.ImageWMS.prototype,\n      'un',\n      ol.source.ImageWMS.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.OSM.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'setTileGridForProjection',\n      ol.source.OSM.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getTileLoadFunction',\n      ol.source.OSM.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getTileUrlFunction',\n      ol.source.OSM.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getUrls',\n      ol.source.OSM.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'setTileLoadFunction',\n      ol.source.OSM.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'setTileUrlFunction',\n      ol.source.OSM.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'setUrl',\n      ol.source.OSM.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'setUrls',\n      ol.source.OSM.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getTileGrid',\n      ol.source.OSM.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'refresh',\n      ol.source.OSM.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getAttributions',\n      ol.source.OSM.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getLogo',\n      ol.source.OSM.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getProjection',\n      ol.source.OSM.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getState',\n      ol.source.OSM.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'setAttributions',\n      ol.source.OSM.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'get',\n      ol.source.OSM.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getKeys',\n      ol.source.OSM.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getProperties',\n      ol.source.OSM.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'set',\n      ol.source.OSM.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'setProperties',\n      ol.source.OSM.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'unset',\n      ol.source.OSM.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'changed',\n      ol.source.OSM.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'dispatchEvent',\n      ol.source.OSM.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'getRevision',\n      ol.source.OSM.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'on',\n      ol.source.OSM.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'once',\n      ol.source.OSM.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.OSM.prototype,\n      'un',\n      ol.source.OSM.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'getAttributions',\n      ol.source.Raster.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'getLogo',\n      ol.source.Raster.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'getProjection',\n      ol.source.Raster.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'getState',\n      ol.source.Raster.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'refresh',\n      ol.source.Raster.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'setAttributions',\n      ol.source.Raster.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'get',\n      ol.source.Raster.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'getKeys',\n      ol.source.Raster.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'getProperties',\n      ol.source.Raster.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'set',\n      ol.source.Raster.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'setProperties',\n      ol.source.Raster.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'unset',\n      ol.source.Raster.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'changed',\n      ol.source.Raster.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'dispatchEvent',\n      ol.source.Raster.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'getRevision',\n      ol.source.Raster.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'on',\n      ol.source.Raster.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'once',\n      ol.source.Raster.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.Raster.prototype,\n      'un',\n      ol.source.Raster.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Raster.Event.prototype,\n      'type',\n      ol.source.Raster.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.source.Raster.Event.prototype,\n      'target',\n      ol.source.Raster.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.source.Raster.Event.prototype,\n      'preventDefault',\n      ol.source.Raster.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.source.Raster.Event.prototype,\n      'stopPropagation',\n      ol.source.Raster.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.Stamen.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'setTileGridForProjection',\n      ol.source.Stamen.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getTileLoadFunction',\n      ol.source.Stamen.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getTileUrlFunction',\n      ol.source.Stamen.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getUrls',\n      ol.source.Stamen.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'setTileLoadFunction',\n      ol.source.Stamen.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'setTileUrlFunction',\n      ol.source.Stamen.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'setUrl',\n      ol.source.Stamen.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'setUrls',\n      ol.source.Stamen.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getTileGrid',\n      ol.source.Stamen.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'refresh',\n      ol.source.Stamen.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getAttributions',\n      ol.source.Stamen.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getLogo',\n      ol.source.Stamen.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getProjection',\n      ol.source.Stamen.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getState',\n      ol.source.Stamen.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'setAttributions',\n      ol.source.Stamen.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'get',\n      ol.source.Stamen.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getKeys',\n      ol.source.Stamen.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getProperties',\n      ol.source.Stamen.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'set',\n      ol.source.Stamen.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'setProperties',\n      ol.source.Stamen.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'unset',\n      ol.source.Stamen.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'changed',\n      ol.source.Stamen.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'dispatchEvent',\n      ol.source.Stamen.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'getRevision',\n      ol.source.Stamen.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'on',\n      ol.source.Stamen.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'once',\n      ol.source.Stamen.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.Stamen.prototype,\n      'un',\n      ol.source.Stamen.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Tile.Event.prototype,\n      'type',\n      ol.source.Tile.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.source.Tile.Event.prototype,\n      'target',\n      ol.source.Tile.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.source.Tile.Event.prototype,\n      'preventDefault',\n      ol.source.Tile.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.source.Tile.Event.prototype,\n      'stopPropagation',\n      ol.source.Tile.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.TileArcGISRest.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'setTileGridForProjection',\n      ol.source.TileArcGISRest.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getTileLoadFunction',\n      ol.source.TileArcGISRest.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getTileUrlFunction',\n      ol.source.TileArcGISRest.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getUrls',\n      ol.source.TileArcGISRest.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'setTileLoadFunction',\n      ol.source.TileArcGISRest.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'setTileUrlFunction',\n      ol.source.TileArcGISRest.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'setUrl',\n      ol.source.TileArcGISRest.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'setUrls',\n      ol.source.TileArcGISRest.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getTileGrid',\n      ol.source.TileArcGISRest.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'refresh',\n      ol.source.TileArcGISRest.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getAttributions',\n      ol.source.TileArcGISRest.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getLogo',\n      ol.source.TileArcGISRest.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getProjection',\n      ol.source.TileArcGISRest.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getState',\n      ol.source.TileArcGISRest.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'setAttributions',\n      ol.source.TileArcGISRest.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'get',\n      ol.source.TileArcGISRest.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getKeys',\n      ol.source.TileArcGISRest.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getProperties',\n      ol.source.TileArcGISRest.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'set',\n      ol.source.TileArcGISRest.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'setProperties',\n      ol.source.TileArcGISRest.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'unset',\n      ol.source.TileArcGISRest.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'changed',\n      ol.source.TileArcGISRest.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'dispatchEvent',\n      ol.source.TileArcGISRest.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'getRevision',\n      ol.source.TileArcGISRest.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'on',\n      ol.source.TileArcGISRest.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'once',\n      ol.source.TileArcGISRest.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.TileArcGISRest.prototype,\n      'un',\n      ol.source.TileArcGISRest.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'getTileGrid',\n      ol.source.TileDebug.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'refresh',\n      ol.source.TileDebug.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'getAttributions',\n      ol.source.TileDebug.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'getLogo',\n      ol.source.TileDebug.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'getProjection',\n      ol.source.TileDebug.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'getState',\n      ol.source.TileDebug.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'setAttributions',\n      ol.source.TileDebug.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'get',\n      ol.source.TileDebug.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'getKeys',\n      ol.source.TileDebug.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'getProperties',\n      ol.source.TileDebug.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'set',\n      ol.source.TileDebug.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'setProperties',\n      ol.source.TileDebug.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'unset',\n      ol.source.TileDebug.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'changed',\n      ol.source.TileDebug.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'dispatchEvent',\n      ol.source.TileDebug.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'getRevision',\n      ol.source.TileDebug.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'on',\n      ol.source.TileDebug.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'once',\n      ol.source.TileDebug.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.TileDebug.prototype,\n      'un',\n      ol.source.TileDebug.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.TileJSON.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'setTileGridForProjection',\n      ol.source.TileJSON.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getTileLoadFunction',\n      ol.source.TileJSON.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getTileUrlFunction',\n      ol.source.TileJSON.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getUrls',\n      ol.source.TileJSON.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'setTileLoadFunction',\n      ol.source.TileJSON.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'setTileUrlFunction',\n      ol.source.TileJSON.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'setUrl',\n      ol.source.TileJSON.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'setUrls',\n      ol.source.TileJSON.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getTileGrid',\n      ol.source.TileJSON.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'refresh',\n      ol.source.TileJSON.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getAttributions',\n      ol.source.TileJSON.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getLogo',\n      ol.source.TileJSON.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getProjection',\n      ol.source.TileJSON.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getState',\n      ol.source.TileJSON.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'setAttributions',\n      ol.source.TileJSON.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'get',\n      ol.source.TileJSON.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getKeys',\n      ol.source.TileJSON.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getProperties',\n      ol.source.TileJSON.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'set',\n      ol.source.TileJSON.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'setProperties',\n      ol.source.TileJSON.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'unset',\n      ol.source.TileJSON.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'changed',\n      ol.source.TileJSON.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'dispatchEvent',\n      ol.source.TileJSON.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'getRevision',\n      ol.source.TileJSON.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'on',\n      ol.source.TileJSON.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'once',\n      ol.source.TileJSON.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.TileJSON.prototype,\n      'un',\n      ol.source.TileJSON.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getTileGrid',\n      ol.source.TileUTFGrid.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'refresh',\n      ol.source.TileUTFGrid.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getAttributions',\n      ol.source.TileUTFGrid.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getLogo',\n      ol.source.TileUTFGrid.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getProjection',\n      ol.source.TileUTFGrid.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getState',\n      ol.source.TileUTFGrid.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'setAttributions',\n      ol.source.TileUTFGrid.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'get',\n      ol.source.TileUTFGrid.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getKeys',\n      ol.source.TileUTFGrid.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getProperties',\n      ol.source.TileUTFGrid.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'set',\n      ol.source.TileUTFGrid.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'setProperties',\n      ol.source.TileUTFGrid.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'unset',\n      ol.source.TileUTFGrid.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'changed',\n      ol.source.TileUTFGrid.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'dispatchEvent',\n      ol.source.TileUTFGrid.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'getRevision',\n      ol.source.TileUTFGrid.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'on',\n      ol.source.TileUTFGrid.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'once',\n      ol.source.TileUTFGrid.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.TileUTFGrid.prototype,\n      'un',\n      ol.source.TileUTFGrid.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.TileWMS.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'setTileGridForProjection',\n      ol.source.TileWMS.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getTileLoadFunction',\n      ol.source.TileWMS.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getTileUrlFunction',\n      ol.source.TileWMS.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getUrls',\n      ol.source.TileWMS.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'setTileLoadFunction',\n      ol.source.TileWMS.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'setTileUrlFunction',\n      ol.source.TileWMS.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'setUrl',\n      ol.source.TileWMS.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'setUrls',\n      ol.source.TileWMS.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getTileGrid',\n      ol.source.TileWMS.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'refresh',\n      ol.source.TileWMS.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getAttributions',\n      ol.source.TileWMS.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getLogo',\n      ol.source.TileWMS.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getProjection',\n      ol.source.TileWMS.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getState',\n      ol.source.TileWMS.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'setAttributions',\n      ol.source.TileWMS.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'get',\n      ol.source.TileWMS.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getKeys',\n      ol.source.TileWMS.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getProperties',\n      ol.source.TileWMS.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'set',\n      ol.source.TileWMS.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'setProperties',\n      ol.source.TileWMS.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'unset',\n      ol.source.TileWMS.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'changed',\n      ol.source.TileWMS.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'dispatchEvent',\n      ol.source.TileWMS.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'getRevision',\n      ol.source.TileWMS.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'on',\n      ol.source.TileWMS.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'once',\n      ol.source.TileWMS.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.TileWMS.prototype,\n      'un',\n      ol.source.TileWMS.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Vector.Event.prototype,\n      'type',\n      ol.source.Vector.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.source.Vector.Event.prototype,\n      'target',\n      ol.source.Vector.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.source.Vector.Event.prototype,\n      'preventDefault',\n      ol.source.Vector.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.source.Vector.Event.prototype,\n      'stopPropagation',\n      ol.source.Vector.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getTileLoadFunction',\n      ol.source.VectorTile.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getTileUrlFunction',\n      ol.source.VectorTile.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getUrls',\n      ol.source.VectorTile.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'setTileLoadFunction',\n      ol.source.VectorTile.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'setTileUrlFunction',\n      ol.source.VectorTile.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'setUrl',\n      ol.source.VectorTile.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'setUrls',\n      ol.source.VectorTile.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getTileGrid',\n      ol.source.VectorTile.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'refresh',\n      ol.source.VectorTile.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getAttributions',\n      ol.source.VectorTile.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getLogo',\n      ol.source.VectorTile.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getProjection',\n      ol.source.VectorTile.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getState',\n      ol.source.VectorTile.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'setAttributions',\n      ol.source.VectorTile.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'get',\n      ol.source.VectorTile.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getKeys',\n      ol.source.VectorTile.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getProperties',\n      ol.source.VectorTile.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'set',\n      ol.source.VectorTile.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'setProperties',\n      ol.source.VectorTile.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'unset',\n      ol.source.VectorTile.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'changed',\n      ol.source.VectorTile.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'dispatchEvent',\n      ol.source.VectorTile.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'getRevision',\n      ol.source.VectorTile.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'on',\n      ol.source.VectorTile.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'once',\n      ol.source.VectorTile.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.VectorTile.prototype,\n      'un',\n      ol.source.VectorTile.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.WMTS.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'setTileGridForProjection',\n      ol.source.WMTS.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getTileLoadFunction',\n      ol.source.WMTS.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getTileUrlFunction',\n      ol.source.WMTS.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getUrls',\n      ol.source.WMTS.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'setTileLoadFunction',\n      ol.source.WMTS.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'setTileUrlFunction',\n      ol.source.WMTS.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'setUrl',\n      ol.source.WMTS.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'setUrls',\n      ol.source.WMTS.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getTileGrid',\n      ol.source.WMTS.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'refresh',\n      ol.source.WMTS.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getAttributions',\n      ol.source.WMTS.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getLogo',\n      ol.source.WMTS.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getProjection',\n      ol.source.WMTS.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getState',\n      ol.source.WMTS.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'setAttributions',\n      ol.source.WMTS.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'get',\n      ol.source.WMTS.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getKeys',\n      ol.source.WMTS.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getProperties',\n      ol.source.WMTS.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'set',\n      ol.source.WMTS.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'setProperties',\n      ol.source.WMTS.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'unset',\n      ol.source.WMTS.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'changed',\n      ol.source.WMTS.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'dispatchEvent',\n      ol.source.WMTS.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'getRevision',\n      ol.source.WMTS.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'on',\n      ol.source.WMTS.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'once',\n      ol.source.WMTS.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.WMTS.prototype,\n      'un',\n      ol.source.WMTS.prototype.un);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'setRenderReprojectionEdges',\n      ol.source.Zoomify.prototype.setRenderReprojectionEdges);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'setTileGridForProjection',\n      ol.source.Zoomify.prototype.setTileGridForProjection);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getTileLoadFunction',\n      ol.source.Zoomify.prototype.getTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getTileUrlFunction',\n      ol.source.Zoomify.prototype.getTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getUrls',\n      ol.source.Zoomify.prototype.getUrls);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'setTileLoadFunction',\n      ol.source.Zoomify.prototype.setTileLoadFunction);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'setTileUrlFunction',\n      ol.source.Zoomify.prototype.setTileUrlFunction);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'setUrl',\n      ol.source.Zoomify.prototype.setUrl);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'setUrls',\n      ol.source.Zoomify.prototype.setUrls);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getTileGrid',\n      ol.source.Zoomify.prototype.getTileGrid);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'refresh',\n      ol.source.Zoomify.prototype.refresh);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getAttributions',\n      ol.source.Zoomify.prototype.getAttributions);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getLogo',\n      ol.source.Zoomify.prototype.getLogo);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getProjection',\n      ol.source.Zoomify.prototype.getProjection);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getState',\n      ol.source.Zoomify.prototype.getState);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'setAttributions',\n      ol.source.Zoomify.prototype.setAttributions);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'get',\n      ol.source.Zoomify.prototype.get);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getKeys',\n      ol.source.Zoomify.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getProperties',\n      ol.source.Zoomify.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'set',\n      ol.source.Zoomify.prototype.set);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'setProperties',\n      ol.source.Zoomify.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'unset',\n      ol.source.Zoomify.prototype.unset);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'changed',\n      ol.source.Zoomify.prototype.changed);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'dispatchEvent',\n      ol.source.Zoomify.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'getRevision',\n      ol.source.Zoomify.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'on',\n      ol.source.Zoomify.prototype.on);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'once',\n      ol.source.Zoomify.prototype.once);\n  \n  goog.exportProperty(\n      ol.source.Zoomify.prototype,\n      'un',\n      ol.source.Zoomify.prototype.un);\n  \n  goog.exportProperty(\n      ol.reproj.Tile.prototype,\n      'getTileCoord',\n      ol.reproj.Tile.prototype.getTileCoord);\n  \n  goog.exportProperty(\n      ol.reproj.Tile.prototype,\n      'load',\n      ol.reproj.Tile.prototype.load);\n  \n  goog.exportProperty(\n      ol.renderer.Layer.prototype,\n      'changed',\n      ol.renderer.Layer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.Layer.prototype,\n      'dispatchEvent',\n      ol.renderer.Layer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.Layer.prototype,\n      'getRevision',\n      ol.renderer.Layer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.Layer.prototype,\n      'on',\n      ol.renderer.Layer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.Layer.prototype,\n      'once',\n      ol.renderer.Layer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.Layer.prototype,\n      'un',\n      ol.renderer.Layer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.Layer.prototype,\n      'changed',\n      ol.renderer.webgl.Layer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.Layer.prototype,\n      'dispatchEvent',\n      ol.renderer.webgl.Layer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.Layer.prototype,\n      'getRevision',\n      ol.renderer.webgl.Layer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.Layer.prototype,\n      'on',\n      ol.renderer.webgl.Layer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.Layer.prototype,\n      'once',\n      ol.renderer.webgl.Layer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.Layer.prototype,\n      'un',\n      ol.renderer.webgl.Layer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.ImageLayer.prototype,\n      'changed',\n      ol.renderer.webgl.ImageLayer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.ImageLayer.prototype,\n      'dispatchEvent',\n      ol.renderer.webgl.ImageLayer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.ImageLayer.prototype,\n      'getRevision',\n      ol.renderer.webgl.ImageLayer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.ImageLayer.prototype,\n      'on',\n      ol.renderer.webgl.ImageLayer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.ImageLayer.prototype,\n      'once',\n      ol.renderer.webgl.ImageLayer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.ImageLayer.prototype,\n      'un',\n      ol.renderer.webgl.ImageLayer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.TileLayer.prototype,\n      'changed',\n      ol.renderer.webgl.TileLayer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.TileLayer.prototype,\n      'dispatchEvent',\n      ol.renderer.webgl.TileLayer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.TileLayer.prototype,\n      'getRevision',\n      ol.renderer.webgl.TileLayer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.TileLayer.prototype,\n      'on',\n      ol.renderer.webgl.TileLayer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.TileLayer.prototype,\n      'once',\n      ol.renderer.webgl.TileLayer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.TileLayer.prototype,\n      'un',\n      ol.renderer.webgl.TileLayer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.VectorLayer.prototype,\n      'changed',\n      ol.renderer.webgl.VectorLayer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.VectorLayer.prototype,\n      'dispatchEvent',\n      ol.renderer.webgl.VectorLayer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.VectorLayer.prototype,\n      'getRevision',\n      ol.renderer.webgl.VectorLayer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.VectorLayer.prototype,\n      'on',\n      ol.renderer.webgl.VectorLayer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.VectorLayer.prototype,\n      'once',\n      ol.renderer.webgl.VectorLayer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.webgl.VectorLayer.prototype,\n      'un',\n      ol.renderer.webgl.VectorLayer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.Layer.prototype,\n      'changed',\n      ol.renderer.canvas.Layer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.Layer.prototype,\n      'dispatchEvent',\n      ol.renderer.canvas.Layer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.Layer.prototype,\n      'getRevision',\n      ol.renderer.canvas.Layer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.Layer.prototype,\n      'on',\n      ol.renderer.canvas.Layer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.Layer.prototype,\n      'once',\n      ol.renderer.canvas.Layer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.Layer.prototype,\n      'un',\n      ol.renderer.canvas.Layer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.IntermediateCanvas.prototype,\n      'changed',\n      ol.renderer.canvas.IntermediateCanvas.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.IntermediateCanvas.prototype,\n      'dispatchEvent',\n      ol.renderer.canvas.IntermediateCanvas.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.IntermediateCanvas.prototype,\n      'getRevision',\n      ol.renderer.canvas.IntermediateCanvas.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.IntermediateCanvas.prototype,\n      'on',\n      ol.renderer.canvas.IntermediateCanvas.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.IntermediateCanvas.prototype,\n      'once',\n      ol.renderer.canvas.IntermediateCanvas.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.IntermediateCanvas.prototype,\n      'un',\n      ol.renderer.canvas.IntermediateCanvas.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.ImageLayer.prototype,\n      'changed',\n      ol.renderer.canvas.ImageLayer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.ImageLayer.prototype,\n      'dispatchEvent',\n      ol.renderer.canvas.ImageLayer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.ImageLayer.prototype,\n      'getRevision',\n      ol.renderer.canvas.ImageLayer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.ImageLayer.prototype,\n      'on',\n      ol.renderer.canvas.ImageLayer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.ImageLayer.prototype,\n      'once',\n      ol.renderer.canvas.ImageLayer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.ImageLayer.prototype,\n      'un',\n      ol.renderer.canvas.ImageLayer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.TileLayer.prototype,\n      'changed',\n      ol.renderer.canvas.TileLayer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.TileLayer.prototype,\n      'dispatchEvent',\n      ol.renderer.canvas.TileLayer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.TileLayer.prototype,\n      'getRevision',\n      ol.renderer.canvas.TileLayer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.TileLayer.prototype,\n      'on',\n      ol.renderer.canvas.TileLayer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.TileLayer.prototype,\n      'once',\n      ol.renderer.canvas.TileLayer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.TileLayer.prototype,\n      'un',\n      ol.renderer.canvas.TileLayer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorLayer.prototype,\n      'changed',\n      ol.renderer.canvas.VectorLayer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorLayer.prototype,\n      'dispatchEvent',\n      ol.renderer.canvas.VectorLayer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorLayer.prototype,\n      'getRevision',\n      ol.renderer.canvas.VectorLayer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorLayer.prototype,\n      'on',\n      ol.renderer.canvas.VectorLayer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorLayer.prototype,\n      'once',\n      ol.renderer.canvas.VectorLayer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorLayer.prototype,\n      'un',\n      ol.renderer.canvas.VectorLayer.prototype.un);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorTileLayer.prototype,\n      'changed',\n      ol.renderer.canvas.VectorTileLayer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorTileLayer.prototype,\n      'dispatchEvent',\n      ol.renderer.canvas.VectorTileLayer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorTileLayer.prototype,\n      'getRevision',\n      ol.renderer.canvas.VectorTileLayer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorTileLayer.prototype,\n      'on',\n      ol.renderer.canvas.VectorTileLayer.prototype.on);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorTileLayer.prototype,\n      'once',\n      ol.renderer.canvas.VectorTileLayer.prototype.once);\n  \n  goog.exportProperty(\n      ol.renderer.canvas.VectorTileLayer.prototype,\n      'un',\n      ol.renderer.canvas.VectorTileLayer.prototype.un);\n  \n  goog.exportProperty(\n      ol.render.Event.prototype,\n      'type',\n      ol.render.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.render.Event.prototype,\n      'target',\n      ol.render.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.render.Event.prototype,\n      'preventDefault',\n      ol.render.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.render.Event.prototype,\n      'stopPropagation',\n      ol.render.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.pointer.PointerEvent.prototype,\n      'type',\n      ol.pointer.PointerEvent.prototype.type);\n  \n  goog.exportProperty(\n      ol.pointer.PointerEvent.prototype,\n      'target',\n      ol.pointer.PointerEvent.prototype.target);\n  \n  goog.exportProperty(\n      ol.pointer.PointerEvent.prototype,\n      'preventDefault',\n      ol.pointer.PointerEvent.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.pointer.PointerEvent.prototype,\n      'stopPropagation',\n      ol.pointer.PointerEvent.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'get',\n      ol.layer.Base.prototype.get);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getKeys',\n      ol.layer.Base.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getProperties',\n      ol.layer.Base.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'set',\n      ol.layer.Base.prototype.set);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'setProperties',\n      ol.layer.Base.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'unset',\n      ol.layer.Base.prototype.unset);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'changed',\n      ol.layer.Base.prototype.changed);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'dispatchEvent',\n      ol.layer.Base.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'getRevision',\n      ol.layer.Base.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'on',\n      ol.layer.Base.prototype.on);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'once',\n      ol.layer.Base.prototype.once);\n  \n  goog.exportProperty(\n      ol.layer.Base.prototype,\n      'un',\n      ol.layer.Base.prototype.un);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getExtent',\n      ol.layer.Group.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getMaxResolution',\n      ol.layer.Group.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getMinResolution',\n      ol.layer.Group.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getOpacity',\n      ol.layer.Group.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getVisible',\n      ol.layer.Group.prototype.getVisible);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getZIndex',\n      ol.layer.Group.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'setExtent',\n      ol.layer.Group.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'setMaxResolution',\n      ol.layer.Group.prototype.setMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'setMinResolution',\n      ol.layer.Group.prototype.setMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'setOpacity',\n      ol.layer.Group.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'setVisible',\n      ol.layer.Group.prototype.setVisible);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'setZIndex',\n      ol.layer.Group.prototype.setZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'get',\n      ol.layer.Group.prototype.get);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getKeys',\n      ol.layer.Group.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getProperties',\n      ol.layer.Group.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'set',\n      ol.layer.Group.prototype.set);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'setProperties',\n      ol.layer.Group.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'unset',\n      ol.layer.Group.prototype.unset);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'changed',\n      ol.layer.Group.prototype.changed);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'dispatchEvent',\n      ol.layer.Group.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'getRevision',\n      ol.layer.Group.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'on',\n      ol.layer.Group.prototype.on);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'once',\n      ol.layer.Group.prototype.once);\n  \n  goog.exportProperty(\n      ol.layer.Group.prototype,\n      'un',\n      ol.layer.Group.prototype.un);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getExtent',\n      ol.layer.Layer.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getMaxResolution',\n      ol.layer.Layer.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getMinResolution',\n      ol.layer.Layer.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getOpacity',\n      ol.layer.Layer.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getVisible',\n      ol.layer.Layer.prototype.getVisible);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getZIndex',\n      ol.layer.Layer.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setExtent',\n      ol.layer.Layer.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setMaxResolution',\n      ol.layer.Layer.prototype.setMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setMinResolution',\n      ol.layer.Layer.prototype.setMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setOpacity',\n      ol.layer.Layer.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setVisible',\n      ol.layer.Layer.prototype.setVisible);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setZIndex',\n      ol.layer.Layer.prototype.setZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'get',\n      ol.layer.Layer.prototype.get);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getKeys',\n      ol.layer.Layer.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getProperties',\n      ol.layer.Layer.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'set',\n      ol.layer.Layer.prototype.set);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'setProperties',\n      ol.layer.Layer.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'unset',\n      ol.layer.Layer.prototype.unset);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'changed',\n      ol.layer.Layer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'dispatchEvent',\n      ol.layer.Layer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'getRevision',\n      ol.layer.Layer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'on',\n      ol.layer.Layer.prototype.on);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'once',\n      ol.layer.Layer.prototype.once);\n  \n  goog.exportProperty(\n      ol.layer.Layer.prototype,\n      'un',\n      ol.layer.Layer.prototype.un);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setMap',\n      ol.layer.Vector.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setSource',\n      ol.layer.Vector.prototype.setSource);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getExtent',\n      ol.layer.Vector.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getMaxResolution',\n      ol.layer.Vector.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getMinResolution',\n      ol.layer.Vector.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getOpacity',\n      ol.layer.Vector.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getVisible',\n      ol.layer.Vector.prototype.getVisible);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getZIndex',\n      ol.layer.Vector.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setExtent',\n      ol.layer.Vector.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setMaxResolution',\n      ol.layer.Vector.prototype.setMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setMinResolution',\n      ol.layer.Vector.prototype.setMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setOpacity',\n      ol.layer.Vector.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setVisible',\n      ol.layer.Vector.prototype.setVisible);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setZIndex',\n      ol.layer.Vector.prototype.setZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'get',\n      ol.layer.Vector.prototype.get);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getKeys',\n      ol.layer.Vector.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getProperties',\n      ol.layer.Vector.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'set',\n      ol.layer.Vector.prototype.set);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'setProperties',\n      ol.layer.Vector.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'unset',\n      ol.layer.Vector.prototype.unset);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'changed',\n      ol.layer.Vector.prototype.changed);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'dispatchEvent',\n      ol.layer.Vector.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'getRevision',\n      ol.layer.Vector.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'on',\n      ol.layer.Vector.prototype.on);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'once',\n      ol.layer.Vector.prototype.once);\n  \n  goog.exportProperty(\n      ol.layer.Vector.prototype,\n      'un',\n      ol.layer.Vector.prototype.un);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getSource',\n      ol.layer.Heatmap.prototype.getSource);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getStyle',\n      ol.layer.Heatmap.prototype.getStyle);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getStyleFunction',\n      ol.layer.Heatmap.prototype.getStyleFunction);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setStyle',\n      ol.layer.Heatmap.prototype.setStyle);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setMap',\n      ol.layer.Heatmap.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setSource',\n      ol.layer.Heatmap.prototype.setSource);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getExtent',\n      ol.layer.Heatmap.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getMaxResolution',\n      ol.layer.Heatmap.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getMinResolution',\n      ol.layer.Heatmap.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getOpacity',\n      ol.layer.Heatmap.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getVisible',\n      ol.layer.Heatmap.prototype.getVisible);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getZIndex',\n      ol.layer.Heatmap.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setExtent',\n      ol.layer.Heatmap.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setMaxResolution',\n      ol.layer.Heatmap.prototype.setMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setMinResolution',\n      ol.layer.Heatmap.prototype.setMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setOpacity',\n      ol.layer.Heatmap.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setVisible',\n      ol.layer.Heatmap.prototype.setVisible);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setZIndex',\n      ol.layer.Heatmap.prototype.setZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'get',\n      ol.layer.Heatmap.prototype.get);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getKeys',\n      ol.layer.Heatmap.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getProperties',\n      ol.layer.Heatmap.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'set',\n      ol.layer.Heatmap.prototype.set);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'setProperties',\n      ol.layer.Heatmap.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'unset',\n      ol.layer.Heatmap.prototype.unset);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'changed',\n      ol.layer.Heatmap.prototype.changed);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'dispatchEvent',\n      ol.layer.Heatmap.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'getRevision',\n      ol.layer.Heatmap.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'on',\n      ol.layer.Heatmap.prototype.on);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'once',\n      ol.layer.Heatmap.prototype.once);\n  \n  goog.exportProperty(\n      ol.layer.Heatmap.prototype,\n      'un',\n      ol.layer.Heatmap.prototype.un);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setMap',\n      ol.layer.Image.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setSource',\n      ol.layer.Image.prototype.setSource);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getExtent',\n      ol.layer.Image.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getMaxResolution',\n      ol.layer.Image.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getMinResolution',\n      ol.layer.Image.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getOpacity',\n      ol.layer.Image.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getVisible',\n      ol.layer.Image.prototype.getVisible);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getZIndex',\n      ol.layer.Image.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setExtent',\n      ol.layer.Image.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setMaxResolution',\n      ol.layer.Image.prototype.setMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setMinResolution',\n      ol.layer.Image.prototype.setMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setOpacity',\n      ol.layer.Image.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setVisible',\n      ol.layer.Image.prototype.setVisible);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setZIndex',\n      ol.layer.Image.prototype.setZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'get',\n      ol.layer.Image.prototype.get);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getKeys',\n      ol.layer.Image.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getProperties',\n      ol.layer.Image.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'set',\n      ol.layer.Image.prototype.set);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'setProperties',\n      ol.layer.Image.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'unset',\n      ol.layer.Image.prototype.unset);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'changed',\n      ol.layer.Image.prototype.changed);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'dispatchEvent',\n      ol.layer.Image.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'getRevision',\n      ol.layer.Image.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'on',\n      ol.layer.Image.prototype.on);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'once',\n      ol.layer.Image.prototype.once);\n  \n  goog.exportProperty(\n      ol.layer.Image.prototype,\n      'un',\n      ol.layer.Image.prototype.un);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setMap',\n      ol.layer.Tile.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setSource',\n      ol.layer.Tile.prototype.setSource);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getExtent',\n      ol.layer.Tile.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getMaxResolution',\n      ol.layer.Tile.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getMinResolution',\n      ol.layer.Tile.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getOpacity',\n      ol.layer.Tile.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getVisible',\n      ol.layer.Tile.prototype.getVisible);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getZIndex',\n      ol.layer.Tile.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setExtent',\n      ol.layer.Tile.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setMaxResolution',\n      ol.layer.Tile.prototype.setMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setMinResolution',\n      ol.layer.Tile.prototype.setMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setOpacity',\n      ol.layer.Tile.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setVisible',\n      ol.layer.Tile.prototype.setVisible);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setZIndex',\n      ol.layer.Tile.prototype.setZIndex);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'get',\n      ol.layer.Tile.prototype.get);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getKeys',\n      ol.layer.Tile.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getProperties',\n      ol.layer.Tile.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'set',\n      ol.layer.Tile.prototype.set);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'setProperties',\n      ol.layer.Tile.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'unset',\n      ol.layer.Tile.prototype.unset);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'changed',\n      ol.layer.Tile.prototype.changed);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'dispatchEvent',\n      ol.layer.Tile.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'getRevision',\n      ol.layer.Tile.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'on',\n      ol.layer.Tile.prototype.on);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'once',\n      ol.layer.Tile.prototype.once);\n  \n  goog.exportProperty(\n      ol.layer.Tile.prototype,\n      'un',\n      ol.layer.Tile.prototype.un);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getStyle',\n      ol.layer.VectorTile.prototype.getStyle);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getStyleFunction',\n      ol.layer.VectorTile.prototype.getStyleFunction);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setStyle',\n      ol.layer.VectorTile.prototype.setStyle);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setMap',\n      ol.layer.VectorTile.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setSource',\n      ol.layer.VectorTile.prototype.setSource);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getExtent',\n      ol.layer.VectorTile.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getMaxResolution',\n      ol.layer.VectorTile.prototype.getMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getMinResolution',\n      ol.layer.VectorTile.prototype.getMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getOpacity',\n      ol.layer.VectorTile.prototype.getOpacity);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getVisible',\n      ol.layer.VectorTile.prototype.getVisible);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getZIndex',\n      ol.layer.VectorTile.prototype.getZIndex);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setExtent',\n      ol.layer.VectorTile.prototype.setExtent);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setMaxResolution',\n      ol.layer.VectorTile.prototype.setMaxResolution);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setMinResolution',\n      ol.layer.VectorTile.prototype.setMinResolution);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setOpacity',\n      ol.layer.VectorTile.prototype.setOpacity);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setVisible',\n      ol.layer.VectorTile.prototype.setVisible);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setZIndex',\n      ol.layer.VectorTile.prototype.setZIndex);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'get',\n      ol.layer.VectorTile.prototype.get);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getKeys',\n      ol.layer.VectorTile.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getProperties',\n      ol.layer.VectorTile.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'set',\n      ol.layer.VectorTile.prototype.set);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'setProperties',\n      ol.layer.VectorTile.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'unset',\n      ol.layer.VectorTile.prototype.unset);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'changed',\n      ol.layer.VectorTile.prototype.changed);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'dispatchEvent',\n      ol.layer.VectorTile.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'getRevision',\n      ol.layer.VectorTile.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'on',\n      ol.layer.VectorTile.prototype.on);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'once',\n      ol.layer.VectorTile.prototype.once);\n  \n  goog.exportProperty(\n      ol.layer.VectorTile.prototype,\n      'un',\n      ol.layer.VectorTile.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'get',\n      ol.interaction.Interaction.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'getKeys',\n      ol.interaction.Interaction.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'getProperties',\n      ol.interaction.Interaction.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'set',\n      ol.interaction.Interaction.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'setProperties',\n      ol.interaction.Interaction.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'unset',\n      ol.interaction.Interaction.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'changed',\n      ol.interaction.Interaction.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'dispatchEvent',\n      ol.interaction.Interaction.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'getRevision',\n      ol.interaction.Interaction.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'on',\n      ol.interaction.Interaction.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'once',\n      ol.interaction.Interaction.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.Interaction.prototype,\n      'un',\n      ol.interaction.Interaction.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'getActive',\n      ol.interaction.DoubleClickZoom.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'getMap',\n      ol.interaction.DoubleClickZoom.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'setActive',\n      ol.interaction.DoubleClickZoom.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'get',\n      ol.interaction.DoubleClickZoom.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'getKeys',\n      ol.interaction.DoubleClickZoom.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'getProperties',\n      ol.interaction.DoubleClickZoom.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'set',\n      ol.interaction.DoubleClickZoom.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'setProperties',\n      ol.interaction.DoubleClickZoom.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'unset',\n      ol.interaction.DoubleClickZoom.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'changed',\n      ol.interaction.DoubleClickZoom.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'dispatchEvent',\n      ol.interaction.DoubleClickZoom.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'getRevision',\n      ol.interaction.DoubleClickZoom.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'on',\n      ol.interaction.DoubleClickZoom.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'once',\n      ol.interaction.DoubleClickZoom.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.DoubleClickZoom.prototype,\n      'un',\n      ol.interaction.DoubleClickZoom.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'getActive',\n      ol.interaction.DragAndDrop.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'getMap',\n      ol.interaction.DragAndDrop.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'setActive',\n      ol.interaction.DragAndDrop.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'get',\n      ol.interaction.DragAndDrop.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'getKeys',\n      ol.interaction.DragAndDrop.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'getProperties',\n      ol.interaction.DragAndDrop.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'set',\n      ol.interaction.DragAndDrop.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'setProperties',\n      ol.interaction.DragAndDrop.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'unset',\n      ol.interaction.DragAndDrop.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'changed',\n      ol.interaction.DragAndDrop.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'dispatchEvent',\n      ol.interaction.DragAndDrop.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'getRevision',\n      ol.interaction.DragAndDrop.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'on',\n      ol.interaction.DragAndDrop.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'once',\n      ol.interaction.DragAndDrop.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.prototype,\n      'un',\n      ol.interaction.DragAndDrop.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.Event.prototype,\n      'type',\n      ol.interaction.DragAndDrop.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.Event.prototype,\n      'target',\n      ol.interaction.DragAndDrop.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.Event.prototype,\n      'preventDefault',\n      ol.interaction.DragAndDrop.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.interaction.DragAndDrop.Event.prototype,\n      'stopPropagation',\n      ol.interaction.DragAndDrop.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'getActive',\n      ol.interaction.Pointer.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'getMap',\n      ol.interaction.Pointer.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'setActive',\n      ol.interaction.Pointer.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'get',\n      ol.interaction.Pointer.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'getKeys',\n      ol.interaction.Pointer.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'getProperties',\n      ol.interaction.Pointer.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'set',\n      ol.interaction.Pointer.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'setProperties',\n      ol.interaction.Pointer.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'unset',\n      ol.interaction.Pointer.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'changed',\n      ol.interaction.Pointer.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'dispatchEvent',\n      ol.interaction.Pointer.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'getRevision',\n      ol.interaction.Pointer.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'on',\n      ol.interaction.Pointer.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'once',\n      ol.interaction.Pointer.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.Pointer.prototype,\n      'un',\n      ol.interaction.Pointer.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'getActive',\n      ol.interaction.DragBox.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'getMap',\n      ol.interaction.DragBox.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'setActive',\n      ol.interaction.DragBox.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'get',\n      ol.interaction.DragBox.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'getKeys',\n      ol.interaction.DragBox.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'getProperties',\n      ol.interaction.DragBox.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'set',\n      ol.interaction.DragBox.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'setProperties',\n      ol.interaction.DragBox.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'unset',\n      ol.interaction.DragBox.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'changed',\n      ol.interaction.DragBox.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'dispatchEvent',\n      ol.interaction.DragBox.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'getRevision',\n      ol.interaction.DragBox.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'on',\n      ol.interaction.DragBox.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'once',\n      ol.interaction.DragBox.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.prototype,\n      'un',\n      ol.interaction.DragBox.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.Event.prototype,\n      'type',\n      ol.interaction.DragBox.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.Event.prototype,\n      'target',\n      ol.interaction.DragBox.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.Event.prototype,\n      'preventDefault',\n      ol.interaction.DragBox.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.interaction.DragBox.Event.prototype,\n      'stopPropagation',\n      ol.interaction.DragBox.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'getActive',\n      ol.interaction.DragPan.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'getMap',\n      ol.interaction.DragPan.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'setActive',\n      ol.interaction.DragPan.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'get',\n      ol.interaction.DragPan.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'getKeys',\n      ol.interaction.DragPan.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'getProperties',\n      ol.interaction.DragPan.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'set',\n      ol.interaction.DragPan.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'setProperties',\n      ol.interaction.DragPan.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'unset',\n      ol.interaction.DragPan.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'changed',\n      ol.interaction.DragPan.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'dispatchEvent',\n      ol.interaction.DragPan.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'getRevision',\n      ol.interaction.DragPan.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'on',\n      ol.interaction.DragPan.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'once',\n      ol.interaction.DragPan.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.DragPan.prototype,\n      'un',\n      ol.interaction.DragPan.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'getActive',\n      ol.interaction.DragRotate.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'getMap',\n      ol.interaction.DragRotate.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'setActive',\n      ol.interaction.DragRotate.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'get',\n      ol.interaction.DragRotate.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'getKeys',\n      ol.interaction.DragRotate.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'getProperties',\n      ol.interaction.DragRotate.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'set',\n      ol.interaction.DragRotate.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'setProperties',\n      ol.interaction.DragRotate.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'unset',\n      ol.interaction.DragRotate.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'changed',\n      ol.interaction.DragRotate.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'dispatchEvent',\n      ol.interaction.DragRotate.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'getRevision',\n      ol.interaction.DragRotate.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'on',\n      ol.interaction.DragRotate.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'once',\n      ol.interaction.DragRotate.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotate.prototype,\n      'un',\n      ol.interaction.DragRotate.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'getActive',\n      ol.interaction.DragRotateAndZoom.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'getMap',\n      ol.interaction.DragRotateAndZoom.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'setActive',\n      ol.interaction.DragRotateAndZoom.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'get',\n      ol.interaction.DragRotateAndZoom.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'getKeys',\n      ol.interaction.DragRotateAndZoom.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'getProperties',\n      ol.interaction.DragRotateAndZoom.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'set',\n      ol.interaction.DragRotateAndZoom.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'setProperties',\n      ol.interaction.DragRotateAndZoom.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'unset',\n      ol.interaction.DragRotateAndZoom.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'changed',\n      ol.interaction.DragRotateAndZoom.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'dispatchEvent',\n      ol.interaction.DragRotateAndZoom.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'getRevision',\n      ol.interaction.DragRotateAndZoom.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'on',\n      ol.interaction.DragRotateAndZoom.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'once',\n      ol.interaction.DragRotateAndZoom.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.DragRotateAndZoom.prototype,\n      'un',\n      ol.interaction.DragRotateAndZoom.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'getGeometry',\n      ol.interaction.DragZoom.prototype.getGeometry);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'getActive',\n      ol.interaction.DragZoom.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'getMap',\n      ol.interaction.DragZoom.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'setActive',\n      ol.interaction.DragZoom.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'get',\n      ol.interaction.DragZoom.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'getKeys',\n      ol.interaction.DragZoom.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'getProperties',\n      ol.interaction.DragZoom.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'set',\n      ol.interaction.DragZoom.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'setProperties',\n      ol.interaction.DragZoom.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'unset',\n      ol.interaction.DragZoom.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'changed',\n      ol.interaction.DragZoom.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'dispatchEvent',\n      ol.interaction.DragZoom.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'getRevision',\n      ol.interaction.DragZoom.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'on',\n      ol.interaction.DragZoom.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'once',\n      ol.interaction.DragZoom.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.DragZoom.prototype,\n      'un',\n      ol.interaction.DragZoom.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'getActive',\n      ol.interaction.Draw.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'getMap',\n      ol.interaction.Draw.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'setActive',\n      ol.interaction.Draw.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'get',\n      ol.interaction.Draw.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'getKeys',\n      ol.interaction.Draw.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'getProperties',\n      ol.interaction.Draw.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'set',\n      ol.interaction.Draw.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'setProperties',\n      ol.interaction.Draw.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'unset',\n      ol.interaction.Draw.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'changed',\n      ol.interaction.Draw.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'dispatchEvent',\n      ol.interaction.Draw.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'getRevision',\n      ol.interaction.Draw.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'on',\n      ol.interaction.Draw.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'once',\n      ol.interaction.Draw.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.prototype,\n      'un',\n      ol.interaction.Draw.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.Event.prototype,\n      'type',\n      ol.interaction.Draw.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.Event.prototype,\n      'target',\n      ol.interaction.Draw.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.Event.prototype,\n      'preventDefault',\n      ol.interaction.Draw.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.interaction.Draw.Event.prototype,\n      'stopPropagation',\n      ol.interaction.Draw.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'getActive',\n      ol.interaction.Extent.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'getMap',\n      ol.interaction.Extent.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'setActive',\n      ol.interaction.Extent.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'get',\n      ol.interaction.Extent.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'getKeys',\n      ol.interaction.Extent.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'getProperties',\n      ol.interaction.Extent.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'set',\n      ol.interaction.Extent.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'setProperties',\n      ol.interaction.Extent.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'unset',\n      ol.interaction.Extent.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'changed',\n      ol.interaction.Extent.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'dispatchEvent',\n      ol.interaction.Extent.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'getRevision',\n      ol.interaction.Extent.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'on',\n      ol.interaction.Extent.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'once',\n      ol.interaction.Extent.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.prototype,\n      'un',\n      ol.interaction.Extent.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.Event.prototype,\n      'type',\n      ol.interaction.Extent.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.Event.prototype,\n      'target',\n      ol.interaction.Extent.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.Event.prototype,\n      'preventDefault',\n      ol.interaction.Extent.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.interaction.Extent.Event.prototype,\n      'stopPropagation',\n      ol.interaction.Extent.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'getActive',\n      ol.interaction.KeyboardPan.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'getMap',\n      ol.interaction.KeyboardPan.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'setActive',\n      ol.interaction.KeyboardPan.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'get',\n      ol.interaction.KeyboardPan.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'getKeys',\n      ol.interaction.KeyboardPan.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'getProperties',\n      ol.interaction.KeyboardPan.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'set',\n      ol.interaction.KeyboardPan.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'setProperties',\n      ol.interaction.KeyboardPan.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'unset',\n      ol.interaction.KeyboardPan.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'changed',\n      ol.interaction.KeyboardPan.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'dispatchEvent',\n      ol.interaction.KeyboardPan.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'getRevision',\n      ol.interaction.KeyboardPan.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'on',\n      ol.interaction.KeyboardPan.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'once',\n      ol.interaction.KeyboardPan.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardPan.prototype,\n      'un',\n      ol.interaction.KeyboardPan.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'getActive',\n      ol.interaction.KeyboardZoom.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'getMap',\n      ol.interaction.KeyboardZoom.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'setActive',\n      ol.interaction.KeyboardZoom.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'get',\n      ol.interaction.KeyboardZoom.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'getKeys',\n      ol.interaction.KeyboardZoom.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'getProperties',\n      ol.interaction.KeyboardZoom.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'set',\n      ol.interaction.KeyboardZoom.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'setProperties',\n      ol.interaction.KeyboardZoom.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'unset',\n      ol.interaction.KeyboardZoom.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'changed',\n      ol.interaction.KeyboardZoom.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'dispatchEvent',\n      ol.interaction.KeyboardZoom.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'getRevision',\n      ol.interaction.KeyboardZoom.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'on',\n      ol.interaction.KeyboardZoom.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'once',\n      ol.interaction.KeyboardZoom.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.KeyboardZoom.prototype,\n      'un',\n      ol.interaction.KeyboardZoom.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'getActive',\n      ol.interaction.Modify.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'getMap',\n      ol.interaction.Modify.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'setActive',\n      ol.interaction.Modify.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'get',\n      ol.interaction.Modify.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'getKeys',\n      ol.interaction.Modify.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'getProperties',\n      ol.interaction.Modify.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'set',\n      ol.interaction.Modify.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'setProperties',\n      ol.interaction.Modify.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'unset',\n      ol.interaction.Modify.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'changed',\n      ol.interaction.Modify.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'dispatchEvent',\n      ol.interaction.Modify.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'getRevision',\n      ol.interaction.Modify.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'on',\n      ol.interaction.Modify.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'once',\n      ol.interaction.Modify.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.prototype,\n      'un',\n      ol.interaction.Modify.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.Event.prototype,\n      'type',\n      ol.interaction.Modify.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.Event.prototype,\n      'target',\n      ol.interaction.Modify.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.Event.prototype,\n      'preventDefault',\n      ol.interaction.Modify.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.interaction.Modify.Event.prototype,\n      'stopPropagation',\n      ol.interaction.Modify.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'getActive',\n      ol.interaction.MouseWheelZoom.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'getMap',\n      ol.interaction.MouseWheelZoom.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'setActive',\n      ol.interaction.MouseWheelZoom.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'get',\n      ol.interaction.MouseWheelZoom.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'getKeys',\n      ol.interaction.MouseWheelZoom.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'getProperties',\n      ol.interaction.MouseWheelZoom.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'set',\n      ol.interaction.MouseWheelZoom.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'setProperties',\n      ol.interaction.MouseWheelZoom.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'unset',\n      ol.interaction.MouseWheelZoom.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'changed',\n      ol.interaction.MouseWheelZoom.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'dispatchEvent',\n      ol.interaction.MouseWheelZoom.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'getRevision',\n      ol.interaction.MouseWheelZoom.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'on',\n      ol.interaction.MouseWheelZoom.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'once',\n      ol.interaction.MouseWheelZoom.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.MouseWheelZoom.prototype,\n      'un',\n      ol.interaction.MouseWheelZoom.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'getActive',\n      ol.interaction.PinchRotate.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'getMap',\n      ol.interaction.PinchRotate.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'setActive',\n      ol.interaction.PinchRotate.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'get',\n      ol.interaction.PinchRotate.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'getKeys',\n      ol.interaction.PinchRotate.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'getProperties',\n      ol.interaction.PinchRotate.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'set',\n      ol.interaction.PinchRotate.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'setProperties',\n      ol.interaction.PinchRotate.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'unset',\n      ol.interaction.PinchRotate.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'changed',\n      ol.interaction.PinchRotate.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'dispatchEvent',\n      ol.interaction.PinchRotate.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'getRevision',\n      ol.interaction.PinchRotate.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'on',\n      ol.interaction.PinchRotate.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'once',\n      ol.interaction.PinchRotate.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.PinchRotate.prototype,\n      'un',\n      ol.interaction.PinchRotate.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'getActive',\n      ol.interaction.PinchZoom.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'getMap',\n      ol.interaction.PinchZoom.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'setActive',\n      ol.interaction.PinchZoom.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'get',\n      ol.interaction.PinchZoom.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'getKeys',\n      ol.interaction.PinchZoom.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'getProperties',\n      ol.interaction.PinchZoom.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'set',\n      ol.interaction.PinchZoom.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'setProperties',\n      ol.interaction.PinchZoom.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'unset',\n      ol.interaction.PinchZoom.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'changed',\n      ol.interaction.PinchZoom.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'dispatchEvent',\n      ol.interaction.PinchZoom.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'getRevision',\n      ol.interaction.PinchZoom.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'on',\n      ol.interaction.PinchZoom.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'once',\n      ol.interaction.PinchZoom.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.PinchZoom.prototype,\n      'un',\n      ol.interaction.PinchZoom.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'getActive',\n      ol.interaction.Select.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'getMap',\n      ol.interaction.Select.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'setActive',\n      ol.interaction.Select.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'get',\n      ol.interaction.Select.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'getKeys',\n      ol.interaction.Select.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'getProperties',\n      ol.interaction.Select.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'set',\n      ol.interaction.Select.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'setProperties',\n      ol.interaction.Select.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'unset',\n      ol.interaction.Select.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'changed',\n      ol.interaction.Select.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'dispatchEvent',\n      ol.interaction.Select.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'getRevision',\n      ol.interaction.Select.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'on',\n      ol.interaction.Select.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'once',\n      ol.interaction.Select.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.Select.prototype,\n      'un',\n      ol.interaction.Select.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Select.Event.prototype,\n      'type',\n      ol.interaction.Select.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.interaction.Select.Event.prototype,\n      'target',\n      ol.interaction.Select.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.interaction.Select.Event.prototype,\n      'preventDefault',\n      ol.interaction.Select.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.interaction.Select.Event.prototype,\n      'stopPropagation',\n      ol.interaction.Select.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'getActive',\n      ol.interaction.Snap.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'getMap',\n      ol.interaction.Snap.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'setActive',\n      ol.interaction.Snap.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'get',\n      ol.interaction.Snap.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'getKeys',\n      ol.interaction.Snap.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'getProperties',\n      ol.interaction.Snap.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'set',\n      ol.interaction.Snap.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'setProperties',\n      ol.interaction.Snap.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'unset',\n      ol.interaction.Snap.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'changed',\n      ol.interaction.Snap.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'dispatchEvent',\n      ol.interaction.Snap.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'getRevision',\n      ol.interaction.Snap.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'on',\n      ol.interaction.Snap.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'once',\n      ol.interaction.Snap.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.Snap.prototype,\n      'un',\n      ol.interaction.Snap.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'getActive',\n      ol.interaction.Translate.prototype.getActive);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'getMap',\n      ol.interaction.Translate.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'setActive',\n      ol.interaction.Translate.prototype.setActive);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'get',\n      ol.interaction.Translate.prototype.get);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'getKeys',\n      ol.interaction.Translate.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'getProperties',\n      ol.interaction.Translate.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'set',\n      ol.interaction.Translate.prototype.set);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'setProperties',\n      ol.interaction.Translate.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'unset',\n      ol.interaction.Translate.prototype.unset);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'changed',\n      ol.interaction.Translate.prototype.changed);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'dispatchEvent',\n      ol.interaction.Translate.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'getRevision',\n      ol.interaction.Translate.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'on',\n      ol.interaction.Translate.prototype.on);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'once',\n      ol.interaction.Translate.prototype.once);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.prototype,\n      'un',\n      ol.interaction.Translate.prototype.un);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.Event.prototype,\n      'type',\n      ol.interaction.Translate.Event.prototype.type);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.Event.prototype,\n      'target',\n      ol.interaction.Translate.Event.prototype.target);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.Event.prototype,\n      'preventDefault',\n      ol.interaction.Translate.Event.prototype.preventDefault);\n  \n  goog.exportProperty(\n      ol.interaction.Translate.Event.prototype,\n      'stopPropagation',\n      ol.interaction.Translate.Event.prototype.stopPropagation);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'get',\n      ol.geom.Geometry.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'getKeys',\n      ol.geom.Geometry.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'getProperties',\n      ol.geom.Geometry.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'set',\n      ol.geom.Geometry.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'setProperties',\n      ol.geom.Geometry.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'unset',\n      ol.geom.Geometry.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'changed',\n      ol.geom.Geometry.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'dispatchEvent',\n      ol.geom.Geometry.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'getRevision',\n      ol.geom.Geometry.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'on',\n      ol.geom.Geometry.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'once',\n      ol.geom.Geometry.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.Geometry.prototype,\n      'un',\n      ol.geom.Geometry.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'getClosestPoint',\n      ol.geom.SimpleGeometry.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'intersectsCoordinate',\n      ol.geom.SimpleGeometry.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'getExtent',\n      ol.geom.SimpleGeometry.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'rotate',\n      ol.geom.SimpleGeometry.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'scale',\n      ol.geom.SimpleGeometry.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'simplify',\n      ol.geom.SimpleGeometry.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'transform',\n      ol.geom.SimpleGeometry.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'get',\n      ol.geom.SimpleGeometry.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'getKeys',\n      ol.geom.SimpleGeometry.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'getProperties',\n      ol.geom.SimpleGeometry.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'set',\n      ol.geom.SimpleGeometry.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'setProperties',\n      ol.geom.SimpleGeometry.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'unset',\n      ol.geom.SimpleGeometry.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'changed',\n      ol.geom.SimpleGeometry.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'dispatchEvent',\n      ol.geom.SimpleGeometry.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'getRevision',\n      ol.geom.SimpleGeometry.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'on',\n      ol.geom.SimpleGeometry.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'once',\n      ol.geom.SimpleGeometry.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.SimpleGeometry.prototype,\n      'un',\n      ol.geom.SimpleGeometry.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getFirstCoordinate',\n      ol.geom.Circle.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getLastCoordinate',\n      ol.geom.Circle.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getLayout',\n      ol.geom.Circle.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'rotate',\n      ol.geom.Circle.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'scale',\n      ol.geom.Circle.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getClosestPoint',\n      ol.geom.Circle.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'intersectsCoordinate',\n      ol.geom.Circle.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getExtent',\n      ol.geom.Circle.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'simplify',\n      ol.geom.Circle.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'get',\n      ol.geom.Circle.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getKeys',\n      ol.geom.Circle.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getProperties',\n      ol.geom.Circle.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'set',\n      ol.geom.Circle.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'setProperties',\n      ol.geom.Circle.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'unset',\n      ol.geom.Circle.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'changed',\n      ol.geom.Circle.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'dispatchEvent',\n      ol.geom.Circle.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'getRevision',\n      ol.geom.Circle.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'on',\n      ol.geom.Circle.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'once',\n      ol.geom.Circle.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.Circle.prototype,\n      'un',\n      ol.geom.Circle.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'getClosestPoint',\n      ol.geom.GeometryCollection.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'intersectsCoordinate',\n      ol.geom.GeometryCollection.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'getExtent',\n      ol.geom.GeometryCollection.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'rotate',\n      ol.geom.GeometryCollection.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'scale',\n      ol.geom.GeometryCollection.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'simplify',\n      ol.geom.GeometryCollection.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'transform',\n      ol.geom.GeometryCollection.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'get',\n      ol.geom.GeometryCollection.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'getKeys',\n      ol.geom.GeometryCollection.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'getProperties',\n      ol.geom.GeometryCollection.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'set',\n      ol.geom.GeometryCollection.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'setProperties',\n      ol.geom.GeometryCollection.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'unset',\n      ol.geom.GeometryCollection.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'changed',\n      ol.geom.GeometryCollection.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'dispatchEvent',\n      ol.geom.GeometryCollection.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'getRevision',\n      ol.geom.GeometryCollection.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'on',\n      ol.geom.GeometryCollection.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'once',\n      ol.geom.GeometryCollection.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.GeometryCollection.prototype,\n      'un',\n      ol.geom.GeometryCollection.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getFirstCoordinate',\n      ol.geom.LinearRing.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getLastCoordinate',\n      ol.geom.LinearRing.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getLayout',\n      ol.geom.LinearRing.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'rotate',\n      ol.geom.LinearRing.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'scale',\n      ol.geom.LinearRing.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getClosestPoint',\n      ol.geom.LinearRing.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'intersectsCoordinate',\n      ol.geom.LinearRing.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getExtent',\n      ol.geom.LinearRing.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'simplify',\n      ol.geom.LinearRing.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'transform',\n      ol.geom.LinearRing.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'get',\n      ol.geom.LinearRing.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getKeys',\n      ol.geom.LinearRing.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getProperties',\n      ol.geom.LinearRing.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'set',\n      ol.geom.LinearRing.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'setProperties',\n      ol.geom.LinearRing.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'unset',\n      ol.geom.LinearRing.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'changed',\n      ol.geom.LinearRing.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'dispatchEvent',\n      ol.geom.LinearRing.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'getRevision',\n      ol.geom.LinearRing.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'on',\n      ol.geom.LinearRing.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'once',\n      ol.geom.LinearRing.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.LinearRing.prototype,\n      'un',\n      ol.geom.LinearRing.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getFirstCoordinate',\n      ol.geom.LineString.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getLastCoordinate',\n      ol.geom.LineString.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getLayout',\n      ol.geom.LineString.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'rotate',\n      ol.geom.LineString.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'scale',\n      ol.geom.LineString.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getClosestPoint',\n      ol.geom.LineString.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'intersectsCoordinate',\n      ol.geom.LineString.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getExtent',\n      ol.geom.LineString.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'simplify',\n      ol.geom.LineString.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'transform',\n      ol.geom.LineString.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'get',\n      ol.geom.LineString.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getKeys',\n      ol.geom.LineString.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getProperties',\n      ol.geom.LineString.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'set',\n      ol.geom.LineString.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'setProperties',\n      ol.geom.LineString.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'unset',\n      ol.geom.LineString.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'changed',\n      ol.geom.LineString.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'dispatchEvent',\n      ol.geom.LineString.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'getRevision',\n      ol.geom.LineString.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'on',\n      ol.geom.LineString.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'once',\n      ol.geom.LineString.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.LineString.prototype,\n      'un',\n      ol.geom.LineString.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getFirstCoordinate',\n      ol.geom.MultiLineString.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getLastCoordinate',\n      ol.geom.MultiLineString.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getLayout',\n      ol.geom.MultiLineString.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'rotate',\n      ol.geom.MultiLineString.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'scale',\n      ol.geom.MultiLineString.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getClosestPoint',\n      ol.geom.MultiLineString.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'intersectsCoordinate',\n      ol.geom.MultiLineString.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getExtent',\n      ol.geom.MultiLineString.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'simplify',\n      ol.geom.MultiLineString.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'transform',\n      ol.geom.MultiLineString.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'get',\n      ol.geom.MultiLineString.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getKeys',\n      ol.geom.MultiLineString.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getProperties',\n      ol.geom.MultiLineString.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'set',\n      ol.geom.MultiLineString.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'setProperties',\n      ol.geom.MultiLineString.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'unset',\n      ol.geom.MultiLineString.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'changed',\n      ol.geom.MultiLineString.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'dispatchEvent',\n      ol.geom.MultiLineString.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'getRevision',\n      ol.geom.MultiLineString.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'on',\n      ol.geom.MultiLineString.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'once',\n      ol.geom.MultiLineString.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.MultiLineString.prototype,\n      'un',\n      ol.geom.MultiLineString.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getFirstCoordinate',\n      ol.geom.MultiPoint.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getLastCoordinate',\n      ol.geom.MultiPoint.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getLayout',\n      ol.geom.MultiPoint.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'rotate',\n      ol.geom.MultiPoint.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'scale',\n      ol.geom.MultiPoint.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getClosestPoint',\n      ol.geom.MultiPoint.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'intersectsCoordinate',\n      ol.geom.MultiPoint.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getExtent',\n      ol.geom.MultiPoint.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'simplify',\n      ol.geom.MultiPoint.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'transform',\n      ol.geom.MultiPoint.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'get',\n      ol.geom.MultiPoint.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getKeys',\n      ol.geom.MultiPoint.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getProperties',\n      ol.geom.MultiPoint.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'set',\n      ol.geom.MultiPoint.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'setProperties',\n      ol.geom.MultiPoint.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'unset',\n      ol.geom.MultiPoint.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'changed',\n      ol.geom.MultiPoint.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'dispatchEvent',\n      ol.geom.MultiPoint.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'getRevision',\n      ol.geom.MultiPoint.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'on',\n      ol.geom.MultiPoint.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'once',\n      ol.geom.MultiPoint.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.MultiPoint.prototype,\n      'un',\n      ol.geom.MultiPoint.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getFirstCoordinate',\n      ol.geom.MultiPolygon.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getLastCoordinate',\n      ol.geom.MultiPolygon.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getLayout',\n      ol.geom.MultiPolygon.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'rotate',\n      ol.geom.MultiPolygon.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'scale',\n      ol.geom.MultiPolygon.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getClosestPoint',\n      ol.geom.MultiPolygon.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'intersectsCoordinate',\n      ol.geom.MultiPolygon.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getExtent',\n      ol.geom.MultiPolygon.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'simplify',\n      ol.geom.MultiPolygon.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'transform',\n      ol.geom.MultiPolygon.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'get',\n      ol.geom.MultiPolygon.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getKeys',\n      ol.geom.MultiPolygon.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getProperties',\n      ol.geom.MultiPolygon.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'set',\n      ol.geom.MultiPolygon.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'setProperties',\n      ol.geom.MultiPolygon.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'unset',\n      ol.geom.MultiPolygon.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'changed',\n      ol.geom.MultiPolygon.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'dispatchEvent',\n      ol.geom.MultiPolygon.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'getRevision',\n      ol.geom.MultiPolygon.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'on',\n      ol.geom.MultiPolygon.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'once',\n      ol.geom.MultiPolygon.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.MultiPolygon.prototype,\n      'un',\n      ol.geom.MultiPolygon.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getFirstCoordinate',\n      ol.geom.Point.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getLastCoordinate',\n      ol.geom.Point.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getLayout',\n      ol.geom.Point.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'rotate',\n      ol.geom.Point.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'scale',\n      ol.geom.Point.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getClosestPoint',\n      ol.geom.Point.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'intersectsCoordinate',\n      ol.geom.Point.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getExtent',\n      ol.geom.Point.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'simplify',\n      ol.geom.Point.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'transform',\n      ol.geom.Point.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'get',\n      ol.geom.Point.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getKeys',\n      ol.geom.Point.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getProperties',\n      ol.geom.Point.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'set',\n      ol.geom.Point.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'setProperties',\n      ol.geom.Point.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'unset',\n      ol.geom.Point.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'changed',\n      ol.geom.Point.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'dispatchEvent',\n      ol.geom.Point.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'getRevision',\n      ol.geom.Point.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'on',\n      ol.geom.Point.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'once',\n      ol.geom.Point.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.Point.prototype,\n      'un',\n      ol.geom.Point.prototype.un);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getFirstCoordinate',\n      ol.geom.Polygon.prototype.getFirstCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getLastCoordinate',\n      ol.geom.Polygon.prototype.getLastCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getLayout',\n      ol.geom.Polygon.prototype.getLayout);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'rotate',\n      ol.geom.Polygon.prototype.rotate);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'scale',\n      ol.geom.Polygon.prototype.scale);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getClosestPoint',\n      ol.geom.Polygon.prototype.getClosestPoint);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'intersectsCoordinate',\n      ol.geom.Polygon.prototype.intersectsCoordinate);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getExtent',\n      ol.geom.Polygon.prototype.getExtent);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'simplify',\n      ol.geom.Polygon.prototype.simplify);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'transform',\n      ol.geom.Polygon.prototype.transform);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'get',\n      ol.geom.Polygon.prototype.get);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getKeys',\n      ol.geom.Polygon.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getProperties',\n      ol.geom.Polygon.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'set',\n      ol.geom.Polygon.prototype.set);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'setProperties',\n      ol.geom.Polygon.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'unset',\n      ol.geom.Polygon.prototype.unset);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'changed',\n      ol.geom.Polygon.prototype.changed);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'dispatchEvent',\n      ol.geom.Polygon.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'getRevision',\n      ol.geom.Polygon.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'on',\n      ol.geom.Polygon.prototype.on);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'once',\n      ol.geom.Polygon.prototype.once);\n  \n  goog.exportProperty(\n      ol.geom.Polygon.prototype,\n      'un',\n      ol.geom.Polygon.prototype.un);\n  \n  goog.exportProperty(\n      ol.format.GML.prototype,\n      'readFeatures',\n      ol.format.GML.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.GML2.prototype,\n      'readFeatures',\n      ol.format.GML2.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.format.GML3.prototype,\n      'readFeatures',\n      ol.format.GML3.prototype.readFeatures);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'get',\n      ol.control.Control.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'getKeys',\n      ol.control.Control.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'getProperties',\n      ol.control.Control.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'set',\n      ol.control.Control.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'setProperties',\n      ol.control.Control.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'unset',\n      ol.control.Control.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'changed',\n      ol.control.Control.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'dispatchEvent',\n      ol.control.Control.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'getRevision',\n      ol.control.Control.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'on',\n      ol.control.Control.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'once',\n      ol.control.Control.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.Control.prototype,\n      'un',\n      ol.control.Control.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'getMap',\n      ol.control.Attribution.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'setMap',\n      ol.control.Attribution.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'setTarget',\n      ol.control.Attribution.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'get',\n      ol.control.Attribution.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'getKeys',\n      ol.control.Attribution.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'getProperties',\n      ol.control.Attribution.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'set',\n      ol.control.Attribution.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'setProperties',\n      ol.control.Attribution.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'unset',\n      ol.control.Attribution.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'changed',\n      ol.control.Attribution.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'dispatchEvent',\n      ol.control.Attribution.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'getRevision',\n      ol.control.Attribution.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'on',\n      ol.control.Attribution.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'once',\n      ol.control.Attribution.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.Attribution.prototype,\n      'un',\n      ol.control.Attribution.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'getMap',\n      ol.control.FullScreen.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'setMap',\n      ol.control.FullScreen.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'setTarget',\n      ol.control.FullScreen.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'get',\n      ol.control.FullScreen.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'getKeys',\n      ol.control.FullScreen.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'getProperties',\n      ol.control.FullScreen.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'set',\n      ol.control.FullScreen.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'setProperties',\n      ol.control.FullScreen.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'unset',\n      ol.control.FullScreen.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'changed',\n      ol.control.FullScreen.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'dispatchEvent',\n      ol.control.FullScreen.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'getRevision',\n      ol.control.FullScreen.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'on',\n      ol.control.FullScreen.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'once',\n      ol.control.FullScreen.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.FullScreen.prototype,\n      'un',\n      ol.control.FullScreen.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'getMap',\n      ol.control.MousePosition.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'setMap',\n      ol.control.MousePosition.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'setTarget',\n      ol.control.MousePosition.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'get',\n      ol.control.MousePosition.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'getKeys',\n      ol.control.MousePosition.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'getProperties',\n      ol.control.MousePosition.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'set',\n      ol.control.MousePosition.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'setProperties',\n      ol.control.MousePosition.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'unset',\n      ol.control.MousePosition.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'changed',\n      ol.control.MousePosition.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'dispatchEvent',\n      ol.control.MousePosition.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'getRevision',\n      ol.control.MousePosition.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'on',\n      ol.control.MousePosition.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'once',\n      ol.control.MousePosition.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.MousePosition.prototype,\n      'un',\n      ol.control.MousePosition.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'getMap',\n      ol.control.OverviewMap.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'setMap',\n      ol.control.OverviewMap.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'setTarget',\n      ol.control.OverviewMap.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'get',\n      ol.control.OverviewMap.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'getKeys',\n      ol.control.OverviewMap.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'getProperties',\n      ol.control.OverviewMap.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'set',\n      ol.control.OverviewMap.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'setProperties',\n      ol.control.OverviewMap.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'unset',\n      ol.control.OverviewMap.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'changed',\n      ol.control.OverviewMap.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'dispatchEvent',\n      ol.control.OverviewMap.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'getRevision',\n      ol.control.OverviewMap.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'on',\n      ol.control.OverviewMap.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'once',\n      ol.control.OverviewMap.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.OverviewMap.prototype,\n      'un',\n      ol.control.OverviewMap.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'getMap',\n      ol.control.Rotate.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'setMap',\n      ol.control.Rotate.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'setTarget',\n      ol.control.Rotate.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'get',\n      ol.control.Rotate.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'getKeys',\n      ol.control.Rotate.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'getProperties',\n      ol.control.Rotate.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'set',\n      ol.control.Rotate.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'setProperties',\n      ol.control.Rotate.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'unset',\n      ol.control.Rotate.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'changed',\n      ol.control.Rotate.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'dispatchEvent',\n      ol.control.Rotate.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'getRevision',\n      ol.control.Rotate.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'on',\n      ol.control.Rotate.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'once',\n      ol.control.Rotate.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.Rotate.prototype,\n      'un',\n      ol.control.Rotate.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'getMap',\n      ol.control.ScaleLine.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'setMap',\n      ol.control.ScaleLine.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'setTarget',\n      ol.control.ScaleLine.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'get',\n      ol.control.ScaleLine.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'getKeys',\n      ol.control.ScaleLine.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'getProperties',\n      ol.control.ScaleLine.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'set',\n      ol.control.ScaleLine.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'setProperties',\n      ol.control.ScaleLine.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'unset',\n      ol.control.ScaleLine.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'changed',\n      ol.control.ScaleLine.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'dispatchEvent',\n      ol.control.ScaleLine.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'getRevision',\n      ol.control.ScaleLine.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'on',\n      ol.control.ScaleLine.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'once',\n      ol.control.ScaleLine.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.ScaleLine.prototype,\n      'un',\n      ol.control.ScaleLine.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'getMap',\n      ol.control.Zoom.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'setMap',\n      ol.control.Zoom.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'setTarget',\n      ol.control.Zoom.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'get',\n      ol.control.Zoom.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'getKeys',\n      ol.control.Zoom.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'getProperties',\n      ol.control.Zoom.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'set',\n      ol.control.Zoom.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'setProperties',\n      ol.control.Zoom.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'unset',\n      ol.control.Zoom.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'changed',\n      ol.control.Zoom.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'dispatchEvent',\n      ol.control.Zoom.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'getRevision',\n      ol.control.Zoom.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'on',\n      ol.control.Zoom.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'once',\n      ol.control.Zoom.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.Zoom.prototype,\n      'un',\n      ol.control.Zoom.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'getMap',\n      ol.control.ZoomSlider.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'setMap',\n      ol.control.ZoomSlider.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'setTarget',\n      ol.control.ZoomSlider.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'get',\n      ol.control.ZoomSlider.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'getKeys',\n      ol.control.ZoomSlider.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'getProperties',\n      ol.control.ZoomSlider.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'set',\n      ol.control.ZoomSlider.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'setProperties',\n      ol.control.ZoomSlider.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'unset',\n      ol.control.ZoomSlider.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'changed',\n      ol.control.ZoomSlider.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'dispatchEvent',\n      ol.control.ZoomSlider.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'getRevision',\n      ol.control.ZoomSlider.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'on',\n      ol.control.ZoomSlider.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'once',\n      ol.control.ZoomSlider.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.ZoomSlider.prototype,\n      'un',\n      ol.control.ZoomSlider.prototype.un);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'getMap',\n      ol.control.ZoomToExtent.prototype.getMap);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'setMap',\n      ol.control.ZoomToExtent.prototype.setMap);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'setTarget',\n      ol.control.ZoomToExtent.prototype.setTarget);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'get',\n      ol.control.ZoomToExtent.prototype.get);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'getKeys',\n      ol.control.ZoomToExtent.prototype.getKeys);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'getProperties',\n      ol.control.ZoomToExtent.prototype.getProperties);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'set',\n      ol.control.ZoomToExtent.prototype.set);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'setProperties',\n      ol.control.ZoomToExtent.prototype.setProperties);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'unset',\n      ol.control.ZoomToExtent.prototype.unset);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'changed',\n      ol.control.ZoomToExtent.prototype.changed);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'dispatchEvent',\n      ol.control.ZoomToExtent.prototype.dispatchEvent);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'getRevision',\n      ol.control.ZoomToExtent.prototype.getRevision);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'on',\n      ol.control.ZoomToExtent.prototype.on);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'once',\n      ol.control.ZoomToExtent.prototype.once);\n  \n  goog.exportProperty(\n      ol.control.ZoomToExtent.prototype,\n      'un',\n      ol.control.ZoomToExtent.prototype.un);\n  ol.VERSION = 'v4.6.5';\n  OPENLAYERS.ol = ol;\n  \n    return OPENLAYERS.ol;\n  }));\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var visual;\r\n        (function (visual) {\r\n            var powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB;\r\n            (function (powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB) {\r\n                \"use strict\";\r\n                var DataViewObjectsParser = powerbi.extensibility.utils.dataview.DataViewObjectsParser;\r\n                var VisualSettings = (function (_super) {\r\n                    __extends(VisualSettings, _super);\r\n                    function VisualSettings() {\r\n                        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n                        _this.dataPoint = new dataPointSettings();\r\n                        return _this;\r\n                    }\r\n                    return VisualSettings;\r\n                }(DataViewObjectsParser));\r\n                powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.VisualSettings = VisualSettings;\r\n                var dataPointSettings = (function () {\r\n                    function dataPointSettings() {\r\n                        // Default color\r\n                        this.defaultColor = \"\";\r\n                        // Show all\r\n                        this.showAllDataPoints = true;\r\n                        // Fill\r\n                        this.fill = \"\";\r\n                        // Color saturation\r\n                        this.fillRule = \"\";\r\n                        // Text Size\r\n                        this.fontSize = 12;\r\n                    }\r\n                    return dataPointSettings;\r\n                }());\r\n                powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.dataPointSettings = dataPointSettings;\r\n            })(powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB = visual.powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB || (visual.powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB = {}));\r\n        })(visual = extensibility.visual || (extensibility.visual = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var visual;\r\n        (function (visual) {\r\n            var powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB;\r\n            (function (powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB) {\r\n                \"use strict\";\r\n                var Visual = (function () {\r\n                    function Visual(options) {\r\n                        console.log('Visual constructor', options);\r\n                        this.target = options.element;\r\n                        var mapElement = document.createElement(\"div\");\r\n                        mapElement.id = \"map\";\r\n                        this.target.appendChild(mapElement);\r\n                        this.map = new powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.OL3Map(mapElement);\r\n                    }\r\n                    Visual.prototype.update = function (options) {\r\n                        this.settings = Visual.parseSettings(options && options.dataViews && options.dataViews[0]);\r\n                        console.log(options.dataViews[0].table);\r\n                        this.map.initialize(options.dataViews[0].table);\r\n                    };\r\n                    Visual.parseSettings = function (dataView) {\r\n                        return powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.VisualSettings.parse(dataView);\r\n                    };\r\n                    /**\r\n                     * This function gets called for each of the objects defined in the capabilities files and allows you to select which of the\r\n                     * objects and properties you want to expose to the users in the property pane.\r\n                     *\r\n                     */\r\n                    Visual.prototype.enumerateObjectInstances = function (options) {\r\n                        return powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.VisualSettings.enumerateObjectInstances(this.settings || powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.VisualSettings.getDefault(), options);\r\n                    };\r\n                    return Visual;\r\n                }());\r\n                powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.Visual = Visual;\r\n            })(powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB = visual.powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB || (visual.powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB = {}));\r\n        })(visual = extensibility.visual || (extensibility.visual = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\nvar colors = [];\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var extensibility;\r\n    (function (extensibility) {\r\n        var visual;\r\n        (function (visual) {\r\n            var powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB;\r\n            (function (powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB) {\r\n                \"use strict\";\r\n                var OL3Map = (function () {\r\n                    function OL3Map(target) {\r\n                        console.log(\"[Map Constructor]\");\r\n                        this.map = new ol.Map({\r\n                            target: target,\r\n                            layers: [\r\n                                new ol.layer.Tile({\r\n                                    source: new ol.source.XYZ({\r\n                                        url: 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'\r\n                                    })\r\n                                })\r\n                            ],\r\n                            view: new ol.View({\r\n                                center: [-40030988.957286224, 6808398.9834172195],\r\n                                zoom: 10\r\n                            })\r\n                        });\r\n                        this.map.on(\"click\", function (evt) {\r\n                            console.log(evt);\r\n                        });\r\n                        this.loadTileLayers();\r\n                    }\r\n                    OL3Map.prototype.loadTileLayers = function () {\r\n                        var projection = ol.proj.get('EPSG:3857');\r\n                        var projectionExtent = projection.getExtent();\r\n                        var size = ol.extent.getWidth(projectionExtent) / 256;\r\n                        var resolutions = new Array(25);\r\n                        var matrixIds = new Array(25);\r\n                        for (var z = 0; z < 25; ++z) {\r\n                            resolutions[z] = size / Math.pow(2, z);\r\n                            matrixIds[z] = 'EPSG:900913:' + z;\r\n                        }\r\n                        var loads = [];\r\n                        for (var x = 0; x < 25; ++x) {\r\n                            loads.push({ \"level\": matrixIds[x], \"resolution\": resolutions[x] });\r\n                        }\r\n                        var layers = [\r\n                            { name: 'grosight:STATUTORY_SEWAGE_CATCHMENT_AREA', label: 'Catchment Poly' },\r\n                            { name: 'grosight:PARISHES', label: 'Parish' },\r\n                            { name: 'grosight:SEWER_PIPE', label: 'Sewer' },\r\n                            { name: 'grosight:WATER_TREATMENT', label: 'Water Treatment' },\r\n                            { name: 'grosight:SEWER_MANHOLE', label: 'Manhole' },\r\n                            { name: 'grosight:ADDRESS', label: 'Address' }\r\n                        ];\r\n                        for (var x = 0; x < layers.length; x++) {\r\n                            var layer = layers[x];\r\n                            var layerSource = new ol.source.WMTS({\r\n                                url: 'https://aws-gs-app-dev-01.azurewebsites.net/geoserver/gwc/service/wmts',\r\n                                layer: layer.name,\r\n                                matrixSet: 'EPSG:900913',\r\n                                format: 'image/png',\r\n                                projection: projection,\r\n                                tileGrid: new ol.tilegrid.WMTS({\r\n                                    origin: ol.extent.getTopLeft(projectionExtent),\r\n                                    resolutions: resolutions,\r\n                                    matrixIds: matrixIds\r\n                                }),\r\n                                style: '',\r\n                                wrapX: true,\r\n                                crossOrigin: 'anonymous',\r\n                                t: Date.now(),\r\n                            });\r\n                            var WMSLayer = new ol.layer.Tile({\r\n                                title: layer.label,\r\n                                id: 'layer_' + x,\r\n                                name: layer.label,\r\n                                visible: true,\r\n                                geometryColumn: 'G3E_GEOMETRY',\r\n                                source: layerSource\r\n                            });\r\n                            //this.map.addLayer(WMSLayer);\r\n                        }\r\n                    };\r\n                    OL3Map.prototype.initialize = function (data) {\r\n                        var features = [];\r\n                        this.generateColors();\r\n                        data.rows.forEach(function (row) {\r\n                            var coordinates = ol.proj.transform([row[0], row[1]], 'EPSG:4326', 'EPSG:3857');\r\n                            var f = new ol.Feature(new ol.geom.Point(coordinates));\r\n                            features.push(f);\r\n                        });\r\n                        var source = new ol.source.Vector({\r\n                            features: features\r\n                        });\r\n                        var vectorLayer = new ol.layer.Vector({\r\n                            source: source,\r\n                            style: this.styleFunction\r\n                        });\r\n                        this.map.addLayer(vectorLayer);\r\n                        console.log(\"added vector layer\");\r\n                    };\r\n                    OL3Map.prototype.generateColors = function () {\r\n                        for (var x = 0; x < 3000; x++) {\r\n                            var colorArr = [Math.floor(Math.random() * 254), Math.floor(Math.random() * 254), Math.floor(Math.random() * 254)];\r\n                            var color = 'rgba(' + colorArr.join(\",\") + ')';\r\n                            colors.push(color);\r\n                        }\r\n                    };\r\n                    OL3Map.prototype.styleFunction = function (feature, resolution) {\r\n                        return new ol.style.Style({\r\n                            image: new ol.style.Circle({\r\n                                fill: new ol.style.Fill({\r\n                                    color: colors[Math.floor(Math.random() * 3000)]\r\n                                }),\r\n                                radius: 20,\r\n                                stroke: new ol.style.Stroke({\r\n                                    color: '#000',\r\n                                    width: 1\r\n                                })\r\n                            })\r\n                        });\r\n                    };\r\n                    return OL3Map;\r\n                }());\r\n                powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.OL3Map = OL3Map;\r\n            })(powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB = visual.powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB || (visual.powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB = {}));\r\n        })(visual = extensibility.visual || (extensibility.visual = {}));\r\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\r\n})(powerbi || (powerbi = {}));\r\nvar powerbi;\r\n(function (powerbi) {\r\n    var visuals;\r\n    (function (visuals) {\r\n        var plugins;\r\n        (function (plugins) {\r\n            plugins.powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG = {\r\n                name: 'powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG',\r\n                displayName: 'PowerbiOl3Viz',\r\n                class: 'Visual',\r\n                version: '1.0.0',\r\n                apiVersion: '1.11.0',\r\n                create: function (options) { return new powerbi.extensibility.visual.powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB.Visual(options); },\r\n                custom: true\r\n            };\r\n        })(plugins = visuals.plugins || (visuals.plugins = {}));\r\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\r\n})(powerbi || (powerbi = {}));\r\n//# sourceMappingURL=visual.js.map","css":".visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-box {\n  box-sizing: border-box;\n  border-radius: 2px;\n  border: 2px solid #00f;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-mouse-position {\n  top: 8px;\n  right: 8px;\n  position: absolute;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-scale-line {\n  background: rgba(0, 60, 136, 0.3);\n  border-radius: 4px;\n  bottom: 8px;\n  left: 8px;\n  padding: 2px;\n  position: absolute;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-scale-line-inner {\n  border: 1px solid #eee;\n  border-top: none;\n  color: #eee;\n  font-size: 10px;\n  text-align: center;\n  margin: 1px;\n  will-change: contents, width;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overlay-container {\n  will-change: left, right, top, bottom;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-unsupported {\n  display: none;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-unselectable,\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-viewport {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-selectable {\n  -webkit-touch-callout: default;\n  -webkit-user-select: auto;\n  -moz-user-select: auto;\n  -ms-user-select: auto;\n  user-select: auto;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-grab {\n  cursor: move;\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-control {\n  position: absolute;\n  background-color: rgba(255, 255, 255, 0.4);\n  border-radius: 4px;\n  padding: 2px;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-control:hover {\n  background-color: rgba(255, 255, 255, 0.6);\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-zoom {\n  top: .5em;\n  left: 0.5em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-rotate {\n  top: .5em;\n  right: .5em;\n  transition: opacity 0.25s linear, visibility 0s linear;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-rotate.ol-hidden {\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity 0.25s linear, visibility 0s linear 0.25s;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-zoom-extent {\n  top: 4.643em;\n  left: 0.5em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-full-screen {\n  right: .5em;\n  top: 0.5em;\n}\n@media print {\n  .visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-control {\n    display: none;\n  }\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-control button {\n  display: block;\n  margin: 1px;\n  padding: 0;\n  color: #fff;\n  font-size: 1.14em;\n  font-weight: 700;\n  text-decoration: none;\n  text-align: center;\n  height: 1.375em;\n  width: 1.375em;\n  line-height: .4em;\n  background-color: rgba(0, 60, 136, 0.5);\n  border: none;\n  border-radius: 2px;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-control button::-moz-focus-inner {\n  border: none;\n  padding: 0;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-zoom-extent button {\n  line-height: 1.4em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-compass {\n  display: block;\n  font-weight: 400;\n  font-size: 1.2em;\n  will-change: transform;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-touch .ol-control button {\n  font-size: 1.5em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-touch .ol-zoom-extent {\n  top: 5.5em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-control button:focus,\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-control button:hover {\n  text-decoration: none;\n  background-color: rgba(0, 60, 136, 0.7);\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-zoom .ol-zoom-in {\n  border-radius: 2px 2px 0 0;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-zoom .ol-zoom-out {\n  border-radius: 0 0 2px 2px;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution {\n  text-align: right;\n  bottom: .5em;\n  right: .5em;\n  max-width: calc(98.7%);\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution ul {\n  margin: 0;\n  padding: 0 .5em;\n  font-size: .7rem;\n  line-height: 1.375em;\n  color: #000;\n  text-shadow: 0 0 2px #fff;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution li {\n  display: inline;\n  list-style: none;\n  line-height: inherit;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution li:not(:last-child):after {\n  content: \" \";\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution img {\n  max-height: 2em;\n  max-width: inherit;\n  vertical-align: middle;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution button,\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution ul {\n  display: inline-block;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution.ol-collapsed ul {\n  display: none;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution.ol-logo-only ul {\n  display: block;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution:not(.ol-collapsed) {\n  background: rgba(255, 255, 255, 0.8);\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution.ol-uncollapsible {\n  bottom: 0;\n  right: 0;\n  border-radius: 4px 0 0;\n  height: 1.1em;\n  line-height: 1em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution.ol-logo-only {\n  background: 0 0;\n  bottom: .4em;\n  height: 1.1em;\n  line-height: 1em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution.ol-uncollapsible img {\n  margin-top: -0.2em;\n  max-height: 1.6em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution.ol-logo-only button,\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-attribution.ol-uncollapsible button {\n  display: none;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-zoomslider {\n  top: 4.5em;\n  left: .5em;\n  height: 200px;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-zoomslider button {\n  position: relative;\n  height: 10px;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-touch .ol-zoomslider {\n  top: 5.5em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap {\n  left: .5em;\n  bottom: 0.5em;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap.ol-uncollapsible {\n  bottom: 0;\n  left: 0;\n  border-radius: 0 4px 0 0;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap .ol-overviewmap-map,\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap button {\n  display: inline-block;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap .ol-overviewmap-map {\n  border: 1px solid #7b98bc;\n  height: 150px;\n  margin: 2px;\n  width: 150px;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap:not(.ol-collapsed) button {\n  bottom: 1px;\n  left: 2px;\n  position: absolute;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap.ol-collapsed .ol-overviewmap-map,\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap.ol-uncollapsible button {\n  display: none;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap:not(.ol-collapsed) {\n  background: rgba(255, 255, 255, 0.8);\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap-box {\n  border: 2px dotted rgba(0, 60, 136, 0.7);\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .ol-overviewmap .ol-overviewmap-box:hover {\n  cursor: move;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG .visualTitle {\n  display: none!important;\n}\n.visual-powerbiOl3VizCD46B2BA4997410B9423D41CAF42E3AB_DEBUG #map {\n  width: 100%;\n  height: 100%;\n  border: 1px solid olive;\n}\n","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2RpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpBOEJGMzkxN0NBRDNFMDExQTcxQ0JFODI3ODBCQUE5RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3NEY1QjA1NUQ0OTAxMUUwQTgxREI2NjMxMkNEMUNEMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3NEY1QjA1NEQ0OTAxMUUwQTgxREI2NjMxMkNEMUNEMyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5Mjk5RDU1ODBGRDRFMDExQTcxQ0JFODI3ODBCQUE5RSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBOEJGMzkxN0NBRDNFMDExQTcxQ0JFODI3ODBCQUE5RSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpDoNX0AAAI3SURBVHjarJRLSFVRFIY9t7SiRDGLoEEPCRJRaCSYkxCiFCXCF+LIMExQLkilgumgwkbdBuWDRC2EomhURCOjgagkXEgKLUKhidobM6H0+i34rxyPnuvEA5/rXPda/1l7739vJxKJxG3ls93+hEKhTILxJhgMftmsiPxdhHw4CfepeR8dCyjWwwB0kZy3iVgCoQ2ewnmXxhrBD7Cgr/ZQVA17fDRPw2UYhzK6G99IsBse6/0QNME+H8FT4EA/YiPqOgA1q4IMzBNuw6iKjkCpj+Av+AdnEEmD3bxfhzvuDk30HaEaLsEkXCO53rN+Bwg5qsvTuj/TjGYtx9nINhRmEx7AYWiFW7AXOuEcbPOUvIZ2mnrl+PkQUbNEh4QHNKUSDdsSBWEOlmxTEfvs26FL9Khe211if6Acgee+xo7xzMgBxfq9qPe3fgWBGN2lEnqtG9nExM7CV3jp3bDos2bKJB0nHFRxAxRpA/5CIXyHh5ABv6GZqd9dJ6iz2SjbxMMypGhJFtTlNzu3kK7xgDxpove8U66FK2A+s6nul5gVVMEL+Ak7lG/T+g9JcIOGar2CRUoogxMwpP/bLTJMB9bRhDbkk5bBUU0y3ES0xS04CBfN9RSHiY90vJK0BHaSzG9h2eejS3RJeVfdtrGzuGyd8CX7Yq6ExuCH63jaVMPkFOv6OibB6DKs2+VEQp+WYBoqERn2sVWWRNN0YurIfeL14U6YkpkLYCSG6e0yqdCxvKBLIm5FgAEAV0nKuwMYRUsAAAAASUVORK5CYII="}}